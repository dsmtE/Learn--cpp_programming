{"searchDocs":[{"title":"Git","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Git","content":"Git","keywords":"","version":"Next"},{"title":"S1 - Exercice - Structure Fraction","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Archives/Fraction","content":"S1 - Exercice - Structure Fraction Le but de cet exercice est de cr√©er une structure permettant de repr√©senter une fraction. Cette structure devra contenir deux entiers positifs, un pour le num√©rateur et un pour le d√©nominateur. On va utiliser un fichier d'en-t√™te pour d√©finir la structure et les fonctions qui vont permettre de manipuler les fractions. Cr√©er un fichier fraction.hpp qui contiendra la d√©finition de la structure et les prototypes des m√©thodes. La structure devra s'appeler Fraction et contenir deux entiers positifs nomm√©s numerator et denominator de type unsigned int avec comme valeur par d√©faut 0/1. La structure devra contenir une m√©thode display et qui permet d'afficher (std::cout) la fraction sous la forme numerator/denominator. Vous devrez √©galement d√©finir les prototypes des fonctions suivantes : add : prend deux fractions en param√®tre et retourne la somme des deux fractions.sub : prend deux fractions en param√®tre et retourne la diff√©rence des deux fractions.mul : prend deux fractions en param√®tre et retourne le produit des deux fractions.div : prend deux fractions en param√®tre et retourne le quotient des deux fractions. info Pour simplifier on va consid√©rer que les fractions sont toujours positives et on ne va pas g√©rer le cas ou le r√©sultat d'une op√©ration est n√©gatif ou le probl√®me de division par z√©ro. Vous √™tes toute fois libre de g√©rer ces cas si vous le souhaitez (et donc changer le type des attributs de la structure et utiliser des entiers sign√©s). astuce Petit rappel sur la d√©finition des prototypes de m√©thodes pour les structures ici. Cr√©er un fichier fraction.cpp qui contiendra les d√©finitions des m√©thodes et fonctions. Impl√©menter les fonctions dans le fichier fraction.cpp. attention Les fonctions add, sub, mul et div ne doivent pas modifier les fractions pass√©es en param√®tre mais bien retourner une nouvelle fraction qui est le r√©sultat de l'op√©ration. Cr√©er un fichier utils.hpp qui contiendra les fonctions suivantes : gcd : prend deux entiers positifs en param√®tre et retourne le plus grand diviseur commun.simplify : prend une fraction en param√®tre et retourne la fraction simplifi√©e. Cr√©er un fichier utils.cpp et impl√©menter les fonctions. astuce Pour simplifier une fraction, il faut diviser le num√©rateur et le d√©nominateur par le plus grand diviseur commun. On va donc utiliser la fonction gcd pour calculer le plus grand diviseur commun et ensuite diviser le num√©rateur et le d√©nominateur par ce nombre. la fraction 4/6 devient 2/3 car gcd(4, 6) = 2 et 4/2 = 2 et 6/2 = 3. Il faut importer le fichier fraction.hpp dans le fichier utils.hpp pour pouvoir utiliser la structure Fraction dans la fonction simplify. info Pour trouver le plus grand diviseur commun, on peut utiliser l'algorithme d'Euclide qui consiste √† diviser le plus grand nombre par le plus petit et √† r√©p√©ter l'op√©ration avec le reste de la division jusqu'√† obtenir un reste nul. Dans ce cas, le plus petit nombre non nul est le plus grand diviseur commun. exemple avec 22 et 8: 22 % 8 = 6 (reste de la division de 22 par 8) 6 est diff√©rent de 0 donc on continue8 % 6 = 2 (reste de la division de 8 par 6) 2 est diff√©rent de 0 donc on continue6 % 2 = 0 (reste de la division de 6 par 2) 0 est √©gal √† 0 donc on s'arr√™te et le plus grand diviseur commun est 2. Modifier vos fonctions add, sub, mul et div pour simplifier le r√©sultat avant de le retourner. Cr√©er un fichier main.cpp qui contiendra le programme principal. Ce programme devra : Cr√©er deux fractions f1 et f2 avec les valeurs de votre choix. (id√©alement avec des valeurs al√©atoires ou saisies par l'utilisateur)Afficher les deux fractions.Afficher la somme des deux fractions.Afficher la diff√©rence des deux fractions.Afficher le produit des deux fractions.Afficher le quotient des deux fractions. info Vous d√©couvrirez au second semestre comment am√©liorer ce programme en utilisant la surcharge d'op√©rateurs üõ†.","keywords":"","version":"Next"},{"title":"Utiliser des biblioth√®ques en C++","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Libraries","content":"","keywords":"","version":"Next"},{"title":"Fonctionnement d'une biblioth√®que‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#fonctionnement-dune-biblioth√®que","content":" La plupart des biblioth√®ques sont constitu√©es de la m√™me fa√ßon : elles contiennent un ensemble de fichiers d'en-t√™te (extension .h ou .hpp) et des fichiers contenant le code machine de la biblioth√®que. Les premiers contiennent les d√©clarations et sont utile pour l'√©tape de compilation, les seconds contiennent les d√©finitions et sont utiles pour l'√©tape de linkage.  ","version":"Next","tagName":"h2"},{"title":"Statique ou dynamique‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#statique-ou-dynamique","content":" Les fichiers en question peuvent √™tre de deux types : statiques ou dynamiques.  Lorsque l'on compile un programme qui utilise une biblioth√®que statique, le compilateur va inclure les d√©finitions de la biblioth√®que (√† l'aide des fichiers objets statiques) dans le fichier ex√©cutable au moment de l'√©tape de linkage. Cela signifie que le fichier ex√©cutable sera plus gros, mais il n'aura pas besoin d'autres fichiers pour s'ex√©cuter. Avec une biblioth√®que dynamique, la biblioth√®que n'est pas inclus dans le fichier ex√©cutable. Au lieu de cela, le fichier ex√©cutable contient des r√©f√©rences aux fonctions et aux classes de la biblioth√®que. Le contenu de la biblioth√®que est stock√© dans un fichier de biblioth√®que (extension .lib ou .dll sur Windows, .so sur Linux et .dylib sur Mac). Lorsque l'on ex√©cute le programme, le syst√®me d'exploitation charge le fichier de biblioth√®que en m√©moire et fait les correspondances entre les r√©f√©rences et les d√©finitions. Cela signifie que le fichier ex√©cutable sera plus petit, mais il aura besoin de la biblioth√®que pour s'ex√©cuter. L'avantage est que plusieurs programmes peuvent utiliser le m√™me fichier de biblioth√®que en m√©moire. l‚Äôinconvenant et qu'il faut que la biblioth√®que soit pr√©sente sur le syst√®me d'exploitation ou il faut fournir le fichier de biblioth√®que avec le programme (g√©n√©ralement dans le m√™me dossier que l'ex√©cutable).  ","version":"Next","tagName":"h3"},{"title":"Header only‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#header-only","content":" Certaines biblioth√®ques ne contiennent que des fichiers d'en-t√™te. Cela signifie que les d√©clarations et les d√©finitions sont dans les m√™mes fichiers (cela ne pose pas de probl√®me en utilisant certains concepts avanc√©s du langage C++). Ces biblioth√®ques sont appel√©es header only. Elles sont tr√®s faciles √† utiliser, car il suffit de les inclure dans le programme pour pouvoir les utiliser.  ","version":"Next","tagName":"h3"},{"title":"Debug ou release‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#debug-ou-release","content":" Une biblioth√®que peut √™tre compil√©e en mode debug ou en mode release. En mode debug, la biblioth√®que contient des informations suppl√©mentaires qui permettent de d√©boguer le programme (cela s‚Äôaccompagne parfois d'un fichier suppl√©mentaire avec les informations de d√©bogage). En mode release, la biblioth√®que est optimis√©e pour la performance ou la taille du fichier ex√©cutable.  ","version":"Next","tagName":"h3"},{"title":"Inclusion d'une biblioth√®que‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#inclusion-dune-biblioth√®que","content":" Il existe plusieurs fa√ßons d'inclure une biblioth√®que dans un programme et nous allons d√©couvrir les diff√©rentes m√©thodes et les mettre en pratique avec Cmake.  ","version":"Next","tagName":"h2"},{"title":"CMake FetchContent‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#cmake-fetchcontent","content":" Cmake inclut une fonctionnalit√© qui permet de t√©l√©charger une biblioth√®que et de l'inclure dans le projet. Cela s'appel FetchContent et nous allons l'utiliser ensuite dans des exemples.  L'avantage est que cela fonctionne sur tous les syst√®mes d'exploitation et de ne pas avoir √† g√©rer les fichiers de la biblioth√®que manuellement.  ","version":"Next","tagName":"h3"},{"title":"Inclusion manuelle‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#inclusion-manuelle","content":" Il est toujours possible d'inclure une biblioth√®que manuellement. Il faut d'abord t√©l√©charger la biblioth√®que et d√©compresser les fichiers si n√©cessaire. Ensuite, il faut indiquer au compilateur (via CMake) o√π se trouve la biblioth√®que et o√π se trouvent les fichiers d'en-t√™te. Cela va permet de compiler la biblioth√®que et d'inclure les fichiers d'en-t√™te dans le programme.  Parfois certaines biblioth√®ques utilisent √©galement CMake pour faciliter l'inclusion de la biblioth√®que dans un projet. Dans ce cas on peut simplement indiquer le dossier de la biblioth√®que √† cmake et il se chargera de tout.  ","version":"Next","tagName":"h3"},{"title":"Gestionnaire de d√©pendances‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#gestionnaire-de-d√©pendances","content":" Enfin, il des outils nomm√©s gestionnaires de d√©pendances qui permettent de t√©l√©charger et installer/compiler des biblioth√®ques automatiquement sur le syst√®me d'exploitation. Une fois install√©es, il suffit d'indiquer au compilateur que l'on souhaite utiliser la biblioth√®que et elle va √™tre incluse automatiquement et trouver les fichiers d'en-t√™te et les fichiers de la biblioth√®ques sur le syst√®me d'exploitation. C'est une des raisons pour lesquelles certains d√©veloppeurs pr√©f√®rent utiliser Linux plut√¥t que Windows. Il existe des alternatives pour Windows, comme vcpkg ou conan mais ce n'est pas aussi simple que sur Linux.  ","version":"Next","tagName":"h3"},{"title":"Glm‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#glm","content":" Glm est une biblioth√®que qui contient des classes et des fonctions pour faire des calculs math√©matiques. Elle est tr√®s utile pour faire des calculs en 2D et en 3D, comme par exemple des rotations, des translations, des projections, etc.  Glm est une biblioth√®que header only. Cela signifie que les d√©clarations et les d√©finitions sont dans les m√™mes fichiers. Il suffit donc de les inclure dans le programme pour pouvoir utiliser la biblioth√®que.  ","version":"Next","tagName":"h2"},{"title":"FetchContent et Cmake‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#fetchcontent-et-cmake","content":" Pour t√©l√©charger et inclure glm dans un projet CMake nous allons utiliser la fonctionnalit√© FetchContent.  Premi√®rement il faut indiquer √† CMake que l'on souhaite utiliser la fonctionnalit√© FetchContent. C'est une fonction qui est incluse dans CMake √† partir de la version 3.11, mais qui n'est pas activ√©e par d√©faut. Pour l'activer, il faut ajouter la ligne suivante avant de l'utiliser dans CMakeLists.txt :  include(FetchContent)   FetchContent permet de t√©l√©charger une biblioth√®que depuis un url ou un d√©p√¥t git. Nous allons utiliser la fonction FetchContent_Declare pour indiquer √† cmake que l'on souhaite t√©l√©charger la biblioth√®que glm depuis un d√©p√¥t git.  Il suffit d'ajouter les lignes suivantes dans le fichier CMakeLists.txt :  FetchContent_Declare( glm GIT_REPOSITORY https://github.com/g-truc/glm GIT_TAG efec5db081e3aad807d0731e172ac597f6a39447 )   La fonction FetchContent_Declare prend plusieurs param√®tres :  Le nom de la biblioth√®que (ici glm)L'url du d√©p√¥t git (ici https://github.com/g-truc/glm)Le tag git qui fait r√©f√©rence au commit que l'on souhaite t√©l√©charger (ici efec5db081e3aad807d0731e172ac597f6a39447)  Une fois que l'on a d√©clar√© o√π trouver la biblioth√®que, il faut indiquer √† CMake que l'on souhaite la t√©l√©charger et la rendre disponible dans le projet. Pour cela, on utilise la fonction FetchContent_MakeAvailable :  FetchContent_MakeAvailable(glm)   Une fois disponible, on peut pr√©ciser que l'on souhaite utiliser la biblioth√®que glm dans une target CMake avec la fonction target_link_libraries :  target_link_libraries(&lt;target&gt; PUBLIC glm)   Une fois tout assembl√©, Voil√† un exemple de fichier CMakeLists.txt qui utilise glm :  cmake_minimum_required(VERSION 3.20) project(test) // Permet de changer le dossier de sortie des fichiers ex√©cutables (pour qu'ils soient dans un dossier bin au lieu d'√™tre m√©lang√© avec les autres fichiers temporaires dans le dossier build) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) // Ajoute des options de compilation pour le compilateur pour avoir des messages d'erreurs suppl√©mentaires if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # ---Source files--- file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # ---Executable--- add_executable(test ${SRC_FILES}) target_compile_features(test PUBLIC cxx_std_17) target_include_directories(test PUBLIC &quot;src/&quot;) # ---Libraries--- include(FetchContent) # ---glm--- FetchContent_Declare( glm GIT_REPOSITORY https://github.com/g-truc/glm GIT_TAG efec5db081e3aad807d0731e172ac597f6a39447 ) FetchContent_MakeAvailable(glm) // On lie la biblioth√®que glm √† notre ex√©cutable (target) test target_link_libraries(test PUBLIC glm)   ","version":"Next","tagName":"h3"},{"title":"Magic enum‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#magic-enum","content":" Pour illustrer l'ajout manuel d'une biblioth√®que, nous allons utiliser la biblioth√®que magic enum. Par la m√™me occasion on d√©couvre une biblioth√®que tr√®s utile pour manipuler des √©num√©rations qui comble une lacune du langage C++ et simplifie grandement l'utilisation des √©num√©rations.  POur cette approche, l'id√©e est de manuellement t√©l√©charger le fichier de la biblioth√®que (qui est un header only) et de l'inclure dans le projet.  Premi√®rement, il faut t√©l√©charger les fichiers de la biblioth√®que. Pour cela, il faut se rendre sur la page github de la biblioth√®que : https://github.com/Neargye/magic_enum/tree/master/include/magic_enum et t√©l√©charger les fichiers dans le dossier include (en cliquant sur le bouton Code puis Download ZIP par exemple ou en clonant le d√©p√¥t git).  Ensuite, il faut cr√©er un dossier lib dans le dossier du projet et y placer les fichiers de la biblioth√®que (dans un sous dossier magic_enum par exemple).  Enfin, il faut indiquer √† cmake o√π se trouve les fichiers et que l'on souhaite utiliser la biblioth√®que magic enum dans le programme. Pour cela, on utilise la fonction target_include_directories :  target_include_directories(&lt;target&gt; PUBLIC &quot;lib/&quot;)   Ainsi il va √™tre possible d'inclure les fichiers dans le programme afin d'utiliser la biblioth√®que:  #include &lt;magic_enum/magic_enum.hpp&gt;   remarque C'est √©videment plus simple d'utiliser FetchContent pour inclure une biblioth√®que, mais il est important de comprendre que cela fonctionne de la m√™me fa√ßon et que simplement inclure la biblioth√®que et utiliser target_include_directories (dans le cas plus simple d'une biblioth√®que header only) permet de l'utiliser dans le programme.  ","version":"Next","tagName":"h2"},{"title":"Find Package et Cmake‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#find-package-et-cmake","content":" Il est √©galement possible d'utiliser la fonctionnalit√© Find Package de cmake pour inclure une biblioth√®que. Cela permet de simplifier l'inclusion d'une biblioth√®que et de ne pas avoir √† indiquer o√π se trouve les fichiers de la biblioth√®que. Cela repose sur le fait que la biblioth√®que est install√©e sur le syst√®me d'exploitation et/ou que l'on utilise un gestionnaire de d√©pendances. C'est tr√®s pratique sur Linux, mais cela peut √™tre plus compliqu√© sur Windows. Et c'est la raison pour laquelle nous n'allons pas l'utiliser dans ce cours (car trop d√©pendant du syst√®me d'exploitation).  Mais sachez que cela existe et vous ne serez pas surpris si vous tombez dessus.  Voil√† un exemple de fichier CMakeLists.txt (non test√©) qui utilise Find Package :  cmake_minimum_required(VERSION 3.20) project(test) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # ---Source files--- file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # ---Executable--- add_executable(test ${SRC_FILES}) target_compile_features(test PUBLIC cxx_std_17) target_include_directories(test PUBLIC &quot;src/&quot;) # ---glm--- # set(glm_DIR &lt;installation prefix&gt;/lib/cmake/glm) # if necessary find_package(glm REQUIRED) # On lie la biblioth√®que glm √† notre ex√©cutable (target) test target_link_libraries(test PUBLIC glm::glm)   info Enfin, avec de nouvelle version de Cmake il est m√™me possible de configurer le fonctionnement de FetchContent_MakeAvailable pour qu'il utilise Find Package pour inclure la biblioth√®que si c'est possible et qu'il utilise FetchContent sinon. Cela peut √™tre pratique dans certains cas, et permet d'√©viter de t√©l√©charger la biblioth√®que si elle est d√©j√† install√©e sur le syst√®me d'exploitation, mais cela d√©passe le cadre de ce cours.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin: cr√©er sa propre biblioth√®que‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#pour-aller-plus-loin-cr√©er-sa-propre-biblioth√®que","content":" Il est √©galement possible de cr√©er sa propre biblioth√®que. Cela peut √™tre utile pour r√©utiliser du code dans plusieurs projets ou pour partager du code avec d'autres d√©veloppeurs.  Pour cr√©er une biblioth√®que, il faut cr√©er un nouveau projet cmake et ajouter un dossier lib dans lequel on va placer les fichiers de la biblioth√®que. Ensuite, il faut cr√©er un fichier CMakeLists.txt dans le dossier lib et indiquer √† cmake que l'on souhaite cr√©er une biblioth√®que avec la fonction add_library :  add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)   Je ne vais pas rentrer dans les d√©tails dans ce cours mais voil√† un exemple de biblioth√®que ici si c'est quelque chose qui vous int√©resse : Simple-Image-Lib.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Utiliser des biblioth√®ques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#r√©sum√©","content":" Une biblioth√®que est un ensemble de fonctions et de classes qui permettent de r√©aliser des t√¢ches sp√©cifiques.Une biblioth√®que peut √™tre statique ou dynamique.Il existe plusieurs fa√ßons d'inclure une biblioth√®que dans un programme : CMake FetchContentInclusion manuelleGestionnaire de d√©pendances En pratique, il est pr√©f√©rable d'utiliser CMake FetchContent pour inclure une biblioth√®que (compatible avec tous les syst√®mes d'exploitation).Il est √©galement possible d'utiliser Find Package pour inclure une biblioth√®que (mais cela d√©pend du syst√®me d'exploitation). ","version":"Next","tagName":"h2"},{"title":"Comprendre le mot cl√© this","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/this","content":"","keywords":"","version":"Next"},{"title":"Pourquoi this ?‚Äã","type":1,"pageTitle":"Comprendre le mot cl√© this","url":"/Learn--cpp_programming/Annexes/this#pourquoi-this-","content":" Le mot cl√© this est un pointeur qui pointe vers l'objet courant. Il est utilis√© principalement pour acc√©der aux membres de la structure/classe √† partir d'une m√©thode (pour √©viter les ambigu√Øt√©s avec les param√®tres par exemple).  ","version":"Next","tagName":"h2"},{"title":"Utilisation de this pour acc√©der aux membres de la structure √† partir d'une m√©thode‚Äã","type":1,"pageTitle":"Comprendre le mot cl√© this","url":"/Learn--cpp_programming/Annexes/this#utilisation-de-this-pour-acc√©der-aux-membres-de-la-structure-√†-partir-dune-m√©thode","content":" Voici un exemple pour illustrer son utilisation :  struct Point { int x {0}; int y {0}; void set_x(int const x) { this-&gt;x = x; } };   Comme vous pouvez le voir, this est utilis√© pour acc√©der au membre x de la structure Point √† partir de la m√©thode set_x pour √©viter les ambigu√Øt√©s avec le param√®tre x de la m√©thode.  J'en profite pour rappeler deux m√©canismes des pointeurs:  * devant un pointeur permet de d√©r√©f√©rencer une pointeur et obtenir une sorte de r√©f√©rence vers l'objet point√© par le pointeur.-&gt; permet de d√©r√©f√©rencer un pointeur et d'acc√©der √† un membre de l'objet point√© par le pointeur. Donc this-&gt;x est √©quivalent √† (*this).x.  On aurait donc pu √©crire √©galement :  void set_x(int const x) { Point* myself_ptr {this}; // myself_ptr-&gt;x = x; (*myself_ptr).x = x; }   ou bien encore:  void set_x(int const x) { Point* myself_ptr {this}; Point&amp; myself_ref {*myself_ptr}; myself_ref.x = x; }   Dans l'id√©al pour ce cas de figure, il est pr√©f√©rable d'√©viter de nommer les param√®tres de m√©thodes avec le m√™me nom que les membres de la structure pour √©viter les ambigu√Øt√©s. Dans ce cas this n'est m√™me pas n√©cessaire car il n'y a pas d'ambigu√Øt√© et on peut simplement utiliser le nom du membre de la structure pour y acc√©der:  void set_x(int const new_x) { x = new_x; }   Je t'invite √† relire cette section √©galement : structure et this.  ","version":"Next","tagName":"h2"},{"title":"Utilisation de this pour cha√Æner les appels de m√©thodes‚Äã","type":1,"pageTitle":"Comprendre le mot cl√© this","url":"/Learn--cpp_programming/Annexes/this#utilisation-de-this-pour-cha√Æner-les-appels-de-m√©thodes","content":" This permet √©galement de retourner une r√©f√©rence vers l'objet courant pour pouvoir cha√Æner les appels de m√©thodes:  struct Point { int x {0}; int y {0}; Point&amp; set_x(int const new_x) { x = new_x; return *this; } Point&amp; set_y(int const new_y) { y = new_y; return *this; } }; int main() { Point p {}; p.set_x(3).set_y(4); }   C'est particuli√®rement utile pour les op√©rateurs de flux par exemple qui retournent une r√©f√©rence vers le flux pour pouvoir cha√Æner les appels de &lt;&lt;.  Un exemple d'op√©rateur de flux pour la structure Point et son utilisation :  #include &lt;iostream&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { os &lt;&lt; &quot;Point(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return os; } int main() { Point p {1, 2}; std::cout &lt;&lt; p &lt;&lt; std::endl; }   C'est √©galement utilis√© dans les op√©rateurs d'affection pour permettre d'√©crire a = b = c par exemple.  En effet, l'op√©rateur d'affectation retourne une r√©f√©rence vers l'objet courant pour permettre de cha√Æner les appels de l'op√©rateur d'affectation.  Voil√† un exemple d'op√©rateur d'affectation pour la structure Point et son utilisation :  struct Point { int x {0}; int y {0}; Point&amp; operator=(Point const&amp; other) { x = other.x; y = other.y; return *this; } };   Lorsque l'on √©crit a = b = c, l'op√©rateur d'affectation est appel√© sur b avec c en param√®tre et retourne une r√©f√©rence vers b qui est ensuite utilis√©e pour appeler l'op√©rateur d'affectation sur a avec b en param√®tre.  ainsi a = b = c est √©quivalent √† a.operator=(b.operator=(c)).  Si l'op√©rateur d'affectation ne retournait pas une r√©f√©rence vers l'objet courant, on ne pourrait pas √©crire a = b = c et on devrait √©crire a = c; b = c;. C'est √† mon sens tout √† fait valable √©galement mais ce n'est pas la convention en C++ et cela pourrait √™tre bloquant pour pouvoir utiliser des classes de la librairie standard qui utilisent cette convention.  Il faut par contre √©viter de retourner une copie de l'objet plut√¥t qu'une r√©f√©rence (Point operator=(Point const&amp; other)). Cela permettrait toujours de cha√Æner les appels de m√©thodes mais cela serait moins efficace car cela impliquerait de faire des copies et des destructions d'objets inutiles.  ","version":"Next","tagName":"h2"},{"title":"Appeler une fonction par r√©f√©rence √† partir d'une m√©thode‚Äã","type":1,"pageTitle":"Comprendre le mot cl√© this","url":"/Learn--cpp_programming/Annexes/this#appeler-une-fonction-par-r√©f√©rence-√†-partir-dune-m√©thode","content":" le mot cl√© this permet √©galement de passer une r√©f√©rence vers l'objet courant √† une fonction (depuis une m√©thode).  Prenons par exemple la structure Point et une m√©thode turn_point qui prend une r√©f√©rence vers un point en param√®tre :  struct Point { int x {0}; int y {0}; }; void turn_point(Point&amp; p) { int temp {x}; x = p.y; p.y = -temp; }   Si l'on souhaite appeler la fonction turn_point depuis une m√©thode de la structure Point, on peut utiliser this pour passer une r√©f√©rence vers l'objet courant √† la fonction turn_point :  struct Point { // ... void turn() { turn_point(*this); } };   J'esp√®re que cette section t'a permis de mieux comprendre le mot cl√© this en C++. ","version":"Next","tagName":"h2"},{"title":"Markdown","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Markdown","content":"","keywords":"","version":"Next"},{"title":"Extensions‚Äã","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#extensions","content":" Vous aurez besoin de ces extensions pour facilement √©crire du markdown dans VS Code :  markdown-preview-enhanced Pour voir le rendu final de votre texte.markdown-all-in-one Pour que VSCode comprenne la syntaxe Markdown.code-spell-checker-french Un correcteur d'orthographe. ATTENTION il est par d√©faut en anglais, et pour activer le fran√ßais il faut faire F1 puis chercher et cliquer sur Enable French Spell Checker Dictionary  ","version":"Next","tagName":"h2"},{"title":"Syntaxe‚Äã","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#syntaxe","content":" Voici une cheatsheet o√π vous retrouvez tout la syntaxe.  En r√©sum√© :  SyntaxeR√©sultat *Italique* **Gras** [lien](https://github.com/dsmtE/Learn--cpp_programming) ![image](./output/pouet.png) #### Titre (plus ou moins gros en fonction du nombre de #) - Listes - avec - plusieurs items ```cpp // Bloc de code C++ int x{0}; std::cout &lt;&lt; &quot;x vaut &quot; &lt;&lt; x &lt;&lt; '\\n'; '`` Bout de code `int x0;` au milieu d'une phrase. √âquations de math avec LaTeX : $$ \\int_{-\\infty{}}^{+\\infty{}} x^2 dx $$ Notes de bas de page [^1] [^1]: Je suis une note de bas de page ! &gt; Citation | Tableaux | :grin: | :sparkles: | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | S√©parateur : ---  Et vous pouvez √©galement utiliser n'importe quelle balise html √† tout moment, si la syntaxe Markdown ne fournit pas de quoi faire ce que vous voulez. Par exemple :  &lt;kbd&gt;F2&lt;/kbd&gt; pour faire des touches : F2&lt;summary&gt;&lt;/summary&gt; et &lt;details&gt;&lt;/details&gt; pour faire des sections collapsables :  &lt;details&gt; &lt;summary&gt;Ouvre-moi !&lt;/summary&gt; Salut, ceci est un secret ! &lt;/details&gt;   Details Ouvre-moi !Salut, ceci est un secret !  ","version":"Next","tagName":"h2"},{"title":"G√©n√©rer une table des mati√®res‚Äã","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#g√©n√©rer-une-table-des-mati√®res","content":" VS Code peut g√©n√©rer automatiquement une table des mati√®res pour votre document, qui va lister toutes les diff√©rentes sections que vous aurez d√©limit√©es avec des titres (#, ##, ###, etc.). Pour cela, mettez votre curseur l√† o√π vous voulez la g√©n√©rer (typiquement au d√©but de votre document), puis faites F1 et cherchez et s√©lectionnez Markdown All In One: Create Table of Contents (ou juste toc pour faire court).    Footnotes‚Äã Je suis une note de bas de page ! ‚Ü© ","version":"Next","tagName":"h2"},{"title":"L'IDE VSCode","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/VSCode","content":"","keywords":"","version":"Next"},{"title":"Les raccourcis et actions rapides‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#les-raccourcis-et-actions-rapides","content":" Je vais pr√©senter ci-dessous quelques unes des choses les plus importantes pour lesquelles un IDE peut vous aider. Je vais les illustrer √† l'aide de VSCode mais la majorit√© de ces fonctionnalit√©s sont √©galement pr√©sentes dans d'autres IDE.  ","version":"Next","tagName":"h2"},{"title":"Recherche dans le fichier courant‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#recherche-dans-le-fichier-courant","content":" Vous pouvez utiliser tout simplement la recherche dans le fichier courant en utilisant le raccourci : CTRL+F. Une popup va s'ouvrir et vous laisser naviguer avec les fl√®ches entre les occurrences. Vous pouvez √©galement faire du remplacement via la popup.    ","version":"Next","tagName":"h3"},{"title":"Recherche dans un projet‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#recherche-dans-un-projet","content":" Avec le raccourci CTRL+SHIFT+F il est possible de rechercher dans un projet entier. Cela peut √™tre tr√®s utile si vous savez comment une variable s'appelle mais que vous ne retrouvez plus dans quel fichier elle se trouve par exemple.  La barre de recherche de VSCode est g√©niale, vous pouvez m√™me renommer les choses (pour corriger une typo) par lot ou limiter la recherche √† un dossier sp√©cifique. Cette option est disponible en cliquant sur les trois points √† droite.    ","version":"Next","tagName":"h3"},{"title":"Renommer par symbole‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#renommer-par-symbole","content":" Faites un clic droit et s√©lectionnez &quot;rename symbol&quot; ou m√™me directement avec le raccourci F2 sur ta s√©lection.    C'est mieux que de faire une simple recherche (avec CTRL+F) car ce renommage arrive √† prendre en compte le contexte (les symboles) et permet de remplacer par exemple une variable nomm√©e &quot;Box&quot; sans affecter une autre qui pourrait par exemple s'appeler &quot;boundingBox&quot;.  Etape 1Etape 2Etape 3  ","version":"Next","tagName":"h3"},{"title":"Aller √† la d√©finition‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-√†-la-d√©finition","content":" Cela vous m√®nera directement √† la d√©finition de la variable / fonction / classe. C'est une fonctionnalit√© super utile pour se d√©placer dans un projet.    Et si vous voulez rester concentr√© sur la portion de code que vous √™tes en train d'√©diter, vous pouvez aussi regarder la d√©finition et cela ouvrira une petite fen√™tre dans votre fichier actuel.    ","version":"Next","tagName":"h3"},{"title":"Aller √† un symbole‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-√†-un-symbole","content":" Avec le raccourci CTRL+SHIFT+O vous pouvez acc√©der √† la liste des symboles. C'est en somme la liste des m√©thodes et fonctions du fichier courant. Vous pouvez ensuite taper ce que vous recherchez pour affiner la liste.    ","version":"Next","tagName":"h3"},{"title":"Aller √† un fichier‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-√†-un-fichier","content":" De la m√™me mani√®re, il est possible d'aller √† un fichier sans passer par l'explorateur en utilisant le raccourci : CTRL+P. C'est beaucoup plus rapide si vous connaissez le nom du fichier que vous cherchez.    ","version":"Next","tagName":"h3"},{"title":"Passer d'un fichier .hpp √† un .cpp et inversement‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#passer-dun-fichier-hpp-√†-un-cpp-et-inversement","content":" Vous pouvez utiliser ALT+O pour passer rapidement du fichier d'en-t√™te au fichier d'impl√©mentation. Tr√®s utile lorsque vous √©crivez du code pour une classe ou structure.  attention Cette action ne fonctionne que dans le contexte d'un projet C++ et n√©cessite l'extension suivante cpptools-extension-pack .    ","version":"Next","tagName":"h3"},{"title":"Aller plus loin‚Äã","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-plus-loin","content":" Si besoin, voici les liens vers les pdf de r√©f√©rence des raccourcis par plateforme de VSCode:  WindowsmacOSLinux ","version":"Next","tagName":"h3"},{"title":"D√©boguer son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors","content":"","keywords":"","version":"Next"},{"title":"Qu'est-ce qu'un d√©bogueur ?‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#quest-ce-quun-d√©bogueur-","content":" Un d√©bogueur est un outil qui permet d'arr√™ter l'ex√©cution d'un programme √† un point pr√©cis, appel√© point d'arr√™t (ou breakpoint en anglais), ou juste avant qu'un crash se produise.  Une fois atteint, vous √™tes en mesure d'inspecter la valeur de toutes les variables (et de toute la m√©moire du programme). Vous pouvez √©galement voir quelles fonctions ont √©t√© appel√©es jusqu'√† ce point gr√¢ce √† la pile d'appel (callstack).  Enfin, vous serez en mesure d'avancer pas √† pas dans l'ex√©cution.  Nous allons voir comment cela se passe dans VSCode en C++.  ","version":"Next","tagName":"h2"},{"title":"Configurer le d√©bogueur‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#configurer-le-d√©bogueur","content":" Pour commencer, il faut configurer le d√©bogueur.  Si vous avez suivi le cours sur CMake, vous n'avez rien √† faire, tout est d√©j√† configur√©.  Configuration manuelle Sinon, sachez qu'il est possible de configurer le d√©bogueur manuellement √† l'aide d'un fichier launch.json. Si vous voulez le configurer vous-m√™me, vous pouvez vous rendre dans le panneau &quot;Run and Debug&quot; et cliquer sur le bouton &quot;Run and Debug&quot;. Vous devez ensuite s√©lectionner le d√©bogueur que vous voulez utiliser (ici C++ (GDB/LLDB)) et cliquer sur Add Configuration. Cela cr√©era un fichier launch.json dans un dossier /.vscode √† la racine du projet. Si vous voulez plus de d√©tails sur la configuration manuelle, vous pouvez vous rendre ici. S'il y a une seule chose √† v√©rifier, c'est que le champ &quot;program&quot; pointe bien vers votre ex√©cutable. En g√©n√©ral, avec la configuration de CMake, il sera sous &quot;${workspaceFolder}/build/bin/Debug/YOURPROGRAM.exe&quot;  ","version":"Next","tagName":"h2"},{"title":"Utiliser le d√©bogueur‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#utiliser-le-d√©bogueur","content":" Il suffit d'appuyer sur CTRL + F5, ou sur l'ic√¥ne de debug üêõ dans la barre inf√©rieure :    √áa y est ! VSCode a lanc√© le programme en mode d√©bogage. On va pouvoir commencer √† l'utiliser.  ","version":"Next","tagName":"h2"},{"title":"Ajouter des points d'arr√™t‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#ajouter-des-points-darr√™t","content":" Comme vous pouvez le voir sur la capture ci-dessous, le programme est arr√™t√© avec une ligne surlign√©e.    C'est gr√¢ce √† un point d'arr√™t que j'ai ajout√© √† la ligne 171717.  Vous pouvez ajouter des points d'arr√™t en cliquant √† gauche de la ligne sur laquelle vous voulez vous arr√™ter, juste avant le num√©ro de ligne, ou en appuyant sur F9 apr√®s avoir s√©lectionn√© une ligne.  Comme son nom l'indique, il permet d'arr√™ter le programme √† un endroit pr√©cis pour inspecter celui-ci.  Points d'arr√™t conditionnels‚Äã  Il est possible de rendre un point d'arr√™t conditionnel, c'est-√†-dire qu'il ne sera d√©clench√© que si une certaine condition est remplie.  Pour cela, il suffit de faire un clic droit sur le point d'arr√™t et de s√©lectionner Edit Breakpoint.  Vous pouvez ensuite ajouter une expression qui sera √©valu√©e √† chaque fois que le programme passera par ce point d'arr√™t pour d√©terminer s'il doit s'arr√™ter ou non.  Cela peut √™tre tr√®s utile pour ne pas s'arr√™ter √† chaque it√©ration d'une boucle ou d'une fonction, mais seulement lorsqu'une certaine condition est remplie par exemple.  ","version":"Next","tagName":"h3"},{"title":"Inspecter les variables‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#inspecter-les-variables","content":" Dans la section Variables, vous pouvez voir toutes les variables du programme √† l'instant o√π il est arr√™t√©.    Par exemple, ici x vaut 10 !  Vous pouvez √©galement laisser votre curseur sur une variable (hover) qui vous int√©resse et un petit encadr√© va s'afficher pour vous montrer sa valeur.  C'est super utile et √©vite de devoir ajouter des std::cout (ou print/log en fonction des langages) pour afficher les valeurs actuelles de certaines variables.  Il est √©galement possible de regarder sp√©cifiquement certaines variables via la section Watch. (Cela peut √™tre utile dans des cas plus complexes avec beaucoup de variables locales qui g√™nent la visibilit√© de la section Variables par exemple).    Vous pouvez aussi ajouter des expressions √† √©valuer dans cette section.  Par exemple, si on veut savoir si x est sup√©rieur √† 3:    Cela peut √™tre tr√®s utile pour v√©rifier des conditions ou des valeurs interm√©diaires ou inspecter des variables qui ne sont pas directement accessibles (comme des membres de structures ou des √©l√©ments de tableaux).  ","version":"Next","tagName":"h3"},{"title":"Pile d'appel‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#pile-dappel","content":" La pile d'appel liste les diff√©rents appels que le programme a parcouru (fonctions/m√©thodes) pour arriver au point o√π le programme est arr√™t√© actuellement.    Vous pouvez voir que le programme est arr√™t√© dans la fonction fib (qui est r√©cursive). Il est possible de naviguer dans la pile d'appel en cliquant sur les diff√©rentes lignes.  ","version":"Next","tagName":"h3"},{"title":"Navigation en mode debug‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#navigation-en-mode-debug","content":" Une fois que le programme est en mode d√©bogage, un ensemble de boutons appara√Æt en haut de ton √©cran.    Ces boutons contr√¥lent l'ex√©cution du programme :  Le bouton Continue permet de lancer l'ex√©cution du programme et de la poursuivre jusqu'√† ce qu'un nouveau point d'arr√™t soit atteint.  remarque Celui-ci se transforme en un bouton pause lorsque le programme n'est pas actuellement arr√™t√©. Cela peut s'av√©rer utile quand vous avez l'impression que votre programme est bloqu√© (boucle infinie, appel asynchrone, etc).  Step Over et Step Into se d√©placent d'une instruction √† la fois et g√®rent la fa√ßon dont les appels de fonctions sont trait√©s.Step Over sautera les appels de fonctions (ou de m√©thodes), tandis que Step Into suivra ces appels (pour rentrer dans la fonction qui va √™tre appel√©e). La quatri√®me option est Step Out. Elle ex√©cute toutes les commandes de la fonction en cours et s'interrompt lorsqu'elle revient √† la fonction appelante. Les deux derni√®res options sont Restart et Stop, qui permettent de continuer l'ex√©cution du programme ou de l'arr√™ter.  ","version":"Next","tagName":"h3"},{"title":"Arr√™t automatique sur les erreurs‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#arr√™t-automatique-sur-les-erreurs","content":" Il est possible de configurer le d√©bogueur pour qu'il s'arr√™te automatiquement lorsqu'une erreur se produit.  Une fois le programme lanc√© en mode d√©bogage, vous pouvez allez dans la section Breakpoints et cocher la case All C++ Exceptions. Cela permettra de s'arr√™ter automatiquement lorsqu'une exception non g√©r√©e se produit.  Cela permet de voir o√π l'erreur se produit et de remonter la pile d'appel pour comprendre pourquoi et surtout o√π pr√©cis√©ment l'erreur se produit.  info g√©n√©ralement, le d√©bogueur s'arr√™te √† un point o√π l'exception est lanc√©e mais au sein de la biblioth√®que standard, donc il faut remonter un peu dans la pile d'appel pour trouver o√π l'erreur a √©t√© d√©clench√©e depuis votre code.  ","version":"Next","tagName":"h3"},{"title":"Raccourcis clavier‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#raccourcis-clavier","content":" Si vous utilisez le d√©bogueur pour la premi√®re fois vous allez s√ªrement utiliser les boutons pour vous d√©placer.  Mais il est possible d'utiliser des raccourcis clavier pour aller plus vite. Une fois ma√Ætris√©s, ils vous permettront de gagner un temps consid√©rable lors du d√©bogage de vos programmes.  Continue\tStep Over\tStep Into\tStep Out\tRestart\tStopF5\tF10\tF11\tSHIFT + F11\tCTRL + SHIFT + F5\tSHIFT + F5  ","version":"Next","tagName":"h3"},{"title":"Erreurs courantes‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreurs-courantes","content":" Vous avez s√ªrement d√©j√† rencontr√© des erreurs lors de la compilation ou de l'ex√©cution de vos programmes.  C'est normal, tout le monde en fait, m√™me les plus exp√©riment√©s.  Une erreur peut survenir √† la compilation ou √† l'ex√©cution de votre programme, ll est important d'apprendre √† les lire pour pouvoir les corriger et les comprendre.  Les erreurs de compilation sont les plus courantes. Elles se produisent lorsque le compilateur ne peut pas g√©n√©rer le fichier ex√©cutable √† partir de votre code.  Voici quelques exemples d'erreurs de compilation courantes.  ","version":"Next","tagName":"h2"},{"title":"Erreur de segmentation‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-segmentation","content":" L'erreur de segmentation est une erreur tr√®s courante en C++. Elle se produit lorsque vous essayez d'acc√©der √† une zone de m√©moire √† laquelle vous n'avez pas le droit d'acc√©der. Cela peut √™tre d√ª √† plusieurs raisons :  Acc√®s √† un tableau en dehors de ses limitesAcc√®s √† un pointeur non initialis√© ou lib√©r√© (dangling pointer) (nous verrons cela plus tard)  Elle se manifeste par un message d'erreur du type :  Segmentation fault (core dumped)   ","version":"Next","tagName":"h3"},{"title":"Erreur de syntaxe‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-syntaxe","content":" Les erreurs de syntaxe sont les plus simples √† trouver. Elles se produisent lorsque vous avez mal √©crit quelque chose dans votre code.  Par exemple, si vous oubliez un point-virgule √† la fin d'une ligne, ou si vous oubliez une accolade, le compilateur vous le signalera.  int x {10}   error: expected ';' after expression   parfois le message d'erreur peut √™tre un peu cryptique, mais en g√©n√©ral, il vous indique la ligne et la colonne o√π il a trouv√© l'erreur. Il suffit de regarder √† cet endroit (et un peu avant) pour trouver l'erreur.  ","version":"Next","tagName":"h3"},{"title":"Erreur de type‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-type","content":" Les erreurs de type se produisent lorsque vous essayez d'assigner un type √† un autre incompatible.  Par exemple, si vous essayez d'assigner un tableau (std::vector) √† une variable de type int :  int x { std::vector&lt;int&gt;{1, 2, 3} };   error: conversion from 'std::vector&lt;int&gt;' to non-scalar type 'int' requested   Les explications peuvent √™tre un peu plus complexes, mais en g√©n√©ral, le message d'erreur vous indique clairement ce qui ne va pas.  ","version":"Next","tagName":"h3"},{"title":"Erreur de d√©finition multiple‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-d√©finition-multiple","content":" Les erreurs de d√©finition se produisent lorsque vous d√©clarez une variable ou une fonction plusieurs fois.  Par exemple, si vous d√©clarez une variable dans un fichier d'en-t√™te et que vous l'incluez dans plusieurs fichiers source :  // file1.hpp #pragma once int x;   // file1.cpp #include &quot;file1.hpp&quot; int x {10};   error: redefinition of 'int x'   danger C'est pour cela qu'il est tr√®s fortement d√©conseill√© de d√©clarer des variables dans des fichiers d'en-t√™te ou des variables globales de mani√®re g√©n√©rale.  ","version":"Next","tagName":"h3"},{"title":"Erreur de r√©f√©rence non d√©finie‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-r√©f√©rence-non-d√©finie","content":" Les erreurs de r√©f√©rence non d√©finie (Undefined reference) se produisent lorsque vous d√©clarez une fonction mais que vous ne l'impl√©mentez pas.  Par exemple, si vous d√©clarez une fonction dans un fichier d'en-t√™te et que vous ne l'impl√©mentez pas dans un fichier source :  // file1.hpp #pragma once void foo();   // file1.cpp #include &quot;file1.hpp&quot; int main() { foo(); return 0; }   error: undefined reference to `foo()'   Le compilateur ne peut pas trouver la d√©finition de la fonction foo et vous signale une erreur.  ","version":"Next","tagName":"h3"},{"title":"Erreur de lien‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-lien","content":" Les erreurs de lien (linker error) se produisent lorsque le compilateur ne peut pas trouver une biblioth√®que ou un fichier objet n√©cessaire √† la compilation.  Elles sont souvent plus difficiles √† comprendre, mais en g√©n√©ral, elles vous indiquent le nom du fichier ou de la biblioth√®que manquante.  ","version":"Next","tagName":"h3"},{"title":"Erreur de logique‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-logique","content":" Les erreurs de logique (ou d'impl√©mentation) sont les plus difficiles √† trouver. Elles se produisent lorsque votre programme ne fait pas ce que vous attendez de lui, mais qu'il compile et s'ex√©cute sans erreur.  Pour les trouver, il faut souvent d√©boguer des points d'arr√™t et inspecter les variables pour comprendre ce qui ne va pas.  Quelques exemples d'erreurs de logique typiques :  Une boucle infinie :  int i {0}; while (i &lt; 10) { // Oubli d'incr√©menter i }   Une condition mal √©crite :  int x {10}; if (x = 0) { // Ne sera jamais ex√©cut√© }   Un tableau ou un pointeur mal utilis√© :  int tab[10] {}; for (int i = 0; i &lt;= 10; i++) { // Acc√®s en dehors des limites du tableau }   Cela peut parfois ne pas g√©n√©rer d'erreur de segmentation, mais le comportement du programme sera incorrect.  Une utilisation de valeur non sign√©e incorrecte :  unsigned int x {0}; int y {-1}; if (x &gt; y) { // Ne sera jamais ex√©cut√© }   ou encore  unsigned int x {10}; while (x &gt;= 0) { // Boucle infinie x -= 1; // x est toujours positif et donc lorsqu'il est d√©cr√©ment√© mais qu'il est d√©j√† √† 0, //il repasse √† la valeur maximale d'un unsigned int }   Une division par z√©ro :  float division(float const x, float const y) { return x / y; } float x {10}; float y {0}; float z {division(x, y)};   Floating point exception (core dumped)   Passage par copie au lieu de passage par r√©f√©rence :  void increment(int x) { x++; } int x {10}; increment(x); std::cout &lt;&lt; x &lt;&lt; std::endl; // Affiche 10   Ici la fonction increment prend x par copie et non par r√©f√©rence, donc la variable x n'est pas modifi√©e. C'est une copie locale √† la fonction increment qui est modifi√©e.  ","version":"Next","tagName":"h3"},{"title":"Exceptions‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#exceptions","content":" Dans le cas de la division par z√©ro par exemple on pourrait utiliser un if pour v√©rifier si y est diff√©rent de 0 avant de faire la division. Mais dans le cas o√π y est √©gal √† 0 on aimerait pouvoir le signaler √† l'utilisateur de la fonction pour afficher un message d'erreur ou alors effectuer une autre action sp√©cifique (redemander une valeur √† l'utilisateur par exemple).  C'est l√† qu'interviennent les exceptions. Les exceptions sont des objets qui permettent de signaler une erreur ou un comportement anormal dans un programme.  En C++ on utilise le mot cl√© throw pour lancer une exception.  #include &lt;stdexcept&gt; float division(float const x, float const y) { if (y == 0) { throw std::runtime_error(&quot;Division by zero&quot;); } return x / y; }   De m√™me par exemple lors de l'utilisation d'un std::vector si on essaye d'acc√©der au dernier √©l√©ment gr√¢ce √† la m√©thode back() alors que le vecteur est vide, une exception de type std::out_of_range sera lanc√©e.    Ces exceptions peuvent √™tre &quot;attrap√©es&quot; et trait√©es dans un bloc try catch:  try { float z {division(x, y)}; std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; z &lt;&lt; std::endl; } catch (std::exception&amp; const e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }   Il y aurait beaucoup √† dire sur les exceptions (utilisation, avantage et inconv√©nient, etc) mais ce n'est pas le sujet de ce cours. Je voulais juste vous montrer qu'elles existent et introduire le mot cl√© throw pour que vous puissiez l'identifier si vous le voyez dans du code.  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"D√©boguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#r√©sum√©","content":" Le d√©bogueur est un outil puissant pour comprendre le comportement de votre programme. Il permet d'arr√™ter l'ex√©cution √† un point pr√©cis appel√© point d'arr√™t (ou breakpoint). Vous pouvez inspecter les variables, la pile d'appel (callstack) et avancer pas √† pas dans l'ex√©cution. Il est possible de configurer le d√©bogueur pour qu'il s'arr√™te automatiquement lorsqu'une erreur se produit. Les erreurs courantes sont : Erreur de segmentation (segmentation fault) : acc√®s √† une zone de m√©moire interditeErreur de syntaxe : oubli de point-virgule, d'accolade, etcErreur de type : assignation ou conversion de type incorrecteErreur de logique : boucle infinie, condition mal √©crite, etcErreur de compilation : undefined reference, multiple definition, linker error, etc Il est possible de lancer des exceptions avec le mot cl√© throw et de les g√©rez avec un bloc try catch. ","version":"Next","tagName":"h2"},{"title":"Des tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Tableaux‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#tableaux","content":" Les tableaux sont l√† pour r√©soudre ce probl√®me et nous permettre de stocker plusieurs √©l√©ments.  Ils font partie de ce qu'on appelle les structures de donn√©es, des structures permettant d'organiser de fa√ßon particuli√®re des donn√©es, on les nomme aussi des conteneurs.  En ce qui concerne les tableaux il en existe principalement deux types:  std::array qui permet de stocker un nombre fix√© √† l'avance d'√©l√©mentsstd::vector qui permet de stocker un nombre variable ou dynamique d'√©l√©ments  A retenir que les tableaux permettent seulement de stocker des variables de m√™me type.  remarque Il existe bien d'autres structures de donn√©es qui stockent de fa√ßon diff√©rente (avec des avantages et des inconv√©nients) mais nous n'allons pas rentrer dans ce d√©tail pour l'instant.  ","version":"Next","tagName":"h2"},{"title":"std::vector‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdvector","content":" Comme vous le remarquez, j'ai ajout√© std:: devant vector ce qui nous indique que c'est une fonctionnalit√© d√©j√† cod√©e pour nous dans la biblioth√®que standard. Pour pouvoir s'en servir on va donc inclure le fichier contenant cette fonctionnalit√© en faisant #include &lt;vector&gt;  std::vector est un tableau dynamique qui s'agrandit et se r√©tr√©cit en fonction du nombre d'√©l√©ments que l'on souhaite stocker √† l'int√©rieur.  On l'initialise entre accolades en pr√©cisant entre chevrons (&lt; et &gt;) le type de variable que l'on souhaite stocker:  std::vector&lt;/* type des √©l√©ments du tableau */&gt; nom {};   des exemples #include &lt;vector&gt; int main() { // initialisation d'un tableau √† remplir plus tard std::vector&lt;int&gt; vector01 {}; // il est aussi possible de le pr√©remplir √† sa cr√©ation std::vector&lt;int&gt; vector02 { 12, 18, 8, 4, 9 }; // on peut rendre constant afin d'√©viter de future modifications si c'est ce que l'on souhaite std::vector&lt;float&gt; const vector03 { 3.1415f, 5.2365f }; // il est aussi possible de l'initialiser en copiant les valeurs d'un autre tableau de cette mani√®re std::vector&lt;float&gt; vector04 { vector03 }; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Manipuler notre tableau‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#manipuler-notre-tableau","content":" ","version":"Next","tagName":"h2"},{"title":"Acc√©der aux √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#acc√©der-aux-√©l√©ments","content":" Pour acc√©der aux √©l√©ments on utilise les crochets ([ et ]) apr√®s le nom de notre tableau, avec la position de l‚Äô√©l√©ment √† r√©cup√©rer.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; &quot;the second √©l√©ment is &quot; &lt;&lt; vector[1] &lt;&lt; std::endl; return 0; }   attention ‚ö†Ô∏è g√©n√©ralement en informatique (c'est le cas en C++), les √©l√©ments sont index√©s √† partir de 0 et non 1. c'est pour √ßa que 0 correspond au premier √©l√©ment et 1 au deuxi√®me dans notre exemple.  danger Et si j‚Äôacc√®de √† l‚Äô√©l√©ment d'index 6 (donc le 7√®me √©l√©ment) alors que mon tableau n'en contient que 6, que se passe-t-il‚ÄØ? C'est un comportement ind√©termin√©. Le programme peut continuer sans rien dire, ou alors s'arr√™ter brusquement avec des erreurs nomm√©es g√©n√©ralement &quot;out of range&quot; (d√©passement de capacit√©) ou &quot;segmentation fault&quot; (erreur de segmentation). Il ne faut pas utiliser d‚Äôindice inf√©rieur √† 0 ou sup√©rieur ou √©gal √† la taille de notre tableau.  ","version":"Next","tagName":"h3"},{"title":"Taille du tableau‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#taille-du-tableau","content":" Pour conna√Ætre la taille du tableau on va utiliser la fonction propre (appel√©e m√©thode) size() qui renvoie le nombre d'√©l√©ments.  remarque Une fonction est un regroupement d'instructions que permet de r√©utiliser du code √† plusieurs endroits d'un programme. Une m√©thode est une fonction propre √† un objet (ici notre std::vector) et qui peut le manipuler ou retourner des informations √† son sujet. Nous en reparlerons plus en d√©tail dans un prochain chapitre, mais nous pouvons d√®s maintenant en utiliser.  Le type de retour de cette m√©thode est un type nouveau, que nous n‚Äôavons pas rencontr√© jusque-l√† et qui s‚Äôappelle std::size_t. C‚Äôest un type entier non sign√© capable de stocker l'index d'un √©l√©ment ou la taille de n‚Äôimporte quel tableau, aussi grand soit-il. C'est, pour faire simple, un tr√®s grand entier positif √©quivalent √† √©crire unsigned long int.  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; std::size_t const size { vector.size() }; std::cout &lt;&lt; &quot;Mon tableau contient &quot; &lt;&lt; size &lt;&lt; &quot; √©l√©ments.&quot; &lt;&lt; std::endl; return 0; }   remarque Il existe aussi une fonction std::size(...) qui prends en param√®tre le tableau et retourne sa taille. std::size_t const size { std::size(vector) }; Dans la pratique, j'utilise plut√¥t la m√©thode, plus lisible selon moi mais c'est un avis personnel et vous √™tes libres de choisir ce qu‚Äôil vous pla√Æt.  ","version":"Next","tagName":"h3"},{"title":"Premier et dernier √©l√©ment‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#premier-et-dernier-√©l√©ment","content":" On pourrait utiliser la taille pour acc√©der au dernier √©l√©ment du tableau mais on peut aussi utiliser deux autres m√©thodes (front() et back()) pour acc√©der au premier et au dernier √©l√©ment du tableau:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; // Fa√ßon de faire h√©rit√© du c en utilisant la taille du tableau (attention au -1 les index commencent √† 0) std::cout &lt;&lt; &quot;Le dernier √©l√©ment est &quot; &lt;&lt; vector[vector.size() - 1] &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le premier √©l√©ment est &quot; &lt;&lt; vector.front() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le dernier √©l√©ment est &quot; &lt;&lt; vector.back() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"V√©rifier si un tableau est vide‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#v√©rifier-si-un-tableau-est-vide","content":" Pour savoir si le tableau est vide on peut utiliser une condition sur la taille du tableau. Il y a aussi la m√©thode empty() qui fait ce test pour nous et permet d'√©crire quelque chose de plus lisible:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector01 { }; std::vector&lt;int&gt; const vector02 { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.size() == 0 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.empty() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector02 est vide : &quot; &lt;&lt; vector02.empty() &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Afficher les √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#afficher-les-√©l√©ments","content":" Pour afficher les √©l√©ments du tableau on peut simplement utiliser sa taille et une boucle for pour it√©rer sur les diff√©rentes valeurs:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; for (std::size_t i {0}; i &lt; vector.size(); i++) { std::cout &lt;&lt; vector[i] &lt;&lt; std::endl; } return 0; }   Range-based for loop‚Äã  Depuis le C++ moderne (√† partir de C++11) il existe une nouvelle fa√ßon de parcourir des conteneurs (qui se g√©n√©ralise sur d'autres structures de donn√©es):  for (/* type d'un √©l√©ment du tableau */ nom : /* structure de donn√©es √† parcourir */) { }   remarque On appelle cela un foreach dans d'autres languages.  Plus besoin de r√©cup√©rer la taille et cela va rendre notre code plus lisible:  Petit exemple avec std::vector #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   ","version":"Next","tagName":"h3"},{"title":"Ajouter, supprimer et modifier des √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#ajouter-supprimer-et-modifier-des-√©l√©ments","content":" Comme expliqu√©, le std::vector est dynamique dans le sens o√π il est possible d'ajouter ou de supprimer des √©l√©ments. C'est avec la m√©thode push_back que l'on ajoute un √©l√©ment:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; vector { 42.f }; // On ajoute des √©l√©ments vector.push_back(23.f); vector.push_back(5.f); for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   attention On ne pourra pas ajouter un √©l√©ment de type diff√©rent dans notre tableau, un tableau ne peut contenir qu'un seul type de variable.    Pour supprimer un √©l√©ment on utilisera les m√©thodes pop_back ou clear.  clear comme son nom l'indique permet de vider enti√®rement le tableau et pop_back permet de retirer le dernier √©l√©ment.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;float&gt; vector { 42.f, 12.f }; std::cout &lt;&lt; &quot;Taille avant clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.clear(); std::cout &lt;&lt; &quot;Taille apr√®s clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.push_back(23.f); vector.push_back(42.f); vector.push_back(25.f); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; vector.pop_back(); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; if(!std::empty(vector)) { float last_value {vector.back()}; vector.pop_back(); std::cout &lt;&lt; &quot;La derniere valeur du tableau etait : &quot; &lt;&lt; last_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; } return 0; }   danger Appeler pop_back sur un tableau vide est aussi un comportement ind√©termin√©. Une tr√®s bonne pratique est donc de s'assurer que le tableau n'est pas vide.    Enfin, pour pouvoir modifier une valeur il suffit d'acc√©der √† l'√©l√©ment (√† condition que le tableau ou la variable ne soit pas constante √©videmment) d'utiliser le symbole √©gal =.  #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 24, 12, 6 }; // On change la valeur du premier √©l√©ment vector[0] = 15; return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::array‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdarray","content":" std::array est un tableau statique, c‚Äôest-√†-dire que sa taille doit √™tre connue √† la compilation et ne peut pas varier. En contre-partie, cette structure de donn√©es est plus performant et plus rapide qu‚Äôun std::vector puisqu‚Äôil n‚Äôy a pas d‚Äôop√©ration d‚Äôajout ou de retrait d‚Äô√©l√©ments.  Pour l‚Äôutiliser, il faut inclure le ficher qui contient cette fonctionnalit√© (#include &lt;array&gt;).  On l'initialise en pr√©cisant entre chevrons le type de variable que l'on souhaite stocker et sa taille:  std::array&lt;/* type des √©l√©ments du tableau */, /* taille du tableau */&gt; nom {};   Contrairement √† std::vector, un tableau statique doit contenir autant d'√©l√©ments que la taille pr√©cis√©e. Ainsi, si l'on ne pr√©cise donc rien ou pas la totalit√© des √©l√©ments √† son initialisation, le tableau va √™tre rempli avec des valeurs par d√©faut.  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array_of_integer { 24, 12, 6, 32, 8 }; // On change la valeur du deuxi√®me √©l√©ment array_of_integer[1] = 42; std::cout &lt;&lt; &quot;Le tableau d'entier contient: &quot;; for (int const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // les 4 autres valeurs non pr√©cis√©es seront donc √©gale √† 0.0f std::array&lt;float, 6&gt; array_of_float { 45.3f, 142.857f }; std::cout &lt;&lt; &quot;Le tableau de flottant contient: &quot;; for (float const value : array_of_float) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // Ce tableau sera rempli de 4 valeurs par d√©faut √©gales √† 0.0 std::array&lt;double, 4&gt; array_of_double { }; return 0; }   Il existe la m√©thode fill sp√©cifique au std::array qui permet de le remplir avec une valeur donn√©e:  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array { 1, 2, 3, 4, 5}; array.fill(3); std::cout &lt;&lt; &quot;Le tableau contient: &quot;; for (int const value : array) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; return 0; }   Le reste des fonctionnalit√©s reste identique avec le std::vector (hors les ajouts et suppressions car le tableau ne change pas de taille ici).  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#pour-aller-plus-loin","content":" std::vector et std::array sont des structures qui disposent d'une multitude de m√©thodes tr√®s utiles, je vous laisse chercher par vous m√™me dans la documentation ou revenir vers moi si vous avez des questions √† ce sujet.  ","version":"Next","tagName":"h2"},{"title":"std::string: un tableau cach√©‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdstring-un-tableau-cach√©","content":" Nous avions d√©couvert le type un peu particulier std::string dans le chapitre sur les variables.  Ce &quot;type&quot; est lui m√™me une structure de donn√©es qui permet de stocker du texte, une suite de caract√®res (de type char donc).  Le type std::string n‚Äôest donc rien d‚Äôautre qu'un tableau dynamique de char, con√ßu et optimis√© sp√©cialement pour le stockage de texte.  On peut donc faire toutes les op√©rations que nous venons de voir, acc√©der √† sa taille, acc√©der aux caract√®res, les modifier, en ajouter ou supprimer et enfin boucler sur les caract√®res.  des exemples #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string phrase { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; &quot;Premier caract√®re : &quot; &lt;&lt; phrase.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dernier caract√®re : &quot; &lt;&lt; phrase.back() &lt;&lt; std::endl; phrase.pop_back(); phrase.push_back('.'); std::cout &lt;&lt; phrase &lt;&lt; std::endl; phrase[9] = ' '; std::cout &lt;&lt; phrase &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Cette phrase contient &quot; &lt;&lt; phrase.size() &lt;&lt; &quot; caract√®res.&quot; &lt;&lt; std::endl; // Il existe aussi &quot;phrase.length()&quot; qui fait exactement la m√™me chose for (char lettre : phrase) { std::cout &lt;&lt; lettre &lt;&lt; ','; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Est ce que la phrase est vide ? &quot; &lt;&lt; std::empty(phrase) &lt;&lt; std::endl; return 0; }   std::string dispose de nombreuses autres m√©thodes permettant de faire d'autres choses sp√©cifiques √† la gestion de texte. Nous aurons l‚Äôoccasion de le revoir, retenez simplement ici que std::string peut √™tre manipul√© comme un tableau.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#r√©sum√©","content":" Il existe plusieurs types de tableaux, statique quand la taille est fixe et dynamique quand elle peut varier.  std::vector est un tableau dynamique.std::array est un tableau statique.std::string est un tableau dynamique sp√©cialement con√ßu pour la gestion du texte. ","version":"Next","tagName":"h2"},{"title":"Un peu d'histoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/introduction","content":"","keywords":"","version":"Next"},{"title":"Pourquoi apprendre C++ ?‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#pourquoi-apprendre-c-","content":" Sa popularit√©‚ÄØ: le C++ est un langage qui est utilis√© dans de nombreux projets importants de d√©veloppement logiciel. Il est √©galement beaucoup utilis√© dans l'industrie du jeu vid√©o. Il est enseign√© dans de nombreuses formations en informatique. Il poss√®de une communaut√© tr√®s importante, beaucoup de documentation et d‚Äôaide en ligne ainsi qu'une biblioth√®ques pr√©existantes tr√®s riche. Sa rapidit√©‚ÄØ: C‚Äôest cette caract√©ristique qui fait de lui un des langages de choix pour les gros logiciels, les calculs scientifiques et le domaine du jeu vid√©o. Son anciennet√©‚ÄØ: C++ est un langage ancien d‚Äôun point de vue informatique, il a fait l'objet de plusieurs mises √† jour ce qui donne une certaine garantie de maturit√©, de stabilit√© et de p√©rennit√© (il ne dispara√Ætra pas dans quelques ann√©es). Sa modernisation‚ÄØ: depuis sa version de 2011, C++ est beaucoup plus facile √† apprendre. La version C++11 le rend plus facile √† utiliser et plus puissant dans les fonctionnalit√©s qu‚Äôil propose.  ","version":"Next","tagName":"h2"},{"title":"Langage difficile ?‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#langage-difficile-","content":" Tout n‚Äôest tout de m√™me pas parfait et le C++ a aussi ses d√©fauts.  Son h√©ritage du C‚ÄØ: C++ est un descendant du langage C, invent√© dans les ann√©es 1970. Certains choix de conception, s√ªrement pertinents pour l‚Äô√©poque, sont plus probl√©matiques aujourd‚Äôhui, et C++ les traine avec lui.  Sa complexit√©‚ÄØ: La libert√© et les performances qu'il offre viennent avec leur lot de complexit√©s. Avoir une certaine ma√Ætrise du C++ est &quot;long&quot; et demandera des ann√©es d‚Äôexp√©rience, notamment parce que certaines des fonctionnalit√©s les plus puissantes demandent de bien conna√Ætre les bases.  Mais je vous rassure, nous allons commencer par les bases pour aborder pas √† pas ce langage, que vous ayez d√©j√† programm√© ou non. Nous allons d√©couvrir les notions petit √† petit pour que ce soit le plus compr√©hensible possible (certaines notions plus complexes ne seront d'ailleurs vu qu'en deuxi√®me ann√©e).  ","version":"Next","tagName":"h2"},{"title":"La documentation‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#la-documentation","content":" En programmation, un bon r√©flexe √† adopter est d'aller consulter la documentation de l‚Äôoutil concern√©, et ce avant de demander de l‚Äôaide sur un forum par exemple.  Voici un lien vers une excellente documentation C++. Elle est en anglais, mais je suis √©galement l√† pour vous aider. Je vous donnerai des liens, vous expliquerai comment comprendre et exploiter les informations fournies pour que, par la suite, vous puissiez le faire vous-m√™me.  Enfin, sachez qu‚Äôil existe une r√©f√©rence ultime appel√©e la norme, produit par un organisme de validation international, l'ISO, qui explique tous les d√©tails et les r√®gles du C++ mais qui est un document (trop) complexe, m√™me pour des professionels, et est donc largement hors de port√©e nous concernant. Je le mentionne simplement pour que vous soyez au courant de son existence, sans √™tre surpris si, lors de vos recherches sur Internet, des r√©ponses mentionnent ou citent la norme.  ","version":"Next","tagName":"h2"},{"title":"Compil√© vs interpr√©t√©‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#compil√©-vs-interpr√©t√©","content":" Il existe deux grands types de langages informatiques, les langages interpr√©t√©s et compil√©s.  Dans un langage interpr√©t√©, le m√™me code source pourra marcher directement sur tout ordinateur disposant de l'interpr√©teur n√©cessaire, c'est le cas du Python par exemple.  remarque L'interpr√©teur est un programme en lui m√™me qui interpr√®te le code pour le convertir en instructions compr√©hensibles pour la machine.  Avec un langage compil√©, il faut compiler son programme (enti√®rement ou recompiler partiellement) √† chaque fois pour pouvoir obtenir un ex√©cutable utilisable sur la machine sur laquelle on veut lancer celui-ci.  Cela n√©cessite donc une √©tape suppl√©mentaire (plus ou moins rapide): la compilation. Mais cela apporte √©galement l'avantage de pouvoir optimiser et adapter l'ex√©cutable pour une ou des machines sp√©cifiques.  Dans la majorit√© des cas, l'ex√©cutable compil√© sera plus performant et plus rapide qu'un √©quivalent dans un langage interpr√©t√©.  Dans votre cas, vous allez coder en C++ qui est un langage compil√© et ce sera donc la premi√®re √©tape de ce cours.  Nous allons voir ensemble comment installer tous les outils n√©cessaires √† tout d√©veloppeur C++ sur votre machine afin d'ex√©cuter votre premier programme C++. ","version":"Next","tagName":"h2"},{"title":"Compilation et Headers: S√©parer en plusieurs fichiers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Headers","content":"","keywords":"","version":"Next"},{"title":"M√©canisme de compilation (en simple)‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#m√©canisme-de-compilation-en-simple","content":" Revenons √† la compilation quelques instants pour mieux comprendre.  Quand j'ai parl√© de compilation j'ai fait un abus de langage et j'ai englob√© plusieurs √©tapes. Pour faire simple, il y a en r√©alit√© trois grandes √©tapes lors de la compilation en C++:  Le pr√©processeurLa compilationLe linkage  ","version":"Next","tagName":"h2"},{"title":"Le pr√©processeur‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-pr√©processeur","content":" La toute premi√®re √©tape est celle du pr√©processeur. C'est le moment o√π toutes les directives pr√©processeur sont trait√©es (toutes les lignes commen√ßant par #).  Par exemple, nous avons d√©j√† la directive pr√©processeur #include qui permet d'inclure des fonctionnalit√©s.  Cette directive fait simplement un copi√©-coll√© du contenu du fichier √† inclure dans le fichier o√π la directive est utilis√©e.  Je ne vais pas en parler ici mais sachez qu'il existe d'autres directives permettant de faire des conditions en fonction des plateformes par exemple.  ","version":"Next","tagName":"h3"},{"title":"La compilation‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#la-compilation","content":" Ensuite nous avons la compilation √† proprement parler.  Chaque fichier .cpp, obtenu apr√®s les modifications du pr√©processeur, appel√© unit√© de compilation, va √™tre trait√© individuellement. Le but de cette √©tape est de transformer le code C++ (sous format texte) en langage compr√©hensible pour l'ordinateur.  C‚Äôest √† cette √©tape que des v√©rifications du code ont lieu. Par exemple, dans le cas o√π le compilateur ne trouve pas la d√©claration d‚Äôune fonction que vous appelez. Dans notre exemple pr√©c√©dent dans le fichier main.cpp, la compilation va s'arr√™ter avec un message d'erreur indiquant ce qui n‚Äôa pas fonctionn√©.  Cette √©tape va produire des fichiers objets.  Un fichier objet, reconnaissable √† son extension en .o ou .obj, n‚Äôest rien d‚Äôautre que du langage machine mais seul, sans aucun lien avec le reste des autres fichiers. Tel quel, il n‚Äôest pas ex√©cutable, car il lui manque des informations.  Il est possible de pr√©ciser aux compilateurs que l'on souhaite s'arr√™ter √† ce stade en ajoutant des flags de compilation:  WindowsLinux et MacOS Avec MSVC le flag est /c: cl /c helloImac.cpp   Cela indique au compilateur que l'on souhaite produire des fichiers objets et pas directement lier les fichiers pour en faire un ex√©cutable.  Les fichiers d'objets peuvent faire r√©f√©rence √† des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore enti√®rement d√©finis. C'est le cas lorsque l'on utilise une fonction d√©clar√©e et que l'on n'a pas encore √©crit le corps de celle-ci, nous allons le voir juste apr√®s. Le compilateur ne s'en pr√©occupe pas et produit le fichier objet demand√© si le reste du code est correct.  remarque L'avantage est qu'il n'est pas n√©cessaire de tout recompiler si vous ne modifiez qu'un seul fichier. Si aucune modification n‚Äôest d√©tect√©e depuis la derni√®re compilation, alors le compilateur r√©utilise le fichier objet pr√©c√©demment cr√©√© lors d'une prochaine compilation ce qui acc√©l√®re la compilation d‚Äôun projet. Cmake g√®re les fichiers objets lui m√™me automatiquement dans le fameux dossier build.  ","version":"Next","tagName":"h3"},{"title":"Le linkage‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-linkage","content":" Nos fichiers objets ne sont pas utilisables en l'√©tat et c'est la derni√®re √©tape de linkage qui va les lier entre eux pour produire un ex√©cutable.  C'est ce qui va permettre de lier la d√©claration d'une fonction dans un fichier et le corps de la fonction dans un autre fichier par exemple.  Il est aussi possible de faire cette op√©ration en ligne de commande √† partir des fichiers objets mais ce n'est pas tr√®s utile en pratique car des outils comme CMake se charge de cette √©tape pour nous.  ","version":"Next","tagName":"h3"},{"title":"En pratique‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#en-pratique","content":" Revenons √† notre exemple avec les fichiers maths.cpp et main.cpp:  Premi√®rement, il manque la d√©claration de la fonction sum (son prototype) dans le fichier main.cpp pour pouvoir produire un fichier objet valide:  main.cpp #include &lt;iostream&gt; int sum (int const a, int const b); int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   Ce fichier ne permet toujours pas de cr√©er un ex√©cutable √† lui seul (car il manque le corps de la fonction sum) mais il est maintenant possible d'en faire un fichier objet.  ","version":"Next","tagName":"h2"},{"title":"Fichier d'en-t√™te‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#fichier-den-t√™te","content":" Pour une seule fonction dans mon exemple c'est simple de recopier le prototype de la fonction. Imaginons que notre fichier maths.cpp soit compos√© de dizaines de fonctions et que l'on souhaite les utiliser dans le fichier main.cpp mais aussi dans un autre fichier du m√™me projet. Cela commence √† √™tre fastidieux de tout recopier.  On va donc regrouper les d√©clarations des fonctions dans un autre fichier d'extension .hpp que l'on appelle fichier d'en-t√™te (header en anglais).  Ainsi gr√¢ce √† la directive pr√©processeur #include on va pouvoir inclure (recopier) toutes les d√©clarations des fonctions facilement.  Dans notre exemple le fichier d'en-t√™te serait simplement:  maths.hpp int sum (int const a, int const b);   et le main.cpp devient:  main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   guillemets ou chevrons On peut noter une petite diff√©rence, j'utilise ici des guillemets &quot;&quot; pour l'inclusion et pas des chevrons &lt; &gt;. On pourrait tr√®s bien utiliser des guillemets tout le temps et faire: #include &quot;iostream&quot;. Cette diff√©rence est une question de convention et on r√©serve les chevrons &lt; &gt; pour les fichiers de qui viennent de biblioth√®ques comme la biblioth√®que standard (iostream, string, vector, etc) et les guillemets &quot;&quot; pour le reste.  On va √©galement inclure ce fichier d'en-t√™te dans notre fichier maths.cpp pour s'assurer que l'on impl√©mente les bonnes fonctions list√©es dans le fichier d'en-t√™te.  maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   cpp ou hpp Les fichiers d‚Äôen-t√™te peuvent aussi utiliser l‚Äôextension .h. La diff√©rence n‚Äôest qu‚Äôune histoire de go√ªt. Je pr√©f√®re utiliser .hpp plut√¥t que .h pour mieux faire la distinction entre C et C++ par analogie aux fichiers sources, qui se terminent par .cpp en C++ mais .c en C.  ","version":"Next","tagName":"h3"},{"title":"Pragma once: √©viter les doublons‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#pragma-once-√©viter-les-doublons","content":" Mais se pose alors la question des doublons si l'on inclut de nombreux fichiers, les uns d√©pendants des autres.  Dans le cas des fonctions ce n'est pas bien grave car d√©clarer plusieurs fois une fonction (je parle du prototype pas du corps qui lui doit √™tre unique) est autoris√© bien que ce soit inutile.  Par contre ce n'est pas toujours le cas. Par exemple avec les Enums il n'est pas possible de les d√©clarer deux fois et on obtient une erreur de compilation si on le fait.  Un exemple Admettons que l'on a un autre fichier utils.cpp qui inclut maths.cpp pour fonctionner. utils.hpp contient les d√©clarations des fonctions propres au fichier utils.cpp. Le fichier maths.hpp d√©finit un enum. Si maintenant on souhaite utiliser des fonctions des deux fichiers dans notre fichier principal main.cpp, on va se retrouver √† inclure les deux: main.cpp #include &quot;utils.hpp&quot; #include &quot;maths.hpp&quot; int main() { // ... return 0; } Cela va provoquer une erreur lors de la compilation du fichier objet main car l'enum est d√©clar√© deux fois. Une fois provenant de l'inclusion de utils.hpp (qui inclut lui-m√™me maths.hpp) et une seconde fois en incluant directement le fichier maths.hpp.  #pragma once est une directive du pr√©processeur l√† pour r√©pondre √† notre besoin.  Elle est utilis√©e pour emp√™cher que le contenu des fichiers d'en-t√™te soient inclus plusieurs fois. La directive #pragma once, pr√©sente dans un fichier d'en-t√™te, garantit que le contenu du fichier sera inclus une seule fois dans une compilation.  Le fichier maths.hpp dans notre exemple devient donc:  maths.hpp #pragma once int sum (int const a, int const b);   Un fichier d'en-t√™te doit toujours contenir cette directive au d√©but du fichier.  Structures‚Äã  Bien que ce soit possible de mettre la d√©claration d'une structure dans un fichier .cpp g√©n√©ralement on a besoin de s'en resservir dans plusieurs fichiers et la d√©claration se trouve donc dans un fichier d'en-t√™te (.hpp).  Cependant, comme pour les enums, une structure ne peut √™tre d√©clar√©e qu'une fois et il ne faut donc surtout pas oublier la directive pr√©processeur #pragma once pour √©viter un doublon lors d'inclusions.  On utilisera dans ce cas la d√©claration de la structure avec les prototypes des fonctions qui lui sont associ√©es dans notre fichier d'en-t√™te.  ","version":"Next","tagName":"h3"},{"title":"Espaces de noms‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#espaces-de-noms","content":" Il est possible de regrouper du code (d√©claration, fonction, ect) dans un espace de noms (namespace en anglais) pour √©viter les conflits de noms.  Nous avons d√©j√† rencontr√© sans le savoir des espaces de noms avec la biblioth√®que standard de C++. Par exemple, std::cout est dans l'espace de noms std (pour standard).  Cela permet de diff√©rencier et s√©parer des fonctions (venant de diff√©rentes biblioth√®ques par exemple) qui ont le m√™me nom.  Par exemple, si vous avez deux fonctions sum (avec la m√™me signature) dans deux fichiers diff√©rents, vous allez avoir une erreur de compilation car le compilateur ne saura pas laquelle choisir.  Dans ce cas, vous pouvez les mettre dans un espace de noms pour les diff√©rencier.  Pour cela on utilise le mot cl√© namespace suivi du nom de l'espace de noms et des accolades pour d√©limiter le code qui appartient √† cet espace de noms.  maths.hpp namespace Maths { int sum (int const a, int const b); }   Pour d√©finir la fonction on va devoir pr√©ciser l'espace de noms en ajoutant le pr√©fixe Maths:: devant le nom de la fonction.  On peut √©galement de nouveau utiliser le mot cl√© namespace si on souhaite d√©finir plusieurs fonctions dans le m√™me espace de noms.  maths.cpp #include &quot;maths.hpp&quot; int Maths::sum (int const a, int const b) { return a + b; }   Pour appeler la fonction sum dans le fichier main.cpp il faudra maintenant pr√©ciser l'espace de noms en ajoutant le pr√©fixe Maths:: devant le nom de la fonction.  main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + 2*b; } int main() { // Cette ligne va appeler la fonction sum du namespace Maths std::cout &lt;&lt; Maths::sum(42, 27) &lt;&lt; std::endl; // Cette ligne va appeler la fonction sum d√©clar√©e dans le fichier main.cpp std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Utiliser Cmake‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#utiliser-cmake","content":" Pour r√©sumer nous avons donc maintenant les fichiers suivants:  maths.hpp #pragma once int sum (int const a, int const b);   main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   Nous allons les placer dans un dossier de projet puis dans un sous dossier /src (pour sources). Pour certains projets on peut avoir plusieurs sous dossiers comme /src, /include (pour s√©parer les fichiers d'en-t√™te). C'est une question d'organisation et de pr√©f√©rence.  Dans ce dossier de projet nous allons cr√©er notre fichier CMakeLists.txt pour nous aider √† compiler le projet.  Nous allons reprendre et modifier notre premier fichier Cmake.  Dans le fichier CMakeLists.txt il va falloir indiquer les r√©pertoires o√π se trouvent les fichiers d'en-t√™te par target_include_directories().  On va √©galement r√©gler une variable Cmake CMAKE_RUNTIME_OUTPUT_DIRECTORY qui va permettre d'indiquer que l'on souhaite placer l'ex√©cutable compil√© dans un sous dossier bin.  CMakeLists.txt # la version de cmake √† utiliser cmake_minimum_required(VERSION 3.10) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On souhaite placer l'ex√©cutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # On indique que l'on souhaite faire un ex√©cutable avec nos deux fichiers .cpp add_executable(helloImac &quot;src/main.cpp&quot; &quot;src/maths.cpp&quot;) # le dossier contenant les fichiers d'en-t√™te pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   CMAKE_SOURCE_DIR est une variable cmake qui indique le dossier dans lequel se trouve le fichier CMakeLists.txt (documentation ici).  attention Il faut s'assurer qu'il y a exactement une fonction d'entr√©e main() dans les fichiers sources list√©s pour un ex√©cutable.  Petit r√©sum√© de notre dossier:  projet_folder/ ‚îú‚îÄ‚îÄ src/ ‚îÇ ‚îú‚îÄ‚îÄ main.cpp ‚îÇ ‚îú‚îÄ‚îÄ maths.cpp ‚îÇ ‚îî‚îÄ‚îÄ maths.hpp ‚îî‚îÄ‚îÄ CMakeLists.txt   Vous pouvez maintenant ouvrir le dossier de projet dans VSCode et compiler votre projet.  ","version":"Next","tagName":"h2"},{"title":"Quelques am√©liorations‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#quelques-am√©liorations","content":" Je vous ai parl√© de &quot;warnings&quot; de compilation √† plusieurs reprises. Il est possible d'ajouter des options pour activer des warnings et avoir des informations suppl√©mentaires lors de la compilation.  Je vous propose d'ajouter ces lignes dans votre fichier CMakeLists.txt:  if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif()   Cela va se complexifier avec un nombre plus important de fichiers sources. Avec Cmake il est possible de faire une recherche de fichier afin de ne pas avoir √† lister tous les fichiers sources manuellement:  file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;)   Notre fichier CMakeLists.txt devient:  # la version de cmake √† utiliser cmake_minimum_required(VERSION 3.10) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # R√©glage du compilateur pour les warnings if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # On souhaite placer l'ex√©cutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources message(STATUS &quot;Found source files:&quot;) foreach(SRC_FILE ${SRC_FILES}) message(STATUS &quot; - ${SRC_FILE}&quot;) endforeach() # On indique que l'on souhaite faire un ex√©cutable avec nos fichiers sources add_executable(helloImac ${SRC_FILES}) # le dossier contenant les fichiers d'en-t√™te pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#r√©sum√©","content":" Les fichiers d'en-t√™te ou headers (d'extension .hpp) sont l√† pour lister les diff√©rentes d√©clarations des fonctions (et d'autres choses comme les enums) afin de pouvoir les utiliser dans plusieurs fichiers. Les fichiers objets sont des fichiers g√©n√©r√©s pendant la compilation. Ils peuvent faire r√©f√©rence √† des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore enti√®rement d√©finis mais seulement d√©clar√©s (et inclus √† l'aide des fichiers d'en-t√™te). Ils permettent aussi d'acc√©l√©rer la compilation pour r√©utiliser des parties de code inchang√©es. La directive pr√©processeur #include fait simplement un copier-coller du fichier cible dans le fichier actuel. La directive pr√©processeur #pragma once permet d'√©viter de copier deux fois des d√©clarations lors d'inclusions. C'est tr√®s utile pour les fichiers d'en-t√™te contenant des enums ou des structures. Il faut toujours l'utiliser dans les fichiers d'en-t√™te. il y a 3 √©tapes dans la compilation: Le pr√©processeur qui transforme les directives pr√©processeur comme #include ou #pragma once.La compilation qui g√©n√®re des fichiers objets pour chaque unit√© de compilation (fichiers .cpp apr√®s traitement du pr√©processeur).Le linkage qui permet de lier tous les fichiers objets ensemble pour obtenir un ex√©cutable. Cmake permet de g√©rer ces √©tapes de compilation simplement. ","version":"Next","tagName":"h2"},{"title":"Mise en place des outils","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/","content":"Mise en place des outils Comme expliqu√© pr√©c√©demment le C++ est un langage compil√© et il va donc falloir installer un compilateur. Mais ce n'est pas tout, il est aussi pr√©f√©rable d'utiliser un √©diteur ou IDE (Integrated Development Environment) adapt√© pour coder et je vous propose d'utiliser Visual Studio Code. De plus, nous installerons √©galement un petit outil suppl√©mentaire pour simplifier grandement l'√©tape de compilation (et particuli√®rement plus tard pour un projet compos√© de plusieurs fichiers).","keywords":"","version":"Next"},{"title":"Fonctions : D√©couper son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Structure d'une fonction‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#structure-dune-fonction","content":" Une fonction est un ensemble d'instructions d√©limit√© par des accolades { et } ce qui d√©fini sa port√©e (scope).  Elle a un nom et peut ou non prendre des informations en entr√©e et peut ou non fournir une information en sortie.  type_de_retour nom(param√®tres) { instructions }   Un exemple bien connu D√®s notre premier programme nous avions rencontr√© une fonction, la fonction main. Celle-ci est le point d‚Äôentr√©e de tous les programmes que nous codons en C++. int main() { // Instructions diverses return 0; } Ici, main est le nom de la fonction. Le int situ√© juste avant indique son type de retour. Dans ce cas, la fonction renvoie une valeur enti√®re (via le return 0;) qui indique que tout s‚Äôest bien pass√©. Apr√®s, le nom, il y a des parenth√®ses vides (), ce qui signifie que la fonction n‚Äôattend aucune information en entr√©e. Enfin, entre les accolades , nous avons les instructions qui la composent.  ","version":"Next","tagName":"h2"},{"title":"Choisir un nom‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#choisir-un-nom","content":" Les r√®gles de nommage des fonctions sont les m√™mes que pour nommer nos variables, vous pouvez aller les relire ici si n√©cessaire.  De m√™me que pour les variables, il est important de donner un nom explicite aux fonctions afin de d√©finir clairement ce qu‚Äôelles font.  ","version":"Next","tagName":"h3"},{"title":"Type de retour‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#type-de-retour","content":" Une fonction peut ou non renvoyer une valeur de retour, comme nous l‚Äôavons vu avec la fonction main. Il faut simplement pr√©ciser le type de la valeur √† retourner comme vu pr√©c√©demment.  Pour renvoyer une valeur, on utilise le mot-cl√© return, exactement comme dans la fonction main.  info Il peut y avoir plusieurs return dans une fonction. Un si un if est vrai, l‚Äôautre s‚Äôil est faux par exemple. Mais d√®s que l'instruction return est ex√©cut√©e, on sort de la fonction en cours et tout le code restant n‚Äôest pas ex√©cut√©. Cela coupe le flot d‚Äôex√©cution de la fonction comme avec les mots-cl√©s break et continue avec les boucles.  Si votre fonction ne doit rien renvoyer, alors on utilise le mot-cl√© void, qui signifie &quot;vide&quot; et qui, dans ce contexte, indique que la fonction ne retourne pas d'information (dans ce cas il n'est pas n√©cessaire d'utiliser l'instruction return mais peut tout de m√™me √™tre utilis√©e pour couper le flot d‚Äôex√©cution).  ","version":"Next","tagName":"h3"},{"title":"Des param√®tres‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#des-param√®tres","content":" Maintenant, parlons des param√®tres. C'est via des param√®tres que la fonction d√©crit ce qu'elle attend pour travailler.  On les d√©clare entre les parenth√®ses (()). Il faut que chaque param√®tre ait un type et un nom. S‚Äôil y en a plusieurs, ils seront s√©par√©s par des virgules.  Des exemples #include &lt;iostream&gt; int sum (int a, int b) { return a + b; } int pgcd(int a, int b) { int r { a % b }; while (r != 0) { a = b; b = r; r = a % b; } // On peut tout √† fait renvoyer la valeur d'un param√®tre return b; } int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le PGCD de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; pgcd(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   attention Une fonction doit √™tre d√©clar√©e avant son utilisation. Il faut donc la d√©clarer avant la fonction main afin d'√™tre en mesure de l'utiliser dans la fonction main par exemple.  Le nom donn√© aux param√®tres d'une fonction est sp√©cifique √† cette fonction et n'est pas partag√© par le reste du code. Il est possible de donner en argument √† une fonction une variable qui porte le m√™me nom qu‚Äôun des param√®tres.  Inversement, il n‚Äôest pas possible d‚Äôutiliser un param√®tre de fonction en dehors de celle-ci. Le code suivant produit donc une erreur.  int function(int parameter) { parameter += 5; return parameter; } int main() { int const a { function(37) }; int const b { function(a) }; // La variable parameter n'existe pas ici parameter = 410; return 0; }   Argument vs param√®tre Attention, il faut bien faire la distinction entre param√®tre et argument. Un param√®tre, c‚Äôest ce qu‚Äôattend une fonction pour travailler et qui est inscrit dans sa d√©claration, le nom du param√®tre est propre √† la fonction et utilisable uniquement dans celle-ci. Un argument, c‚Äôest la valeur transmise √† la fonction quand on l‚Äôutilise. Dans notre exemple pr√©c√©dent parameter est le param√®tre de la fonction. 37 est l'argument de la fonction pour l'assignation de la variable a. Ensuite a devient lui m√™me argument de la fonction pour l'assignation de b. En pratique, il y a souvent un abus de langage et les deux termes s'utilisent de fa√ßon interchangeable et je ne vous en voudrais si vous faites de m√™me mais je tenais √† vous expliquer la diff√©rence.  ","version":"Next","tagName":"h3"},{"title":"Petit point vocabulaire: les m√©thodes‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#petit-point-vocabulaire-les-m√©thodes","content":" Dans le pr√©c√©dent chapitre sur les tableaux nous avons vu des fonctions propres ou m√©thodes.  On parle de m√©thode quand une fonction est associ√©e √† un objet. C'est le cas par exemple de la fonction size() sur l'objet std::vector. Elle s'utilise avec un point . apr√®s le nom de la variable en question. On dit que size() est une m√©thode de std::vector. Une m√©thode a donc &quot;connaissance&quot; de l'objet en question pour le modifier, lire des informations, etc.  std::vector&lt;int&gt; const array { 12, 18, 8, 4, 9 }; std::size_t const size { array.size() };   Nous y reviendrons plus tard, pour l'instant gardez simplement √† l'esprit que c'est r√©serv√© √† des type &quot;particuliers&quot; comme le std::vector ou std::string et que l'on appelle √ßa des m√©thodes.  ","version":"Next","tagName":"h3"},{"title":"Une port√©e limit√©e‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#une-port√©e-limit√©e","content":" J'avais d√©j√† √©voqu√© la notion de port√©e (ou scope) lors de l'introduction des stuctures de contr√¥le. Cette notion est aussi vraie avec les fonctions. Les instructions d'une fonction sont contenues entre des accolades et donc restreignent la port√©e des variables √† l'int√©rieur de ce bloc.  C‚Äôest une bonne pratique de d√©clarer ses variables dans la plus petite port√©e possible.  Cela permet premi√®rement de limiter son utilisation √† cette port√©e et √©viter un usage malencontreux plus tard. D√©clarer une variable proche de son utilisation √©vite de devoir chercher et parcourir un code parfois long et complexe pour comprendre pourquoi cette variable est utilis√©e √† cet endroit pr√©cis. Cela aide donc √† la lecture et la compr√©hension du code.  Enfin, lorsqu‚Äôon atteint la fin d'un bloc (accolade }), le programme lib√®re dans la m√©moire les emplacements qu‚Äôil avait r√©serv√©s pour les variables du bloc en question. C'est donc plus propre et plus performant (niveau m√©moire) de d√©clarer les variables √† l‚Äôint√©rieur d'un bloc (fonction, condition, etc) si elles ne sont pas destin√©es √† √™tre utilis√©es ailleurs.  ","version":"Next","tagName":"h2"},{"title":"Param√®tre par copie‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#param√®tre-par-copie","content":" J‚Äôai expliqu√© pr√©c√©demment que les param√®tres d‚Äôune fonction √©taient dans une port√©e diff√©rente concernant le nommage.  La port√©e diff√©rente implique une copie. Pour chaque utilisation de la fonction, le compilateur va r√©server un nouvel espace m√©moire et copier l'argument (la variable) qu‚Äôon lui passe en param√®tre. Une variable dans la fonction est donc totalement diff√©rente. C‚Äôest ce qu'on appelle un passage par copie.  On peut donc nommer nos param√®tres avec le m√™me nom qu'une de nos variables.  Un exemple #include &lt;iostream&gt; void addOne(int a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   On pourrait penser que cela va afficher 9 mais en r√©alit√© a est toujours √©gal √† 8. la fonction addOne a re√ßu une copie de la variable a (nomm√©e a elle aussi) mais elle ne peut pas modifier la variable a originale.  Dans le cas d‚Äôun entier ou d‚Äôun caract√®re par exemple ce n'est pas tr√®s grave, mais dans le cas d‚Äôun tableau de plusieurs d‚Äô√©l√©ments, on perd du temps inutilement √† copier toutes les valeurs du tableau (m√™me si on ne veut en lire que quelques unes dans la fonction).  ","version":"Next","tagName":"h2"},{"title":"R√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rence","content":" Mais, en C++, il existe un moyen de cr√©er un alias, une r√©f√©rence vers une variable. Cette r√©f√©rence devient manipulable comme si nous avions la variable originale entre les mains.  On indique qu'une variable est une r√©f√©rence vers une autre en ajoutant une esperluette (&amp;) apr√®s le type de notre variable.  #include &lt;iostream&gt; int main() { int a { 8 }; // refA est une r√©f√©rence vers la variable a int &amp; refA { a }; // ici je modifie donc la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   danger On ne peut pas cr√©er de r√©f√©rence qui ne cible rien, ni changer la cible d‚Äôune r√©f√©rence une fois qu‚Äôon l‚Äôa cr√©√©e. Une r√©f√©rence est un alias vers une autre variable, si on essaye de l'assigner de nouveau cela revient √† modifier la variable originale et pas √† r√©atribuer la r√©f√©rence. #include &lt;iostream&gt; int main() { int a { 8 }; int b { 42 }; int &amp; refA { a }; refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; // ici refA reste une r√©f√©rence vers la variable a qui prend la valeur de b // refA ne devient PAS une r√©f√©rence vers la variable b refA = b; // Je modifie ici toujours la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par r√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#passage-par-r√©f√©rence","content":" Cela devient int√©ressant dans nos fonctions o√π il va aussi √™tre possible de d√©clarer un param√®tre en tant que r√©f√©rence et non pas comme une copie de la variable originale.  Pour indiquer que l'on souhaite recevoir une r√©f√©rence il faut ajouter une esperluette (&amp;) apr√®s le type de notre param√®tre.  remarque Bien entendu on ne pourra passer en argument qu'une variable du m√™me type que le type de la r√©f√©rence attendue par la fonction.  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"R√©f√©rence constante‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rence-constante","content":" Je vous avais dit que les variables constantes allaient prendre tout leur importance et bien c'est ici ! :partying_face:  En effet, si on manipule une r√©f√©rence, on peut tr√®s bien modifier la variable originale comme vu pr√©c√©demment. Mais parfois on aimerait utiliser une r√©f√©rence (pour √©viter une copie d'un tableau par exemple) mais prot√©ger la variable originale et interdire les modifications de celle-ci, un mode lecture seule.  On peut donc rajouter le mot cl√© const dans notre param√®tre comme cela:  #include &lt;iostream&gt; #include &lt;vector&gt; float sum(std::vector&lt;float&gt; const&amp; list) { float sum {0}; for(float const value: list) { sum += value; } return sum; } int main() { std::vector&lt;float&gt; list { 8.f, 4.2f, 3.1415f, 43.8f }; float sum { sum(list) }; std::cout &lt;&lt; &quot;La somme des valeurs de mon tableau est de &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   Si vous essayez de modifier un param√®tre constant vous allez obtenir une erreur (et c'est tant mieux !).  #include &lt;iostream&gt; void addOne(int const&amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   main.cpp: In function ‚Äòvoid addOne(const int&amp;)‚Äô: main.cpp:4:7: error: assignment of read-only reference ‚Äòa‚Äô 4 | a += 1; | ~~^~~~   Le compilateur nous indique qu'il y a une tentative de modification d'un param√®tre d√©clar√© comme constant.  C'est donc une s√©curit√© importante pour √©viter des erreurs et je vous recommande d'utiliser des variables ou param√®tres constants d√®s que possible.  remarque Une r√©f√©rence constante ne peut √©videmment pas redevenir modifiable et le code ci-dessous va aussi produire une erreur de compilation. #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } void readyOnlyFunction(int const &amp; a) { addOne(a); } int main() { int a { 8 }; readyOnlyFunction(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Le cas des litt√©raux‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#le-cas-des-litt√©raux","content":" Avec les lit√©raux il se passe un autre m√©canisme.  Le code ci-dessous ne va pas compiler, √† cause de la ligne 15.  #include &lt;iostream&gt; void display(int &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { display(42); displayConst(42); return 0; }   En effet, nous passons un lit√©ral √† notre fonction qui attend une r√©f√©rence, un alias, sur une variable modifiable. Un lit√©ral n'est pas √† proprement parl√© une variable, il est invariable et n‚Äôexiste nulle part en m√©moire, il n'est pas modifiable.  Par contre, supprimez-la et le code compilera, la fonction displayConst ne pose pas de probl√®me de compilation. La seule diff√©rence entre les deux fonctions, c‚Äôest la pr√©sence du mot-cl√© const.  Ici, le compilateur va cr√©er une variable constante temporaire, qui n‚Äôexistera que le temps que la fonction, et va lui assigner le lit√©ral comme valeur. Cela revient √† faire cela par exemple:  #include &lt;iostream&gt; void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { { int const temporaryVariable { 42 }; displayConst(temporaryVariable); // A la sortie de ce scope (d√©limit√© entre accolades) la variable temporaire va √™tre d√©truite } return 0; }   C'est donc pr√©f√©rable d'utiliser des param√®tres constants car cela permet √©galement de rendre compatible nos fonctions avec les litt√©raux.  ","version":"Next","tagName":"h3"},{"title":"Retour par r√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#retour-par-r√©f√©rence","content":" Les r√©f√©rences ont une contrainte particuli√®re‚ÄØ: elles doivent toujours √™tre valides.  Dans le cas d‚Äôun param√®tre de fonction il n'y a pas de probl√®me car l‚Äôargument transmis √† la fonction existera toujours quand celle-ci se terminera:  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; // la variable a est pass√©e en argument addOne(a); // Ici la variable a existe toujours return 0; }   Mais, dans le cas o√π l‚Äôon souhaite qu‚Äôune fonction retourne une r√©f√©rence, cela peut √™tre dangereux et on peut renvoyer une r√©f√©rence sur une variable qui n‚Äôexistera plus √† la fin de la fonction‚ÄØ!  #include &lt;iostream&gt; int&amp; test() { int a { 33 }; return a; // A la fin du scope de la fonction la variable 'a' va √™tre d√©truite } int main() { int &amp; reference { test() }; // ici notre r√©f√©rence est invalide ! return 0; }   C'est un comportement ind√©termin√©. Il ne produira pas d'erreur de compilation mais l'utilisation de la r√©f√©rence est invalide.  danger Il ne faut jamais renvoyer une r√©f√©rence vers une variable locale √† une fonction.  ","version":"Next","tagName":"h3"},{"title":"R√©f√©rences et types standard‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rences-et-types-standard","content":" Utiliser des r√©f√©rences pour std::vector ou std::string d‚Äôaccord, mais qu‚Äôen est-il des types standard comme int, char et double ? Y a-t-il un int√©r√™t √† utiliser des r√©f√©rences ? Doit-on bannir toutes les copies de notre code ?  Les types standard sont petits (en m√©moire) et le co√ªt de la cr√©ation d‚Äôune r√©f√©rence sur des types aussi simples est souvent plus √©lev√© ou √©quivalent que celui d‚Äôune &quot;b√™te&quot; copie. En effet, le compilateur arrive tr√®s souvent √† optimiser les copies et les rendre extr√™mement rapides, bien plus qu‚Äôavec les r√©f√©rences.  Donc ne tombez pas dans le pi√®ge de l‚Äôoptimisation pr√©matur√©e. Pensez au r√©f√©rences lorsqu'il s'agit d'objets &quot;gros&quot;. Vouloir mettre des r√©f√©rences partout n'est pas une erreur (et je ne vous en tiendrai pas compte au contraire cela veux dire que vous pensez aux r√©f√©rences). Mais, garder √† l'esprit que cela a aussi un co√ªt de cr√©er une r√©f√©rence et que laisser juste un int const parameter permet au compilateur de mieux optimiser le code.  ","version":"Next","tagName":"h2"},{"title":"Signature et fonctions surcharg√©es‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#signature-et-fonctions-surcharg√©es","content":" Ce qui diff√©rencie deux fonctions, √ßa n‚Äôest pas seulement leur nom mais √©galement leurs param√®tres. C‚Äôest ce qu‚Äôon appelle la signature d‚Äôune fonction.  On peut donc tr√®s bien avoir deux fonctions qui ont le m√™me nom mais pas les m√™mes param√®tres:  #include &lt;iostream&gt; void testDisplay(int const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void testDisplay(float const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { testDisplay(42); testDisplay(63.5f); return 0; }   Ici, le compilateur voit deux signatures diff√©rentes testDisplay(int const a) et testDisplay(float const a) il n'y a donc pas de probl√®me.  On appelle cela la surcharge, de l‚Äôanglais &quot;overloading&quot;. Cela rend le code plus simple et le compilateur appelle la bonne surcharge de la fonction pour les arguments pr√©cis√©s (si elle existe √©videmment).  Par contre, le type de retour n'est pas une forme de surcharge. Deux fonctions avec le m√™me nom, les m√™mes param√®tres et des types de retour diff√©rents ne compileront pas. Et c‚Äôest logique, car comment savoir quelle fonction utiliser et quoi retourner sans ambigu√Øt√© sinon ?  ","version":"Next","tagName":"h2"},{"title":"Prototype: d√©claration des fonctions‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-d√©claration-des-fonctions","content":" J'ai expliqu√© pr√©c√©demment qu'une fonction a besoin d'√™tre d√©clar√©e avant son utilisation. C'est vrai mais incomplet.  Cette d√©claration peut se faire √† l'aide de ce qu'on appelle le prototype de la fonction.  Le prototype est tr√®s similaire √† la signature et est compos√© du nom, des param√®tres(et leur type) ET du type de retour de la fonction.  Voil√† un petit exemple de fonction et son prototype:  // la d√©claration de la fonction sum avec son prototype int sum (int a, int b); // Le corps de la fonction qui contient les instructions de la fonction int sum (int a, int b) { return a + b; }   Il est possible d'utiliser une fonction d√®s lors qu'elle est d√©clar√©e avec son prototype seulement.  #include &lt;iostream&gt; int sum (int const a, int const b); int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; } int sum (int const a, int const b) { return a + b; }   Je compl√®te donc:  Une fonction doit √™tre d√©clar√©e avant son utilisation. Cela peut se faire avec le prototype de la fonction ou le corps lui m√™me. Une fonction peut √™tre utilis√©e m√™me si le corps de la fonction est √©crit plus tard du moment que son prototype est √©crit avant toute utilisation de la fonction.  Le prototype est l√† pour d√©clarer/signaler au compilateur que le corps de la fonction qu'on appelle sera bien d√©fini plus tard dans le programme.  remarque √âvidemment le programme ne va pas compiler si le corps de la fonction d√©clar√©e n'existe pas et va nous l'indiquer (undefined reference): in function `main': main.cpp: undefined reference to `sum(int, int)'   remarque C'est une notion qui va √™tre utile quand on verra la s√©paration du code en plusieurs fichiers.  ","version":"Next","tagName":"h2"},{"title":"Prototype vs signature‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-vs-signature","content":" Il y a souvent un abus de langage et les termes de prototype et signature sont souvent interchang√©s. Je ne vous en voudrais donc pas si vous utilisez le terme de signature ou de prototype.  Si on veut √™tre pointilleux le prototype d√©signe le nom, les param√®tres et le type de retour d'une fonction alors que la signature indique seulement son nom et ses param√®tres (permettant de faire de la surcharge de fonction).  ","version":"Next","tagName":"h3"},{"title":"R√©cursivit√©‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©cursivit√©","content":" Enfin, il est possible d'utiliser une fonction dans elle m√™me, on parle alors de r√©cursivit√©.  Cela peut √™tre utile quand le probl√®me que l'on souhaite r√©soudre est de nature r√©cursive, se r√©p√®te sur lui m√™me.  ","version":"Next","tagName":"h2"},{"title":"Un petit exemple‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#un-petit-exemple","content":" Par exemple si l'on souhaite calculer le produit de tous les entiers de 1 √† une valeur n.  Pn=1√ó2√ó‚ãØ√ón‚àí1√ónP_n = 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\Pn‚Äã=1√ó2√ó‚ãØ√ón‚àí1√ón  On pourrait voir ce probl√®me de mani√®re r√©cursive en exprimant cette somme en fonction de la somme √† l'√©tape d'avant (n-1):  Pn=1√ó2√ó‚ãØ√ón‚àí1√ónPn=(1√ó2√ó‚ãØ√ón‚àí1)√ónPn=Pn‚àí1√ón\\begin{aligned} P_n &amp;= 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\ P_n &amp;= (1 \\times 2 \\times \\dots \\times n-1) \\times n \\\\ P_n &amp;= P_{n-1} \\times n \\end{aligned}Pn‚ÄãPn‚ÄãPn‚Äã‚Äã=1√ó2√ó‚ãØ√ón‚àí1√ón=(1√ó2√ó‚ãØ√ón‚àí1)√ón=Pn‚àí1‚Äã√ón‚Äã  On a finalement exprim√© le produit des entiers de 1 √† n comme √©tant n fois le produit des entiers de 1 √† n-1.  remarque On nomme ce r√©sulat la factorielle de n en Math√©matiques.  Sous forme de fonction r√©cursive cela nous donnerait:  int fact(int n) { return fact(n-1) * n; }   On oublie cependant un ingr√©dient tr√®s important des fonctions r√©cursives: la condition d'arr√™t.  En effet, dans notre probl√®me on a bien pr√©cis√© que c'√©tait de 1 √† n. On fait donc attention de s'arr√™ter quand n &lt;= 1. La factorielle de 1 √©tant √©gale √† 1 je retourne donc 1.  int fact(int n) { if( n &lt;= 1 ) { return 1; } return fact(n-1) * n; }   Il faut faire attention √† ne pas oublier cette condition d'arr√™t et bien s'assurer qu'il est possible de la v√©rifier pour s'arr√™ter sinon notre fonction ne va jamais se terminer et notre programme va s√ªrement planter.    Dans la plupart des cas, il existe une version alternative non r√©cursive (avec des boucles par exemple).  int fact(int n) { int P { 1 }; // Ici si n est n√©gatif alors la condition i &lt;= n est directement invalide et on ne passe pas dans la boucle if et on retourne 1 for(int i {2}; i &lt;= n; i++) { P *= i; } return P; }   Il est pr√©f√©rable d'utiliser des fonctions non r√©cursives quand c'est possible car elle sont g√©n√©ralement plus performantes et moins propices √† l'erreur (condition d'arr√™t jamais valide, etc).  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©sum√©","content":" Une fonction est un ensemble d'instructions d√©limit√© par des accolades ().Elle peut retourner une valeur en pr√©cisant le type de retour avant le nom ou le mot-cl√© void dans le cas o√π l'on souhaite ne rien retourner.Elle peut avoir des param√®tres.Les arguments pass√©s en param√®tre sont par d√©faut copi√©s.Il est possible de manipuler la variable d'origine √† l'aide de r√©f√©rence (en ajoutant une esperluette (&amp;) apr√®s le type de notre variable).Il est possible de surcharger un fonction, c'est √† dire avoir le m√™me nom mais des param√®tres diff√©rents, on parle de signatures diff√©rentes.Il est recommand√© d'utiliser des param√®tres constants (avec le mot-cl√© const) pour √©viter des erreurs, √©viter des copies et prot√©ger nos variables. ","version":"Next","tagName":"h2"},{"title":"Des conditions et des boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops","content":"","keywords":"","version":"Next"},{"title":"Conditions‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#conditions","content":" ","version":"Next","tagName":"h2"},{"title":"Les valeurs bool√©ennes‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#les-valeurs-bool√©ennes","content":" J'ai omis un type lors du pr√©c√©dent chapitre, il s'agit du type bool√©en, il s'utilise avec le mot cl√© bool.  Ce type peut prendre deux valeurs: soit true, signifiant vrai, soit false qui veut dire faux. C'est donc id√©al pour stocker le r√©sultat d'une condition.  Voici un petit exemple int main() { bool const condition { true }; return 0; }   Cela va devenir int√©ressant gr√¢ce √† ce que l'on appelle les op√©rateurs de comparaison.  Op√©rateur\tSignification==\t√âgalit√©, compare si deux variables sont √©gales !=\tIn√©galit√©, compare si deux variables sont diff√©rentes &lt;\tStrictement inf√©rieur, compare si la variable de gauche est strictement inf√©rieure √† celle de droite &lt;=\tInf√©rieur ou √©gal, compare si la variable de gauche est inf√©rieure ou √©gale √† celle de droite &gt;\tStrictement sup√©rieur, compare si la variable de gauche est strictement sup√©rieure √† celle de droite &gt;=\tSup√©rieur ou √©gal, compare si la variable de gauche est sup√©rieure ou √©gale √† celle de droite  Ces op√©rateurs vont nous permettre de cr√©er des conditions (des valeurs bool√©ennes) √† partir de nos autres variables.  #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; != &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a != b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt; &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt; b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt;= &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt;= b) &lt;&lt; std::endl; // On peut aussi stocker le r√©sultat de la condition dans une variable bool√©enne float const price { 24.5f }; bool const is_too_expensive { price &gt;= 100.f }; return 0; }   remarque Par d√©faut, std::cout affiche 1 pour une condition vraie (true) et 0 pour une condition fausse (false). Il est possible de changer ce comportement en ajoutant un &quot;modificateur&quot; sur le stream std::cout: #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Op√©rateurs logiques‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#op√©rateurs-logiques","content":" Maintenant que nous disposons d'un moyen d'obtenir une valeur bool√©enne (via les op√©rateurs de comparaison) nous allons pouvoir manipuler ces valeurs avec ce que l'on nomme des op√©rateurs logiques.  Ces op√©rateurs vont permettre de combiner et modifier des valeurs bool√©ennes afin d'en obtenir d'autres et faire ce que l'on appelle plus g√©n√©ralement de l‚Äôalg√®bre bool√©enne. Mais ne vous inqui√©tez pas, derri√®re ce nom tr√®s math√©matique se cache des choses tr√®s simples.  NOT: La n√©gation‚Äã  L'op√©rateur ! (plac√© devant une valeur bool√©enne) permet d'exprimer la n√©gation d'une condition.  remarque C'est ici un op√©rateur dit unaire (qui s'applique sur une seule valeur) et donne en retour la condition inverse.  Voici ce qu‚Äôon appelle la table de v√©rit√© de l‚Äôop√©rateur NOT, qui formalise les entr√©es et les sorties de cet op√©rateur.  A\tR√©sultattrue\tfalse false\ttrue  float price { 114.2f }; bool isExpensive { price &gt;= 100.f }; bool isCheap { !isExpensive };   AND‚Äã  L'op√©rateur &amp;&amp; (plac√© entre deux valeurs bool√©ennes) permet d'exprimer la validit√© de deux conditions en m√™me temps. On peut l'interpr√©ter en fran√ßais par : &quot;ma condition1 est vraie ET ma condition2 est aussi vraie&quot;.  A\tB\tR√©sultattrue\ttrue\ttrue true\tfalse\tfalse false\ttrue\tfalse false\tfalse\tfalse  OR‚Äã  L'op√©rateur || (plac√© entre deux valeurs bool√©ennes) permet d'exprimer si au moins une des deux conditions est vraie. On peut l'interpr√©ter en fran√ßais par : &quot;ma condition1 est vraie OU ma condition2 est vraie&quot;.  A\tB\tR√©sultattrue\ttrue\ttrue true\tfalse\ttrue false\ttrue\ttrue false\tfalse\tfalse    remarque Il est √©galement possible d'utiliser les mots-cl√©s and, or et not pour remplacer respectivement les op√©rateurs &amp;&amp;, || et !. C'est possible mais tr√®s peu r√©pandu en C++ c'est pourquoi je ne l'utiliserai pas personnellement mais sachez que √ßa existe √©galement. Avec de vielles versions de Visual Studio il est possible que cette syntaxe ne fonctionne pas et dans ce cas il faut inclure le fichier &lt;ciso646&gt;.  danger Pour l'op√©rateur AND (&amp;&amp;) on note qu'il y a bien deux fois le symbole &amp;. C'est tr√®s important car il existe un autre op√©rateur (avec un seul &amp;) qui fait tout autre chose. Je ne d√©taillerai pas dans ce chapitre son utilit√© mais il est important de le souligner car c'est une erreur qui arrive fr√©quemment. De m√™me pour l'op√©rateur OR (||) diff√©rent de |.  ","version":"Next","tagName":"h3"},{"title":"Des structures de contr√¥le‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#des-structures-de-contr√¥le","content":" C'est bien beau toutes ces valeurs bool√©ennes mais comment on peut s'en servir pour ex√©cuter une partie d'un code ou un autre en fonction d'une condition ?  ","version":"Next","tagName":"h2"},{"title":"If‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#if","content":" Notre premi√®re structure de contr√¥le va s'utiliser avec le mot cl√© if. De l'anglais, ce mot cl√© signifiant &quot;si&quot;, ex√©cute des instructions si et seulement si la condition donn√©e est vraie.  Un petit sch√©ma d'explications:    Voil√† comment l'utiliser. Toutes les instructions entre accolades seront ex√©cut√©es si la condition est vraie.  if( /* condtion */ ) { // ... }   Un petit exemple #include &lt;iostream&gt; int main() { float price { 114.2f }; if ( price &gt;= 100.f ) { // appliquer une r√©duction si l'on d√©passe un certain prix price *= 0.9f; } std::cout &lt;&lt; &quot;Le prix final est de &quot; &lt;&lt; price &lt;&lt; &quot;‚Ç¨&quot; &lt;&lt; std::endl; return 0; }   attention Il est possible de cr√©er des variables √† l'int√©rieur m√™me des accolades de la structure de contr√¥le mais celles-ci sont restreintes √† cette port√©e. C'est ce qu'on appelle la port√©e des variables (scope en anglais). Plus g√©n√©ralement, cette r√®gle du C++ s'applique √† n'importe quel bloc entre accolades.Une variable n‚Äôest utilisable que dans la port√©e, ou le bloc d‚Äôaccolades o√π elle a √©t√© d√©clar√©e. Nous en reparlerons plus en d√©tail dans d'autres chapitres.  attention Il n'est pas tr√®s utile de tester par une √©galit√© le r√©sultat d'une condition : float const price { 114.2f }; bool const isExpensive { price &gt;= 100.f }; if ( isExpensive == true ) { // ... } isExpensive ici √©tant d√©j√† une valeur bool√©enne ajouter une √©galit√© suppl√©mentaire avec la valeur true ne va rien faire d'autre que de cr√©er une nouvelle valeur bool√©enne qui a la m√™me valeur. Il est donc plus clair et concis d'√©crire directement: bool const isExpensive { price &gt;= 100.f }; if ( isExpensive ) { // ... }   ","version":"Next","tagName":"h3"},{"title":"Else‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#else","content":" C'est tr√®s bien de pouvoir effectuer quelque chose si une condition est v√©rif√©e mais comment faire si l'on veut effectuer une action A si la condition est v√©rif√©e et une autre action B si ce n'est pas le cas ?  On pourrait tr√®s bien encha√Æner deux if avec la condition oppos√©e:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } if ( temperature &lt; 35.f ) { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Mais c'est l√† que le mot-cl√© else (de l'anglais &quot;sinon&quot;) nous permet d'ex√©cuter des instructions si la condition du if est fausse de mani√®re plus compr√©hensible:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Ici le else n'a pas de parenth√®se et indique donc &quot;tout le reste&quot; (ce qui ne v√©rifie pas la condition).  remarque L'op√©rateur logique de n√©gation ! est parfois tr√®s utile dans le cas o√π l'on avait stock√© une valeur mais l'on souhaite faire une suite d'instructions uniquement dans le bloc else du if. Au lieu de faire : #include &lt;iostream&gt; int main() { bool condition { false }; if ( condition ) { // ... ne rien faire } else { // effectuer nos instructions } return 0; } Il est pr√©f√©rable de faire: #include &lt;iostream&gt; int main() { bool condition { false }; if ( !condition ) { // effectuer nos instructions } return 0; }   Mais comment tester une succession de conditions diff√©rentes avant de faire &quot;tout le reste&quot;‚ÄØ?  ","version":"Next","tagName":"h3"},{"title":"Else if‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#else-if","content":" On pourrait tr√®s bien cha√Æner plusieurs if et else imbriqu√©s de cette mani√®re:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( /* condition1 */ ) { // ... } else { if ( /* condition2 */ ) { // ... } else { if ( /* condition3 */ ) { //... } else { //... } } } return 0; }   Mais vous √™tes s√ªrement d'accord pour dire que √ßa commence √† √™tre difficile √† suivre et √©crire √† cause des imbrications. Le C++ est bien fait et nous permet de d'utiliser la combinaison else if pour ce cas de figure.  else if s‚Äôutilise entre un if et un else et signifie &quot;ou alors si cette condition est vraie&quot;.  #include &lt;iostream&gt; int main() { if ( /* condition1 */ ) { // ... } else if ( /* condition2 */ ) { // ... } else if ( /* condition3 */ ) { //... } else { //... } return 0; }   remarque Enfin, il existe une derni√®re syntaxe (le switch pour les curieux) qui permet de faire quelque chose de similaire au else if lorsque nos conditions sont des √©galit√©s sur une m√™me variable. mais il nous manque quelques notions avant de pouvoir l'aborder correctement. Nous y reviendrons plus tard dans ce chapitre.  ","version":"Next","tagName":"h3"},{"title":"Faux-ami‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#faux-ami","content":" danger Attention le test d'√©galit√© == est diff√©rent de l'op√©rateur d'affectation =.  int number { 20 }; if ( number = 10 ) { // ... }   En C++, l'assignation retourne la valeur de la variable assign√©e. Ici, la condition sera vraie car number vaut 10 apr√®s l'assignation et 10 est consid√©r√© comme vrai.  Les valeurs num√©riques non nulles sont consid√©r√©es comme vraies et la valeur 0 est consid√©r√©e comme fausse.  ","version":"Next","tagName":"h3"},{"title":"Combinaison d'expressions et logique bool√©enne‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#combinaison-dexpressions-et-logique-bool√©enne","content":" Avec tous les op√©rateurs logiques vu pr√©c√©demment il est m√™me possible de tester plusieurs conditions dans un m√™me if.  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; bool const isRaining { false }; bool const wantToGoOut { true }; bool const ownsAnUmbrella { false }; if ( wantToGoOut &amp;&amp; (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella) ) ) { // ... } else { //... } return 0; }   danger Les op√©rateurs logiques sont comme les op√©rateurs math√©matiques que nous avons vus dans les chapitres pr√©c√©dents: ils ont une priorit√©. Le plus prioritaire est la n√©gation !Ensuite c'est le ET &amp;&amp;Enfin, le OU || est le moins prioritaire Par exemple avec le code a &amp;&amp; b || c &amp;&amp; d, dans l‚Äôordre, on √©value a &amp;&amp; b, c &amp;&amp; d et enfin (a &amp;&amp; b) || (c &amp;&amp; d). Pour des raisons de lisibilit√© je vous recommande tr√®s fortement d'ajouter des parenth√®ses (comme dans mon exemple ci-dessus) pour expliciter quelles op√©rations vous voulez prioriser dans ce genre de cas plus &quot;complexe&quot;.  Pour aller plus loin: Alg√®bre de Boole‚Äã  Enfin, pour aller encore plus loin il est possible de manipuler les op√©rateurs &amp;&amp;, || et ! et trouver des expressions donnant le m√™me r√©sultat. Cela permet parfois de simplifier le code ou alors d'exprimer la condition sous une forme plus lisible ou compr√©hensible.  Dans mon exemple pr√©c√©dent la condition (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella)) est √©quivalente √† √©crire (!isRaining || ownsAnUmbrella).  En effet, si il ne pleut pas(!isRaining) , peu importe si j'ai un parapluie ou non, je peux sortir, Si cependant la premi√®re condition est fausse (il pleut) alors inutile de v√©rifier de nouveau si il pleut (!isRaining || (isRaining &amp;&amp;...) c'est implicite par la premi√®re condition et donc il suffit de v√©rifier si j'ai un parapluie.  Il existe aussi le th√©or√®me de De Morgan qui permet d'exprimer la n√©gation d'un ET avec un OU et inversement.  Il est possible d'exprimer mon exemple pr√©c√©dent sous cette forme:  (!isRaining || ownsAnUmbrella) √©quivalent √† !(isRaining &amp;&amp; !ownsAnUmbrella)  On peut s'en convaincre en essayant de traduire ces conditions en phrases:  (!isRaining || ownsAnUmbrella): c'est le cas o√π il ne pleut pas ou alors j'ai un parapluie.!(isRaining &amp;&amp; !ownsAnUmbrella) ce n'est pas le cas o√π il pleut et je n'ai pas de parapluie.  Vous trouverez des exemples de propri√©t√©s et simplifications possibles sur la page Wikip√©dia suivante:Alg√®bre de Boole  ","version":"Next","tagName":"h3"},{"title":"Boucles‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#boucles","content":" Nous avons maintenant la capacit√© d'ex√©cuter des codes diff√©rents en fonction de conditions. Cependant, notre programme reste essentiellement lin√©aire, car nous ex√©cutons les instructions de haut en bas, l'un √† la suite des autres.  Nous allons maintenant explorer de nouvelles structures de contr√¥le: les boucles. Elles vont nous permettre de r√©p√©ter plusieurs fois une s√©rie d'instructions, selon nos besoins.  ","version":"Next","tagName":"h2"},{"title":"While - \"Tant que ...\"‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#while---tant-que-","content":" La premi√®re est la boucle while, de l'anglais qui signifie &quot;tant que&quot;. Elle ex√©cute une s√©rie d‚Äôinstructions tant qu'une condition est vraie. Une fois que la condition devient fausse la boucle s‚Äôarr√™te et passe √† la suite.    Un petit exemple #include &lt;iostream&gt; int main() { int count { 0 }; // initialisation (d'un compteur ou autre chose li√© √† la boucle) while ( count &lt; 10 /* condition */) { std::cout &lt;&lt; count &lt;&lt; std::endl; // Instructions count++; // It√©ration (mise √† jour du compteur g√©n√©ralement) } return 0; }   Le code √©value la condition avant d'effectuer quoi que ce soit. Dans notre cas si le compte est inf√©rieur √† 10 alors on va afficher le nombre et l'incr√©menter. Quand finalement count vaut 10, la condition devient fausse, on passe √† la suite du code. (on ne va donc pas afficher la valeur 10)  attention Attention aux boucles infinies ! Lorsque vous cr√©ez une boucle, assurez-vous qu'elle puisse s'arr√™ter √† un moment ! Si la condition est toujours vraie, votre programme ne s'arr√™tera jamais !  ","version":"Next","tagName":"h3"},{"title":"Do while‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#do-while","content":" De mani√®re tr√®s similaire il existe la boucle Do... while, qui signifie &quot;fait .. tant que...&quot;  Ce type de boucle est moins utilis√©. La seule chose qui change par rapport √† une boucle while, c'est la position de la condition : au lieu d'√™tre au d√©but de la boucle, la condition est √† la fin.  remarque La boucle while peut tr√®s bien ne jamais √™tre ex√©cut√©e si la condition est fausse d√®s le d√©part. Dans mon exemple pr√©c√©dent, si on avait initialis√© le count √† 20, la condition aurait √©t√© fausse d√®s le d√©but, et on ne serait jamais rentr√© dans la boucle.  Pour la boucle Do... while, on rentre au moins une fois √† l'int√©rieur. Le test se fait √† la fin.  Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.  #include &lt;iostream&gt; int main() { int sum {0}; // On d√©clare la variable en dehors de la boucle pour pouvoir l'utiliser apr√®s // Il n'est pas n√©cessaire de l'initialiser ici car on va √©crire une valeur avant de l'utiliser mais c'est une bonne pratique pour √©viter les valeurs ind√©finies int number {}; do { std::cout &lt;&lt; &quot;Entre un nombre: &quot;; std::cin &gt;&gt; number; sum += number; } while (number != 0); std::cout &lt;&lt; &quot;La somme vaut &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   attention Il y a une petite sp√©cificit√© suppl√©mentaire ici, il faut ajouter un &quot;;&quot; √† la fin de la ligne contenant la condition while.  ","version":"Next","tagName":"h3"},{"title":"For‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#for","content":" Un des cas les plus fr√©quents avec les boucles est d'avoir un compteur et un nombre d'it√©rations pr√©d√©fini.  On pourrait tr√®s bien le faire avec la boucle while:  int count { 0 }; // initialisation (d'un compteur ou autre chose li√© √† la boucle) while ( count &lt; 10 /* condition */) { // Instructions count++; // It√©ration (mise √† jour du compteur g√©n√©ralement) }   Mais il existe une boucle d√©di√©e √† cela qui permet de s√©parer le reste de notre code de ce qui est li√© √† la boucle. Cela rend le code plus clair et plus compr√©hensible surtout dans le cas ou l'on connait √† l'avance le nombre d'it√©rations.  C'est la boucle for (&quot;pour&quot; en anglais) et elle s'utilise selon le sch√©ma suivant:  for (int count {0} /*initialisation*/ ; count &lt; 10 /*condition*/ ; count++/*It√©ration*/) { // Instructions }   Voil√† le m√™me exemple qu'avec la boucle while mais ici avec la boucle for :  #include &lt;iostream&gt; int main() { for (int count { 0 }; count &lt; 10 ; count++) { std::cout &lt;&lt; count &lt;&lt; std::endl; } return 0; }   L'avantage ici est que le d√©tail de ce que fait la boucle est concentr√© sur une m√™me ligne.  info Un autre gros avantage est que la port√©e de la variable (scope) est limit√©e √† la boucle et donc rend notre code plus s√ªr et propre. #include &lt;iostream&gt; int main() { for (int count { 10 }; count &gt; 0 ; count--) { std::cout &lt;&lt; count &lt;&lt; std::endl; } std::cout &lt;&lt; count &lt;&lt; std::endl; return 0; } La variable count ici est uniquement n√©cessaire pour la boucle en question et n'a donc pas lieu d'√™tre partag√©e ensuite avec le reste du code pour √©viter des erreurs. Si on essaye de le faire le compilateur nous donne l'erreur suivante: Compilation failed due to following error(s) main.cpp: In function ‚Äòint main()‚Äô: main.cpp:17:18: error: ‚Äòcount‚Äô was not declared in this scope 17 | std::cout &lt;&lt; count &lt;&lt; std::endl; | ^~~~~   Mais alors quand choisir une boucle while ou une boucle for ?  C'est une question l√©gitime et il n'y a pas de bonne r√©ponse, vous √™tes libre. En g√©n√©ral on utilise une boucle for dans le cas o√π l'on conna√Æt le nombre d'it√©rations √† l'avance (un compteur, un nombre de niveaux ou de joueurs dans un jeu, etc...). La boucle while, quant √† elle, est g√©n√©ralement utilis√©e pour effectuer des actions sans savoir √† l'avance le nombre d'it√©rations que l'on va effectuer (par exemple la gestion de l'entr√©e utilisateur ou dans un jeu faire bouger un ennemi tant qu'il n'a pas atteint sa cible)  astuce Plus simplement, essayez de dire ce que vous voulez faire et si votre phrase contient &quot;pour&quot; ou &quot;pour chaque ... faire ...&quot; il est pr√©f√©rable d'utiliser une boucle for. Et si vous vous d√Ætes &quot;Tant que ... faire ...&quot; alors vous devriez utiliser une boucle while.  ","version":"Next","tagName":"h3"},{"title":"Contr√¥ler l'ex√©cution‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#contr√¥ler-lex√©cution","content":" Les boucles sont tr√®s utiles, mais parfois on aimerait pouvoir contr√¥ler plus finement les instructions √† l‚Äôint√©rieur des accolades et pouvoir s'arr√™ter plus t√¥t ou ne pas ex√©cuter les instructions pour un cas particulier.  Il existe en C++ deux mots-cl√©s: break et continue  Break‚Äã  Break (de anglais &quot;casser&quot;/&quot;interrompre&quot;) permet d'interrompre une boucle et mettre fin √† l‚Äôex√©cution de celle-ci peu importe o√π on en est.  Voyons un exemple plus &quot;complexe&quot; ensemble:  for (int i { 0 }; i &lt; 5; ++i) { std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; for (int j { 0 }; j &lt; i; ++j) { if (j == 2) { std::cout &lt;&lt; &quot;break j == 2&quot; &lt;&lt; std::endl; break; } std::cout &lt;&lt; &quot;j : &quot; &lt;&lt; j &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl; }   qui nous donne le r√©sultat suivant:  i: 0 i: 1 j: 0 i: 2 j: 0 j: 1 i: 3 j: 0 j: 1 break j == 2 i: 4 j: 0 j: 1 break j == 2   Ici il y a plusieurs choses qui se passent:  il y a d√©j√† deux boucles imbriqu√©es, et oui rien ne nous emp√™che de faire cela en C++la deuxi√®me boucle (sur la variable j) d√©pend de la variable i de la premi√®re (c'est parfois utile de le faire et je vous montre donc un petit exemple)ici le mot cl√© break permet d'interrompre la boucle de la variable j si la valeur de j est √©gale √† 2.  Une petite analyse des it√©rations s'impose:  la premi√®re fois i est √©gal √† 0 et donc la condition j &lt; i est directement fausse vu que j aussi est √©gal √† 0. ensuiteensuite i est √©gal √† 1 et donc on passe une fois seulement dans la boucle du j car √† la seconde it√©ration j devient √©gal √† i et invalide la condition j &lt; i.la troisi√®me fois c'est le break qui entre en jeu et permet d'interrompre la boucle quand j est √©gal √† 2 (√† noter que la condition de la boucle aurait aussi invalid√© la condition j &lt; i)enfin ici le break prend tout son sens car s'il n'√©tait pas l√†, on aurait encore continu√© un tour car j √©tant √©gal √† 3, la condition (j &lt; i) serait valide car i est √©gal √† 4 et que 3 &lt; 4.  attention Comme nous venons de le voir, dans le cas de boucles imbriqu√©es cela arr√™te seulement la boucle du niveau au dessus et pas toutes les boucles.  Continue‚Äã  L‚Äôautre mot-cl√©, continue, permet de sauter l‚Äôit√©ration courante.  Toutes les instructions restantes du bloc sont ignor√©es et la boucle continue au tour suivant.  for (int i { 0 }; i &lt; 5; ++i) { if( i == 3) { continue; } std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; }   Ce qui nous donne:  i : 0 i : 1 i : 2 i : 4   danger Comme cela interrompt la totalit√© des instructions suivantes de la boucle cela peut √™tre dangereux dans le cas d'une boucle while: #include &lt;iostream&gt; int main() { int count { 10 }; while (count &gt; 0) { std::cout &lt;&lt; count &lt;&lt; std::endl; if (count == 5) { continue; } count--; } return 0; } Ici, l'instruction de count--; ne sera donc jamais appel√©e une fois que count devient √©gal √† 5.count restera donc √©gal √† 5 ind√©finiment: C'est une boucle infinie.  ","version":"Next","tagName":"h3"},{"title":"Nouvelle structure de contr√¥le: switch‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#nouvelle-structure-de-contr√¥le-switch","content":" Maintenant que nous avons toutes les cartes en main revenons bri√®vement au switch dont je vous parlais pr√©c√©demment.  Tr√®s souvent on veut seulement tester la valeur d'une variable et effectuer telle ou telle action en fonction. On pourrait tr√®s bien √©crire cela avec des else if:  #include &lt;iostream&gt; int main() { int value { 42 }; if ( value == 12 ) { // ... } else if ( value == 33 ) { // ... } else if ( value == 52) { //... } else { //... } return 0; }   C'est avec le mot cl√© switch que l'on va pouvoir faire cela de fa√ßon plus lisible:  #include &lt;iostream&gt; int main() { int value { 42 }; switch (value) { case 12: // ... break; // permet de quitter le bloc switch case 33: // ... break; case 52: // ... break; default: // ... break; } return 0; }   Lorsque l'expression test√©e est √©gale √† une des valeurs list√©es avec les mots-cl√©s case la totalit√© des instructions qui suivent sont ex√©cut√©es. Le mot cl√© break indique la sortie de la structure de contr√¥le. Le mot cl√© default indique quelles instructions ex√©cuter si l'expression n'est jamais √©gale √† une des valeurs.  danger De mani√®re g√©n√©rale, n'oubliez pas d'ins√©rer des instructions break entre chaque test, ce genre d'oubli est difficile √† d√©tecter car aucune erreur n'est signal√©e... En effet la totalit√© des instructions suivant le case sont ex√©cut√©es et donc on pourrait se retrouver √† ex√©cuter des instructions de mani√®re involontaire. #include &lt;iostream&gt; int main() { int value { 33 }; switch (value) { case 12: std::cout &lt;&lt; &quot;value est √©gale √† 12&quot; &lt;&lt; std::endl; case 33: std::cout &lt;&lt; &quot;value est √©gale √† 33&quot; &lt;&lt; std::endl; default: std::cout &lt;&lt; &quot;value est diff√©rent de 12 ou 33&quot; &lt;&lt; std::endl; } return 0; } qui nous donne: value est √©gale √† 33 value est diff√©rent de 12 ou 33 Cela peut √™tre parfois voulu mais ici on se rend bien compte qu'il y a un probl√®me et il ne faut donc pas oublier le mot cl√© break. Voici un exemple o√π cela peut √™tre utile: #include &lt;iostream&gt; int main() { char letter { 'e' }; switch(letter) { case 'a': case 'e': case 'i': case 'o': case 'u': case 'y': std::cout &lt;&lt; &quot;You entered a vowel.&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;You entered a consonant.&quot; &lt;&lt; std::endl; break; } return 0; } Certains warnings de compilateur permette d'indiquer ce genre de cas mais c'est mieux d'y faire attention.  Switch et cha√Ænes de caract√®res Il est important de noter que le mot cl√© switch ne peut pas √™tre utilis√© avec des cha√Ænes de caract√®res. Il ne peut √™tre utilis√© qu'avec des types entiers (int, char, short, long, etc...) ou encore les √©num√©rations. il est possible de faire cela avec des if et else if mais g√©n√©ralement lors de l'utilisation de switch on conna√Æt √† l'avance les valeurs possibles et donc on utilisera de pr√©f√©rence des √©num√©rations ou des constantes.  ","version":"Next","tagName":"h2"},{"title":"En r√©sum√©‚Äã","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#en-r√©sum√©","content":" Une valeur bool√©enne est du type bool et peut prendre comme valeur true ou false. On obtient une valeur bool√©enne avec une condition sur nos variables (avec les op√©rateurs de comparaison ==, !=, &lt;, &lt;=, &gt; ou &gt;=) Les op√©rateurs &amp;&amp;, || et ! permettent de modifier et combiner les valeurs bool√©ennes. On utilise les structures de contr√¥le if, else, else if pour ex√©cuter des instructions diff√©rentes en fonction des conditions.    Il existe trois types de boucle: la boucle while qui permet d'ex√©cuter des instructions tant qu'une condition est v√©rifi√©e.la boucle Do while qui permet de faire la m√™me chose que la boucle while mais en faisant le test seulement √† la fin et permettant d'ex√©cuter les instructions au moins une fois.la boucle for plus utile en pratique quand l'on connait √† l'avance le nombre d'it√©rations √† effectuer. Elle permet aussi de mieux &quot;scoper&quot; les variables et limiter leur port√©e. Il existe deux mots-cl√©s break et continue qui permettent de contr√¥ler plus finement les boucles. La structure de contr√¥le switch est une alternative au else if compatible seulement avec des types entiers et les √©num√©rations. ","version":"Next","tagName":"h2"},{"title":"Cmake","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/CMake","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Cmake","url":"/Learn--cpp_programming/Lessons/S1/Setup/CMake#installation","content":" WindowsLinuxMacOS Si vous √™tes pass√© par l'installation avec Winlibs, vous avez normalement d√©j√† CMake d'install√©.  Vous pouvez ensuite v√©rifier que c'est bien install√© en ex√©cutant la commande suivante dans un terminal :  cmake --version   Si vous obtenez un message d'erreur, c'est que CMake n'est pas install√© correctement.  Dans ce cas, vous pouvez aussi t√©l√©charger l'installeur sur le site officiel de CMake. Vous pouvez vous rendre ici et s√©lectionner l'installeur qui correspond √† votre OS. ","version":"Next","tagName":"h2"},{"title":"Installation d'un compilateur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler","content":"","keywords":"","version":"Next"},{"title":"V√©rifier que le compilateur est install√©‚Äã","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#v√©rifier-que-le-compilateur-est-install√©","content":" Dans un premier temps, vous allez pouvoir v√©rifier que le compilateur GCC est bien install√© avec la commande suivante :  g++ --version   WindowsLinuxMacOS MSVC Avec MSVC c'est un peu particulier et la commande du compilateur ne sera accessible qu'√† travers un terminal particulier. Vous pouvez le trouver en cherchant &quot;developer powershell&quot; ou &quot;developer Command Prompt&quot; dans le Menu Windows. Vous pouvez ouvrir un terminal d√©veloppeur et essayer d'ex√©cuter la commande suivante! cl Vous devriez voir un retour comme celui l√† : C:\\Program Files\\Microsoft Visual Studio\\2022\\Community&gt; cl Microsoft (R) C/C++ Optimizing Compiler Version 19.31.31105 for x86 Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option... ] filename... [ /link linkoption... ]   Cela peut ne pas fonctionner si le r√©pertoire contenant le compilateur n'est pas &quot;accessible&quot;. Dans ce cas, il faut ajouter le chemin du compilateur aux variables d'environnement.  ","version":"Next","tagName":"h2"},{"title":"Variables d'environnement‚Äã","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#variables-denvironnement","content":" Les commandes sont elles-m√™mes des ex√©cutables sous forme de fichiers situ√©s quelque part sur votre ordinateur.  Depuis un terminal, l'ordinateur a une liste de tous les endroits dans lesquels il va essayer de chercher les dits fichiers (commandes) √† ex√©cuter. Ces endroits (sous forme de chemins de dossier) sont list√©s dans ce qu'on appelle des variables d'environnement et particuli√®rement la variable d'environnement PATH.  Pour pouvoir avoir acc√®s √† la commande du compilateur depuis n'importe o√π dans votre ordinateur il va donc falloir ajouter le chemin o√π est install√© l'ex√©cutable (les outils de compilation dans notre cas) √† cette variable PATH.  WindowsLinuxMacOS Vous pouvez y acc√©der en allant dans le Panneau de configuration et en cliquant sur le lien Param√®tres syst√®me avanc√©s puis sur Variables d'environnement. Ou plus simplement en cherchant &quot;path&quot; ou &quot;variable&quot; dans le Menu d√©marrer. Dans la section Variables syst√®me recherchez la variable d'environnement PATH et s√©lectionnez-la. Cliquez sur Modifier. Dans la fen√™tre qui vient de s'ouvrir, ajoutez une valeur avec le chemin vers le dossier contenant la commande. (Pour MSVC par exemple c'est quelque chose comme : &quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\19.09.26726\\bin\\HostX86\\x64&quot;)Cliquez sur OK.Fermez toutes les fen√™tres restantes en cliquant sur OK. C'est √©galement expliqu√© ici avec des illustrations si n√©cessaire.  ::: ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#installation","content":" Tout d'abord il s'agit d'installer l'IDE.  Rendez-vous .css-6ww85o{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;line-height:1.5;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;height:24px;background-color:#1976d2;color:#fff;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-6ww85o.Mui-disabled{opacity:0.38;pointer-events:none;}.css-6ww85o .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-6ww85o .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-6ww85o .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-6ww85o .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-6ww85o .MuiChip-icon{margin-left:5px;margin-right:-6px;}.css-6ww85o .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-6ww85o .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-6ww85o .MuiChip-icon{font-size:18px;margin-left:4px;margin-right:-4px;}.css-6ww85o .MuiChip-deleteIcon{font-size:16px;margin-right:4px;margin-left:-4px;}.css-6ww85o .MuiChip-deleteIcon{color:rgba(255, 255, 255, 0.7);}.css-6ww85o .MuiChip-deleteIcon:hover,.css-6ww85o .MuiChip-deleteIcon:active{color:#fff;}.css-6ww85o .MuiChip-icon{color:#616161;}.css-6ww85o .MuiChip-icon{color:inherit;}.css-6ww85o:hover{background-color:rgba(0, 0, 0, 0.12);}.css-6ww85o.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-6ww85o:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-6ww85o:hover,.css-6ww85o.Mui-focusVisible{background-color:#1565c0;} .css-1bfn3f{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;line-height:1.5;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;height:24px;background-color:#1976d2;color:#fff;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1bfn3f::-moz-focus-inner{border-style:none;}.css-1bfn3f.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1bfn3f{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1bfn3f.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1bfn3f .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1bfn3f .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1bfn3f .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1bfn3f .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1bfn3f .MuiChip-icon{margin-left:5px;margin-right:-6px;}.css-1bfn3f .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-1bfn3f .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1bfn3f .MuiChip-icon{font-size:18px;margin-left:4px;margin-right:-4px;}.css-1bfn3f .MuiChip-deleteIcon{font-size:16px;margin-right:4px;margin-left:-4px;}.css-1bfn3f .MuiChip-deleteIcon{color:rgba(255, 255, 255, 0.7);}.css-1bfn3f .MuiChip-deleteIcon:hover,.css-1bfn3f .MuiChip-deleteIcon:active{color:#fff;}.css-1bfn3f .MuiChip-icon{color:#616161;}.css-1bfn3f .MuiChip-icon{color:inherit;}.css-1bfn3f:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1bfn3f.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1bfn3f:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1bfn3f:hover,.css-1bfn3f.Mui-focusVisible{background-color:#1565c0;} ici et s√©lectionnez l'installeur adapt√© √† votre syst√®me d'exploitation.   ","version":"Next","tagName":"h2"},{"title":"Les extensions‚Äã","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#les-extensions","content":" Les extensions sont, comme le nom l'indique, des modules qui permettent d'√©tendre les fonctionnalit√©s de l'IDE.  Elles sont list√©es ici et vous pouvez √©galement les parcourir pour les installer √† l'int√©rieur de l'IDE via le raccourci CTRL+SHIFT+X ou en cliquant sur cet onglet :    N'h√©sitez pas √† consulter les extensions recommand√©es par langage ou d√©couvrir ce que d'autres personnes utilisent.  Concernant le C++, nous avons besoin au minimum d'installer ces extensions :  cpptools-extension-packcmakeBuildOutputColorizererrorlens  Ces extensions vont nous permettre de lancer notre programme C++ sans difficult√©.  Si vous voulez aller plus loin et conna√Ætre un peu mieux VSCode, je vous invite √† aller regarder la page suivante. ","version":"Next","tagName":"h2"},{"title":"Allouer et manipuler la m√©moire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Mode d'allocation‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#mode-dallocation","content":" Il existe trois principaux modes d‚Äôallocation de la m√©moire:  l‚Äôallocation statiquel‚Äôallocation sur la Stackl‚Äôallocation sur le Heap  ","version":"Next","tagName":"h2"},{"title":"Allocation statique‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-statique","content":" Lorsque le programme s‚Äôinitialise, il demande une quantit√© de m√©moire sp√©cifi√©e dans le code source du programme, laquelle ne pourra pas changer par la suite.  Nous n'avons pas rencontr√© ce type d'allocation pour l'instant mais sachez que √ßa existe.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Stack‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-stack","content":" Jusqu'√† pr√©sent, nous avons principalement rencontr√© des allocations de m√©moire sur la Stack. C'est le cas de toutes nos variables locales (quand on fait par exemple int i{0}; dans des fonctions, y compris dans la fonction main).  La Stack (ou pile en fran√ßais) est une zone m√©moire qui sert d‚Äôespace de stockage aux variables d√©clar√©es par les fonctions et permet aussi de garder une trace des appels de fonctions.  Elle tient son nom de son mode de fonctionnement, semblable √† une pile de dossiers. Il s‚Äôagit d‚Äôune structure de donn√©es fond√©e sur le principe ‚Äúdernier pos√© sur le dessus de la pile, premier √† sortir‚Äù. Cet ordonnancement s‚Äôappelle LIFO (Last In, First Out). La Stack poss√®de donc deux actions principales : push, pour ajouter un √©l√©ment, et pop pour retirer et r√©cup√©rer cet √©l√©ment. Cela rend tr√®s simple le suivi de la pile pour lib√©rer ou demander de la m√©moire.  Comme les acc√®s √† la Stack sont contigu√´s et que les m√™mes adresses m√©moire tendent √† √™tre r√©utilis√©es, les lectures et √©critures dans la Stack sont tr√®s performantes. Cependant cela manque de souplesse car son allocation doit √™tre &quot;pr√©vue&quot; lors de l‚Äô√©criture du programme (Pour des variables de taille d√©j√† connue √† la compilation).  info La Stack a une taille fix√©e (qui d√©pend des machines et syst√®mes d'exploitation(OS)). Pour garder une trace de l‚Äôemplacement m√©moire actuel, il existe un pointeur appel√© Stack Pointer. Chaque fois que quelque chose doit √™tre √©crit ou retir√© dans la Stack, on d√©place simplement ce pointeur. Le pointeur ne peut pas aller au del√† des limites de la Stack, cela risque de provoquer un crash du programme appel√© Stack overflow. Cela peut se produire avec une fonction r√©cursive avec de nombreux appels r√©cursifs ou sans condition d'arr√™t par exemple.  La syntaxe pour allouer de la m√©moire sur la Stack est la suivante:  int x {};   Vous connaissez d√©j√† cette syntaxe, c'est simplement la d√©claration d'une variable locale.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Heap‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-heap","content":" L‚Äôallocation sur la Heap se fait de mani√®re dynamique pendant l‚Äôex√©cution d‚Äôun programme (on parle de runtime). L‚Äôespace n√©cessaire n‚Äôa pas besoin d'√™tre d√©fini en amont dans le code. Le programme effectue la demande d‚Äôallocation d‚Äôespace √† l‚ÄôOS au cours de son ex√©cution.  remarque Il y a g√©n√©ralement un abus de langage et ce que l'on qualifie d'allocation dynamique d√©signe ce type d'allocation sur la Heap. L'allocation sur la Stack est √©galement dynamique dans le sens o√π elle se produit pendant l'ex√©cution du programme en fonction des variables d√©clar√©es.  La Heap permet donc le contr√¥le compl√®tement arbitraire de l‚Äôallocation et de la lib√©ration. Lorsque le processus n√©cessite plus de m√©moire, il en fait simplement la demande √† l‚ÄôOS (dans la limite o√π il est en mesure de fournir un tel emplacement m√©moire). C'est donc aussi ce type d'allocation que l'on privil√©gie dans le cas de gros volumes de donn√©es.  Cependant, cela demande de maintenir des pointeurs pour chacune des valeurs stock√©es, afin de savoir o√π se trouve la m√©moire demand√©e pour pouvoir la manipuler mais aussi la lib√©rer. Cette gestion de la m√©moire √©tant plus &quot;complexe&quot;, les performances n‚Äôen sont g√©n√©ralement pas aussi bonnes, mais parfois on n'a tout simplement pas le choix.  La syntaxe pour allouer de la m√©moire sur la Heap est la suivante:  int* x { new int };   Je vous expliquerai plus en d√©tail ce que cela signifie dans la suite de ce chapitre.  ","version":"Next","tagName":"h3"},{"title":"Adresse et pointeurs‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#adresse-et-pointeurs","content":" J'ai √©voqu√© le terme de pointeur mais qu'est ce que c'est ?  Une variable est localis√©e quelque part dans notre m√©moire. On peut voir la m√©moire de notre ordinateur comme une grande √©tag√®re √† livres dans laquelle chaque emplacement est num√©rot√©. Chaque variable a une adresse (un num√©ro) qui permet de savoir o√π elle se trouve en m√©moire.  Cette adresse est simplement un nombre (g√©n√©ralement repr√©sent√© sous forme hexad√©cimale).  On peut r√©cup√©rer l'adresse d'une variable en ajoutant le symbole &quot;esperluette&quot; &amp; devant le nom de la variable en question.  Essayons: #include &lt;iostream&gt; int main() { int integer {4}; std::cout &lt;&lt; &amp;integer &lt;&lt; std::endl; return 0; }   qui nous donne un truc qui ressemble √† √ßa:  0x7ffe08bf5854   Ce nombre indique o√π est stock√©e la valeur de notre variable en m√©moire (que ce soit la heap ou la stack).  Maintenant que nous savons o√π se trouve notre variable on va pouvoir stocker cette adresse.  C'est justement le r√¥le du pointeur de stocker l'adresse d'une variable.  On indique que l'on souhaite manipuler un pointeur en ajoutant le symbole * apr√®s le type de la variable. Cela indique donc que l'on stocke une adresse vers une variable du type indiqu√© et non une valeur.  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"D√©r√©f√©rencement‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#d√©r√©f√©rencement","content":" Avec ce pointeur, il est possible de faire ce qu'on appelle un d√©r√©f√©rencement et aller voir le contenu de l'emplacement situ√© √† l'adresse stock√©e. C'est-√†-dire, la valeur de la variable point√©e.  Pour faire un d√©r√©f√©rencement on utilise √©galement le symbole * devant le nom de notre pointeur comme cela:  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; *integer_pointer &lt;&lt; std::endl; // On peut m√™me modifier la valeur de notre variable par ce biais *integer_pointer = 18; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Null pointer‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#null-pointer","content":" Il est possible d'indiquer qu'un pointeur ne pointe actuellement sur rien en lui attribuant une valeur nulle avec le mot-cl√© nullptr:  Il s'agit alors d'un pointeur nul (ou null pointer en anglais). Le d√©r√©f√©rencement d'un pointeur nul provoque une erreur:  #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { float* float_pointer {nullptr}; displayPointer(float_pointer); // null return 0; }   info Il existe √©galement le mot-cl√© NULL qui vient du C pour indiquer un pointeur nul. Il a cependant des inconv√©nients et je vous demande d'utiliser nullptr en C++ qui est plus s√ªr.  ","version":"Next","tagName":"h3"},{"title":"Allocation dynamique en pratique: New & delete‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-dynamique-en-pratique-new--delete","content":" Comme je l'ai √©voqu√© pr√©c√©demment avec l‚Äôallocation dynamique dans la Heap on va donc demander un emplacement m√©moire et le lib√©rer plus tard. Cela se fait avec les mots-cl√©s new et delete. Cette demande de m√©moire va retourner un pointeur.  #include &lt;iostream&gt; int main() { // je demande un emplacement m√©moire pour un entier int* integer_ptr {new int}; // je peux aussi demander et initialiser un entier int* number_ptr {new int{5}}; std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; // Une fois que l'on en a plus besoin, on lib√®re les zones m√©moire demand√©es delete number_ptr; delete integer_ptr; return 0; }   qui nous donne: 0x557590f93eb0 5   danger Le pointeur est toujours &quot;existant&quot; apr√®s avoir √©t√© lib√©r√©. Le pointeur n'est rien d'autre qu'un nombre repr√©sentant l'adresse m√©moire. Cela ne veut pas dire que nous avons le droit de manipuler cette m√©moire. Si l'espace m√©moire point√© par le pointeur est lib√©r√©, il ne faut pas l'utiliser car cet emplacement m√©moire ne nous appartient plus. #include &lt;iostream&gt; int main() { int* number_ptr {new int{2}}; delete number_ptr; // Ici l'adresse √©tant un nombre, elle est toujours valide std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; // Mais la valeur contenue √† cette adresse peut prendre n'importe quelle valeur en fonction de l'usage nouveau de cet emplacement m√©moire std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; return 0; } Il est donc recommand√© d'assigner au pointeur la valeur nullptr une fois lib√©r√© pour √©viter tout probl√®me. int* number_ptr {new int{2}}; delete number_ptr; number_ptr = nullptr; // ...   ","version":"Next","tagName":"h2"},{"title":"Tableaux‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#tableaux","content":" Il est √©galement possible de demander plusieurs emplacements m√©moire contigu√´s (autrement dit un tableau) d'un coup en pr√©cisant entre crochets la taille du tableau [ ] . Le pointeur va contenir alors l'adresse du premier √©l√©ment du tableau.  L'adresse stock√©e par le pointeur √©tant un nombre (repr√©sent√© en hexad√©cimal) il est possible de faire des op√©rations dessus comme l'addition ou la soustraction. Cela permet de se positionner sur un emplacement m√©moire pr√©cis du tableau.  Pour lib√©rer un tableau allou√© dynamiquement, il faut utiliser le mot-cl√© delete suivi de crochets [ ] .  int main() { // attention ici les valeurs ne sont pas initialis√©es int* array_ptr {new int[5]}; // Je me positionne sur le 3√®me √©l√©ment du tableau et j'utilise le d√©r√©f√©rencement pour modifier sa valeur *(array_ptr + 2) = 42; // On peut aussi utiliser la notation avec les crochets qui est √©quivalente array_ptr[2] = 42; // Je lib√®re l'espace m√©moire allou√© delete[] array_ptr; return 0; }   remarque Si la taille est connue √† l'avance (√† la compilation), il est aussi possible de d√©clarer un tableau sur la Stack avec la taille entre crochets [ ]. int main() { int array[5]; // Je peux acc√©der aux valeurs du tableau avec les crochets array[0] = 42; return 0; }   danger Il est important de noter que le pointeur ne contient pas la taille du tableau. Il est donc important de la conserver quelque part pour ne pas d√©passer la taille du tableau. Si vous d√©passez, vous risquez de modifier des valeurs qui ne vous appartiennent pas et donc de causer des erreurs. int main() { int* array_ptr {new int[5]}; // Ici je d√©passe la taille du tableau et j'essaie de modifier une valeur qui ne m'appartient pas array_ptr[5] = 42; return 0; } Il s'agit d'une erreur tr√®s courante appel√©e &quot;erreur de segmentation&quot;. Elle se produit lorsque votre programme essaie de lire ou d'√©crire dans une zone m√©moire qui ne lui a pas √©t√© attribu√©e (ou ne l'est plus).  C'est la fa√ßon de g√©rer les tableaux en C. Cependant, en C++ il existe des structures de donn√©es plus adapt√©es pour g√©rer les tableaux comme std::array ou std::vector que nous avons vu pr√©c√©demment.  ","version":"Next","tagName":"h2"},{"title":"std::vector: explications‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdvector-explications","content":" Justement, parlons un peu de std::vector. Comme dit pr√©c√©demment, l'allocation dynamique (sur la Heap) est particuli√®rement int√©ressante lorsque l‚Äôon ne sait pas √† l‚Äôavance la taille dont on va avoir besoin. C'est exactement le cas d'utilisation du std::vector.  En effet, std::vector n'est rien d'autre qu'une structure de donn√©e qui g√®re en interne un pointeur vers une zone m√©moire contigu√´. Lorsque celui-ci est trop petit et que l'on souhaite tout de m√™me ajouter une valeur, la structure demande un nouvel espace m√©moire plus grand, copie les donn√©es dans ce nouvel espace m√©moire et enfin lib√®re l'ancien espace m√©moire qui n'est donc plus utilis√©.  Ce changement (allocation, copie, lib√©ration de m√©moire) a un co√ªt, c'est pourquoi std::vector pr√©voit un espace plus grand que n√©cessaire lors d'une allocation pour anticiper de futurs ajouts dans le tableau dynamique.  Il est possible de conna√Ætre la taille de l'espace de stockage allou√© pour le std::vector avec sa m√©thode capacity() qui retourne cette taille exprim√©e en nombre d'√©l√©ments. C'est diff√©rent de la taille actuellement utilis√©e qui s'obtient avec la m√©thode size().   Une impl√©mentation simplifi√©e struct IntegerVector { size_t size {0}; size_t capacity {0}; int* pointer {nullptr}; void reserve(size_t const newCapacity) { if (newCapacity &lt;= capacity) { return; } // Je demande un nouvel espace m√©moire int* newPointer {new int[newCapacity]}; // Si j'avais d√©j√† un espace m√©moire if (pointer != nullptr) { // Je copie les donn√©es de l'ancien espace m√©moire vers le nouveau std::copy(pointer, pointer + size, newPointer); // Je lib√®re l'ancien espace m√©moire delete [ ] pointer; } // Je met √† jour les informations de la structure capacity = newCapacity; pointer = newPointer; } void push_back(int const value) { // Si je n'ai plus de place dans mon tableau, j'en demande plus if( size == capacity ) { reserve( 2 * capacity + 1 ); } // J'ajoute la valeur √† la fin du tableau objects[size] = value; size++; } void pop_back() { if (size &gt; 0) { size--; } } int &amp; at(size_t const index) { // Si l'index est en dehors du tableau, je l√®ve une exception (erreur) // Nous n'avons pas encore vu les exceptions, mais c'est un m√©canisme qui permet de g√©rer les erreurs if (index &gt;= size) { throw std::out_of_range(&quot;Index out of range&quot;); } // Je retourne la valeur √† l'index demand√© return pointer[index]; } //... }; std::vector est bien s√ªr plus complexe que cela et a √©t√© fait par des experts du C++ mais cela permet de comprendre le principe qui se cache derri√®re cette structure de donn√©e.  ","version":"Next","tagName":"h2"},{"title":"Structure et This‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#structure-et-this","content":" Vous vous souvenez de l'utilisation du mot-cl√© this dans les m√©thodes de nos structures ?  this est en fait un pointeur vers la structure elle m√™me !  On peut donc faire un d√©r√©f√©rencement et avoir acc√®s √† la structure pour la modifier.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { (*this).price = price; // this-&gt;price = price; } };   C'est ce qui permet ici de faire la diff√©rence entre price qui est un param√®tre de la m√©thode et this-&gt;price qui est le membre de la structure.  info La syntaxe -&gt; est en r√©alit√© un raccourci de syntaxe qui permet de faire un d√©r√©f√©rencement puis d'acc√©der √† un membre ou une m√©thode de la structure: Ces deux √©critures sont donc √©quivalentes: this-&gt;member (*this).member.  ","version":"Next","tagName":"h2"},{"title":"Les r√©f√©rences dans tout √ßa‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#les-r√©f√©rences-dans-tout-√ßa","content":" Vous avez remarqu√© des ressemblances entre les pointeurs et les r√©f√©rences ? C'est normal, c'est le m√™me m√©canisme sous-jacent. La r√©f√©rence utilise l'adresse m√©moire de la variable cibl√©e.  attention Cependant, une r√©f√©rence ne peut pas √™tre nulle comme avec nullptr pour les pointeurs. Une r√©f√©rence est forc√©ment associ√©e √† une variable.  Une r√©f√©rence peut √™tre consid√©r√©e comme un pointeur avec d√©r√©f√©rencement automatique, c'est-√†-dire que le compilateur applique en quelque sorte l'op√©rateur * pour vous.  comparaison #include &lt;iostream&gt; void addOneUsingPtr(int * a) { *a += 1; } void addOneUsingRef(int &amp; a) { a += 1; } void constDisplayUsingRef(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void constDisplayUsingPtr(int const * a) { std::cout &lt;&lt; *a &lt;&lt; std::endl; }   La r√©f√©rence a donc l'avantage d'√™tre plus lisible et simple √† utiliser.  remarque Utiliser les pointeurs directement est plut√¥t r√©serv√© √† des cas sp√©cifiques. Comme par exemple dans le cas o√π on souhaite une &quot;r√©f√©rence&quot; optionnelle (qui peut √™tre nulle) ou alors r√©assigner la r√©f√©rence √† une autre variable. #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { int a {42}; int b {24}; int&amp; ref {a}; ref = b; // a = b int* ptr {&amp;a}; *ptr = 12; // a = 12 ptr = &amp;b; // ptr pointe sur b *ptr = 36; // b = 36 displayPointer(ptr); // 36 ptr = nullptr; displayPointer(ptr); // null return 0; }   ","version":"Next","tagName":"h2"},{"title":"Pointeurs intelligents‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#pointeurs-intelligents","content":" Pendant l‚Äôex√©cution d'un programme, le syst√®me ne peut pas √©craser ce que les d√©veloppeurs ont demand√©. C‚Äôest √† nous, humains, de le g√©rer avec le mot-cl√© delete sinon cela provoque une fuite de m√©moire.  Une fuite de m√©moire est la m√©moire qui a √©t√© demand√©e par l‚Äôutilisateur et qui n‚Äôa jamais √©t√© lib√©r√©e. Si on en accumule trop, le programme peut finir par avoir demand√© plus de m√©moire que disponible sur l'ordinateur, ce qui peut provoquer un crash du programme ou ralentir le syst√®me d'exploitation ou m√™me dans le pire des cas faire planter l'ordinateur.  Pour √©viter cela, chaque fois que nous n‚Äôavons plus besoin d‚Äôun √©l√©ment de la Heap allou√©, nous devons absolument le lib√©rer.    Pour √©viter ce probl√®me, et nous aider √† g√©rer la m√©moire, le C++11 a introduit des pointeurs dits intelligents (smart pointer en anglais) dans la biblioth√®que standard.  Lorsque le pointeur est d√©truit, la m√©moire allou√©e pr√©c√©demment est √©galement lib√©r√©e. Il n'est donc pas n√©cessaire de lib√©rer la m√©moire explicitement avec delete, c'est le pointeur intelligent qui s'en charge.  Un pointeur intelligent est en quelque sorte une structure enveloppant un pointeur et permettant de s'assurer que la m√©moire est lib√©r√©e une fois que le pointeur n'est plus utilis√©.  ","version":"Next","tagName":"h2"},{"title":"unique_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#unique_ptr","content":" std::unique_ptr est un pointeur intelligent qui g√®re une zone m√©moire allou√©e dynamiquement. Il est, comme son l'indique, l'unique responsable de cette zone m√©moire. Elle sera d√©truite d√®s que le pointeur est d√©truit.  Il ne peut pas √™tre copi√©, c'est √† dire que l'on ne peut pas avoir deux std::unique_ptr pointant vers le m√™me objet. Sinon, lors de la destruction des deux pointeurs, l'objet serait d√©truit deux fois.  #include &lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; ptr {std::make_unique&lt;int&gt;(42)}; // On ne peut pas copier un unique_ptr // std::unique_ptr&lt;int&gt; ptr2 {ptr}; // A la fin du bloc (de la fonction main ici), ptr est d√©truit et l'espace m√©moire est lib√©r√© }   ","version":"Next","tagName":"h3"},{"title":"shared_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#shared_ptr","content":" std::shared_ptr est un pointeur intelligent qui g√®re une zone m√©moire allou√©e dynamiquement. La responsabilit√© de cette zone m√©moire peut-√™tre partag√©e entre plusieurs std::shared_ptr, et elle ne sera d√©truite que quand tous les std::shared_ptr responsables auront √©t√© d√©truits. Il est possible de copier un std::shared_ptr pour partager la responsabilit√© de la zone m√©moire. Il utilise un compteur interne pour savoir combien de std::shared_ptr pointent vers la zone m√©moire. Lorsque ce compteur tombe √† z√©ro, la zone m√©moire est lib√©r√©e.  #include &lt;memory&gt; int main() { std::shared_ptr&lt;int&gt; ptr1 {std::make_shared&lt;int&gt;(42)}; { // On peut copier un shared_ptr std::shared_ptr&lt;int&gt; ptr2 {ptr1}; // Changer la valeur de ptr1 *ptr1 = 24; // ptr1 et ptr2 pointent vers la m√™me zone m√©moire std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 24 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 24 *ptr2 = 12; std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 12 // Ici ptr2 est d√©truit mais la zone m√©moire n'est pas lib√©r√©e car ptr1 pointe toujours vers cette zone m√©moire } std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 // A la fin du bloc (de la fonction main ici), ptr1 est d√©truit et l'espace m√©moire est lib√©r√© return 0; }   C'est utile lorsque l'on souhaite partager un objet entre plusieurs parties du code.  ","version":"Next","tagName":"h3"},{"title":"std::weak_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdweak_ptr","content":" Il existe √©galement un pointeur intelligent std::weak_ptr qui est un pointeur qui permet de pointer vers un objet g√©rer par un std::shared_ptr sans augmenter le compteur de r√©f√©rences. C'est utile pour √©viter des r√©f√©rences circulaires et mieux g√©rer le cycle de vie des objets mais nous n'irons pas plus loin dans ce cours.  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#r√©sum√©","content":" Il existe plusieurs types d'allocation de m√©moire: L'allocation de m√©moire statique est effectu√©e √† la compilation. Elle est donc tr√®s rapide mais ne permet pas de modifier la taille de la m√©moire allou√©e.L'allocation de m√©moire sur la stack est effectu√©e √† l'ex√©cution. Elle est utilis√©e pour allouer nos variables locales et est √† privil√©gier car elle est rapide.L'allocation de m√©moire dynamique sur la heap est effectu√©e √† l'ex√©cution. Elle est utilis√©e si on ne conna√Æt pas la taille de la m√©moire √† allouer √† la compilation ou si on veut modifier la taille de la m√©moire allou√©e. Cela permet de g√©rer plus finement la m√©moire mais est plus lente que l'allocation de m√©moire sur la stack. Un pointeur est une variable qui contient une adresse m√©moire (un nombre repr√©sent√© en hexad√©cimal). C'est un type de variable √† part enti√®re qu'on diff√©rencie avec le symbole * apr√®s le type de la variable. On utilise les mots-cl√©s new et delete pour allouer et d√©sallouer de la m√©moire sur la heap. Le d√©r√©f√©rencement d'un pointeur permet d'acc√©der √† la valeur de la variable point√©e. Cela s'effectue avec l'op√©rateur * devant le nom du pointeur. Il est possible d'attribuer √† un pointeur la valeur nullptr qui repr√©sente un pointeur nul. Cela permet d'indiquer qu'un pointeur ne pointe sur rien. On l'utilise pour v√©rifier qu'un pointeur est valide avant de l'utiliser. std::vector est un conteneur qui permet de g√©rer les allocations dynamiques de tableaux √† notre place. le mot-cl√© this est un pointeur vers la structure elle m√™me. Cela permet de faire la diff√©rence entre un param√®tre de m√©thode et un membre de la structure. Il existe des pointeurs intelligents (smart pointer) qui permettent de g√©rer la m√©moire √† notre place. Ils sont tr√®s pratiques car ils permettent d'√©viter les fuites m√©moires et les erreurs de d√©sallocation de m√©moire. ","version":"Next","tagName":"h2"},{"title":"Compiler votre premier programme","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac","content":"","keywords":"","version":"Next"},{"title":"Utiliser CMake et VSCode‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#utiliser-cmake-et-vscode","content":" C'est donc possible de le faire uniquement avec des lignes de commandes mais par simplicit√© nous allons d√®s maintenant utiliser CMake dont j'ai parl√© pr√©c√©demment qui s'int√®gre facilement avec VSCode.  Pour utiliser CMake il faut tout d'abord cr√©er un fichier nomm√© CMakeLists.txtVoici le premier qu'on va utiliser (quelques explications en commentaire &quot;#&quot; du fichier) :  CMakeLists.txt # Nous voulons un cmake &quot;r√©cent&quot; pour utiliser les derni√®res fonctionnalit√©s cmake_minimum_required(VERSION 3.10) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On indique que l'on veut cr√©er un ex√©cutable &quot;helloImac&quot; compil√© √† partir du fichier helloImac.cpp add_executable(helloImac helloImac.cpp)   Ce fichier CMakeLists.txt va √™tre bien pratique car il est reconnu par divers IDE et en ce qui nous concerne on va l'utiliser avec VSCode.  Il suffit d'avoir au pr√©alable install√© l'extension dont je vous ai parl√© .css-l7agxw{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;line-height:1.5;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-l7agxw.Mui-disabled{opacity:0.38;pointer-events:none;}.css-l7agxw .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-l7agxw .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-l7agxw .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-l7agxw .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-l7agxw .MuiChip-icon{margin-left:5px;margin-right:-6px;}.css-l7agxw .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-l7agxw .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-l7agxw .MuiChip-icon{color:#616161;}.css-l7agxw:hover{background-color:rgba(0, 0, 0, 0.12);}.css-l7agxw.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-l7agxw:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-l7agxw.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-l7agxw.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-l7agxw .MuiChip-avatar{margin-left:4px;}.css-l7agxw .MuiChip-avatarSmall{margin-left:2px;}.css-l7agxw .MuiChip-icon{margin-left:4px;}.css-l7agxw .MuiChip-iconSmall{margin-left:2px;}.css-l7agxw .MuiChip-deleteIcon{margin-right:5px;}.css-l7agxw .MuiChip-deleteIconSmall{margin-right:3px;} .css-14qpy53{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;line-height:1.5;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-14qpy53::-moz-focus-inner{border-style:none;}.css-14qpy53.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-14qpy53{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-14qpy53.Mui-disabled{opacity:0.38;pointer-events:none;}.css-14qpy53 .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-14qpy53 .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-14qpy53 .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-14qpy53 .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-14qpy53 .MuiChip-icon{margin-left:5px;margin-right:-6px;}.css-14qpy53 .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-14qpy53 .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-14qpy53 .MuiChip-icon{color:#616161;}.css-14qpy53:hover{background-color:rgba(0, 0, 0, 0.12);}.css-14qpy53.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-14qpy53:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-14qpy53.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-14qpy53.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-14qpy53 .MuiChip-avatar{margin-left:4px;}.css-14qpy53 .MuiChip-avatarSmall{margin-left:2px;}.css-14qpy53 .MuiChip-icon{margin-left:4px;}.css-14qpy53 .MuiChip-iconSmall{margin-left:2px;}.css-14qpy53 .MuiChip-deleteIcon{margin-right:5px;}.css-14qpy53 .MuiChip-deleteIconSmall{margin-right:3px;} cmake et d'ouvrir le dossier contenant le fichier CMakeLists.txt dans VSCode (il est recommand√© de cr√©er un dossier d√©di√© au &quot;projet&quot; contenant les fichiers sources et le fichier CMakeLists.txt ). L'extension devrait normalement reconna√Ætre automatiquement qu'il y a un fichier cmake et vous proposer d'initialiser celui-ci automatiquement.     Si c'est la premi√®re fois que vous l'ouvrez ce qui est s√ªrement le cas il devrait vous demander de choisir un kit de compilation et il faudra donc s√©lectionner GCC (ou MSVC si c'est ce que vous avez d√©cid√© d'installer).    astuce Si ce n'est pas le cas vous pouvez toujours utiliser le raccourci Ctrl+Shift+P puis taper et s√©lectionner &quot;CMake: select a kit&quot;  Une fois tout initialis√©, vous devriez voir des logs dans un terminal ressemblant √† cela (dans mon cas sous Linux avec le compilateur GCC ici) :  [variant] Loaded new set of variants [kit] Successfully loaded 1 kits from /home/user/.local/share/CMakeTools/cmake-tools-kits.json [proc] Executing command: /usr/bin/cmake --version [proc] Executing command: /usr/bin/gcc -v [proc] The command: ninja --version failed with error: Error: spawn ninja ENOENT [proc] The command: ninja-build --version failed with error: Error: spawn ninja-build ENOENT [proc] Executing command: /usr/bin/cmake &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [main] Configuring project: helloImac [proc] Executing command: /usr/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/gcc -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/g++ &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [cmake] Not searching for unused variables given on the command line. [cmake] -- Configuring done [cmake] -- Generating done [cmake] -- Build files have been written to: /home/user/DATA/Cours IMAC1/helloImac/build   Vous pouvez maintenant cliquer sur le bouton &quot;play&quot; dans la barre en bas pour ex√©cuter le programme. ü•≥    remarque En cliquant sur ce bouton, l'IDE compile automatiquement si n√©cessaire puis ex√©cute l'ex√©cutable.  remarque Cmake devrait normalement cr√©er un dossier build, c'est normal. CMake est un outil de compilation mais ne compile pas directement, il permet de g√©n√©rer des fichiers permettant ensuite de compiler un projet. Vous n'avez pas besoin d'aller voir ce qui s'y trouve, CMake g√®re automatiquement ce dossier build pour vous.  attention Pour qu'un projet CMake soit fonctionnel, il faut que le dossier ouvert dans votre IDE contienne un fichier CMakeLists.txt √† la racine du dossier. Sinon, l'extension CMake ne d√©tectera pas le dossier ouvert comme un projet CMake et il ne va pas s'initialiser automatiquement. Les fonctionnalit√©s de l'extension ne seront donc pas disponibles.  ","version":"Next","tagName":"h2"},{"title":"Quelques explications sur le programme‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#quelques-explications-sur-le-programme","content":" ","version":"Next","tagName":"h2"},{"title":"include ?‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#include-","content":" #include &lt;iostream&gt;   Le but de notre programme est d‚Äôafficher un message. Des d√©veloppeurs experts ont d√©j√† cr√©√© un outil qui permet de le faire facilement. Il se trouve dans un fichier nomm√© iostream, acronyme de &quot;Input Output Stream&quot;, soit &quot;Flux d‚ÄôEntr√©es Sorties&quot;. Ce fichier fait partie de la biblioth√®que standard C++ STD (pour &quot;C++ STandarD library&quot;), un ensemble de fonctionnalit√©s d√©j√† pr√©-cod√©es et disponibles partout avec n'importe quel compilateur C++.  Pour utiliser les fonctionnalit√©s offertes par ce fichier, notamment √©crire un message avec std::cout, on doit l‚Äôimporter dans notre programme. On dit qu‚Äôon l‚Äôinclut, d‚Äôo√π l‚Äôanglais &quot;include&quot;. Nous utiliserons beaucoup cette fonctionnalit√© en C++.  Essayez donc de supprimer la ligne, puis compilez de nouveau votre programme et voyez ce qu'il se passe !    Le compilateur ne peut pas compiler notre programme, et il nous fournit donc une erreur de compilation. Il est tr√®s important d'apprendre √† lire et comprendre ces erreurs car elles vous apportent beaucoup d'informations pour vous aider √† corriger votre programme ! En l'occurrence elle nous indique que le symbole std::cout est introuvable, et nous donne m√™me une piste pour corriger le probl√®me : rajouter #include &lt;iostream&gt; !  Il nous indique m√™me o√π l'erreur s'est produite :cela signifie que c'est dans le fichier helloImac.cpp, √† la ligne 4, et au 8√®me caract√®re de cette ligne. Vous pouvez aussi CTRL+click dessus pour que VSCode vous emm√®ne directement au bon endroit !  info #include s'appelle une directive pr√©processeur. Le pr√©processeur est un programme ex√©cut√© lors de la premi√®re phase de la compilation qui effectue des modifications textuelles sur le fichier source √† partir de directives. Ces directives commencent par le caract√®re # et doivent se terminer par un saut de ligne. Retenez simplement que #include nous permet d‚Äôimporter des fichiers pour les inclure dans le programme que l'on est en train d'√©crire, et je le d√©taillerai plus tard dans le semestre.  ","version":"Next","tagName":"h3"},{"title":"La fonction main‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#la-fonction-main","content":" int main() { // ... return 0; }   Lorsqu‚Äôon lance le programme, celui-ci doit savoir par o√π commencer. On parle de point d‚Äôentr√©e. Ce point d'entr√©e doit √™tre une fonction nomm√©e main et renvoyer une valeur avec le mot cl√© return.  Nous reviendrons sur les fonctions dans un autre chapitre mais retenez que c'est un ensemble d'instructions d√©limit√© par des accolades { et }, et auquel on donne un nom (main dans ce cas).  remarque La fonction main est un peu sp√©ciale et sa valeur de retour (de type int) sert √† indiquer si le programme s‚Äôest termin√© sans erreur. Si tout se passe bien, il faut retourner 0. N‚Äôimporte quelle autre valeur indique une erreur.  ","version":"Next","tagName":"h3"},{"title":"Hello and welcome to IMAC !‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#hello-and-welcome-to-imac-","content":" L‚Äôinstruction ci-dessous permet d‚Äôafficher le texte (qu'on appelle &quot;cha√Æne de caract√®res&quot;, ou &quot;string&quot;, en programmation) &quot;Hello and welcome to IMAC !&quot; sur la sortie standard du programme.  std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl;   Premi√®rement &quot;std&quot; fait r√©f√©rence √† la biblioth√®que standard C++ dont je parlais pr√©c√©demment.  std:: permet d'indiquer que l'on veut utiliser une fonctionnalit√© particuli√®re de cette biblioth√®que, ici cout :  Il s‚Äôagit de l'objet (on parle de stream dans le jargon C++) permettant de renvoyer des caract√®res, g√©n√©ralement pour les afficher dans le terminal. Le 'c' fait r√©f√©rence √† caract√®re et ‚Äòout‚Äô indique ‚Äòsortie‚Äô.  Enfin, std::endl indique ici &quot;end-line&quot; soit la 'fin de ligne'.  ","version":"Next","tagName":"h3"},{"title":"Dernier point (virgule)‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#dernier-point-virgule","content":" Chaque instruction doit √™tre identifiable afin de que compilateur puisse faire son travail et produire un programme ex√©cutable.  C'est le r√¥le du point-virgule ; de d√©limiter chaque instruction et il est donc important de ne pas l'oublier.  On le retrouve par exemple dans notre programme √† la fin du return 0;.  attention Ce n'est pas le cas pour les directives pr√©processeur comme #include vu pr√©c√©demment qui, elles, doivent avoir leur propre ligne et ne doivent pas se terminer par un point-virgule ; mais un saut de ligne.  Les sauts de lignes et espacements sont l√† pour am√©liorer la lisibilit√© mais pas pour le bon fonctionnement du compilateur en lui m√™me et on pourrait tr√®s bien √©crire :  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl; return 0; }   Je vous recommande tout de m√™me d'utiliser des espacements et sauts de ligne pour mieux s'y retrouver et c'est ce que je vais faire tout au long de ce cours.    Et voil√† ! Vous avez ex√©cut√© votre premier programme C++ √† l'aide de VSCode ! üéâ ","version":"Next","tagName":"h3"},{"title":"Structure: organiser nos donn√©es","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"D√©claration‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#d√©claration","content":" C'est en utilisant le mot-cl√© struct que l'on va cr√©er une nouvelle structure. La syntaxe de d√©claration est la suivante:  struct nom { // liste des membres // type nom; // type nom; };   Cette structure est ensuite utilisable comme n'importe quel autre type de variable.  Un exemple de d√©claration:  struct People { std::string name; std::string lastName; unsigned int age; };   ","version":"Next","tagName":"h2"},{"title":"Initialisation‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#initialisation","content":" Pour initialiser une structure, il y a plusieurs fa√ßons de faire similaire √† la d√©claration des variables &quot;classiques&quot;.  // Initialisation avec des valeurs (elles doivent √™tre ordonn√©es comme les membres de la structure) People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Syntaxe possible utilisant le signe = (comme en C) People people = { &quot;name&quot;, &quot;lastName&quot;, 42 };   remarque Lors de l'initialisation avec des valeurs, elles doivent √™tre ordonn√©es dans l‚Äôordre dans lequel elles sont d√©finies dans la structure. On ne peut pas donner juste un entier comme premi√®re valeur pour l'age dans notre cas.  danger Comme pour les variables, ne pas initialiser une structure est un comportement ind√©termin√©. // Initialisation ind√©termin√©e People defaultPeople; Dans ce cas, il faut s'assurer de bien d√©finir les membres de la structure ensuite !  ","version":"Next","tagName":"h2"},{"title":"Valeurs par d√©faut‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#valeurs-par-d√©faut","content":" Lors de l'initialisation, si il n'y a pas de valeur fournie entre accolades () pour les membres de la structure, ils seront initialis√©s avec une valeur par d√©faut. Pour les types primitifs (comme int, float, double, char, bool, etc.) la valeur par d√©faut est z√©ro. Pour les objets (comme std::string, std::vector, etc.) la valeur par d√©faut est l'objet vide.  Si une valeur est fournie en m√™me temps que la d√©claration d'un membre, c'est cette valeur qui sera utilis√©e lors de l'initialisation par d√©faut de la structure.  un exemple #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name {&quot;unknown&quot;}; float price {0.f}; unsigned int quantity {1}; }; void Display(Product const&amp; product) { std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; product.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; product.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; product.quantity &lt;&lt; std::endl; } int main() { Product unknownProduct {}; Display(unknownProduct); return 0; }   Name: unknown Price: 0 Quantity: 1   R√©sum√© de toutes les possibilit√©s d'initialisation Si une structure est initialis√©e avec accolades (ce qu'il fait faire tout le temps comme pour les variables) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur explicite est utilis√©e.Si une valeur est manquante dans les accolades et qu'il existe une valeur de variable membre par d√©faut, cette valeur est utilis√©e. (c'est l'exemple de la structure Product ci-dessus)Si une valeur est manquante dans les accolades et qu'il n'y a pas valeur par d√©faut dans la structure, l'initialisation par d√©faut pour le type de la variable est utilis√©e. Si une structure est initialis√©e sans accolades (ce qui est √† √©viter) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur est utilis√©e.Si une valeur est manquante dans les accolades, la variable membre reste non initialis√©e. (comportement ind√©termin√©)  Bonne pratique Une bonne pratique est de toujours initialiser les variables membres de la structure avec une valeur par d√©faut explicite ou √† d√©faut d'utiliser des accolades vide pour √©viter le risque de variables non initialis√©es et de comportement ind√©termin√©. #include &lt;string&gt; struct Product { std::string name {}; float price {}; unsigned int quantity {1}; };   ","version":"Next","tagName":"h3"},{"title":"Utilisation‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#utilisation","content":" Pour manipuler un membre, c‚Äôest-√†-dire une variable appartenant √† la structure, il suffit d‚Äôutiliser la syntaxe structure.membre.  #include &lt;iostream&gt; #include &lt;string&gt; struct People { std::string name; std::string lastName; unsigned int age; }; int main() { People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Modification de l'age people.age = 19; // Lecture des membres std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; people.name &lt;&lt; &quot; &quot; &lt;&lt; people.lastName &lt;&lt; &quot; and i'm &quot; &lt;&lt; people.age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par r√©f√©rence‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#passage-par-r√©f√©rence","content":" Une structure √©tant un agr√©gat de donn√©es (plus ou moins gros) il est int√©ressant d'utiliser des r√©f√©rences pour passer en param√®tres nos structures afin d'√©viter des copies.  #include &lt;string&gt; #include &lt;iostream&gt; struct Product { std::string name; float price; unsigned int quantity; }; float GetTotalPrice(Product const&amp; product) { return product.price * product.quantity; } int main() { Product product { &quot;Tomatos&quot;, 0.32, 12 }; // Lecture des membres std::cout &lt;&lt; &quot;The total price for &quot; &lt;&lt; product.name &lt;&lt; &quot; is &quot; &lt;&lt; GetTotalPrice(product) &lt;&lt; &quot; ‚Ç¨.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des m√©thodes‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#des-m√©thodes","content":" Maintenant que nous avons nos propres structures cela va devenir int√©ressant d'utiliser des m√©thodes. En effet, dans mon exemple pr√©c√©dent j'ai cr√©√© des fonctions GetTotalPrice et Display. Mais j'aurais bien aim√© pouvoir faire : product.TotalPrice(). Autrement dit, cr√©er et utiliser une m√©thode TotalPrice() pour ma structure Product.  Il suffit simplement de d√©clarer notre fonction au sein m√™me des accolades de notre structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() { return price * quantity; } };   remarque Vous pouvez remarquer qu'ici je peux acc√©der aux membres de ma struct sans avoir √† faire struct.membre. En effet, la m√©thode a connaissance de la structure elle-m√™me et peut manipuler ses membres directement.  ","version":"Next","tagName":"h2"},{"title":"Prototype de m√©thodes‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#prototype-de-m√©thodes","content":" Comme pour les fonctions, il est possible de d√©clarer seulement le prototype de la m√©thode et d'impl√©menter le corps de la m√©thode plus tard. Il y a juste un petit d√©tail en plus, il faut indiquer √† l'aide du nom de la structure et des caract√®res :: ,l'appartenance de la m√©thode √† la structure (comme avec std::).  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; }   remarque C'est une notion qui va √™tre utile quand on verra la s√©paration du code en plusieurs fichiers.  ","version":"Next","tagName":"h3"},{"title":"M√©thode constante‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#m√©thode-constante","content":" Ici, il est aussi possible de pr√©ciser qu'une m√©thode ne modifie pas la structure, on parle de m√©thode constante. Il faut ajouter le mot-cl√© const √† la fin de la d√©claration de la m√©thode, avant le point virgule ;.  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() const; }; float Product::TotalPrice() const { return price * quantity; }   C'est important car si on ne le fait pas on ne pourra pas appeler une m√©thode non constante d'une variable constante car celle-ci est susceptible de modifier la structure alors que c'est interdit par la variable constante.  #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; } int main() { Product const tomatos { &quot;Tomatos&quot;, 0.32, 12 }; // erreur ici: la variable tomatos est constante mais la m√©thode 'TotalPrice' ne l'est pas float tomatosPrice { tomatos.TotalPrice() }; return 0; }   Il faut donc indiquer que la m√©thode est constante:  // le prototype float GetTotalPrice() const; // et la fonction float Product::GetTotalPrice() const { return price * quantity; }   ","version":"Next","tagName":"h3"},{"title":"Conflit de noms‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#conflit-de-noms","content":" Comme pour les fonctions, il est possible de passer des param√®tres √† notre m√©thode.  Mais si le param√®tre a le m√™me nom qu'un des membres de la structure il y a un conflit de noms.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float price) { price = price; } };   Ici la variable price manipul√©e dans la fonction n'est plus le membre mais le param√®tre, les param√®tres ont la priorit√© sur les membres de la structure.  attention Sur certains compilateurs bien configur√©s on peut avoir des warnings : Warning g√©n√©r√© par clang Explicitly assigning value of variable of type 'float' to itself; did you mean to assign to member 'price'? Mais ce n'est pas toujours le cas. Avec un param√®tre constant on aurait g√©n√©r√© des erreurs de compilation et pas seulement un warning et c'est donc pr√©f√©rable pour mieux se rendre compte des erreurs. - Cannot assign to variable 'price' with const-qualified type 'const float' - assignment of read-only parameter 'price'   Pour √©viter la confusion, il est pr√©f√©rable d'utiliser le mot cl√© this suivi des caract√®res -&gt; devant le nom d'un membre de la structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { this-&gt;price = price; } };   Ici, plus de probl√®me, this-&gt;price fait r√©f√©rence √† notre membre et price est le param√®tre constant de la m√©thode.  Une autre solution pr√©f√©rable et recommand√©e est de renommer le nom du param√®tre pour √©viter cette confusion:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const newPrice) { price = newPrice; // this-&gt;price = newPrice; } };   Vous √™tes libre de laisser ou non le this-&gt; pour indiquer plus explicitement l'utilisation du membre de la structure surtout si c'est plus compr√©hensible pour vous.  Je ne rentre pas dans le d√©tail ici. Je reviendrai sur le fonctionnement du mot-cl√© this dans un autre chapitre. Retenez simplement ici que cela permet d'indiquer explicitement que l'on souhaite manipuler la structure.  ","version":"Next","tagName":"h3"},{"title":"Aller plus loin: Forward Declaration‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#aller-plus-loin-forward-declaration","content":" Parfois deux structures ont besoin l'une de l'autre, on veut utiliser une struct A dans une struct B et inversement.  Probl√®me, l'une est d√©finie avant l'autre et donc dans la premi√®re structure A il y a une erreur, B est encore inconnue.    Pour r√©soudre ce probl√®me on va faire une d√©claration anticip√©e (Forward Declaration en anglais).  Un peu √† la mani√®re d'un prototype on va indiquer que la structure existe, sans en d√©finir pr√©cis√©ment encore son contenu.  #include &lt;vector&gt; // D√©claration anticip√©e de la structure Book struct Book; struct Author { std::string name; // Je peux donc l'utiliser ici std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); };   attention Cela ne permet pas de manipuler la structure vu que l'on ne sait pas encore ce qu'elle contient. De ce fait, les m√©thodes de la structure Author qui utilisent la structure Book doivent se trouver apr√®s la d√©claration compl√®te de la structure Book.  Un exemple plus complet #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; struct Book; struct Author { std::string name; std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); }; void Author::Display() { std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Books: &quot; &lt;&lt; std::endl; for (Book const&amp; book : books) { std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; book.title &lt;&lt; std::endl; } } void Author::AddBook(std::string title) { // le &quot;*this&quot; permet de r√©cup√©rer une r√©f√©rence vers l'objet courant // Ce m√©canisme sera d√©taill√© dans un prochain chapitre Book book {title, *this}; // Ici une copie de l'objet book est faite dans le vecteur books.push_back(book); // La variable book va √™tre d√©truite √† la fin de la fonction // mais le vecteur books contient une copie de l'objet book donc pas de probl√®me } void Book::Display() { std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author.name &lt;&lt; std::endl; } int main() { Author author {&quot;Jules Verne&quot;, {}}; author.AddBook(&quot;Vingt mille lieues sous les mers&quot;); author.Display(); return 0; }   ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#r√©sum√©","content":" Une structure est un agr√©gat de donn√©es, on la d√©clare avec le mot-cl√© struct. Les membres de la structure sont les variables qui la composent. On y acc√®de avec un point . apr√®s le nom de la variable. Une structure peut avoir des m√©thodes qui se d√©clarent comme pour les fonctions mais au sein m√™me des accolades de la structure. Le corps d'une m√©thode peut √™tre d√©clar√© plus tard (du moment que le prototype de la m√©thode est dans la structure). Il faut utiliser le nom de la structure suivi des caract√®res :: pour indiquer l'appartenance de la m√©thode √† la structure si elle est d√©clar√©e en dehors des accolades d√©limitant la structure. Une m√©thode peut √™tre constante pour indiquer qu'elle ne va pas modifier la structure. Il faut ajouter le mot-cl√© const apr√®s les param√®tres de la fonction et avant le point virgule ;. On peut utiliser le mot-cl√© this pour expliciter que l'on souhaite manipuler la structure et √©viter des conflits de nommages entre les membres et les param√®tres d'une m√©thode. ","version":"Next","tagName":"h2"},{"title":"Arbres binaires","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree","content":"","keywords":"","version":"Next"},{"title":"Profondeur d'un n≈ìud‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#profondeur-dun-n≈ìud","content":" La profondeur d'un n≈ìud est le nombre de n≈ìuds qui le s√©parent du n≈ìud racine. En consid√©rant que la profondeur du n≈ìud racine est 1.  Dans notre exemple, la profondeur du n≈ìud racine A est 1. La profondeur du n≈ìud B est 2. La profondeur du n≈ìud E est 3. etc..  ","version":"Next","tagName":"h3"},{"title":"Hauteur d'un arbre‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#hauteur-dun-arbre","content":" La hauteur d'un arbre est la profondeur maximale de ses n≈ìuds. C'est √† dire la profondeur du n≈ìud le plus profond.  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires","content":" Il existe plusieurs types d'arbres qui ont des propri√©t√©s diff√©rentes. On peut par exemple se limiter √† un nombre maximum de fils par n≈ìud, imposer un ordre sur les fils d'un n≈ìud, ou encore imposer que chaque n≈ìud ait un nombre fixe de fils.  C'est le cas des arbres binaires. Un arbre binaire est un arbre dont chaque n≈ìud a au maximum deux fils. Un fils gauche et un fils droit.  C'est une structure de donn√©es tr√®s utilis√©e en informatique et c'est ce que nous allons √©tudier.  ","version":"Next","tagName":"h2"},{"title":"Repr√©sentation d'un arbre binaire‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#repr√©sentation-dun-arbre-binaire","content":" ","version":"Next","tagName":"h2"},{"title":"Structure par r√©cursivit√©‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-r√©cursivit√©","content":" Pour repr√©senter un arbre binaire une solution qui peut sembler naturelle est d'utiliser une structure r√©cursive. C'est √† dire une structure qui contient des √©l√©ments de son propre type.  En effet, n'importe quel n≈ìud de l'arbre, peut √™tre vu comme un sous arbre binaire dont la racine est ce n≈ìud. Ce jeu de l'esprit permet de comprendre qu'un n≈ìud pointe vers deux autres n≈ìuds qui sont les fils gauche et droit de ce n≈ìud.  Il peut ne pointer vers aucun n≈ìud, dans ce cas il est une feuille. Sinon, ce n≈ìud repr√©sente un embranchement de l'arbre.  Mais on peut se demander comment repr√©senter ce lien (qui peut ne pas exister dans le cas d'une feuille) entre un n≈ìud et ses fils.  C'est l√† qu'interviennent les pointeurs. On peut repr√©senter ce lien en utilisant des pointeurs vers les n≈ìuds fils.  attention On ne peut pas utiliser des r√©f√©rences car elles doivent √™tre une r√©f√©rence vers un objet existant. Or, dans le cas d'une feuille, il n'y a pas de n≈ìud fils.  Le pointeur lui peut √™tre nul, c'est √† dire qu'il ne pointe vers aucun objet. C'est cette particularit√© qui permet de repr√©senter le cas d'une feuille.  Voil√† √† quoi ressemble la structure que l'on va utiliser pour repr√©senter un arbre binaire:  struct Node { int value; Node* left; Node* right; };   Elle est compos√©e d'un entier qui repr√©sente la valeur du n≈ìud (cela peut √™tre n'importe quel type de donn√©e), et de deux pointeurs vers des n≈ìuds qui repr√©sentent les fils gauche et droit.  C'est pratique mais cela s'accompagne des inconv√©nients des pointeurs. Il faut faire attention √† ne pas avoir de fuites m√©moires (g√©rer l'allocation et la d√©sallocation de la m√©moire) et il faut faire attention √† ne pas utiliser(d√©r√©f√©rencer) un pointeur qui ne pointe vers rien (pointeur nul).  Exemple d'utilisation:  Node* root { new Node {1, nullptr, nullptr}}; root-&gt;left = { new Node {2, nullptr, nullptr}}; root-&gt;right = { new Node {3, nullptr, nullptr}}; root-&gt;left-&gt;left = { new Node {4, nullptr, nullptr}}; delete root-&gt;left-&gt;left; delete root-&gt;left; delete root-&gt;right; delete root;   attention ‚ö†Ô∏è Il faut faire attention √† d√©sallouer la m√©moire dans le bon ordre ! Si on d√©salloue le n≈ìud racine avant ses fils, on ne pourra plus acc√©der aux fils pour les d√©sallouer. Cela provoque une fuite de m√©moire.  info On pourrait se limiter seulement √† cette structure de n≈ìud pour repr√©senter un arbre binaire. Mais cela peut √™tre pratique d'avoir une structure d√©di√©e √† l'arbre binaire qui contient un pointeur vers le n≈ìud racine. Cela permet de g√©rer le cas o√π l'arbre est vide (qui n'a pas encore de n≈ìud racine). Cela permet aussi de cacher la structure interne de l'arbre. On peut par exemple changer la structure interne Node (la structure de n≈ìud) sans avoir √† modifier le code qui l'utilise (la structure de l'arbre). L'utilisateur de l'arbre n'a pas besoin de savoir comment est repr√©sent√© l'arbre en interne, il n'est pas cens√© manipuler directement les n≈ìuds. Cette notion de cacher la structure interne d'un objet est appel√©e encapsulation. C'est une notion importante en programmation orient√©e objet. Vous d√©couvrirez cela plus en d√©tail l'ann√©e prochaine et cela sera encore plus pertinent avec la notion de visibilit√©. struct BinaryTree { Node* root; };    Pointeurs intelligents Il existe des pointeurs intelligents qui permettent de g√©rer automatiquement la m√©moire. Ils sont d√©finis dans la biblioth√®que &lt;memory&gt;. On pourrait se servir dans notre cas du pointeur intelligent std::unique_ptr qui permet de g√©rer automatiquement la m√©moire d'un objet allou√© dynamiquement. struct Node { int value; std::unique_ptr&lt;Node&gt; left; std::unique_ptr&lt;Node&gt; right; }; On peut alors utiliser la fonction std::make_unique pour cr√©er un objet allou√© dynamiquement et initialiser les pointeurs intelligents. std::unique_ptr&lt;Node&gt; root { std::make_unique&lt;Node&gt;(1, nullptr, nullptr)}; root-&gt;left = std::make_unique&lt;Node&gt;(2, nullptr, nullptr); root-&gt;right = std::make_unique&lt;Node&gt;(3, nullptr, nullptr); Cela permet de ne pas avoir √† g√©rer la d√©sallocation de la m√©moire. La structure est automatiquement d√©sallou√©e lorsque le pointeur intelligent est d√©truit. Cela va se faire dans le bon ordre naturellement car pour d√©truire une structure, il faut d'abord d√©truire ses membres. Ses enfants seront donc d√©truits avant le n≈ìud parent.  ","version":"Next","tagName":"h3"},{"title":"Structure par tableau‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-tableau","content":" Une autre fa√ßon de repr√©senter un arbre binaire est d'utiliser un tableau. Cela peut sembler √©trange mais c'est possible.  On peut repr√©senter un arbre binaire en utilisant un tableau en utilisant la relation entre les indices du tableau et les n≈ìuds de l'arbre.  On commence par num√©roter le n≈ìud racine avec l'indice 0. Ensuite, on d√©finit une relation entre les indices des n≈ìuds et les indices de leurs fils.  On d√©finit que le fils gauche d'un n≈ìud d'indice i est le n≈ìud d'indice 2*i + 1. Et que le fils droit d'un n≈ìud d'indice i est le n≈ìud d'indice 2*i + 2.  Un exemple avec l'arbre suivant:    On peut repr√©senter cet arbre avec le tableau suivant:  [A, B, C, D, E, F, G]   En effet, le n≈ìud A est √† l'indice 0. Son fils gauche est le n≈ìud B qui est √† l'indice 2*0 + 1 = 1. Son fils droit est le n≈ìud C qui est √† l'indice 2*0 + 2 = 2. Pour le n≈ìud B(d'indice 1) , son fils gauche est le n≈ìud D qui est √† l'indice 2*1 + 1 = 3. Son fils droit est le n≈ìud E qui est √† l'indice 2*1 + 2 = 4. Etc...  info On peut remarquer qu'il faut un tableau de taille 2n‚àí12^n - 12n‚àí1 pour repr√©senter un arbre binaire complet de hauteur n. C'est √† dire un arbre binaire dont tous les niveaux sont remplis sauf √©ventuellement le dernier niveau qui peut ne pas √™tre rempli.  Dans le cas o√π l'arbre n'est pas complet (c'est √† dire que tous les feuilles ne sont pas sur le m√™me niveau ou que des n≈ìuds de l'arbre n'ont pas forc√©ment deux fils), on peut avoir des trous dans le tableau. C'est √† dire des cases du tableau qui ne sont pas utilis√©es.  Par exemple, pour l'arbre suivant:    On peut repr√©senter cet arbre avec le tableau suivant:  [A, B, C, _, _, D, E, _, _, _, _, H, _, F, _]   Cette repr√©sentation est int√©ressante car elle permet de repr√©senter un arbre binaire sans avoir √† utiliser de pointeurs. Mais elle a aussi l'inconv√©nient de ne pas √™tre tr√®s efficace quand l'arbre n'est pas compl√®tement rempli. En effet, on peut avoir beaucoup de trous dans le tableau. Cela peut √™tre probl√©matique si l'arbre a une hauteur importante.  De plus il faut un moyen de repr√©senter les trous dans le tableau. On peut par exemple utiliser une valeur sp√©ciale qui ne peut pas √™tre une valeur valide pour un n≈ìud. Par exemple, on peut utiliser la valeur -1 pour repr√©senter un trou dans le tableau. Ou alors on peut utiliser std::optional pour repr√©senter un n≈ìud qui n'existe pas.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un arbre binaire‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-dun-arbre-binaire","content":" Il existe plusieurs fa√ßons de parcourir les diff√©rents n≈ìuds d'un arbre binaire. On peut par exemple parcourir l'arbre en largeur ou en profondeur.  Donnons nous l'arbre suivant:    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-largeur","content":" Le parcours en largeur consiste √† parcourir l'arbre en commen√ßant par le n≈ìud racine puis en parcourant les n≈ìuds de chaque niveau de profondeur de l'arbre de gauche √† droite.  astuce Cela correspond √† l'ordre dans lequel sont rang√©es les donn√©es lorsque l'on repr√©sente un arbre binaire par un tableau.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-profondeur","content":" Le parcours en profondeur consiste √† parcourir l'arbre de la racine vers les feuilles par r√©cursion dans les sous-arbres gauche et droite. On peut parcourir l'arbre en profondeur de diff√©rentes fa√ßons:  Parcours en profondeur pr√©fixe (ou pr√©-ordre): on parcourt d'abord le n≈ìud racine, puis le sous-arbre gauche et enfin le sous-arbre droit.Parcours en profondeur infixe (ou sym√©trique): on parcourt d'abord le sous-arbre gauche, puis le n≈ìud racine et enfin le sous-arbre droit.Parcours en profondeur postfixe (ou post-ordre): on parcourt d'abord le sous-arbre gauche, puis le sous-arbre droit et enfin le n≈ìud racine.  Exemple de parcours Pour l'arbre suivant:    Parcours en largeur: A B C D E F GParcours en profondeur pr√©fixe: A B D E C F GParcours en profondeur infixe: D B E A F C GParcours en profondeur postfixe: D E B F G C A  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires de recherche‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires-de-recherche","content":" Une fois que l'on a vu comment repr√©senter un arbre binaire, on peut se demander √† quoi cela peut servir. On peut par exemple se demander comment faire une recherche efficace dans un arbre binaire.  Un arbre binaire de recherche est un arbre binaire qui a la particularit√© d'√™tre ordonn√©. On va imposer un ordre sur les valeurs des n≈ìuds de l'arbre.  Dans notre cas on va imposer que pour chaque n≈ìud, toutes les valeurs des n≈ìuds du sous-arbre gauche sont inf√©rieures √† la valeur du n≈ìud et toutes les valeurs des n≈ìuds du sous-arbre droit sont sup√©rieures √† la valeur du n≈ìud.  Le premier √©l√©ment ins√©r√© dans l'arbre devient la racine. Ensuite, il suffit de mettre √† gauche les √©l√©ments plus petits et √† droite les √©l√©ments plus grands. C'est cette particularit√© qui rend les arbres binaires de recherche int√©ressants.  Cela permet de faire des recherches efficaces dans l'arbre. Gr√¢ce √† la relation d'ordre entre les n≈ìuds, on peut savoir dans quel sous-arbre se trouve la valeur recherch√©e et effectuer une recherche rappelant le fonctionnement de la recherche dichotomique.  Vous pouvez trouver un visuel interactif pour comprendre le fonctionnement d'un arbre binaire de recherche ici.  ","version":"Next","tagName":"h2"},{"title":"Insertion‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#insertion","content":" L'insertion dans un arbre binaire de recherche est assez simple. Il suffit de trouver le bon endroit pour ins√©rer le nouveau n≈ìud en respectant la relation d'ordre entre les n≈ìuds.  On commence par comparer la valeur du nouveau n≈ìud avec la valeur du n≈ìud racine. Si la valeur du nouveau n≈ìud est inf√©rieure √† la valeur du n≈ìud racine, on ins√®re le nouveau n≈ìud dans le sous-arbre gauche. Sinon, on ins√®re le nouveau n≈ìud dans le sous-arbre droit.  On r√©p√®te cette op√©ration jusqu'√† trouver un n≈ìud qui n'a pas de fils dans la direction o√π l'on souhaite ins√©rer le nouveau n≈ìud. On ins√®re alors le nouveau n≈ìud √† cet endroit.  ","version":"Next","tagName":"h3"},{"title":"Recherche‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#recherche","content":" La recherche dans un arbre binaire de recherche est similaire √† la recherche dichotomique. Pour commencer, on compare la valeur recherch√©e avec la valeur du n≈ìud racine. Si la valeur recherch√©e est inf√©rieure √† la valeur du n≈ìud racine, on effectue la recherche dans le sous-arbre gauche. Sinon, on effectue la recherche dans le sous-arbre droit.  On r√©p√®te cette op√©ration jusqu'√† trouver la valeur recherch√©e ou jusqu'√† arriver √† un n≈ìud qui n'a pas de fils dans la direction o√π l'on souhaite continuer la recherche. Dans ce cas, on peut conclure que la valeur recherch√©e n'est pas dans l'arbre.  L'int√©r√™t de la recherche dans un arbre binaire de recherche est que l'on peut exclure une partie de l'arbre √† chaque √©tape de la recherche. Cela permet de r√©duire le nombre de comparaisons n√©cessaires pour trouver un √©l√©ment dans l'arbre. C'est ce qui rend la recherche dans un arbre binaire de recherche efficace. C'est une complexit√© en O(log(n))O(log(n))O(log(n)).  ","version":"Next","tagName":"h3"},{"title":"Suppression‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#suppression","content":" La suppression dans un arbre binaire de recherche est plus complexe que l'insertion et la recherche. Il faut faire attention √† ne pas casser la relation d'ordre entre les n≈ìuds.  Il existe trois cas de figure:  Le n≈ìud √† supprimer est une feuille: il suffit de supprimer le n≈ìud.Le n≈ìud √† supprimer a un seul fils: il suffit de supprimer le n≈ìud et de le remplacer par son fils.Le n≈ìud √† supprimer a deux fils: il faut trouver le n≈ìud qui va remplacer le n≈ìud √† supprimer tout en conservant la relation d'ordre entre les n≈ìuds.  Dans le cas 3, il faut faire attention √† ne pas casser la relation d'ordre entre les n≈ìuds. Je rappelle que pour chaque n≈ìud, toutes les valeurs des n≈ìuds du sous-arbre gauche sont inf√©rieures √† la valeur du n≈ìud et toutes les valeurs des n≈ìuds du sous-arbre droit sont sup√©rieures √† la valeur du n≈ìud. Pour conserver cette relation d'ordre, il faut alors que le n≈ìud qui remplace le n≈ìud √† supprimer soit plus grand que tous les n≈ìuds du sous-arbre gauche ou plus petit que tous les n≈ìuds du sous-arbre droit.  On va donc par exemple chercher le n≈ìud le plus √† gauche du sous-arbre droit. Ce n≈ìud est le plus petit n≈ìud du sous-arbre droit. Il est donc plus grand que tous les n≈ìuds du sous-arbre gauche et plus petit que tous les n≈ìuds du sous-arbre droit. Il peut donc remplacer le n≈ìud √† supprimer tout en conservant la relation d'ordre entre les n≈ìuds.  ","version":"Next","tagName":"h3"},{"title":"Une multitude d'arbres binaires‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#une-multitude-darbres-binaires","content":" Il existe une multitude d'arbres binaires diff√©rents qui ont des propri√©t√©s diff√©rentes. Cela permet de s'adapter √† diff√©rents cas d'utilisation.  Par exemple, dans le cadre d'une recherche, on peut vouloir que l'arbre soit le plus √©quilibr√© possible (c'est √† dire que la hauteur de l'arbre soit la plus petite possible). Cela permet de r√©duire le nombre de comparaisons n√©cessaires pour trouver un √©l√©ment dans l'arbre. C'est le cas des arbres binaires de recherche AVL. Cela nous force √† impl√©menter des algorithmes d'insertion et de suppression plus complexes pour maintenir l'√©quilibre de l'arbre.  Dans d'autres cas, on peut vouloir privil√©gier la rapidit√© d'insertion et de suppression. C'est le cas des arbres binaires de recherche Rouge-Noir. C'est un autre type d'arbre binaire de recherche qui permet de maintenir un arbre √©quilibr√© mais qui ne garantit pas √† tout moment que l'arbre soit le plus √©quilibr√© possible. Cela permet de simplifier les algorithmes d'insertion et de suppression tout en restant efficace la majorit√© du temps.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#r√©sum√©","content":" Un arbre est une structure de donn√©es qui permet de repr√©senter des donn√©es hi√©rarchiques.Un arbre est compos√© de n≈ìuds. Chaque n≈ìud peut avoir un nombre quelconque de fils. Un n≈ìud qui n'a pas de fils est appel√© une feuille.Un arbre est compos√© d'un n≈ìud racine qui est le n≈ìud de d√©part de l'arbre. Il est possible d'acc√©der √† tous les autres n≈ìuds de l'arbre √† partir du n≈ìud racine.La profondeur d'un n≈ìud est le nombre de n≈ìuds qui le s√©parent du n≈ìud racine.La hauteur d'un arbre est la profondeur maximale de ses n≈ìuds. C'est √† dire la profondeur du n≈ìud le plus profond.Un arbre binaire est un arbre dont chaque n≈ìud a au maximum deux fils. Un fils gauche et un fils droit.Un arbre binaire peut √™tre repr√©sent√© par une structure r√©cursive (C'est √† dire une structure qui contient des √©l√©ments de son propre type) ou par un tableau.Un arbre binaire de recherche est un arbre binaire qui a la particularit√© d'√™tre ordonn√©. On va imposer un ordre sur les valeurs des n≈ìuds de l'arbre. Cela va permettre de faire des recherches efficaces dans l'arbre.Il existe une multitude d'arbres binaires diff√©rents qui ont des propri√©t√©s diff√©rentes. Cela permet de s'adapter √† diff√©rents cas d'utilisation (pour optimiser la recherche, l'insertion, la suppression, etc...) ","version":"Next","tagName":"h2"},{"title":"D√©duction de type et biblioth√®que standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"It√©rateurs‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#it√©rateurs","content":" Les it√©rateurs sont des objets propres √† la STL qui permettent de parcourir les conteneurs et structures de donn√©es sans se soucier de la mani√®re dont ils sont impl√©ment√©s. Cela permet d'abstraire le conteneur utilis√© et de pouvoir utiliser des algorithmes de mani√®re g√©n√©rique.  Les it√©rateurs sont des objets qui se comportent un peu comme des pointeurs. Ils permettent de cibler un √©l√©ment dans un conteneur, de le manipuler et permettent de passer d'un √©l√©ment √† l'autre.  Pour un tableau (comme std::array ou std::vector) le passage d'un √©l√©ment √† l'autre se fait g√©n√©ralement en incr√©mentant un compteur mais pour d'autres conteneurs, le passage d'un √©l√©ment √† l'autre est plus complexe. Gr√¢ce aux it√©rateurs, nous n'avons pas √† nous soucier de la mani√®re dont le conteneur est impl√©ment√©.  info Il existe plusieurs types d'it√©rateurs qui permettent de parcourir les conteneurs de diff√©rentes mani√®res (parcours en lecture seule, parcours en lecture et √©criture, parcours seulement dans un sens, ...). Nous n'allons pas rentrer dans les d√©tails des diff√©rents types d'it√©rateurs mais sachez qu'il existe plusieurs types d'it√©rateurs qui permettent de parcourir les conteneurs de diff√©rentes mani√®res.  Les it√©rateurs ont des op√©rateurs et m√©thodes qui permettent de les manipuler comme avec l'op√©rateur * pour d√©r√©f√©rencer et acc√©der √† la valeur point√©e par l'it√©rateur et l'op√©rateur ++ pour passer √† l'√©l√©ment suivant.  ","version":"Next","tagName":"h2"},{"title":"Begin et end‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#begin-et-end","content":" Il existe principalement deux m√©thodes sur les conteneurs qui permettent de r√©cup√©rer un it√©rateur sur le premier √©l√©ment du conteneur et un it√©rateur permettant d'indiquer la fin du conteneur.  Voici un exemple avec un vecteur (std::vector) :  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // D√©claration d'un it√©rateur sur le vecteur v std::vector&lt;int&gt;::iterator begin_iterator { v.begin() }; // D√©claration d'un it√©rateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() };   remarque Ici, nous utilisons l'it√©rateur std::vector&lt;int&gt;::iterator qui permet de parcourir un vecteur. Il existe aussi l'it√©rateur std::vector&lt;int&gt;::const_iterator qui permet de parcourir un vecteur en lecture seule (const) (on peut obtenir des it√©rateurs constants avec les m√©thodes cbegin et cend).  attention L'it√©rateur end ne pointe pas sur le dernier √©l√©ment du conteneur mais vers un √©l√©ment invalide qui indique la fin du conteneur (g√©n√©ralement un √©l√©ment apr√®s le dernier √©l√©ment du conteneur comme c'est le cas pour std::vector par exemple). Il ne faut donc pas d√©r√©f√©rencer l'it√©rateur end car cela provoquerait une erreur. Il sert uniquement √† indiquer la fin du conteneur.  ","version":"Next","tagName":"h3"},{"title":"Utilisation des it√©rateurs‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#utilisation-des-it√©rateurs","content":" Pour illustrer le fonctionnement des it√©rateurs, reprenons l'exemple pr√©c√©dent avec un vecteur pour utiliser l'it√©rateur pour parcourir le vecteur.  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // D√©claration d'un it√©rateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() }; // Parcours du vecteur avec l'it√©rateur for (std::vector&lt;int&gt;::iterator it { v.begin() }; it != end_iterator; ++it) { std::cout &lt;&lt; *it &lt;&lt; std::endl; }   Quelques explications sur ce code : Nous d√©clarons un it√©rateur sur le premier √©l√©ment du vecteur v et un it√©rateur sur le dernier √©l√©ment du vecteur v. Ensuite, nous parcourons le vecteur avec une boucle for en incr√©mentant l'it√©rateur (pour passer √† l'√©l√©ment suivant). Nous utilisons l'op√©rateur != pour comparer l'it√©rateur actuel avec l'it√©rateur qui indique la fin du vecteur afin de savoir quand nous avons parcouru tout le vecteur. L'op√©rateur * permet de r√©cup√©rer la valeur point√©e par l'it√©rateur (√† l'instar du d√©r√©f√©rencement d'un pointeur).  for range based loop Il existe une syntaxe plus simple pour parcourir un conteneur avec un it√©rateur. Il s'agit de la boucle for avec la syntaxe for (element : container). Nous avons d√©j√† vu cette syntaxe avec les tableaux. Cette syntaxe est aussi valable pour les autres conteneurs de la STL et utilise en fait les it√©rateurs. Voil√† le m√™me exemple que pr√©c√©demment avec la boucle for et la syntaxe for (element : container) : std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Parcours du vecteur avec l'it√©rateur for (int const element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } C'est cette syntaxe que nous privil√©gierons en pratique pour parcourir les conteneurs.  ","version":"Next","tagName":"h3"},{"title":"D√©duction de type‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#d√©duction-de-type","content":" Jusqu'√† pr√©sent, nous avons toujours d√©clar√© nos variables en pr√©cisant leur type. Cependant, il existe une syntaxe qui permet de d√©duire le type d'une variable √† partir de son initialisation. Nous avons vu avec les it√©rateurs que le type de l'it√©rateur d√©pend du conteneur sur lequel il est utilis√© (par exemple std::vector&lt;int&gt;::iterator pour un vecteur de int et std::vector&lt;float&gt;::iterator pour un vecteur de float)  Il est donc impossible de d√©clarer un it√©rateur sans conna√Ætre le type du conteneur. De plus, le type de l'it√©rateur est g√©n√©ralement tr√®s long et compliqu√© √† √©crire.  Dans ce cas, nous pouvons utiliser la d√©duction de type pour d√©clarer notre it√©rateur. Cela se fait avec le mot cl√© auto √† la place du type de la variable.  std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // D√©claration d'un it√©rateur sur le vecteur v auto it { v.begin() };   Pourquoi ne pas utiliser la d√©duction de type pour toutes les variables ? C'est une question de lisibilit√© du code. Il est plus facile de comprendre le code si les types sont pr√©cis√©s. De plus, la d√©duction de type ne fonctionne que si la variable est initialis√©e et que le type peut √™tre d√©duit. Cela peut √™tre probl√©matique dans certains cas o√π le type ne peut pas √™tre d√©duit ou conduit √† des erreurs (par exemple avec {1, 2, 3, 4, 5} qui peut √™tre un std::vector ou un std::array).  Finalement, la d√©duction de type est une fonctionnalit√© tr√®s utile mais qui doit √™tre utilis√©e avec parcimonie quand cela est pertinent. Il est pr√©f√©rable de pr√©ciser le type des variables pour rendre le code plus lisible quand cela est possible.  On pr√©f√©rera donc √©crire float plut√¥t que auto pour d√©clarer une variable de type float. Mais on pr√©f√©rera utiliser la d√©duction de type pour d√©clarer un it√©rateur sur un conteneur.  remarque C'est g√©n√©ralement consid√©r√© comme une mauvaise pratique de ne pas pr√©ciser le type des variables (comme c'est le cas en Python ou en JavaScript). Il existe pour ces langages des surcouches qui permettent de v√©rifier le type des variables (comme TypeScript pour JavaScript et le module typing pour Python). Le C++ est un langage fortement typ√© et nous impose de pr√©ciser le type des variables mais c'est pour une bonne raison et la d√©duction de type (auto) est une fonctionnalit√© qui permet de simplifier le code dans certains cas et n'a pas pour but de remplacer la d√©claration de type.  ","version":"Next","tagName":"h2"},{"title":"Exemples et algorithmes‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#exemples-et-algorithmes","content":" L'int√©r√™t de l'it√©rateur pour boucler sur un conteneur est limit√©. En effet, il est plus simple d'utiliser la boucle for avec la syntaxe for (element : container) pour parcourir un conteneur.  L'int√©r√™t des it√©rateurs est de pouvoir utiliser des algorithmes de la STL qui permettent de manipuler les conteneurs de mani√®re g√©n√©rique.  Toutes ces fonctions sont d√©finies dans le fichier d'en-t√™te algorithm de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-t√™te sur le site cppreference.com (attention, la documentation est en anglais).  Nous allons voir quelques exemples d'algorithmes les plus courants de la STL.  ","version":"Next","tagName":"h2"},{"title":"Find‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#find","content":" L'algorithme std::find permet de rechercher un √©l√©ment dans un conteneur. Il prend en param√®tre un it√©rateur sur le premier √©l√©ment du conteneur, un it√©rateur sur le dernier √©l√©ment du conteneur et la valeur √† rechercher.  L'algorithme std::find renvoie un it√©rateur sur l'√©l√©ment trouv√© ou l'it√©rateur end si l'√©l√©ment n'est pas trouv√©.  Voici un exemple avec un vecteur (std::vector) :  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Recherche de l'√©l√©ment 3 dans le vecteur v auto it { std::find(v.begin(), v.end(), 3) }; // On compare l'it√©rateur avec l'it√©rateur sur le dernier √©l√©ment du vecteur if (it != v.end()) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Sort‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#sort","content":" L'algorithme std::sort permet de trier un conteneur. Il prend en param√®tre un it√©rateur sur le premier √©l√©ment du conteneur et un it√©rateur sur le dernier √©l√©ment du conteneur.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {5, 2, 3, 1, 4}; // Tri du vecteur v std::sort(v.begin(), v.end()); // Parcours du vecteur avec l'it√©rateur for (int element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Remove et Erase‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#remove-et-erase","content":" Pour le std::vector, il existe une m√©thode std::erase qui permet de supprimer des √©l√©ments du vecteur. Cependant, cette m√©thode n'existe pas pour tous les conteneurs.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {14, 25, 36, 42, 53}; // Suppression de tous les √©l√©ments du vecteur v qui sont √©gaux √† 36 std::erase(v, 36); }   Cette fonction propre au std::vector ne permet pas de supprimer un √©l√©ment d'un conteneur g√©n√©rique.  Pour cela, il existe l'algorithme std::remove qui permet de supprimer un √©l√©ment d'un conteneur. Il prend en param√®tre un it√©rateur sur le premier √©l√©ment du conteneur, un it√©rateur sur la fin du conteneur et la valeur √† supprimer. C'est ce qu'utilise la m√©thode std::erase pour supprimer un √©l√©ment du std::vector.  attention std::remove ne supprime pas r√©ellement les √©l√©ments du conteneur. Il d√©place les √©l√©ments √† supprimer √† la fin du conteneur et renvoie un it√©rateur sur le premier √©l√©ment √† supprimer pour d√©finir la nouvelle fin du conteneur. Il faut ensuite utiliser la m√©thode erase pour supprimer les √©l√©ments √† supprimer du conteneur. v.erase(std::remove(v.begin(), v.end(), 5), v.end());   C'est ce qu'on appelle l'idiome remove-erase.  A partir du C++20, il existe de nouvelles fonctions qui permettent de supprimer des √©l√©ments d'un conteneur de mani√®re g√©n√©rique: std::erase et std::erase_if. Ces fonctions prennent en param√®tre des it√©rateurs et fonctionnent donc avec tous les conteneurs.  Vous trouverez une explication ici.  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Les fonctions lambda‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#les-fonctions-lambda","content":" Details Il existe de nombreux autres algorithmes dans la STL. Il est impossible de tous les pr√©senter dans ce cours. Je vous invite √† consulter la documentation de la STL sur le site cppreference.com pour d√©couvrir les autres algorithmes. Certains utilisent des fonctions lambda pour permettre de personnaliser le comportement de l'algorithme. C'est le cas de l'algorithme std::transform qui permet d'appliquer une fonction √† tous les √©l√©ments d'un conteneur. Je ne vais pas rentrer dans les d√©tails des fonctions lambda mais sachez que c'est une syntaxe qui permet de d√©finir une fonction anonyme (g√©n√©ralement petite) et permet de passer une fonction en param√®tre d'une autre fonction. C'est quelque chose de tr√®s utilis√© avec la STL. Cela reste une notion avanc√©e et je ne vais pas rentrer dans les d√©tails des fonctions lambda dans ce cours. Vous pouvez seulement retenir deux choses : La syntaxe est la suivante : [] (param√®tres) { instructions }.Si l'on souhaite acc√©der aux variables d√©finies en dehors de la fonction lambda (sans que ce soit un param√®tre), il faut ajouter le symbole &amp; entre les crochets et les param√®tres de la fonction lambda ([&amp;] (param√®tres) { instructions }) (c'est ce que l'on appelle une capture). Je vais pr√©senter quelques algorithmes qui utilisent des fonctions lambda pour vous montrer comment cela fonctionne.  ","version":"Next","tagName":"h3"},{"title":"Transform‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#transform","content":" Details L'algorithme std::transform permet d'appliquer une fonction √† tous les √©l√©ments d'un conteneur. Il prend en param√®tre un it√©rateur sur le premier et le dernier √©l√©ment du conteneur, un it√©rateur sur le premier √©l√©ment du conteneur de destination et la fonction √† appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {0, 0, 0, 0, 0}; // Application de la fonction lambda √† tous les √©l√©ments du vecteur v std::transform(v.begin(), v.end(), v2.begin(), [](int element) { return element * 2; }); // Parcours du vecteur avec l'it√©rateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } } attention Il faut faire attention √† la taille du conteneur de destination. Si le conteneur de destination est trop petit, il y aura un d√©passement et soit le programme plantera soit il y aura des r√©sultats inattendus (le vecteur de destination ne sera pas rempli, etc...). Avec des conteneurs pour lesquels on peut ajouter des √©l√©ments √† la fin (comme std::vector), il est possible d'utiliser la fonction std::back_inserter pour ajouter des √©l√©ments √† la fin du conteneur de destination. Cela permet de ne pas avoir √† se soucier de la taille du conteneur de destination. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {}; // Application de la fonction lambda √† tous les √©l√©ments du vecteur v std::transform(v.begin(), v.end(), std::back_inserter(v2), [](int element) { return element * 2; }); // Parcours du vecteur avec l'it√©rateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Accumulate et reduce‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#accumulate-et-reduce","content":" Details Lorsque l'on souhaite agr√©ger les √©l√©ments d'un conteneur pour en extraire une valeur, il existe deux algorithmes qui permettent de faire cela : std::accumulate et std::reduce. Il sont inclus dans le fichier d'en-t√™te numeric de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-t√™te sur le site cppreference.com. L'algorithme std::accumulate permet d‚Äôaccumuler les √©l√©ments d'un conteneur selon une op√©ration. Pour en faire la somme par exemple. Il prend en param√®tre un it√©rateur sur le premier et le dernier √©l√©ment du conteneur, la valeur initiale et l'op√©ration √† appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des √©l√©ments du vecteur v int sum { std::accumulate(v.begin(), v.end(), 0, [](int acc, int current_element) { return acc + current_element; }) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; } A chaque it√©ration, l'op√©ration est appliqu√©e entre la valeur accumul√©e et l'√©l√©ment courant du conteneur. La valeur accumul√©e est initialis√©e avec la valeur initiale. Les valeurs sont parcourues dans l'ordre du conteneur. L'algorithme std::reduce fonctionne de la m√™me mani√®re que std::accumulate mais il n'y a pas de valeur initiale. Les valeurs sont parcourues dans n'importe quel ordre. C'est utile quand l'op√©ration est commutative (l'ordre des op√©randes n'a pas d'importance). Somme #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des √©l√©ments du vecteur v int sum { std::reduce(v.begin(), v.end(), [](int a, int b) { return a + b; }) }; // Ou en utilisant std::plus pour faire la somme (une fonction somme d√©j√† impl√©ment√©e dans la STL dans l'ent√™te &lt;functional&gt;) // int sum { std::reduce(v.begin(), v.end(), std::plus&lt;int&gt;()) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; }   ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#r√©sum√©","content":" La STL fournit des algorithmes et des fonctions qui permettent de simplifier la manipulation des conteneurs.La STL fournit des it√©rateurs qui permettent de parcourir les conteneurs de mani√®re g√©n√©rique.Un it√©rateur est un objet qui se comporte un peu comme un pointeur et permet de cibler un √©l√©ment dans un conteneur, de le manipuler et permet de passer d'un √©l√©ment √† l'autre.Il existe deux m√©thodes sur les conteneurs qui permettent de r√©cup√©rer un it√©rateur sur le premier √©l√©ment du conteneur et un it√©rateur sur le dernier √©l√©ment du conteneur : begin et end.La syntaxe for (element : container) utilise les it√©rateurs pour parcourir un conteneur.La d√©duction de type permet de d√©duire le type d'une variable √† partir de son initialisation. Cela se fait avec le mot cl√© auto √† la place du type de la variable.La d√©duction de type est une fonctionnalit√© tr√®s utile mais qui doit √™tre utilis√©e avec parcimonie quand cela est pertinent. Il est pr√©f√©rable de pr√©ciser le type des variables pour rendre le code plus lisible quand cela est possible.L'algorithme std::find permet de rechercher un √©l√©ment dans un conteneur.L'algorithme std::sort permet de trier un conteneur.L'algorithme std::erase permet de supprimer un √©l√©ment d'un std::vector.Les fonctions lambda permettent de d√©finir une fonction anonyme (g√©n√©ralement petite) pour personnaliser le comportement d'un algorithme.L'algorithme std::transform permet d'appliquer une fonction √† tous les √©l√©ments d'un conteneur.Les algorithmes std::accumulate et std::reduce permettent d'agr√©ger les √©l√©ments d'un conteneur pour en extraire une valeur. ","version":"Next","tagName":"h2"},{"title":"Compression et encodage de donn√©es","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression","content":"","keywords":"","version":"Next"},{"title":"Compression de donn√©es‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression-de-donn√©es","content":" La compression de donn√©es est une technique qui permet de r√©duire la taille des donn√©es. Cela permet de stocker plus de donn√©es sur un support de stockage, ou de transmettre les donn√©es plus rapidement sur un r√©seau.  C'est un domaine crucial en informatique moderne. Sans la compression de donn√©es, il serait impossible de stocker des milliers de photos sur un t√©l√©phone portable, ou de regarder des vid√©os en streaming sur Internet.  Il existe deux types de compression de donn√©es : la compression avec perte et la compression sans perte. La compression avec perte permet de r√©duire la taille des donn√©es, mais on ne garantit pas que les donn√©es d√©compress√©es seront identiques aux donn√©es d'origine. C'est le cas par exemple de la compression d'images au format JPEG o√π la perte de qualit√© est relativement ma√Ætris√©e pour cela soit le moins perceptible par l'≈ìil humain. La compression sans perte permet de retrouver les donn√©es d'origine apr√®s les avoir d√©compress√©es. C'est le cas par exemple de la compression d'images au format PNG.  note concernant le format JPEG Le format JPEG est un format de compression avec perte.Le processus de compression JPEG est assez complexe et est compos√© de plusieurs √©tapes. Certaines de ces √©tapes sont des √©tapes de compression avec perte, et d'autres sont des √©tapes de compression sans perte (dont l'encodage RLE et l'encodage de Huffman que nous allons voir dans ce cours). C'est pour cela que l'on dit que le format JPEG est un format de compression avec perte.  ","version":"Next","tagName":"h2"},{"title":"Pr√©requis‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#pr√©requis","content":" Pour ce cours, il est n√©cessaire de conna√Ætre quelques notions de base sur la repr√©sentation des donn√©es en informatique. Voici un r√©sum√© des notions √† conna√Ætre :  Un bit est la plus petite unit√© de stockage en informatique. Il ne peut prendre que deux valeurs : 0 ou 1. Un octet est un groupe de 8 bits. Il peut donc prendre 256 valeurs diff√©rentes (de 0 √† 255). Chaque donn√©e peut √™tre repr√©sent√©e par une suite de bits. Par exemple, le nombre 42 peut √™tre repr√©sent√© en binaire par la suite de bits 101010. Avec un octet, on peut repr√©senter au maximum 256 nombres diff√©rents. Un caract√®re est g√©n√©ralement cod√© sur un octet (cela peut d√©pendre de l'encodage utilis√©). Cela signifie que l'on peut repr√©senter 256 caract√®res diff√©rents. Cela inclut les lettres de l'alphabet, les chiffres, les caract√®res sp√©ciaux, etc.  ","version":"Next","tagName":"h2"},{"title":"Encodage et repr√©sentation des donn√©es‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#encodage-et-repr√©sentation-des-donn√©es","content":" Un encodage est une mani√®re de repr√©senter les donn√©es. Par exemple, on peut repr√©senter le nombre 42 de la mani√®re suivante : 101010. C'est un encodage binaire. On peut aussi repr√©senter le nombre 42 de la mani√®re suivante : 2A. C'est un encodage hexad√©cimal.  Encoder des donn√©es revient √† associer √† chaque donn√©e un code.  Dans la suite de ce cours nous allons nous int√©resser √† l'encodage binaire. C'est l'encodage utilis√© par les ordinateurs et qui permet de repr√©senter les donn√©es de mani√®re la plus compacte possible. C'est aussi l'encodage utilis√© par les algorithmes de compression.    Dans un fichier texte, chaque lettre est repr√©sent√©e par un caract√®re. Ce caract√®re est g√©n√©ralement encod√© sur un octet. Cela signifie que l'on peut repr√©senter au maximum 256 caract√®res diff√©rents. Cela inclut les lettres de l'alphabet, les chiffres, les caract√®res sp√©ciaux, etc.  Mais cela d√©pend des donn√©es du probl√®me. Cet encodage sur un octet est simplement une convention qui permet d'associer √† chaque caract√®re un code unique et d'uniformiser la mani√®re dont les caract√®res sont repr√©sent√©s (chaque caract√®re est repr√©sent√© par un octet). C'est bien pratique et flexible pour communiquer des fichiers texte entre ordinateurs.  ","version":"Next","tagName":"h2"},{"title":"Compression‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression","content":" Mais g√©n√©ralement lorsqu'il s'agit de compresser des donn√©es, les donn√©es du probl√®me sont plus simples. Par exemple on pourrait se limiter aux lettres de l'alphabet. Dans ce cas, avoir un octet pour repr√©senter chaque lettre est une perte d'espace. En effet, on pourrait se contenter de 5 bits pour repr√©senter les 26 lettres de l'alphabet. Cela permettrait de r√©duire la taille du texte de 37.5% !  info Plus g√©n√©ralement, si on se limite √† n possibilit√©s de donn√©es et que l'on souhaite utiliser un encodage avec le m√™me nombre de bits pour chaque donn√©e, il faut ‚åàlog‚Å°2(n)‚åâ\\lceil \\log_2(n) \\rceil‚åàlog2‚Äã(n)‚åâ bits pour repr√©senter chaque donn√©e. Par exemple, si on se limite aux 26 lettres de l'alphabet, il faut ‚åàlog‚Å°2(26)‚åâ=‚åà4.7‚åâ=5\\lceil \\log_2(26) \\rceil = \\lceil 4.7 \\rceil = 5‚åàlog2‚Äã(26)‚åâ=‚åà4.7‚åâ=5 bits pour repr√©senter chaque lettre.  De plus pour n'importe quelle fa√ßon d'encoder les donn√©es, il faut respecter deux r√®gles pour que l'encodage puisse √™tre d√©cod√© :  Chaque donn√©e doit √™tre associ√©e √† un code uniqueIl ne doit pas y avoir d'ambigu√Øt√© lors du d√©codage des donn√©es. Cela signifie qu'il ne faut pas associer √† une donn√©e le code 01 et √† une autre donn√©e le code 011 sinon impossible de savoir si l'on doit d√©coder les deux premiers bits 01 ou si cela faisait en fait partie du code 011. Un tel codage sans ambigu√Øt√© est appel√© pr√©fixe, nous y reviendrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"Codage par plages (Run-Length Encoding)‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-par-plages-run-length-encoding","content":" Le codage par plages est une technique de compression sans perte. Cela signifie que l'on peut retrouver les donn√©es d'origine apr√®s les avoir d√©compress√©es. Elle est tr√®s utilis√©e pour compresser des images, comme par exemple les images au format BMP ou JPEG.  Le principe du codage par plages est de tenir compte de la r√©p√©tition des donn√©es. Admettons que l'on ait un texte de 8 caract√®res, compos√© uniquement de la lettre a : aaaaaaaa. Si l'on veut stocker ce texte sur un support de stockage, il faudra donc 8 octets pour le stocker (1 octet par caract√®re).  Mais si l'on tient compte du fait que le texte est compos√© uniquement de la lettre a, on peut le repr√©senter de la mani√®re suivante : 8a.  On peut donc stocker ce texte sur un support de stockage en utilisant seulement 2 octets. Cela permet de r√©duire la taille du texte de 75% !  C'est le principe du codage par plages : on remplace une suite de caract√®res identiques par le nombre de fois que le caract√®re est r√©p√©t√©, suivi du caract√®re. Par exemple, le texte suivant aaaabbbcddddd peut √™tre repr√©sent√© par 4a3b1c5d. Pour un gain de 13-8=5 octets, soit 38% de gain.  ‚ö†Ô∏è Quand il y a peu de r√©p√©titions cependant le codage par plages peut augmenter la taille des donn√©es. Par exemple, si on applique le codage par plage sur le texte suivant abcdefgh on obtient 1a1b1c1d1e1f1g1h. Cela prend plus de place que la cha√Æne d'origine ! Dans ce cas de figure, pour minimiser cet effet, on choisit plut√¥t d'ajouter un caract√®re de contr√¥le et un nombre n pour indiquer que les n prochains caract√®res ne sont pas compress√©s. Par exemple, on pourrait utiliser le caract√®re * comme caract√®re de contr√¥le et la cha√Æne abcdefgh serait compress√©e en *8abcdefgh.  ","version":"Next","tagName":"h2"},{"title":"En pratique‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#en-pratique","content":" L'encodage RLE peut √™tre exprim√© de multiples fa√ßons en pratique pour tenir compte des propri√©t√©s des donn√©es ainsi que d'algorithmes de compression suppl√©mentaires. Cela permet de compresser les donn√©es seulement lorsque cela est n√©cessaire et de laisser la cha√Æne telle quelle lorsque la compression induit un gaspillage.  Par exemple on pourrait se donner les r√®gles suivantes :  Lorsque trois √©l√©ments ou plus se r√©p√®tent cons√©cutivement alors la m√©thode de compression RLE est utilis√©e. On ins√®re alors le nombre d'√©l√©ments r√©p√©t√©s, suivi du caract√®re r√©p√©t√©.Sinon un caract√®re de contr√¥le (*) est ins√©r√©, suivi du nombre d'√©l√©ments de la cha√Æne non compress√©e puis de cette derni√®re.  Ainsi la cha√Æne aaaabccdeeeeefgh serait compress√©e en 4a*4bccd5e*3fgh et la cha√Æne abcdefgh serait compress√©e en *8abcdefgh.  On pourrait aussi plut√¥t se dire que l'on utilise le caract√®re de contr√¥le pour indiquer que la cha√Æne est compress√©e. Dans ce cas, la cha√Æne aaaabccdeeeeefgh serait compress√©e en *4abccd*5efgh.  Enfin on pourrait aussi se dire que l'on utilise le caract√®re lui m√™me comme caract√®re de contr√¥le. de sorte que chaque fois qu'un caract√®re appara√Æt deux fois, il indique une longueur d'ex√©cution. Dans l'exemple pr√©c√©dent, cela donnerait pour la cha√Æne aaaabccdeeeeefgh l'encodage aa4bcc1dee5fgh.  ","version":"Next","tagName":"h3"},{"title":"Dans les images‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#dans-les-images","content":" Dans les images il est courant de trouver des zones de couleurs uniformes. Par exemple, une image de ciel bleu peut √™tre repr√©sent√©e par une suite de pixels bleus. Dans ce cas, le codage par plages permet de r√©duire consid√©rablement la taille de l'image.  Il existe donc des variantes pour parcourir les pixels d'une image dans un certain sens pour maximiser les zones de couleurs uniformes (ou de valeurs identiques). Par exemple, on peut parcourir les pixels de gauche √† droite, de haut en bas ou m√™me encore en zigzag.  ","version":"Next","tagName":"h3"},{"title":"Codage de Huffman‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-de-huffman","content":" Le codage de Huffman est aussi une technique de compression sans perte. C'est une technique tr√®s utilis√©e pour compresser des fichiers, comme par exemple des fichiers texte. Cette technique est utilis√©e par de nombreux formats de fichiers, comme par exemple le format JPEG pour les images.  Par exemple, si on se limite aux quatre lettres a, b, c et d (on a donc besoin seulement de 2 bits pour coder chaque lettre ). Voil√† un encodage possible :  a est cod√© sur 00b est cod√© sur 01c est cod√© sur 10d est cod√© sur 11  Le texte abbacada peut donc √™tre repr√©sent√© par 0001010010001100. C'est d√©j√† mieux que l'encodage ASCII, qui utilise 8 bits pour coder chaque lettre. On se limite √† des donn√©es particuli√®res, et on utilise un encodage plus compact.  Mais on peut faire mieux !  ","version":"Next","tagName":"h2"},{"title":"Fr√©quence d'apparition des donn√©es‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#fr√©quence-dapparition-des-donn√©es","content":" Le principe du codage de Huffman est de tenir compte de la fr√©quence d'apparition des donn√©es.  Pour un texte compos√© de 100 caract√®res (toujours avec notre alphabet de 4 lettres) il faudra donc 200 bits pour le repr√©senter.  Dans le cas de notre exemple pr√©c√©dent abbacada, on peut remarquer que la lettre a appara√Æt 4 fois, la lettre b appara√Æt 2 fois et les lettres c et d apparaissent 1 fois. On peut donc se demander si l'on ne pourrait pas utiliser un encodage diff√©rent pour chaque lettre, en tenant compte de la fr√©quence d'apparition de chaque lettre. Cela permettrait de r√©duire la taille du texte.  On pourrait donc utiliser moins d'un octet pour coder les lettres les plus utilis√©es, et plus d'un octet pour coder les lettres les moins utilis√©es. Cela permettrait de r√©duire la taille du texte.  Admettons que l'on code les lettres de la mani√®re suivante :  a est cod√© sur 0b est cod√© sur 10c est cod√© sur 110d est cod√© sur 111  remarque J'ai fait attention √† ce que chaque code soit pr√©fixe. Cela signifie qu'il n'y a pas de code qui est pr√©fixe d'un autre code. Cela permet de d√©coder les donn√©es sans ambigu√Øt√©.  Le texte abbacada peut donc √™tre repr√©sent√© par 01010011001110 (soit 14 bits). C'est mieux que l'encodage pr√©c√©dent, qui utilisait 16 bits.  Mais comment faire pour trouver le meilleur encodage possible ?  ","version":"Next","tagName":"h3"},{"title":"Arbre binaire‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#arbre-binaire","content":" Dans la suite de ce cours, nous allons utiliser un arbre binaire (strict) pour trouver l'encodage de Huffman (en fonction de la fr√©quence d'apparition des donn√©es). Mais j'aimerais d'abord vous expliquer pourquoi on utilise un arbre binaire.  remarque Dans un arbre binaire strict (ou localement complet), chaque n≈ìud a soit 0, soit 2 fils. C'est donc soit un n≈ìud interne (qui a deux fils), soit une feuille (qui n'a pas de fils).  Une propri√©t√© int√©ressante des arbres binaires est que pour chaque feuille il existe un chemin unique de la racine √† la feuille. Ce chemin va permettre d'associer un code √† chaque donn√©e. En plus d'√™tre unique, ce chemin est aussi pr√©fixe. Cela signifie que l'on ne peut pas avoir un chemin qui est pr√©fixe d'un autre chemin.  Reprenons notre exemple pr√©c√©dent avec les lettres a, b, c et d. Admettons que les quatre lettres apparaissent avec la m√™me fr√©quence.    Chaque feuille de l'arbre va permettre de repr√©senter une donn√©e, ici une lettre.  Dans cet arbre, si l'on parcourt le chemin 0-0 (successivement le fils gauche puis le fils gauche), on arrive √† la lettre a. De m√™me pour les autres feuillets. On peut donc associer √† chaque lettre un code unique :  a est cod√© sur 00b est cod√© sur 01c est cod√© sur 10d est cod√© sur 11  On retrouve bien l'encodage que l'on avait utilis√© pr√©c√©demment dans le cas de donn√©es √©quiprobables.  ","version":"Next","tagName":"h3"},{"title":"Algorithme‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#algorithme","content":" Revenons maintenant √† notre cas avec des donn√©es non √©quiprobables. Admettons que l'on ait le texte suivant : abbacada. On peut calculer la fr√©quence d'apparition de chaque lettre :  Lettre\tFr√©quencea\t4/8=0.54/8 = 0.54/8=0.5 b\t2/8=0.252/8 = 0.252/8=0.25 c\t1/8=0.1251/8 = 0.1251/8=0.125 d\t1/8=0.1251/8 = 0.1251/8=0.125  On peut remarquer qu'en utilisant une repr√©sentation en arbre binaire complet, les lettres les moins fr√©quentes seront cod√©es sur des codes plus gros (chemins les plus longs dans l'arbre) et donc sur les feuilles les plus basses de l'arbre. Les lettres les plus fr√©quentes seront cod√©es sur des codes plus petits (chemins les plus courts dans l'arbre) et donc sur les feuilles les plus hautes de l'arbre.    C'est donc en suivant cette logique que l'on va construire l'arbre binaire. On va commencer par construire un arbre binaire avec les lettres les moins fr√©quentes.  On va donc commencer par construire un arbre binaire avec les lettres c et d. On va donc cr√©er un n≈ìud cd qui va avoir deux fils c et d. On va associer √† chaque n≈ìud la somme des fr√©quences de ses fils. On va donc associer √† cd la fr√©quence 0.125 + 0.125 = 0.25.  On va consid√©rer maintenant que cd est un substitut aux lettres c et d et repr√©sente donc une seule donn√©e avec un fr√©quence de 0.25.  Je vais appeler ce regroupement de donn√©es un symbole. Un symbole est donc une donn√©e qui peut √™tre compos√©e de plusieurs donn√©es. Par exemple, le symbole cd est compos√© des donn√©es c et d.  On va donc construire un arbre binaire avec les lettres b et cd (qui sont les deux symboles les moins fr√©quents parmi a, b et cd). On va donc cr√©er un n≈ìud bcd qui va avoir deux fils b et cd.  En r√©p√©tant cette op√©ration, on va finir par n'avoir plus que deux symboles : a et bcd. Cela va conduire √† cr√©er l'arbre final qui contient tous les lettres initiales.  Cela nous donne finalement l'arbre suivant:    Ce qui peut se traduire par l'encodage suivant :  a: 0b: 10c: 110d: 111  On retrouve bien l'encodage que j'avais propos√© pr√©c√©demment.  Math√©matiquement, on peut d√©montrer que l'encodage de Huffman est optimal. Cela signifie que l'encodage de Huffman permet de compresser les donn√©es de mani√®re optimale.  remarque En pratique, pour pouvoir d√©coder les donn√©es, il faut stocker l'arbre binaire quelque part. Cela peut √™tre fait de diff√©rentes mani√®res. Par exemple, on peut stocker l'arbre binaire dans le fichier compress√©. Cela ajoute un peu de poids au fichier compress√©, mais cela permet de d√©coder les donn√©es ce qui est tout de m√™me pratique üòÉ.  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#r√©sum√©","content":" La compression de donn√©es permet de r√©duire la taille des donn√©es. Cela permet de stocker plus de donn√©es sur un support de stockage, ou de transmettre les donn√©es plus rapidement sur un r√©seau.Il existe deux types de compression de donn√©es : la compression avec perte et la compression sans perte.L'encodage est le fait d'associer √† chaque donn√©e un code.Le codage par plages (RLE) est une technique de compression sans perte et consiste √† remplacer une suite de caract√®res identiques par le nombre de fois que le caract√®re est r√©p√©t√©, suivi du caract√®re.Le codage de Huffman est une technique de compression sans perte et consiste √† tenir compte de la fr√©quence d'apparition des donn√©es. Chaque donn√©e est associ√©e √† un code unique et pr√©fixe. L'encodage de Huffman est optimal. On peut construire l'encodage de Huffman en utilisant un arbre binaire complet.Un code pr√©fixe est un code dans lequel aucun code n'est pr√©fixe d'un autre code. Cela permet de d√©coder les donn√©es sans ambigu√Øt√©.  ","version":"Next","tagName":"h2"},{"title":"Sources‚Äã","type":1,"pageTitle":"Compression et encodage de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#sources","content":" Super vid√©o sur la th√©orie de l'information et l'encodage de Huffman : https://www.youtube.com/watch?v=B3y0RsVCyrw ","version":"Next","tagName":"h2"},{"title":"Un monde de variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Les litt√©raux‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-litt√©raux","content":" Un litt√©ral est une valeur donn√©e explicitement dans le code. Il y a plusieurs types de litt√©raux en C++.  ","version":"Next","tagName":"h2"},{"title":"Les caract√®res‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-caract√®res","content":" En effet, la phrase &quot;Hello and welcome to IMAC !&quot; pr√©c√©demment rencontr√©e repr√©sente simplement du texte. C'est ce qu'on appelle une cha√Æne de caract√®res.  Qui dit cha√Æne de caract√®res dit caract√®res et il est √©galement possible de repr√©senter un unique caract√®re avec des guillemets simples '.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'a' &lt;&lt; std::endl; std::cout &lt;&lt; '7' &lt;&lt; std::endl; std::cout &lt;&lt; '?' &lt;&lt; std::endl; return 0; }   #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'H' &lt;&lt; 'e' &lt;&lt; 'l' &lt;&lt; 'l' &lt;&lt; 'o' &lt;&lt; ' ' &lt;&lt; 'I' &lt;&lt; 'M' &lt;&lt; 'A' &lt;&lt; 'C' &lt;&lt; '!' &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Les cha√Ænes de caract√®res‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-cha√Ænes-de-caract√®res","content":" On pourrait simplement se contenter de caract√®res me direz vous mais c'est un peu fastidieux et les cha√Ænes de caract√®res sont donc l√† pour nous simplifier la vie.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello IMAC!&quot; &lt;&lt; std::endl; return 0; }   remarque On diff√©rencie les caract√®res simples (utilisant des ') des chaines de caract√®res par les guillemets &quot;.  Les caract√®res sp√©ciaux‚Äã  Avez vous une id√©e de comment afficher des guillemets ?  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello &quot;IMAC&quot;!&quot; &lt;&lt; std::endl; return 0; }   Si j'essaie d'utiliser des guillemets cela ne compile pas comme dans l'exemple ci-dessus.  En effet, les guillemets permettent d√©j√† de signaler le d√©but et la fin d'une cha√Æne de caract√®res.  C'est √©galement le cas quand on essaye de repr√©senter un chemin de dossier au format Windows, par exemple, avec le chemin de fichier &quot;C:\\Program Files&quot; et on obtient une erreur du type warning: unknown escape sequence: '\\P'.  Il existe en C++ des caract√®res dits sp√©ciaux, appel√©s s√©quences d‚Äô√©chappement. Le symbole \\ permet d'indiquer au compilateur d‚Äôafficher et non interpr√©ter ces caract√®res.  Il faut donc pr√©fixer les guillemets du caract√®re \\ pour pouvoir les afficher:  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello \\&quot;IMAC\\&quot;!&quot; &lt;&lt; std::endl; return 0; }   Vous pouvez trouver tous les caract√®res d'√©chappement ici.  Voil√† les plus utiles en pratique:  \\' qui permet d‚Äôafficher un guillemet simple '\\&quot; qui permet d‚Äôafficher un guillemet double &quot;\\n qui permet d‚Äôaller √† la ligne, comme std::endl\\t qui permet de faire une tabulation horizontale\\\\ qui permet d‚Äôafficher un antislash \\  ","version":"Next","tagName":"h3"},{"title":"Les nombres‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-nombres","content":" On peut √©galement manipuler des nombres.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; -1 &lt;&lt; std::endl; std::cout &lt;&lt; 0 &lt;&lt; std::endl; std::cout &lt;&lt; 42 &lt;&lt; std::endl; return 0; }   On les appelle nombres entiers mais il est aussi possible d'utiliser des nombres √† virgule, appel√©s flottants.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 3.141593 &lt;&lt; std::endl; std::cout &lt;&lt; -1.5 &lt;&lt; std::endl; return 0; }   info On remarque que l'on peut utiliser des nombres n√©gatifs sans aucun probl√®me. On y reviendra un peu plus tard.  Concernant les nombres (entiers ou flottants) les op√©rateurs arithm√©tiques usuels sont utilisables:  Op√©rateur\tDescription+\tAddition -\tSoustraction *\tMultiplication /\tDivision %\tModulo (reste de la division)  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Op√©rateurs arithm√©tiques :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Addition: 1 + 2 = &quot; &lt;&lt; 1 + 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Soustraction: 6 - 2 = &quot; &lt;&lt; 6 - 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Multiplication: 3.14 * 2 = &quot; &lt;&lt; 3.14 * 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Division: 42.5 / 3.2 = &quot; &lt;&lt; 42.5 / 3.2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Modulo: 7 % 3 = &quot; &lt;&lt; 7 % 3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; 5 / 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5. / 2 = &quot; &lt;&lt; 5. / 2 &lt;&lt; std::endl; return 0; }   C'est aussi vrai pour les r√®gles de distributivit√©, associativit√©, commutativit√© ou priorit√© des op√©rateurs, rien de bien √©tonnant me direz vous.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Associativit√© :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 + (3 + 6) = &quot; &lt;&lt; 2 + (3 + 6) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(2 + 3) + 6 = &quot; &lt;&lt; (2 + 3) + 6 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distributivit√© :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 * (4 + 3) = &quot; &lt;&lt; 2 * (4 + 3) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Priorit√© des op√©rateurs :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;42 * 3 + (2 + 8 / 4) = &quot; &lt;&lt; 42 * 3 + (2 + 8 / 4) &lt;&lt; std::endl; return 0; }   attention Ne remarquez vous pas quelque chose d'√©tonnant ? 5 / 2 et 5. / 2 ne donne pas la m√™me chose‚ÄØ? La raison est que pour le C++, si on fait une op√©ration sur deux nombres entiers, le r√©sultat doit rester un nombre entier. Si l‚Äôon veut que le r√©sultat soit un flottant, il faut qu‚Äôau moins un des deux nombres soit un flottant. C'est pour cela d'ailleurs que mon exemple 3.14 * 2 fonctionne bien car au moins un des deux nombres est un flottant et le r√©sultat est donc un flottant √©galement.  Pour r√©sumer, toutes ces valeurs √©crites dans notre code s'appellent des litt√©raux.  Les variables  Les litt√©raux c'est sympa mais comment faire si l'on veut se resservir d'un r√©sultat pr√©c√©demment calcul√© ? C'est avec les variables que l'on va pouvoir faire √ßa !  C‚Äôest un concept commun √† beaucoup de langages de programmation qui permet de stocker une valeur et de lui associer un nom, afin de pouvoir l'identifier et la manipuler facilement.  Nous ne rentrons pas dans le d√©tail de comment sont stock√©es ces valeurs dans la m√©moire de l'ordinateur car ce n'est pas le propos ici.  ","version":"Next","tagName":"h3"},{"title":"Cr√©er une variable‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cr√©er-une-variable","content":" Pour d√©clarer une variable en C++, il faut trois choses:  Pr√©ciser d'abord son type, qui indique ce que la variable va stocker (un entier, un flottant, une cha√Æne de caract√®res, etc)Un nom qui permet d'identifier la variableEnfin, la valeur √† stocker dans notre variable. Ceci se fait en mettant la valeur entre accolades   #include &lt;iostream&gt; #include &lt;string&gt; int main() { int number { 42 }; char letter { 'A' }; float pi { 3.1415927f }; double pi_double { 1415926535897931 }; std::string text { &quot;Hello IMAC!&quot; }; return 0; }   Syntaxe h√©rit√©e Il existe √©galement une syntaxe alternative, de la forme type nom = valeur;. Essayez, vous verrez que √ßa marche. #include &lt;iostream&gt; int main() { int number { 42 }; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0; } Cette syntaxe est h√©rit√©e du C et est toujours valable en C++. Dans ce cours je vous conseille fortement d'utiliser la syntaxe dite moderne utilisant les accolades . De plus la syntaxe avec le symbole = a d'autres subtilit√©s et peut parfois induire en erreur (des conversions implicites non desir√©es par exemple), c'est pourquoi nous ne l'utiliserons pas dans la majorit√© des cas. Ne soyez pas surpris si vous rencontrez cette syntaxe, elle est encore tr√®s utilis√©e et je l'ai moi m√™me utilis√© pendant tr√®s longtemps.  ","version":"Next","tagName":"h2"},{"title":"Les types‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-types","content":" Dans l'exemple pr√©c√©dent j'ai utilis√© divers mots-cl√©s qui font chacun r√©f√©rence √† un type de variable sp√©cifique:  Pour les nombres entiers c'est le mot-cl√© int, (abr√©viation de l‚Äôanglais integer signifiant nombre entier). Gr√¢ce √† ce type, on peut stocker des entiers n√©gatifs ou positifs.Pour les flottants(les nombres √† virgule), nous avons le mot-cl√© &quot;float&quot;, (abr√©viation de floating point numbers en anglais). Il existe aussi le mot cl√© &quot;double&quot; pour stocker des nombres √† virgule plus pr√©cis quand c'est n√©cessaire.  remarque Il est recommand√© de faire la distinction entre float et double en ajoutant le suffixe f √† la fin du nombre: #include &lt;iostream&gt; int main() { float pi { 3.141592f }; double price { 4.14 }; return 0; } Pour l'instant √ßa n'a pas beaucoup d'importance mais essayez de le mettre car c'est une bonne pratique et a son importance avec des concepts plus avanc√©s en C++.  Pour les caract√®res, nous avons char.Pour les cha√Ænes de caract√®res nous avons std::string.  Cha√Æne de caract√®res Pour les cha√Ænes de caract√®res c'est l√©g√®rement diff√©rent, nous avons le type std::string. Ce type est particulier car il n‚Äôexiste pas nativement en C++. Pour ceux qui sont attentifs √† std:: c'est un type issu de la biblioth√®que standard dont j'ai d√©j√† parl√©. Ce sont des programmeurs experts qui ont cod√© ce type afin de manipuler ais√©ment des cha√Ænes de caract√®res. Afin de pouvoir manipuler des std::string, il faut donc inclure le bon fichier, ce que l‚Äôon fait gr√¢ce √† la ligne #include &lt;string&gt;. #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string hello { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; hello &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des pr√©fixes modificateurs‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-pr√©fixes-modificateurs","content":" Il est possible d'utiliser des mot-cl√©s modificateurs sur les entiers (type int) devant le type de la variable pour alt√©rer son fonctionnement (et implicitement la fa√ßon dont ils sont stock√©s en m√©moire).  signed: permet d'indiquer que le nombre est sign√© (+ ou -) unsigned: permet d'indiquer que le nombre n'a pas de signe (une valeur absolue ou une taille) short: le nombre sera stock√© sur 16 bits minimum (dans le cas des petits nombres) long: le nombre sera stock√© sur 32 bits minimum (dans le cas de plus grands nombres) long long: le nombre sera stock√© sur 64 bits minimum  remarque Ces pr√©fixes sont une indication pour le compilateur. Cela donne donc un minimum mais le compilateur est libre de choisir une repr√©sentation m√©moire s'il estime que c'est mieux ou plus adapt√© √† un ordinateur sp√©cifique. Pour garantir une taille tr√®s pr√©cise en m√©moire il existe depuis le C++11 des entiers de taille fix√©e (Fixed width integer types en anglais) disponible dans le fichier √† inclure &lt; cstdint &gt;. On retrouve donc par exemple int16_t pour un entier sur 16 bits ou uint32_t pour repr√©senter un entier non sign√© de 32 bits. Une liste exhaustive est disponible ici. C'est vraiment un usage tr√®s sp√©cifique et nous allons pas du tout nous en servir.  ","version":"Next","tagName":"h2"},{"title":"Comportement ind√©termin√©‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#comportement-ind√©termin√©","content":" Mais qu'est ce qui se passe si je ne pr√©cise rien comme valeur pour ma variable (sans les accolades ) ?  int my_varaible;   C'est ce qu'on appelle un comportement ind√©termin√©, en anglais &quot;undefined behaviour&quot;. La variable se voit attribu√©e une valeur ind√©termin√©e. Cela peut √™tre 0 comme 142857, on ne peut pas le pr√©voir.  C'est donc quelque chose qu'il faut absolument √©viter !  remarque Le compilateur l'autorise pour des questions d'optimisation et d'h√©ritage avec le C. Certains warnings de compilation indique ces erreurs.  Il faut toujours initialiser ses variables.  Valeur par d√©faut Si on ajoute les accolades mais sans pr√©ciser de valeur, notre variable va contenir une valeur par d√©faut. Ce sera par exemple une cha√Æne de caract√®res vide (&quot;&quot;) pour les std::string ou un 0 dans le cas d'un entier. Je vous laisse essayer: #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string default_string { }; std::cout &lt;&lt; default_string &lt;&lt; std::endl; // &quot;&quot; int default_int { }; std::cout &lt;&lt; default_int &lt;&lt; std::endl; // 0 float default_float { }; std::cout &lt;&lt; default_float &lt;&lt; std::endl; // 0.0f return 0; } Pour commencer, nous √©crirons toujours les valeurs explicitement pour √©viter de mauvaise surprise... Plus tard, avec un peu plus de pratique, vous aurez la libert√© d'utiliser l‚Äôinitialisation par d√©faut, en connaissance de cause.  ","version":"Next","tagName":"h2"},{"title":"Quelques r√®gles de nommage‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-r√®gles-de-nommage","content":" Les noms des variables sont tout de m√™me soumis √† quelques r√®gles de nommage.  Premi√®rement, de son origine am√©ricaine, le C++ n‚Äôautorise que les 26 lettres de l‚Äôalphabet anglais (plus les chiffres et l‚Äôunderscore _), on peut donc malheureusement dire adieu √† nos jolis accents fran√ßais. Les espaces et les signes de ponctuation sont aussi interdits (', ?, etc). Il ne peut pas commencer par un chiffre, c‚Äôest interdit. L'usage de l'underscore _ au d√©but, bien que possible, est conventionnellement utilis√© dans un cadre sp√©cifique et je vous d√©conseille donc de l'utiliser pour commencer. Enfin, il n'est pas possible d'utiliser un mot-cl√© du C++ comme nom de variable. Par exemple, il est interdit de d√©clarer une variable s‚Äôappelant int.  Quelques exemples int main() { int variable42 { 42 }; int 42variable { 42 }; // Erreur : ne peut pas commencer par un chiffre. int my_variable { 0 }; int my variable { 0 }; // Erreur : espace interdit. float result { 2.71f }; float return { 2.71f }; // Erreur : mot-cl√© r√©serv√© par le C++ return 0; }   ","version":"Next","tagName":"h2"},{"title":"Un joli petit nom‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#un-joli-petit-nom","content":" Au-del√† des r√®gles de nommage, trouver un nom adapt√© √† une variable est un casse t√™te que m√™me les programmeurs exp√©riment√©s rencontrent.  En effet, respecter les r√®gles ne suffit pas √† bien nommer une variable. Le nom d'une variable permet de l'identifier, de comprendre ce qu'elle stocke et comment on la manipule.  remarque Le nom d'une variable est destin√© √† un lecteur humain. On choisit un nom de variable pour qu'il soit compr√©hensible pour nous et nos futurs lecteurs, amis, coll√®gues, etc Une fois le code compil√©, l'ordinateur ne fait aucune diff√©rence entre un nom ou un autre.  ","version":"Next","tagName":"h3"},{"title":"Quelques mauvais exemples‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-mauvais-exemples","content":" lpi: Un acronyme ? Que signifie t'il ?value: Que stocke-t-elle‚ÄØ? Dans quel contexte‚ÄØ? Pourquoi existe-t-elle‚ÄØ?multiplication_of_two_by_sqrt_of_pi: Clair mais un peu trop long.dIsTanCe: Court et compr√©hensible mais les majuscules / minuscules peuvent rendre la lecture moins facile.qsqffqedfqzdjzqoid: S√ªrement un chat qui est pass√© sur mon clavier.  Avec l'exp√©rience et le temps vous arriverez √† trouver plus facilement des noms clairs et simples.  Je vous demande d√®s maintenant de faire quelques efforts pour r√©fl√©chir aux noms des variables. Cela peut vous sembler peu important, jusqu'au jour o√π vous perdrez une semaine de travail √† comprendre ce que votre programme ou variable est suppos√©e faire.  ","version":"Next","tagName":"h3"},{"title":"Enum: Un type suppl√©mentaire‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#enum-un-type-suppl√©mentaire","content":" Vous allez s√ªrement le d√©couvrir en pratiquant mais parfois on souhaite stocker un nombre limit√© de possibilit√©s.  Par exemple les points cardinaux (Nord, Sud, Est, Ouest), les saisons (√©t√©, printemps, automne, hiver), les jours de la semaine, etc  On pourrait bien associer un entier √† chaque possibilit√© (c'est une pratique tr√®s r√©pandue en C) mais ce n'est pas la meilleure fa√ßon de faire. Un entier peut stocker des valeurs n√©gatives ou alors √™tre sup√©rieur au nombre de possibilit√©s voulues ce qui n'a pas vraiment de sens.  C'est l√† qu'entre en jeu les enum (de l'anglais Enumeration).  On le d√©clare en utilisant le pr√©fixe enum class puis le nom de notre √©num√©ration suivis des valeurs possibles entre accolades.  Un exemple enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; return 0; }   remarque On utilise ici aussi la syntaxe avec :: pour signifier l'appartenance de la valeur √† l'enum (de la m√™me fa√ßon qu'avec la biblioth√®que standard comme avec std::string).  repr√©sentation en m√©moire Une enum est stock√©e en m√©moire comme un entier. Chaque valeur de l'enum est associ√©e √† un entier, commen√ßant par 0 pour la premi√®re valeur, 1 pour la deuxi√®me, etc. Il est possible de changer cette valeur en pr√©cisant un entier apr√®s le nom de la valeur mais ce n'est pas une pratique recommand√©e. enum class Season { Spring = 42, Summer, Autumn, Winter, }; Nous verrons un exemple dans la partie conversion de type (cast) pour voir comment r√©cup√©rer la valeur enti√®re associ√©e √† une valeur d'une enum et vice versa.  attention Mais pourquoi le mot cl√© class ici ? Il est √©galement possible de l'omettre mais cette syntaxe est un autre &quot;type&quot; d'enum h√©rit√© du C qui a de nombreux inconv√©nients: Il n'est pas possible de d√©clarer deux enums utilisant la m√™me valeur (mais dans un contexte diff√©rent).D√©clarer une variable ayant le m√™me nom qu'une valeur d'un enum peut avoir des comportements impr√©vus. #include &lt;iostream&gt; enum PrimaryColor { Red, Yellow, Blue }; enum EyesColor { Brown, Hazel, Blue, // Erreur de compilation ici car la valeur Blue est aussi utilis√©e dans l'enum PrimaryColor Green, Grey, Amber }; int main() { // Ici Red fait r√©f√©rence √† la valeur dans l'enum PrimaryColor std::cout &lt;&lt; Red &lt;&lt; std::endl; int Red { 35 }; // Maintenant, bien que la ligne soit identique, Red fait r√©f√©rence √† la variable cr√©√©e ci-dessus std::cout &lt;&lt; Red &lt;&lt; std::endl; return 0; } On parle de &quot;Scoped enumerations&quot; avec enum class (autrement dit ayant une port√©e limit√©e pour √©viter les collisions de valeurs). Pour faire simple on √©crira syst√©matiquement enum class en C++ moderne pour s'√©viter des probl√®mes.  Enfin, il n‚Äôexiste pas de moyen simple de convertir une enum en cha√Æne de caract√®res. C'est un probl√®me r√©current en C++ et il existe plusieurs solutions plus ou moins √©l√©gantes pour le faire. Nous en verrons une plus tard au deuxi√®me semestre (ici).  ","version":"Next","tagName":"h2"},{"title":"Des op√©rateurs pour manipuler nos variables‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-op√©rateurs-pour-manipuler-nos-variables","content":" Il n'est pas seulement possible d'afficher nos variables (via std::cout), il est aussi possible de faire des op√©rations dessus.  Pour cela nous allons utiliser des op√©rateurs.  Les op√©rateurs sont des symboles qui permettent de manipuler des variables, c'est-√†-dire effectuer des op√©rations, les √©valuer, etc.  Il y a principalement deux cat√©gories d'op√©rateurs:  Les op√©rateurs binaires qui utilisent deux valeurs pour en produire une nouvelle (comme a + b par exemple)Les op√©rateurs unaires qui s'appliquent sur une valeur pour en produire une nouvelle.  Nous avons par exemple vu pr√©c√©demment les op√©rateurs arithm√©tiques (+, -, *, / et %) sur les nombres. Ces op√©rateurs sont binaires.  ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'affectation‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#op√©rateurs-daffectation","content":" Pour attribuer une nouvelle valeur √† une variable, on utilise l‚Äôop√©rateur d‚Äôaffectation =, pr√©c√©d√© du nom de la variable et suivi de la valeur √† affecter‚ÄØ: nom = valeur;.  #include &lt;iostream&gt; int main() { int x { 0 }; std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3; std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }   C++ s'occupe en premier lieu de tout ce qui se trouve √† droite du signe =. On peut donc utiliser la valeur d'une variable pour faire un calcul avant de l'assigner √† cette m√™me variable.    Dans le cas o√π l'on veut effectuer une op√©ration sur une variable et assigner le r√©sultat √† cette m√™me variable il existe des op√©rateurs binaires nomm√©s op√©rateurs d'assignation compos√©s.  On retrouve principalement ces op√©rateurs compos√©es avec les op√©rateurs arithm√©tiques:+=, -=, *=, /= et %=  int integer { 42 }; // √©quivalent √† √©crire &quot;integer = integer + 3&quot; integer += 3; integer -= 1; integer *= 4; integer /= 2; integer %= 2;   Il existe d'autres op√©rateurs d'affectation compos√©s mais nous les d√©couvrirons le moment venu.  ","version":"Next","tagName":"h3"},{"title":"Op√©rateurs d'incr√©mentation‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#op√©rateurs-dincr√©mentation","content":" Cela va m√™me plus loin, il existe un raccourci suppl√©mentaire lorsque l'on souhaite ajouter ou soustraire 1 √† un nombre. On parle d'incr√©mentation et de d√©cr√©mentation.  a++ ou ++a pour incr√©menter de 1 la valeur de la variable a.a-- ou --a pour d√©cr√©menter de 1 la valeur de la variable a.  info Les deux syntaxes sont quasiment √©quivalentes, il y a une petite diff√©rence lorsque l'on souhaite utiliser le r√©sultat de l'incr√©mentation: On parle de Post-incr√©mentation avec a++: Cette forme signifie que la variable a est d'abord utilis√©e, puis elle est incr√©ment√©e de 1. Cela signifie que l'effet de l'incr√©mentation ne sera visible qu'apr√®s l'√©valuation de l'expression qui contient a++. int a { 5 }; int result { a++ }; // result prend la valeur de a (5) puis a est incr√©ment√© √† 6. // Maintenant, a vaut 6 et result vaut 5. On parle de Pr√©-incr√©mentation avec ++a: Cette forme signifie que la variable a est d'abord incr√©ment√©e, puis cette nouvelle valeur est utilis√©e. Cela signifie que l'effet de l'incr√©mentation sera visible imm√©diatement dans l'expression qui contient ++a. int a { 5 }; int result { ++a }; // a est incr√©ment√© √† 6, puis result prend la nouvelle valeur de a (6). // Maintenant, a et result valent tous les deux 6. En r√©sum√©, la seule diff√©rence entre les deux formes r√©side dans le moment o√π l'incr√©mentation est r√©alis√©e (avant ou apr√®s l'utilisation de sa valeur actuelle). Lorsque vous voulez r√©cup√©rer le r√©sultat de l'incr√©mentation, assurez-vous de choisir celle qui convient le mieux √† votre situation pour obtenir le comportement souhait√© dans votre programme. Dans la plupart des cas, je vous recommande tout simplement de ne pas l'utiliser! C'est une grosse source d‚Äôerreurs. Faites plut√¥t: int a { 5 }; a++; int result { a }; ou int a { 5 }; int result { a }; a++; Aussi, je recommandes m√™me d‚Äôutiliser a += 1 √† la place. Comme √ßa pas de surprise on est certain de ce qu‚Äôon fait. int a { 5 }; a += 1; int result { a };   ","version":"Next","tagName":"h3"},{"title":"Quelques exemples‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-exemples","content":" #include &lt;iostream&gt; int main() { int variable { 42 }; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je donne une nouvelle valeur √† ma variable variable = 2 + (3 * 9); std::cout &lt;&lt; variable &lt;&lt; std::endl; // J'utilise la valeur de ma variable pour un calcul et r√©affecte le r√©sultat √† la m√™me variable variable = variable + 7; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je me sers de ma variable pour en cr√©er une nouvelle int other_value { variable * 3 }; std::cout &lt;&lt; other_value &lt;&lt; std::endl; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux utiliser d'autres variables √©galement variable = other_value - 1; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux incr√©menter ma variable de deux fa√ßons variable += 1; variable++; std::cout &lt;&lt; variable &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Variables constantes‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#variables-constantes","content":" Il existe enfin un dernier mot cl√© important, le mot cl√© const. Il va permettre, comme son nom l'indique, de rendre constant une variable et ainsi emp√™cher toute modification de celle-ci. Si l‚Äôon essaye de modifier une constante, on obtient une erreur de compilation.  int main() { float const gravity { 9.80665f }; gravity = 9.0f; // Erreur de compilation return 0; }   Pour l'instant cela ne va pas √™tre tr√®s utile. Mais c'est une tr√®s (tr√®s (tr√®s)) bonne pratique et permet de prot√©ger des variables et donner des contraintes fortes √† notre code. Je vais l'utiliser r√©guli√®rement dans des exemples et on d√©couvrira ensemble plus tard o√π cela prendra vraiment toute son importance d'utiliser des const d√®s que possible.  info Vous verrez souvent des codes qui inversent l‚Äôordre de const et √©crivent const float variable ;. C'est tout √† fait possible car le const respecte la r√®gle suivante : Il s‚Äôapplique √† ce qui est √† sa gauche, sauf s‚Äôil n‚Äôy a rien, auquel cas il s‚Äôapplique √† ce qu‚Äôil y a √† droite. Je vais le placer √† droite dans la suite de ce cours car c'est le fonctionnement voulu initialement du const. C'est une question de pr√©f√©rence et de lisibilit√©, vous √™tes libre de choisir ce que vous pr√©f√©rez.  ","version":"Next","tagName":"h2"},{"title":"Entr√©e / Sortie‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#entr√©e--sortie","content":" Jusque l√†, nous avons r√©guli√®rement rencontr√© std::cout qui nous permet d'afficher des caract√®res.  Il est √©galement possible de faire l'inverse en manipulant ce qu'on appelle une entr√©e.  Gr√¢ce aux variables, il est possible de demander des informations √† l‚Äôutilisateur et de stocker cette information afin d'en faire quelque chose.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Entre ton age : &quot; &lt;&lt; std::endl; int age { 0 }; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Tu as &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl; return 0; }   Ici std::cin est tr√®s similaire √† std::cout et signifie &quot;character input&quot;.  Il faut le pr√©fixer par std::, car lui aussi appartient √† la biblioth√®que standard. De plus, on utilise ici les chevrons &gt;&gt; dans le sens inverse pour signifier que l'on &quot;ins√®re&quot;&quot; ce qui vient de notre entr√©e pour le stocker dans notre variable.  attention Dans notre cas le C++ comprend que c'est un nombre et le convertit en entier (int). Mais que se passe t'il si l'on entre des lettres ? Dans ce cas de figure la variable (age ici) n'est pas modifi√©e. Mais pas seulement, std::cin n'arrive pas √† convertir notre entr√©e, il passe dans un √©tat invalide, m√©morise tous les caract√®res invalides et toutes les utilisations suivantes de std::cin seront √©rron√©es. Nous verrons plus tard comment g√©rer ce cas de figure et d√©tecter si une erreur survient.  ","version":"Next","tagName":"h2"},{"title":"Cast‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast","content":" Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast.  Il existe plusieurs types de cast dont le plus courant est le cast statique (static_cast).  static_cast permet de convertir un type en un autre type. Par exemple, un int en float. C'est un cast s√ªr car il fait des v√©rifications. Il est √† utiliser par d√©faut pour les conversions de type.  #include &lt;iostream&gt; int main() { int integer {42}; float floating {3.14f}; float floatingFromInteger {static_cast&lt;float&gt;(integer)}; int integerFromFloating {static_cast&lt;int&gt;(floating)}; std::cout &lt;&lt; &quot;integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // static_cast std::cout &lt;&lt; &quot;static_cast&lt;float&gt;(integer): &quot; &lt;&lt; floatingFromInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;static_cast&lt;int&gt;(floating): &quot; &lt;&lt; integerFromFloating &lt;&lt; std::endl; return 0; }   integer: 42 floating: 3.14 static_cast&lt;float&gt;(integer): 42 static_cast&lt;int&gt;(floating): 3   remarque Il existe √©galement un cast h√©rit√© du C qui s'effectue avec des parenth√®ses ( ( ) ) autour du type vers lequel on veut caster devant la variable √† caster. int integer {42}; float floating {3.14f}; float floatingFromInteger {(float)integer}; int integerFromFloating {(int)floating}; Il est √† √©viter car il est dangereux et fonctionne de diff√©rentes mani√®res en fonction des cas sans v√©rifications et peut donc provoquer des erreurs ou comportements inattendus.  ","version":"Next","tagName":"h2"},{"title":"Cast et enum‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast-et-enum","content":" Il est √©galement possible de caster une valeur d'une enum en entier et vice versa. C'est une pratique courante pour afficher et manipuler une valeur d'une enum.  #include &lt;iostream&gt; enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; int current_season_int { static_cast&lt;int&gt;(current_season) }; std::cout &lt;&lt; current_season_int &lt;&lt; std::endl; int season_int { 2 }; Season season { static_cast&lt;Season&gt;(season_int) }; std::cout &lt;&lt; static_cast&lt;int&gt;(season) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"En r√©sum√©‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#en-r√©sum√©","content":" Nous venons de d√©couvrir les variables en C++. C'est la base de tout programme informatique, ce qui permet d'√©changer et de manipuler des informations.  C++ nous permet de manipuler diff√©rents types de donn√©es: des caract√®res simples (char)des cha√Ænes de caract√®res (via std::string)des nombres entiers (int)des nombres r√©els (float ou double)Des √©num√©rations (avec enum class) Il est possible d'utiliser toutes les op√©rations usuelles qui existent sur les nombres. Les variables nous permettent de stocker des valeurs et d'y associer un nom (en tenant compte de certaines r√®gles de nommage). Il est important de choisir un nom de variable qui a du sens et le plus simple possible. Il est possible de sp√©cifier qu'une variable est non modifiable avec le mot-cl√© const. On utilise des op√©rateurs pour manipuler nos variables. Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast. Le plus courant est le cast statique (static_cast). Il fait des v√©rifications et est donc plus s√ªr. Il est √† utiliser par d√©faut pour les conversions de type. Nous pouvons demander des informations √† l‚Äôutilisateur gr√¢ce √† std::cin. ","version":"Next","tagName":"h2"},{"title":"Structures de donn√©es","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Pile - std::stack‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#pile---stdstack","content":" Une pile est une structure de donn√©es qui permet de stocker des √©l√©ments de fa√ßon √† ce que le dernier √©l√©ment ajout√© soit le premier √† √™tre retir√©. On parle de structure de donn√©es LIFO (Last In First Out).  PushPopStack  La classe std::stack permet de repr√©senter une pile. Elle est d√©finie dans la biblioth√®que &lt;stack&gt;.  On utilise la m√©thode push pour ajouter un √©l√©ment au sommet de la pile et la m√©thode pop pour retirer l'√©l√©ment au sommet de la pile.  Elle s'utilise de la m√™me fa√ßon que d'autres conteneurs de la biblioth√®que standard.  #include &lt;stack&gt; #include &lt;iostream&gt; int main() { std::stack&lt;int&gt; stack; stack.push(1); stack.push(2); stack.push(3); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 3 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 2 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 1 stack.pop(); }   ","version":"Next","tagName":"h3"},{"title":"File - std::queue‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#file---stdqueue","content":" Une file est une structure de donn√©es qui permet de stocker des √©l√©ments de fa√ßon √† ce que le premier √©l√©ment ajout√© soit le premier √† √™tre retir√©. On parle de structure de donn√©es FIFO (First In First Out).  DequeueEnqueueQueue BackQueue FrontQueue  La classe std::queue permet de repr√©senter une file. Elle est d√©finie dans la biblioth√®que &lt;queue&gt;.  On utilise la m√©thode push pour ajouter un √©l√©ment √† la fin de la file et la m√©thode pop pour retirer l'√©l√©ment au d√©but de la file.  #include &lt;queue&gt; #include &lt;iostream&gt; int main() { std::queue&lt;int&gt; queue; queue.push(1); queue.push(2); queue.push(3); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 1 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 2 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 3 queue.pop(); }   ","version":"Next","tagName":"h3"},{"title":"std::pair ‚Äî Un conteneur de paires d'√©l√©ments‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdpair--un-conteneur-de-paires-d√©l√©ments","content":" La classe std::pair (d√©finie dans la biblioth√®que &lt;utility&gt;) permet de repr√©senter une paire d'√©l√©ments de types diff√©rents.  On peut acc√©der aux √©l√©ments de la paire avec les attributs first et second.  ","version":"Next","tagName":"h2"},{"title":"D√©finition d'une paire‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#d√©finition-dune-paire","content":" Pour d√©finir une paire, on peut utiliser la fonction std::make_pair ou assigner les valeurs directement aux attributs first et second.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 { std::make_pair(3, 4) }; std::pair&lt;int, int&gt; p3 {}; p3.first = 5; p3.second = 6; std::cout &lt;&lt; p1.first &lt;&lt; &quot; &quot; &lt;&lt; p1.second &lt;&lt; std::endl; // Affiche 1 2 std::cout &lt;&lt; p2.first &lt;&lt; &quot; &quot; &lt;&lt; p2.second &lt;&lt; std::endl; // Affiche 3 4 std::cout &lt;&lt; p3.first &lt;&lt; &quot; &quot; &lt;&lt; p3.second &lt;&lt; std::endl; // Affiche 5 6 }   Si rien n'est sp√©cifi√©, les attributs first et second sont initialis√©s avec des valeurs par d√©faut.  info La fonction std::make_pair permet d'expliciter le type de la paire. C'est utile dans certains cas o√π le type de la paire ne peut pas √™tre d√©duit automatiquement.  ","version":"Next","tagName":"h3"},{"title":"Comparaison de paires‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#comparaison-de-paires","content":" La paire int√®gre √©galement un op√©rateur de comparaison qui compare les √©l√©ments de la paire dans l'ordre lexicographique.  Ordre lexicographique L'ordre lexicographique est comparable √† l'ordre alphab√©tique. Si l'on se limite aux mots et lettres c'est l'ordre utilis√© pour comparer les mots dans un dictionnaire. On compare les premi√®res lettres des mots. Si les premi√®res lettres sont √©gales, on compare les secondes lettres, etc. Cela peut √™tre √©tendu √† des √©l√©ments plus complexes comme des nombres. On compare les premiers √©l√©ments. Si les premiers √©l√©ments sont √©gaux, on compare les seconds √©l√©ments, etc.  Dans le cas des paires, on compare les premiers √©l√©ments. Si les premiers √©l√©ments sont √©gaux, on compare les seconds √©l√©ments.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 {1, 3}; std::pair&lt;int, int&gt; p3 {2, 1}; std::pair&lt;int, int&gt; p4 {1, 2}; std::cout &lt;&lt; (p1 &lt; p2) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p3) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p4) &lt;&lt; std::endl; // Affiche 0 }   ","version":"Next","tagName":"h3"},{"title":"Utilisation de std::pair‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#utilisation-de-stdpair","content":" On peut se servir de la classe std::pair et de son ordre lexicographique pour trier des √©l√©ments dans un tableau.  #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;std::pair&lt;int, int&gt;&gt; pairs { {1, 2}, {3, 4}, {1, 3}, {2, 1}, {1, 1} }; std::sort(pairs.begin(), pairs.end()); for (auto const&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl; } }   Dans cet exemple, on trie les paires dans l'ordre lexicographique sur les premiers √©l√©ments. Si les premiers √©l√©ments sont √©gaux, on trie les paires dans l'ordre lexicographique sur les seconds √©l√©ments.  Ce qui donne le r√©sultat suivant :  1 1 1 2 1 3 2 1 3 4     Cela peut aussi √™tre utile pour retourner plusieurs valeurs dans une fonction.  #include &lt;utility&gt; #include &lt;vector&gt; std::pair&lt;float, float&gt; minMax(std::vector&lt;float&gt; const&amp; array) { float min {array[0]}; float max {array[0]}; for (float const&amp; value: array) { if (value &lt; min) { min = value; } if (value &gt; max) { max = value; } } return std::make_pair(min, max); }   info La classe std::pair est √©galement utilis√©e par d'autres conteneurs de la biblioth√®que standard comme std::map que nous verrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"std::tuple ‚Äî Un conteneur de donn√©es h√©t√©rog√®nes‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdtuple--un-conteneur-de-donn√©es-h√©t√©rog√®nes","content":" La classe std::tuple (d√©finie dans la biblioth√®que &lt;tuple&gt;) permet de repr√©senter un ensemble de donn√©es h√©t√©rog√®nes  C'est similaire √† std::pair mais on peut stocker plus de deux √©l√©ments.  On peut acc√©der aux √©l√©ments de la paire avec la fonction std::get.  Exemple :   #include &lt;tuple&gt; #include &lt;iostream&gt; int main() { std::tuple&lt;int, float, std::string&gt; t {1, 3.14f, &quot;Hello&quot;}; std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl; // Affiche 3.14 std::cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl; // Affiche Hello }   attention On privil√©gie l'utilisation de structures de donn√©es avec des membres explicites plut√¥t que des tuples ou des pairs quand c'est pertinent. Nomm√©s les membres d'une structure permet de rendre le code plus lisible et plus facile √† maintenir. Les tuples et pair sont utiles dans certains cas, mais il faut faire attention √† ne pas en abuser.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#pour-aller-plus-loin","content":" std::variant La classe std::variant (d√©finie dans la biblioth√®que &lt;variant&gt;) permet de stocker un √©l√©ment parmi un ensemble d'√©l√©ments possibles. Similaires aux aux enums, mais avec la possibilit√© de stocker des types diff√©rents. #include &lt;variant&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::variant&lt;int, float, std::string&gt; v {}; v = 42; // v contient un int v = 3.14f; // v contient un float v = &quot;Hello&quot;; // v contient une std::string if (std::holds_alternative&lt;int&gt;(v)) { std::cout &lt;&lt; &quot;v contient un int dont la valeur est &quot; &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;float&gt;(v)) { std::cout &lt;&lt; &quot;v contient un float dont la valeur est &quot; &lt;&lt; std::get&lt;float&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;std::string&gt;(v)) { std::cout &lt;&lt; &quot;v contient une std::string dont la valeur est &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl; }   std::optional La classe std::optional (d√©finie dans la biblioth√®que &lt;optional&gt;) permet de stocker un √©l√©ment optionnel. C'est-√†-dire un √©l√©ment qui peut √™tre pr√©sent ou non. Pour repr√©senter un √©l√©ment optionnel qui ne contient rien, on peut utiliser la valeur std::nullopt. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::optional&lt;int&gt; o {}; o = 42; // o contient un int if (o.has_value()) { std::cout &lt;&lt; &quot;o contient un int dont la valeur est &quot; &lt;&lt; o.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;o ne contient rien&quot; &lt;&lt; std::endl; } C'est un objet qui peut √™tre utile pour repr√©senter des valeurs optionnelles, comme par exemple le r√©sultat d'une recherche dans un tableau ou un param√®tre optionnel d'une fonction. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; // Recherche la valeur dans le tableau et retourne son index si elle est trouv√©e sous forme d'un std::optional std::optional&lt;size_t&gt; find(std::vector&lt;int&gt; const&amp; array, int value) { for (size_t i {0}; i &lt; array.size(); ++i) { if (array[i] == value) { return i; } } return std::nullopt; } int main() { std::vector&lt;int&gt; array {1, 2, 3, 4, 5}; std::optional&lt;size_t&gt; index {find(array, 3)}; if (index.has_value()) { std::cout &lt;&lt; &quot;3 se trouve √† l'index &quot; &lt;&lt; index.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;3 ne se trouve pas dans le tableau&quot; &lt;&lt; std::endl; } } info Cela permet de ne pas avoir √† utiliser des valeurs sp√©ciales pour repr√©senter l'absence de valeur comme par exemple -1 pour un index comme on retrouve souvent en C.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Structures de donn√©es","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#r√©sum√©","content":" Les piles et les files sont des structures de donn√©es qui permettent de stocker des √©l√©ments de fa√ßon √† ce que le dernier √©l√©ment ajout√© soit le premier √† √™tre retir√© (LIFO) ou le premier √©l√©ment ajout√© soit le premier √† √™tre retir√© (FIFO). On utilise les classes std::stack et std::queue pour les repr√©senter dans la biblioth√®que standard de C++. La classe std::pair (&lt;utility&gt;) permet de repr√©senter une paire d'√©l√©ments de types diff√©rents. C'est une classe qui est utilis√©e par d'autres conteneurs de la biblioth√®que standard comme std::map. La classe std::tuple (&lt;tuple&gt;) permet de repr√©senter un ensemble de donn√©es h√©t√©rog√®nes. std::optional La classe std::optional (&lt;optional&gt;) permet de stocker un √©l√©ment optionnel. C'est utile pour √©viter d'avoir recours √† des valeurs sp√©ciales pour repr√©senter l'absence de valeur. std::variant La classe std::variant (&lt;variant&gt;) permet de stocker un √©l√©ment parmi un ensemble d'√©l√©ments possibles. C'est comparable aux enums, mais permet de stocker des types diff√©rents. ","version":"Next","tagName":"h2"},{"title":"Graphes","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/graphs","content":"","keywords":"","version":"Next"},{"title":"Quelques d√©finitions‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#quelques-d√©finitions","content":" Un graphe est un ensemble de sommets reli√©s par des ar√™tes. On peut repr√©senter un graphe par un ensemble de points reli√©s par des traits. Les points sont les sommets et les traits sont les ar√™tes.    Un graphe est dit orient√© si les ar√™tes ont un sens. Dans ce cas, on parle d'arc. Un graphe est dit non orient√© si les ar√™tes n'ont pas de sens.    Un graphe est dit pond√©r√© si les ar√™tes ont un poids. Dans ce cas, on parle de poids d'une ar√™te. Un graphe est dit non pond√©r√© si les ar√™tes n'ont pas de poids.    Un graphe est dit connexe si tous les sommets sont reli√©s entre eux par une ar√™te ou une suite d'ar√™tes.    graphe orient√© connexe Pour un graphe orient√© il y a plusieurs notions plus pr√©cises de connexit√©: Connexit√© forte: un graphe orient√© est dit fortement connexe si pour chaque paire de sommets uuu et vvv, il existe un chemin de uuu √† vvv et un chemin de vvv √† uuu.Connexit√© unilat√©rale: un graphe orient√© est dit unilat√©ralement connexe si pour chaque paire de sommets uuu et vvv, il existe un chemin de uuu √† vvv ou un chemin de vvv √† uuu.Connexit√© faible: un graphe orient√© est dit faiblement connexe si le graphe sous-jacent non orient√© est connexe.  Un graphe est dit cyclique si il contient au moins un cycle. Un cycle est une suite d'ar√™tes qui permet de revenir au point de d√©part.    ","version":"Next","tagName":"h2"},{"title":"Les arbres‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#les-arbres","content":" On a pr√©c√©demment vu les arbres binaires. Un arbre n'est rien d'autre qu'un graphe particulier. Un arbre est un graphe non orient√©, non pond√©r√©, connexe et acyclique.  ","version":"Next","tagName":"h3"},{"title":"Repr√©sentation d'un graphe‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#repr√©sentation-dun-graphe","content":" Il existe plusieurs mani√®res de repr√©senter un graphe en m√©moire. Nous allons voir les deux plus courantes.  ","version":"Next","tagName":"h2"},{"title":"Matrice d'adjacence‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#matrice-dadjacence","content":" La premi√®re mani√®re de repr√©senter un graphe est d'utiliser une matrice d'adjacence. Une matrice d'adjacence est une matrice carr√©e dont les lignes et les colonnes repr√©sentent les sommets du graphe. Si le sommet iii est reli√© au sommet jjj, alors la case (i,j)(i,j)(i,j) de la matrice vaut 1. Sinon, elle vaut 0. Si le graphe est pond√©r√©, la case (i,j)(i,j)(i,j) de la matrice vaut le poids de l'ar√™te.  Voici un exemple de matrice d'adjacence pour un graphe non orient√© et non pond√©r√© :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t1\t0\t1\t1\t0 C\t1\t1\t0\t0\t1 D\t0\t1\t0\t0\t1 E\t0\t0\t1\t1\t0  Et le graphe correspondant :    Dans le cas d'un graphe orient√©, la matrice n'est plus sym√©trique. Voici un exemple de matrice d'adjacence pour un graphe orient√© et non pond√©r√© :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t0\t0\t1\t1\t0 C\t0\t0\t0\t0\t1 D\t0\t0\t0\t0\t1 E\t0\t0\t0\t0\t0  Et le graphe correspondant :    ","version":"Next","tagName":"h3"},{"title":"Liste d'adjacence‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#liste-dadjacence","content":" La deuxi√®me mani√®re de repr√©senter un graphe est d'utiliser une liste d'adjacence. Une liste d'adjacence est une liste de listes. Pour chaque sommet, on a une liste des sommets adjacents. Si le graphe est pond√©r√©, on a une liste des sommets adjacents avec leur poids (avec une paire par exemple).  Voici un exemple de liste d'adjacence pour un graphe non orient√© et non pond√©r√© :  Sommet\tAdjacentsA\tB, C B\tA, C, D C\tA, B, E D\tB, E E\tC, D  En pratique, on utilise plut√¥t la liste d'adjacence pour repr√©senter un graphe car la matrice d'adjacence peut √™tre tr√®s co√ªteuse en m√©moire. En effet, une matrice d'adjacence est une matrice carr√©e. Donc, si on a nnn sommets, on a n2n^2n2 cases. M√™me si le graphe poss√®de peu d'ar√™tes, la matrice d'adjacence est quand m√™me de taille n2n^2n2. Cela peut √™tre l√©g√®rement optimis√© dans le cas des graphes non orient√©s car la matrice est sym√©trique. On peut donc ne stocker que la moiti√© de la matrice. Mais cela reste quand m√™me tr√®s co√ªteux en m√©moire.  L'utilit√© de la matrice d'adjacence est qu'elle permet de savoir si deux sommets sont reli√©s en temps constant. Dans les cas o√π c'est acceptable de stocker une matrice d'adjacence, on peut donc utiliser cette propri√©t√© pour gagner du temps. Cela a aussi des applications en th√©orie des graphes pour analyser des graphes.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un graphe‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-dun-graphe","content":" Maintenant que nous avons vu comment repr√©senter un graphe en m√©moire, nous allons voir comment parcourir un graphe. Il existe principalement deux mani√®res de parcourir un graphe : en largeur et en profondeur.  Donnons-nous le graphe suivant :    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-largeur","content":" Le parcours en largeur consiste √† parcourir le graphe en partant d'un sommet et en visitant tous les sommets adjacents avant de passer aux sommets adjacents de ces sommets adjacents. On visite donc les sommets par niveau.  Pour parcourir un graphe en largeur, on utilise une file. On commence par ajouter le sommet de d√©part dans la file. Tant que la file n'est pas vide, on retire le premier √©l√©ment de la file et on l'ajoute √† la liste des sommets visit√©s. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file. On recommence jusqu'√† ce que la file soit vide.  Voici le d√©roulement du parcours en largeur au d√©part du n≈ìud A pour le graphe pr√©c√©dent :  On commence par ajouter le sommet A dans la file.  File\tA  Comme la file n'est pas vide, on retire le premier √©l√©ment (A) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc B et C dans la file.  File\tC\tB  On retire le premier √©l√©ment (B) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc D et E dans la file.  File\tE\tD\tC  On retire le premier √©l√©ment (C) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc F et G dans la file.  File\tG\tF\tE\tD  On retire le premier √©l√©ment (D) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc rien dans la file.  File\tG\tF\tE  On fait de m√™me pour E, F et G. La file est maintenant vide. On a donc parcouru tous les sommets du graphe.  Cela nous donne donc le parcours suivant : A, B, C, D, E, F, G.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-profondeur","content":" Le parcours en profondeur consiste √† parcourir le graphe en partant d'un sommet et en visitant ses sommets adjacents puis les sommets adjacents de ces sommets adjacents, etc. On visite donc les sommets en profondeur. On peut voir le parcours en profondeur comme une descente dans le graphe.  Pour parcourir un graphe en profondeur, on utilise une pile. On commence par ajouter le sommet de d√©part dans la pile. Tant que la pile n'est pas vide, on retire le premier √©l√©ment de la pile et on l'ajoute √† la liste des sommets visit√©s. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la pile. On recommence jusqu'√† ce que la pile soit vide.  Voici le d√©roulement du parcours en profondeur au d√©part du n≈ìud A pour le graphe pr√©c√©dent :  On commence par ajouter le sommet A dans la pile.  Pile\tA  Comme la pile n'est pas vide, on retire le premier √©l√©ment (A) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile (B et C).  Pile\tB\tC  On retire le premier √©l√©ment (C) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc F et G dans la pile.  Pile\tB\tF\tG  On retire le premier √©l√©ment (G) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile.  Pile\tB\tF  On retire le premier √©l√©ment (F) de la pile, il n'a pas de sommets adjacents. On ajoute donc rien dans la pile.  Pile\tB  On recommence avec B. On ajoute D et E dans la pile.  Pile\tD\tE  On fait de m√™me pour E et D. La pile est maintenant vide. On a donc parcouru tous les sommets du graphe.  Ce qui nous donne le parcours suivant : A, C, G, F, B, E, D.  ","version":"Next","tagName":"h3"},{"title":"En pratique‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#en-pratique","content":" Maintenant que nous avons vu ce qu'est un graphe il est l√©gitime de se demander √† quoi cela peut bien servir. En effet, on peut se demander si on a d√©j√† rencontr√© des graphes dans la vie de tous les jours. La r√©ponse est oui. Les graphes sont utilis√©s dans de nombreux domaines. En voici quelques exemples :  Les r√©seaux sociaux : les graphes sont utilis√©s pour mod√©liser les relations entre les utilisateurs.Les jeux vid√©os : les graphes sont utilis√©s pour mod√©liser les niveaux, les cartes ou encore pour de la recherche de chemin (intelligence artificielle des ennemis par exemple).Les bases de donn√©es : les graphes sont utilis√©s pour mod√©liser les relations entre les donn√©es.Les probl√®mes de transport : les graphes sont utilis√©s pour mod√©liser les r√©seaux de transport (routes, m√©tro, etc.) et permettent de r√©soudre des probl√®mes d'optimisation (par exemple, trouver le plus court chemin entre deux villes).Des algorithmes de programmation dynamique : les graphes sont beaucoup utilis√©s dans les algorithmes dis de programmation dynamique o√π le probl√®me est si complexe qu'il est n√©cessaire de le d√©composer en sous-probl√®mes, de faire des estimations et d'explorer les solutions possibles √† travers un graphe de solutions.  ","version":"Next","tagName":"h2"},{"title":"Dijkstra‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#dijkstra","content":" Je vous propose de voir un exemple d'algorithme de graphe : l'algorithme de Dijkstra. Cet algorithme permet de trouver le plus court chemin entre deux sommets d'un graphe pond√©r√©. Il est tr√®s r√©pandu et est utilis√© dans de nombreux domaines.  L'algorithme de Dijkstra est simplement une application du parcours en largeur. On part d'un sommet de d√©part et on visite tous les sommets adjacents. On ajoute ensuite les sommets adjacents de ces sommets adjacents dans la file. On recommence jusqu'√† ce qu'on ait trouv√© le sommet d'arriv√©e. On peut alors remonter le chemin en partant du sommet d'arriv√©e et en remontant les sommets pr√©c√©dents jusqu'au sommet de d√©part.  Pour l'illustrer on peut prendre une liste de m√™me taille que le nombre de sommets du graphe pour repr√©senter les distances. On initialise toutes les distances √† l'infini sauf la distance du sommet de d√©part qui est √† 0. On utilise √©galement une file pour stocker les sommets √† visiter et une liste pour stocker les sommets d√©j√† visit√©s. On commence par ajouter le sommet de d√©part dans la file des sommets √† visiter. Tant que la file n'est pas vide, on retire le premier √©l√©ment de la file et on l'ajoute √† la liste des sommets visit√©s. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file s'ils n'ont pas d√©j√† √©t√© visit√©s. Pour chaque sommet adjacent, on met √† jour sa distance si la distance actuelle est plus grande que la distance du sommet actuel plus le poids de l'ar√™te entre le sommet actuel et le sommet adjacent. On recommence jusqu'√† ce que la file soit vide.  astuce Dans la pratique: On utilise une file de priorit√© std::priority_queue pour stocker les sommets √† visiter. Cela permet de retirer le sommet avec la plus petite distance facilement et de mani√®re efficace. On utilise un tableau associatif pour stocker les distances. Cela permet de ne pas avoir √† cr√©er une liste de taille fixe de tout les n≈ìuds avec une distance infinie initialement. On peut simplement ajouter les distances au fur et √† mesure que l'on parcourt le graphe et cela permet au passage de savoir quels n≈ìuds ont d√©j√† √©t√© visit√©s sans avoir de liste de n≈ìuds visit√©s suppl√©mentaire. De plus, g√©n√©ralement, cet algorithme est utilis√© pour trouver le plus court chemin entre deux sommets. On peut donc s'arr√™ter d√®s qu'on a trouv√© le sommet d'arriv√©e.  attention L'algorithme de Dijkstra ne fonctionne que pour les graphes pond√©r√©s positivement. En effet, si le graphe contient des ar√™tes de poids n√©gatif, l'algorithme peut boucler ind√©finiment. Pour √©viter ces probl√®mes,il est aussi possible d'utiliser une variante: l'algorithme de Bellman-Ford qui est plus lent mais qui fonctionne pour les graphes avec des cycles et des ar√™tes de poids n√©gatif.  Pour illustrer l'algorithme de Dijkstra, donnons-nous le graphe suivant :    L'id√©e de l'algorithme est de partir d'un sommet de d√©part que l'on ajoute √† un ensemble de sommets √† visiter (on va √©galement noter la distance depuis le sommet de d√©part pour aller jusqu'√† ce sommet (ce qui va permettre de prioriser les sommets √† visiter)).  On va se servir d'un tableau associatif pour associer √† chaque sommet visit√© la distance la plus courte connue pour aller du sommet de d√©part √† ce sommet et d'o√π on vient pour atteindre cette distance (ce qui permet de reconstruire le chemin le plus court √† la fin). Cela permet au passage de marquer les sommets comme visit√©s sans avoir de liste ou structure de donn√©es suppl√©mentaire.  Ensuite on va it√©rer sur les sommets √† visiter en choisissant √† chaque fois le sommet le plus proche du sommet de d√©part. Pour cela, on va se servi d'une file de priorit√© std::priority_queue qui va nous permettre de choisir le sommet le plus proche √† chaque it√©ration.  Si le sommet choisi n'a pas encore √©t√© visit√©, on va le marquer comme visit√© (mettre √† jour le tableau associatif) et on va ajouter √† la liste des sommets √† visiter tous les sommets voisins de ce sommet.  Si le sommet choisi a d√©j√† √©t√© visit√©, on va regarder si la distance la plus courte connue pour aller √† ce sommet (la valeur dans le tableau associatif) est plus grande en passant par le sommet choisi. Si c'est le cas, on va mettre √† jour la distance la plus courte et le sommet d'o√π on vient pour atteindre cette distance et on va de nouveau ajouter le sommet √† la liste des sommets √† visiter car l'on a trouv√© un chemin plus court pour y arriver, on dois propager cette information.  ","version":"Next","tagName":"h2"},{"title":"Illustration de l'algorithme de Dijkstra‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#illustration-de-lalgorithme-de-dijkstra","content":" on consid√®re que le sommet de d√©part est A et le sommet d'arriv√©e est E.  On ajoute le sommet A √† la liste des sommets √† visiter avec une distance de 0 (on est d√©j√† sur le sommet de d√©part) et d'o√π on vient (on est d√©j√† sur le sommet de d√©part).  Distances\tA visiter-\tA(0)  Il reste des √©l√©ments dans la liste √† visiter on r√©cup√®re le sommet qui a la plus petite distance (A) et on le retire de la liste √† visiter. On parcours la liste des voisins de A (B et C), les deux ne sont pas d√©j√† visit√©s, on les ajoutes √† la liste √† visiter et au tableau associatif avec la distance en passant par A (0 + poids de l'ar√™te) et d'o√π on vient (A).  Distances\tA visiterB(1, A), C(2, A)\tB(1), C(2)  Je r√©cup√®re maintenant B qui est le sommet prioritaire dans la liste √† visiter (plus petites distance).  Je parcours la liste des voisins de B (C et D). C est d√©j√† pr√©sent dans le tableau associatif ce qui indique qu'il a d√©j√† √©t√© visit√© ou marqu√© √† visiter. Ici le poids actuellement dans le tableau des distances est √©gale au poids en passant par B (1 + 1) donc on ne fait rien les deux chemins sont aussi cours l'un que l'autre.  pour D on ajoute comme pr√©c√©demment ce qui donne:  Distances\tA visiterB(1, A), C(2, A), D(6, B)\tC(2), D(6)  Je recommence de nouveau avec C qui est le sommet prioritaire dans la liste √† visiter (plus petites distance).D a d√©j√† √©t√© visit√© mais ici le co√ªt en passant par C est plus faible (2+3&lt;62 + 3 &lt; 62+3&lt;6), je mets donc √† jour la distance et je rajoute de nouveau D dans la liste √† visiter:  Distances\tA visiterB(1, A), C(2, A), D(5, C)\tD(6), D(5)  remarque Ici il y a deux fois D dans la liste, ce n'est pas grave car avec la priorit√© on va de toute fa√ßon choisir le plus petit. Puis au moment de traiter une deuxi√®me fois D on va voir que la distance est plus grande et on ne va rien faire.  Enfin on ajoute aussi E l'autre sommet adjacent √† C:  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(8, C)\tD(6), D(5), E(8)  Je continue avec D :  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(7, D)\tD(6), E(8), E(7)  De nouveau avec D car il √©tait en doublon dans la liste mais cela ne va avoir aucun effet car E est list√© avec un poids donc plus faible.  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(7, D)\tE(8), E(7)  Enfin on r√©cup√®re E, il n'a pas d'arr√™tes donc on ne fait rien, mais c'est le sommet de destination on a atteins notre destination, on peut s'arr√™ter et retourner le tableau associatif.  On peut s'amuser √† retrouver la succession des arr√™tes √† parcours gr√¢ce au tableau associatif: A ‚Üí\\rightarrow‚Üí C ‚Üí\\rightarrow‚Üí D ‚Üí\\rightarrow‚Üí E.  remarque Vous pouvez trouver une autre fa√ßon de repr√©senter l'algorithme avec une liste de distances pour tout les sommets (initialis√©e √† l'infini) et une liste de sommets visit√©s. N√©anmoins, cette m√©thode est plus co√ªteuse en m√©moire et moins proche de l'impl√©mentation de l'algorithme de Dijkstra. C'est pour cela que j'ai choisi de vous pr√©senter cette illustration (avec un tableau associatif (Distances) et une file de priorit√© (A visiter)).  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin: A*‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#pour-aller-plus-loin-a","content":" L'algorithme de Dijkstra peut √™tre am√©lior√©. En effet, il explore tous les sommets adjacents d'un sommet avant de passer au sommet suivant. Cela peut √™tre tr√®s co√ªteux en temps si le graphe est tr√®s grand et / ou si le sommet de d√©part et le sommet d'arriv√©e sont tr√®s √©loign√©s. L'algorithme de Dijkstra explore alors beaucoup de sommets inutilement.  L'algorithme A* est une am√©lioration de l'algorithme de Dijkstra. Il utilise une heuristique pour guider la recherche. L'heuristique est une fonction qui permet d'estimer la distance entre un sommet et le sommet d'arriv√©e. L'algorithme A* explore alors en priorit√© les sommets qui sont les plus proches(selon cette estimation) du sommet d'arriv√©e. Cela permet de r√©duire le nombre de sommets explor√©s et donc de gagner du temps.  Pour donner un exemple concret, on peut utiliser la distance euclidienne comme heuristique. La distance euclidienne est la distance √† vol d'oiseau entre deux points. On peut l'utiliser pour guider la recherche dans un labyrinthe par exemple. On peut alors utiliser la distance euclidienne entre le sommet actuel et le sommet d'arriv√©e comme heuristique. Cela permet d'explorer en priorit√© les sommets qui sont les plus proches (√† vol d'oiseau) du sommet d'arriv√©e.  ","version":"Next","tagName":"h3"},{"title":"Simplification 2D‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#simplification-2d","content":" La repr√©sentation en liste d'adjacence est tr√®s pratique pour repr√©senter un graphe arbitraire. Cependant, dans certains cas, on peut utiliser une repr√©sentation plus simple. C'est le cas par exemple quand on cherche le plus court chemin entre deux points dans une grille. Dans ce cas les sommets sont les centres des cases de la grille et les ar√™tes sont les c√¥t√©s des cases de la grille. Il n'est alors pas n√©cessaire de stocker la repr√©sentation compl√®te du graphe car celle-ci est connue √† l'avance. On peut donc utiliser une repr√©sentation plus simple.  Dans le cas o√π le coup de d√©placement d'une case √† une autre est le m√™me pour toutes les cases, appliquer Dijkstra sur une grille devient alors tr√®s simple. Il suffit de parcourir la grille en largeur en partant du point de d√©part et en s'arr√™tant quand on a trouv√© le point d'arriv√©e. On peut alors remonter le chemin en partant du point d'arriv√©e et en remontant les points pr√©c√©dents jusqu'au point de d√©part (parfois aussi nomm√© Breadth First Search ou BFS).  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#r√©sum√©","content":" Un graphe est un ensemble de sommets reli√©s par des ar√™tes.Un graphe est dit orient√© si les ar√™tes ont un sens. Dans ce cas, on parle d'arc.Un graphe est dit pond√©r√© si les ar√™tes ont un poids.Un graphe est dit connexe si tous les sommets sont reli√©s entre eux par une ar√™te ou une suite d'ar√™tes.Un arbre est un graphe(Un graphe non orient√©, non pond√©r√©, connexe et acyclique)Il existe deux mani√®res de repr√©senter un graphe en m√©moire : la matrice d'adjacence et la liste d'adjacence.Il existe deux mani√®res de parcourir un graphe : en largeur et en profondeur.L'algorithme de Dijkstra permet de trouver les distances les plus courtes entre un sommet de d√©part et tous les autres sommets d'un graphe pond√©r√© positivement.L'algorithme A* est une am√©lioration de l'algorithme de Dijkstra qui utilise une heuristique pour guider la recherche.Dans le cas d'un graphe non pond√©r√©, Dijkstra n'est rien d'autre qu'un parcours en largeur.  ","version":"Next","tagName":"h2"},{"title":"Sources‚Äã","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#sources","content":" Voil√† quelques sources qui peuvent vous aider √† approfondir le sujet et mieux comprendre les graphes et la recherche de chemin :  https://www.redblobgames.com/pathfinding/a-star/introduction.htmlhttps://www.youtube.com/watch?v=GazC3A4OQTEhttps://www.youtube.com/watch?v=i3_V90yUfcAhttps://www.youtube.com/watch?v=-L-WgKMFuhE ","version":"Next","tagName":"h2"},{"title":"Hash et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Hachage‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#hachage","content":" En informatique, le hachage est une technique qui consiste √† associer √† une donn√©e une empreinte num√©rique, appel√©e hash qui permet d'identifier rapidement et efficacement cette donn√©e.  On nomme fonction de hachage une fonction qui prend en entr√©e une donn√©e et qui retourne le hash de cette donn√©e.  La fonction de hachage doit √™tre d√©terministe, c'est-√†-dire que pour une donn√©e donn√©e, elle doit toujours retourner le m√™me hash. Id√©alement, la fonction de hachage doit √™tre aussi:  Rapide √† calculerDonner des r√©sultats diff√©rents pour des donn√©es diff√©rentes (r√©sistance aux collisions)Donner des r√©sultats diff√©rents pour des donn√©es similaires (r√©sistance aux attaques par force brute)  En pratique, il est compliqu√© de trouver une fonction de hachage qui v√©rifie toutes ces propri√©t√©s. On essaye donc de trouver une fonction de hachage qui v√©rifie au mieux ces propri√©t√©s et notamment la r√©sistance aux collisions. Cela permet d'√©viter que deux donn√©es diff√©rentes aient le m√™me hash.  Cela d√©pend aussi de l'application. Par exemple, pour une application qui stocke des mots de passe, il est important que la fonction de hachage soit r√©sistante aux collisions et aux attaques par force brute. Cela permet d'√©viter que deux mots de passe diff√©rents aient le m√™me hash, ce qui permettrait √† un attaquant de trouver un mot de passe valide sans avoir √† le deviner par exemple.  Il existe de nombreux algorithmes et fonctions de hachage complexes pour des applications r√©elles. Vous trouverez par exemple l'algorithme MD5 (consid√©r√© comme obsol√®te) ou la famille de fonctions SHA-2 et notamment SHA-256 qui est r√©put√©e pour √™tre r√©sistante aux collisions et aux attaques par force brute et beaucoup utilis√©e aujourd‚Äôhui.  ","version":"Next","tagName":"h2"},{"title":"Table de hachage‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#table-de-hachage","content":" Dans notre exemple, on a associ√© √† chaque nom de jour de la semaine un indice, une valeur num√©rique enti√®re, qui permet de l'identifier (dans l'id√©al de mani√®re unique).  Ensuite on a utilis√© cet indice comme indice dans un tableau pour r√©cup√©rer une information associ√©e √† ce nom de jour de la semaine: le num√©ro de jour de la semaine.  C'est ce que l'on appelle une table de hachage.  Une table de hachage est une structure de donn√©es qui permet d'associer √† une donn√©e que l'on appelle cl√© une valeur. On peut ensuite retrouver la valeur associ√©e √† une cl√© en utilisant un hash de la cl√© comme indice dans un tableau.  Une fa√ßon de g√©rer les collisions est d'utiliser une liste pour stocker les valeurs associ√©es aux cl√©s qui ont le m√™me hash. Une fois que l'on a calcul√© le hash de la cl√©, on utilise ce hash comme indice dans un tableau pour trouver la liste des valeurs associ√©es. S'il y a plusieurs valeurs associ√©es √† la cl√©, on peut parcourir la liste pour trouver la valeur qui correspond √† la cl√© en comparant les cl√©s.    ","version":"Next","tagName":"h2"},{"title":"Tableau associatif‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#tableau-associatif","content":" La structure de donn√©es que l'on vient de d√©crire est ce que l'on appelle un tableau associatif.  Un tableau associatif est une structure de donn√©es qui permet d'associer √† une donn√©e que l'on appelle cl√© une valeur. On peut ensuite retrouver la valeur associ√©e √† une cl√© en utilisant la cl√©.  ","version":"Next","tagName":"h2"},{"title":"std::unordered_map‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdunordered_map","content":" La biblioth√®que standard de C++ fournit une impl√©mentation de tableau associatif utilisant une table de hachage: la classe std::unordered_map( d√©finie dans la biblioth√®que &lt;unordered_map&gt;).  Implicitement, cette classe utilise la fonction de hachage std::hash pour calculer le hash des cl√©s. Cette fonction de hachage est d√©finie pour les types de base et les types de la biblioth√®que standard (comme std::string par exemple).  Elle utilise aussi la fonction std::equal_to pour comparer les cl√©s dans le cas des collisions. Cette fonction est aussi d√©finie pour les types de base et les types de la biblioth√®que standard.  On utilise la m√©thode insert pour ajouter une valeur associ√©e √† une cl√© et la m√©thode find pour retrouver la valeur associ√©e √† une cl√©. Je vous invite √† relire le cours pr√©c√©dent sur les it√©rateurs pour comprendre comment utiliser ces m√©thodes.  #include &lt;unordered_map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::unordered_map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5}, {&quot;dimanche&quot;, 6} }; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber { days.find(dayName) }; if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour num√©ro &quot; &lt;&lt; (*dayNumber).second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info Il est possible de d√©finir une fonction de hachage personnalis√©e pour la classe std::unordered_map afin de pouvoir utiliser des types personnalis√©s comme des structures ou des classes comme cl√©s. Mais cela d√©passe le cadre de ce cours. Si c'est quelque chose qui vous int√©resse, n'h√©sitez pas √† faire des recherches ou √† me contacter.  ","version":"Next","tagName":"h3"},{"title":"std::map‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdmap","content":" Il existe une autre impl√©mentation de tableau associatif dans la biblioth√®que standard de C++: la classe std::map (d√©finie dans la biblioth√®que &lt;map&gt;).  Cette classe utilise un arbre binaire de recherche pour stocker les donn√©es. Cela permet de stocker les donn√©es dans un ordre d√©fini par une relation d'ordre sur les cl√©s.  Elle utilise une op√©ration de comparaison pour stocker les donn√©es. Cette op√©ration de comparaison est d√©finie pour les types de base et les types de la biblioth√®que standard (comme std::string par exemple).  Elle s'utilise de la m√™me fa√ßon que std::unordered_map.  #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; // On peut ajouter des √©l√©ments √† une std::map avec l‚Äôop√©rateur [] days[&quot;dimanche&quot;] = 6; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber = days.find(dayName); if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour num√©ro &quot; &lt;&lt; dayNumber-&gt;second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info La classe std::map utilise un arbre binaire de recherche pour stocker les associations cl√©-valeur sous la forme de paires (std::pair). On peut donc aussi utiliser la classe std::pair pour ajouter des √©l√©ments √† une std::map. #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; days.insert(std::make_pair(&quot;dimanche&quot;, 6)); return 0; }   Cas d'utilisation avec les √©num√©rations‚Äã  Les √©num√©rations sont des types de donn√©es qui permettent de d√©finir un ensemble de valeurs possibles pour une variable.  Mais il n'est pas simplement possible de convertir un √©l√©ment d'une √©num√©ration en une cha√Æne de caract√®res.  Mais √©tant repr√©sent√©es par des entiers en m√©moire, il est possible de les utiliser comme cl√©s dans un tableau associatif pour y associer des cha√Ænes de caract√®res.  C'est un cas d'utilisation tr√®s courant des tableaux associatifs et des √©num√©rations.  #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; enum class Season { Spring, Summer, Autumn, Winter }; int main() { std::map&lt;Season, std::string&gt; season_to_string { {Season::Spring, &quot;Printemps&quot;}, {Season::Summer, &quot;√ât√©&quot;}, {Season::Autumn, &quot;Automne&quot;}, {Season::Winter, &quot;Hiver&quot;} }; Season currentSeason {Season::Spring}; std::cout &lt;&lt; &quot;La saison actuelle est &quot; &lt;&lt; season_to_string[currentSeason] &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::set ‚Äî Un ensemble d'√©l√©ments uniques‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdset--un-ensemble-d√©l√©ments-uniques","content":" Une autre structure de donn√©es fournie par la biblioth√®que standard de C++ est la classe std::set (d√©finie dans la biblioth√®que &lt;set&gt;).  Elle permet de repr√©senter un ensemble d'√©l√©ments uniques.  Cette classe est similaire √† std::map mais elle ne stocke pas de valeurs associ√©es aux cl√©s. Elle ne stocke que les cl√©s. Cela permet de stocker des ensembles d'√©l√©ments uniques.  Elle s'utilise de la m√™me fa√ßon que std::map.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#r√©sum√©","content":" Une fonction de hachage est une fonction qui prend en entr√©e une donn√©e et qui retourne le hash de cette donn√©e (un nombre entier)Une table de hachage est une structure de donn√©es qui permet d'associer √† une donn√©e que l'on appelle cl√© une valeur. On peut ensuite retrouver la valeur associ√©e √† une cl√© en utilisant un hash de la cl√© comme indice dans un tableau.Une table de hachageUn tableau associatif est une structure de donn√©es qui permet d'associer √† une donn√©e que l'on appelle cl√© une valeur. On peut ensuite retrouver la valeur associ√©e √† une cl√© en utilisant la cl√©.La biblioth√®que standard de C++ fournit deux impl√©mentations de tableau associatif: std::unordered_map qui utilise une table de hachagestd::map qui utilise un arbre binaire de recherche La biblioth√®que standard de C++ fournit aussi une impl√©mentation d'ensemble d'√©l√©ments uniques: std::set. ","version":"Next","tagName":"h2"},{"title":"Retours G√©n√©raux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks","content":"","keywords":"","version":"Next"},{"title":"Caract√®res et ASCII‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#caract√®res-et-ascii","content":" Pour comparer un caract√®re on peut en effet utiliser les codes ASCII mais on peut aussi utiliser le caract√®re directement.  c == 97 // est √©quivalent √† c == 'a'   un caract√®re est en fait un entier(compris entre 0 et 255), donc on peut faire des op√©rations dessus.  char c = 'a'; c = c + 1; // c vaut maintenant 'b'   C'est un nombre qui √† une repr√©sentation particuli√®re(lorsqu'on l'affiche) mais c'est un nombre comme un autre.  Pour des comparaisons de caract√®res, il est pr√©f√©rable d'utiliser la notation avec les caract√®res directement car c'est plus lisible et plus simple √† √©crire.  c == 'a' // est plus lisible que c == 97   Par exemple si l'on souhaite savoir si un caract√®re est un lettre minuscule, on peut faire (en sachant que les lettres minuscules sont les caract√®res entre a et z et qu'ils sont cons√©cutifs dans la table ASCII):  bool isLower(char c) { return c &gt;= 'a' &amp;&amp; c &lt;= 'z'; }   ","version":"Next","tagName":"h2"},{"title":"Condition‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#condition","content":" Pour retourner le r√©sultat d'une condition, il n'est pas n√©cessaire de faire un if suivi d'un else avec un return dans chaque bloc.  #include &lt;cctype&gt; bool isVoyelle(char c) { c = std::tolower(c); if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') { return true; } else { return false; } }   En effet la condition c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' est d√©j√† un bool√©en en soit, donc on peut directement le retourner.  C'est √©quivalent √† faire:  if(true) { return true; } else { return false; }   Ca fonctionne mais c'est pas n√©cessaire et √ßa fait plus de code √† √©crire et √† lire.  il faut donc plut√¥t retourner directement le r√©sultat de la condition.  bool isVoyelle(char c) { c = std::tolower(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; }   ","version":"Next","tagName":"h2"},{"title":"Puissance‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#puissance","content":" Attention,  la syntaxe x**2 n'est pas valide en C++. Il faut utiliser la fonction pow de la biblioth√®que cmath.  #include &lt;cmath&gt; int x = 2; int y = pow(x, 2); // y vaut 4   ou alors pour faire simplement un carr√© une multiplication suffit.  int x = 2; int y = x*x; // y vaut 4   ","version":"Next","tagName":"h2"},{"title":"R√©f√©rence constante‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#r√©f√©rence-constante","content":" Lorsque l'on souhaite juste lire une variable en param√®tre d'une fonction, on peut utiliser une r√©f√©rence constante. Particuli√®rement si cette variable est un &quot;gros&quot; objet comme une chaines de caract√®res, un tableau ou une structure.  Par exemple pour la fonction countVowels on peut utiliser une r√©f√©rence constante pour le param√®tre s qui est un std::string √ßa permet de ne pas faire de copie de la cha√Æne de caract√®re.  int countVowels(std::string const&amp; s) { // ... }   ","version":"Next","tagName":"h2"},{"title":"Initialisation d'un g√©n√©rateur de nombre al√©atoire‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#initialisation-dun-g√©n√©rateur-de-nombre-al√©atoire","content":" std::srand(seed); permet d'initialiser le g√©n√©rateur de nombre al√©atoire avec une valeur qui change √† chaque fois que l'on ex√©cute le programme.  On doit l'appeler une seule fois au d√©but du programme et pas dans une fonction qui retourne un nombre al√©atoire. Car sinon on r√©initialise le g√©n√©rateur √† chaque utilisation de la fonction et on obtient toujours le m√™me nombre al√©atoire. (sauf si le param√®tre seed lui m√™me change √† chaque fois mais √ßa reste pas une bonne solution).  ","version":"Next","tagName":"h2"},{"title":"Include‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#include","content":" Pour pouvoir utiliser les d√©finitions ou fonction √©crit dans un fichier depuis un autre il faut utiliser la directive #include.  Par example, pour pouvoir utiliser l'√©num√©ration Direction dans le fichier Point.cpp (on en a besoin pour d√©finit la fonction move), il faut inclure le fichier Direction.hpp dans le fichier Point.cpp.  ","version":"Next","tagName":"h2"},{"title":"S√©paration des responsabilit√©s‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#s√©paration-des-responsabilit√©s","content":" Dans l'id√©al, il faut que chaque fonction ait une seule responsabilit√©. C'est √† dire qu'elle ne doit faire qu'une seule chose. Cela permet de mieux r√©utiliser le code et permet d'√™tre plus flexible dans l'utilisation de la fonction.  Par exemple, si on veut trouver la valeur maximale d'un tableau, on peut cr√©er une fonction max et ensuite afficher le r√©sultat.  int max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; for (size_t i {1}; i &lt; vec.size(); ++i) { if (vec[i] &gt; max) { max = vec[i]; } } return max; } int main() { std::vector&lt;int&gt; vec {1, 2, 3, 4, 5}; std::cout &lt;&lt; &quot;la valeur maximale est: &quot; &lt;&lt; max(vec) &lt;&lt; std::endl; }   Plut√¥t que de faire:   void max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; // ... std::cout &lt;&lt; &quot;la valeur maximale est: &quot; &lt;&lt; max &lt;&lt; std::endl; } int main() { std::vector&lt;int&gt; vec {1, 2, 3, 4, 5}; max(vec); }   Car imaginons que l'on veuille utiliser la fonction max pour autre chose (un algorithme de tri par exemple), on ne peut pas car la fonction max affiche le r√©sultat et ne le retourne pas. Ou si elle l'affiche et le retourne, cela va tout de m√™me &quot;polluer&quot; l'affichage sans que l'on puisse le contr√¥ler.  ","version":"Next","tagName":"h2"},{"title":"Concat√©nation de cha√Ænes de caract√®res‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#concat√©nation-de-cha√Ænes-de-caract√®res","content":" Pour construire une cha√Æne de caract√®res, on peut utiliser l'op√©rateur + pour concat√©ner des cha√Ænes de caract√®res.  Mais il faut faire attention √† bien utiliser des cha√Ænes de caract√®res et pas des caract√®res.  Les caract√®res √©tant des nombres, l'op√©rateur + va faire une addition et non une concat√©nation.   std::string hello {&quot;Hello&quot;}; std::string world {&quot;World&quot;}; std::string helloWorld {hello + world}; //fonctionne std::string he {'H' + 'e'}; // ne fonctionne pas // Erreur de compilation : &quot;error: narrowing conversion of ‚Äò173‚Äô from ‚Äòint‚Äô to ‚Äòchar‚Äô [-Wnarrowing]&quot;   On ne peux pas non plus faire :   std::string helloWorld {&quot;Hello&quot; + &quot;World&quot;}; // ne fonctionne pas // Erreur de compilation : &quot;error: invalid operands of types ‚Äòconst char [6]‚Äô and ‚Äòconst char [6]‚Äô to binary ‚Äòoperator+‚Äô&quot;   Car &quot;Hello&quot; et &quot;World&quot; ne sont pas encore √† ce stade des std::string du C++ mais des tableaux de caract√®res du C. On ne peut pas utilise l'op√©rateur + sur des tableaux de caract√®res.  Si l'on souhaites construire une cha√Æne de caract√®res √† partir de caract√®res, il faut utiliser la m√©thode std::string::push_back qui permet d'ajouter un caract√®re √† la fin d'une cha√Æne de caract√®res.   std::string hello; helloWorld.push_back('H'); helloWorld.push_back('e'); helloWorld.push_back('l'); helloWorld.push_back('l'); helloWorld.push_back('o');   Ou alors utiliser l'op√©rateur + ou la m√©thode std::string::append qui permet d'ajouter une cha√Æne de caract√®res √† la fin d'une autre cha√Æne de caract√®res.   std::string helloWorld {&quot;Hello&quot;}; helloWorld.append(&quot; World&quot;); helloWorld += &quot; !&quot;;   ","version":"Next","tagName":"h2"},{"title":"Unsigned int et std::cin‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/feedbacks#unsigned-int-et-stdcin","content":" Lorsque l'on utilise std::cin pour lire un nombre entier, si l'on souhaite stocker ce nombre dans un unsigned int il faut faire attention √† ce que l'utilisateur ne rentre pas un nombre n√©gatif. Car dans ce cas std::cin ne va pas signaler d'erreur mais va tenter de stocker la valeur n√©gative dans un unsigned int et va donc stocker une valeur qui n'est pas celle que l'utilisateur a rentr√©. Cela peut provoquer des bugs dans le programme.  Exemple:  #include &lt;iostream&gt; int main() { unsigned int age; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; if (std::cin.fail()) { std::cout &lt;&lt; &quot;Invalid input.&quot; &lt;&lt; std::endl; return 1; } std::cout &lt;&lt; &quot;You are &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }   Avec des lettres il y a bien une erreur:  Enter your age: test Invalid input.   Avec un nombre n√©gatif, il n'y a pas d'erreur mais le r√©sultat n'est pas celui attendu:  Enter your age: -5 You are 4294967291 years old.   Ici la valeur s'explique par le fait qu'il y a un d√©passement (un unsigned int ne peut pas stocker de nombre n√©gatif) et il y a donc une conversion implicite (cast) de -5 en unsigned int qui donne 4294967291.  Un unsigned int qui est cod√© sur 32 bits. Donc la valeur maximale que l'on peut stocker est 2^32 - 1 = 4294967295 et la valeur minimale est 0. Donc si l'on rentre -5 on obtient 2^32 - 5 = 4294967291.  Malheureusement, il n'y a pas de solution simple pour √©viter ce probl√®me. Il faut soit utiliser un int temporaire pour stocker la valeur et v√©rifier que la valeur est positive avant de la stocker dans l'unsigned int mais ce n'est pas id√©al car on ne peut pas b√©n√©ficier des avantages de l'unsigned int √† savoir stocker des nombres plus grands (car on passe par un int temporaire qui est plus limit√© pour les nombres positifs).  Il faut sinon lire la cha√Æne de caract√®re et la convertir ensuite par des fonctions (g√©n√©ralement du C) comme atoi ou strtol qui permettent de convertir une cha√Æne de caract√®re en nombre entier avec une gestion des erreurs au cas o√π la cha√Æne de caract√®re ne repr√©sente pas le nombre attendu. ","version":"Next","tagName":"h2"},{"title":"S√©mantique et op√©rateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Operators","content":"","keywords":"","version":"Next"},{"title":"Op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs","content":" Les op√©rateurs sont des symboles qui permettent de manipuler des donn√©es. Par exemple, l'op√©rateur + permet d'additionner deux nombres entre eux.  En C++, il est possible de d√©finir des op√©rateurs pour nos structures, c'est ce que l'on appelle la surcharge d'op√©rateurs. Cela permet ensuite d'utiliser l'op√©rateur sur nos structures sans devoir passer par une m√©thode.  Pour d√©finir un op√©rateur, on utilise le mot cl√© operator suivi du symbole de l'op√©rateur. Par exemple, pour d√©finir l'op√©rateur +, on utilise operator+.  Par exemple, on peut d√©finir un op√©rateur + pour notre structure Point qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet op√©rateur sur nos structures comme si elles √©taient des nombres.  struct Point { int x; int y; }; Point operator+(Point const&amp; a, Point const&amp; b) { return {a.x + b.x, a.y + b.y}; } int main() { Point a {1, 2}; Point b {3, 4}; Point c {a + b}; // c = {4, 6} }   ","version":"Next","tagName":"h2"},{"title":"√âgalit√©‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#√©galit√©","content":" Ce qui fait g√©n√©ralement sens pour une structure, c'est de pouvoir comparer deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont √©gaux ou non.  Pour √™tre en mesure de d√©finir l‚Äô√©galit√©, on doit respecter les conditions suivantes.  Pour n'importe quel a, a == a doit √™tre vrai, c'est ce qu'on appelle la r√©flexivit√©.Pour n'importe quel a et b de m√™me type, si a == b est vrai, alors b == a doit √™tre vrai, c'est ce qu'on appelle la sym√©trie et la commutativit√©.Pour n'importe quel a, b et c de m√™me type, si a == b et b == c sont vrais, alors a == c doit √™tre vrai, c'est ce qu'on appelle la transitivit√©.  Pour d√©finir l'op√©rateur d'√©galit√©, on utilise operator==. On peut ensuite utiliser cet op√©rateur sur nos structures de la m√™me fa√ßon que pour les types de base.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } int main() { Point a {1, 2}; Point b {1, 2}; if (a==b) { std::cout &lt;&lt; &quot;Les points a et b ont les m√™mes coordonn√©es&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Les points a et b ont des coordonn√©es diff√©rentes&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h2"},{"title":"Fonction ou m√©thode‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#fonction-ou-m√©thode","content":" On peut d√©finir l'op√©rateur d'√©galit√© comme une fonction (en dehors de la d√©finition de la structure) ou comme une m√©thode (√† l'int√©rieur de la d√©finition de la structure).  La diff√©rence est que dans le cas d'une m√©thode, le premier param√®tre est implicite et correspond √† l'instance sur laquelle on appelle la m√©thode.  struct Point { int x; int y; bool operator==(Point const&amp; b) const { return x == b.x &amp;&amp; y == b.y; } };   Cela a une influence sur la fa√ßon dont on utilise l'op√©rateur.  remarque Ici la m√©thode est d√©finie comme const car elle ne modifie pas l'instance sur laquelle on l'appelle. Cela permet d'appeler la m√©thode sur une instance constante.  Par exemple si l'on souhaite multiplier un point par un nombre, on peut d√©finir l'op√©rateur comme une m√©thode.  struct Point { int x; int y; Point operator*(int const a) const { return {x * a, y * a}; } }; int main() { Point a {1, 2}; Point b {a * 2}; // b = {2, 4} }   Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas d√©finir l'op√©rateur comme une m√©thode car le premier param√®tre est implicite et correspond √† l'instance sur laquelle on appelle la m√©thode.  Il faut donc d√©finir l'op√©rateur comme une fonction libre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} }   Les deux syntaxes sont donc valables, mais il faut garder en t√™te que la syntaxe avec une m√©thode implique que le premier param√®tre est implicite et correspond √† l'instance sur laquelle on appelle la m√©thode. Il y a plusieurs √©coles, en g√©n√©ral on pr√©f√®re la syntaxe avec une fonction libre concernant les op√©rateurs binaires (qui prennent deux param√®tres). Cela permet par exemple, dans le cas d'op√©rateurs binaires commutatifs (dans lequel l'ordre des param√®tres n'a pas d'importance), de d√©finir les deux op√©rateurs en fonction l'un de l'autre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } Point operator*(Point const&amp; b, int const a) { // Comme la multiplication est commutative, on peut d√©finir l'op√©rateur en fonction de l'autre // On utilise l'op√©rateur * que l'on vient de d√©finir (int * Point) pour d√©finir notre op√©rateur (Point * int) return a * b; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} Point c {a * 3}; // b = {3, 6} }   ","version":"Next","tagName":"h3"},{"title":"R√©utilisation des op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#r√©utilisation-des-op√©rateurs","content":" Je vous ai d√©j√† parl√© de l‚Äôint√©r√™t de la r√©utilisation avec les fonctions. C'est aussi valable pour les op√©rateurs.  L‚Äôhabitude que beaucoup prennent est de d√©finir les op√©rateurs == et &lt;, puis de d√©finir les autres en fonction de ces deux-l√†.  On va donc d√©finir l'op√©rateur != en fonction de ==.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } bool operator!=(Point const&amp; a, Point const&amp; b) { // Ici on utilise l'op√©rateur == que l'on vient de d√©finir pour d√©finir != return !(a == b); }   Dans notre cas d√©finir les op√©rateurs de comparaison &lt;, &lt;=, &gt;, &gt;= fait moins sens car on ne peut pas vraiment dire qu'un point est plus grand qu'un autre.  ","version":"Next","tagName":"h2"},{"title":"default et C++ 20‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#default-et-c-20","content":" Il est parfois possible de d√©finir automatiquement certains op√©rateurs. Dans le cas de structures simples, on peut d√©finir automatiquement les op√©rateurs == et != avec le mot cl√© default.  struct Point { int x; int y; bool operator==(Point const&amp; p) const = default; bool operator!=(Point const&amp; p) const = default; };   Cela permet de d√©finir automatiquement les op√©rateurs == et != en fonction des op√©rateurs == et != de chaque membre de la structure.  Depuis C++20, il est m√™me possible de d√©finir automatiquement l'op√©rateur d'√©galit√© et les op√©rateurs de comparaison (&lt;, &lt;=, &gt;, &gt;=) d'un coup avec l'op√©rateur &lt;=&gt; (appel√© three-way comparison operator).  struct Point { int x; int y; auto operator&lt;=&gt;(Point const&amp; p) const = default; };   L'op√©rateur &lt;=&gt; est un op√©rateur qui permet de donner un ordre √† une structure. Avec le mot cl√© default, on d√©l√®gue la d√©finition de l'op√©rateur &lt;=&gt; √† chaque membre de la structure. On d√©fini donc automatiquement l'ordre de la structure en fonction de l'ordre de chaque membre (dans notre cas, on compare d'abord x puis y).  C'est tr√®s pratique dans le cas o√π nos structures sont compos√©es de types de base ou de structures qui ont d√©j√† des op√©rateurs de comparaison d√©finis.  Dans le cadre de ce cours nous allons d√©finir les op√©rateurs manuellement pour bien comprendre le principe. Mais dans la pratique, il est pr√©f√©rable d'utiliser default ou default avec &lt;=&gt; si possible.  ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'assignation compos√©s‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-dassignation-compos√©s","content":" Les op√©rateurs d'assignation compos√©s permettent de combiner une op√©ration et une assignation. Par exemple, l'op√©rateur += permet d'additionner une valeur √† une variable et de stocker le r√©sultat dans la variable.  Il est aussi possible de d√©finir des op√©rateurs d'assignation compos√©s pour nos structures. Par exemple, on peut d√©finir l'op√©rateur += pour notre structure Point qui permet d'additionner un point √† un autre point et de stocker le r√©sultat dans le premier point.  Cela fait sens dans ce cas de les d√©finir comme des m√©thodes.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; p) { x += p.x; y += p.y; return *this; } };   astuce L'expression *this peut sembler √©trange. this est un pointeur sur l'instance courante. *this est donc une r√©f√©rence sur l'instance courante. On retourne une r√©f√©rence sur l'instance courante pour pouvoir faire des op√©rations en cha√Æne. Par exemple, on peut √©crire a += b += c qui est √©quivalent √† a += (b += c). Cela nous permet d‚Äôavoir le m√™me comportement pour notre structure que s‚Äôil s‚Äôagissait d‚Äôun type natif comme int.  ","version":"Next","tagName":"h2"},{"title":"Deux en un‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#deux-en-un","content":" Pour chaque op√©rateur d'assignation compos√©, il existe un op√©rateur binaire (prenant deux param√®tres) correspondant. Par exemple, l'op√©rateur += a pour op√©rateur binaire correspondant +.  Dans un souci de r√©utilisation, on peut d√©finir l'op√©rateur binaire en fonction de l'op√©rateur d'assignation compos√©.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; b) { x += b.x; y += b.y; return *this; } }; Point operator+(Point a, Point const&amp; b) { a += b; return a; }   Ici le principe de passage par copie (ou par valeur) du param√®tre a est important. Puisque qu'il est copi√©, on peut le modifier avec l‚Äôop√©rateur += sans risque modifier l'instance originale. On obtient donc l'op√©rateur binaire + en fonction de l'op√©rateur d'assignation compos√© +=.  L'avantage est que si l'on doit modifier ou corriger le comportement de l'addition, on n'a pas besoin de modifier l'op√©rateur binaire + puisqu'il est d√©fini en fonction de l'op√©rateur d'assignation compos√© +=.  ","version":"Next","tagName":"h3"},{"title":"Op√©rateurs de flux‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-de-flux","content":" Les op√©rateurs de flux permettent de d√©finir comment afficher une structure ou la lire depuis un flux (comme std::cout ou std::cin). Par exemple, on peut d√©finir l'op√©rateur &lt;&lt; pour notre structure Point qui permet d'afficher un point dans un flux.  struct Point { int x; int y; }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; ')'; }   L'op√©rateur &lt;&lt; prend en premier param√®tre un flux de sortie (std::ostream&amp;) et en deuxi√®me param√®tre un point (Point const&amp;). Il retourne le flux de sortie pour pouvoir faire des op√©rations en cha√Æne.   Op√©rateur &gt;&gt; Il existe aussi l'op√©rateur &gt;&gt; qui permet de lire depuis un flux pour construire une structure. Il se d√©finit ainsi: std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Point&amp; p) { // gestion de la lecture is &gt;&gt; p.x &gt;&gt; p.y; if( /* Erreur, impossible de construire notre structure */ ) { is.setstate(std::ios::failbit); } return is; } Notez que dans ce cas il faut signaler si l‚Äôentr√©e est invalide en mettant le flux dans un √©tat invalide avec std::ios::failbit, ce qui permet √† l‚Äôutilisateur de faire if (std::cin.fail()).  Ces op√©rateurs s‚Äô√©crivent toujours sous la forme libre car leur premier argument est toujours un flux.  Op√©rateur de flux pour les vecteurs Voil√† un exemple suppl√©mentaire pour impl√©menter l'op√©rateur de flux pour un vecteur (que je prends en r√©f√©rence constante pour √©viter de le copier). #include &lt;iostream&gt; #include &lt;vector&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::vector&lt;int&gt; const&amp; array) { os &lt;&lt; &quot;[ &quot;; for (size_t i {0}; i&lt;array.size()-1; ++i) { os &lt;&lt; array[i] &lt;&lt; &quot;, &quot;; } os &lt;&lt; array[array.size()-1] &lt;&lt; &quot;]&quot;; return os; } Il est m√™me possible de faire mieux avec une fonctionnalit√© avanc√©e de C++ qui permet de d√©finir une fonction &quot;g√©n√©rique&quot; pour n'importe quel type de vecteur. Cela permet de ne pas avoir √† red√©finir l'op√©rateur pour chaque type de vecteur. Je vous donne le code afin que vous puissiez l'utiliser si vous en avez besoin. Vous n'avez pas besoin de comprendre le code pour l'instant. Vous apprendrez √† manipuler les templates l'ann√©e prochaine. #include &lt;iostream&gt; #include &lt;vector&gt; template&lt;typename T&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::vector&lt;T&gt; const&amp; array) { os &lt;&lt; &quot;[ &quot;; for (size_t i {0}; i&lt;array.size()-1; ++i) { os &lt;&lt; array[i] &lt;&lt; &quot;, &quot;; } os &lt;&lt; array[array.size()-1] &lt;&lt; &quot;]&quot;; return os; } astuce En C++20 il est possible de passer par la fonction std::format qui permet de formater une cha√Æne de caract√®res et supporte les vecteurs. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;format&gt; int main() { std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; std::cout &lt;&lt; std::format(&quot;{}&quot;, v) &lt;&lt; std::endl; }   ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'affectation par copie‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-daffectation-par-copie","content":" Parfois, on a besoin de copier une structure. Pas seulement √† l'initialisation (dans ce cas l√† on peut utiliser la syntaxe d'initialisation {}), mais on a besoin d'affecter une nouvelle valeur √† une structure d√©j√† existante.  Point const point {3, 4}; Point copie {1, 1}; // ... copie = point;   Pour faire cela il faut d√©finir l'op√©rateur d'affectation par copie =. Cet op√©rateur est appel√© quand on affecte une valeur √† une structure d√©j√† existante.   struct Point { int x; int y; Point&amp; operator=(Point const&amp; b) { x = b.x; y = b.y; return *this; } };   C'est int√©ressant de le d√©finir s'il a un comportement sp√©cifique √† notre structure. Sinon, il est pr√©f√©rable de ne pas le d√©finir car il y a d√©j√† un op√©rateur d'affectation par copie par d√©faut qui fait une copie membre √† membre. Ce qui correspond souvent √† ce que l'on veut (c'est le cas pour notre structure Point).  ","version":"Next","tagName":"h2"},{"title":"Quelques bonnes pratiques‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#quelques-bonnes-pratiques","content":" Il est important de garder en t√™te que la surcharge d'op√©rateurs est une facilit√© et non une n√©cessit√©. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Il est aussi important de respecter la s√©mantique des op√©rateurs. Par exemple, l'op√©rateur + doit faire une addition et non une soustraction. Si un op√©rateur a une s√©mantique d√©j√† d√©finie pour un domaine, tenez vous-y. Si la signification de l'op√©rateur n'est pas √©vidente et indiscutable, il faut √©viter de le surcharger. Il est pr√©f√©rable de d√©finir une m√©thode explicite dans les cas o√π la s√©mantique n'est pas √©vidente. Si pour une raison ou une autre, vous devez surcharger un op√©rateur qui n'a pas de s√©mantique √©vidente, il faut le commenter absolument. Enfin, certains op√©rateurs sont li√©s entre eux. Par exemple, si vous surchargez l'op√©rateur ==, il est conseill√© de surcharger l'op√©rateur != (en fonction de == si possible). De m√™me, si vous surchargez l'op√©rateur &lt;, les utilisateurs de votre structure s'attendront √† ce que les op√©rateurs &gt;, &lt;= et &gt;= soient d√©finis √©galement.  ","version":"Next","tagName":"h2"},{"title":"D'autres op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#dautres-op√©rateurs","content":" On peut aussi surcharger les op√©rateurs [] et () pour d√©finir un acc√®s √† un √©l√©ment de notre structure ou les op√©rateurs -- et ++ pour d√©finir un incr√©ment ou un d√©cr√©ment.  Il existe de nombreux op√©rateurs que l'on peut surcharger mais le principe reste le m√™me.  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#r√©sum√©","content":" On peut d√©finir des op√©rateurs pour nos structures, c'est ce que l'on appelle la surcharge d'op√©rateurs.Pour d√©finir un op√©rateur, on utilise le mot cl√© operator suivi du symbole de l'op√©rateur. Par exemple, pour d√©finir l'op√©rateur +, on utilise operator+.Les op√©rateurs permettent de donner du sens √† nos structures et de les manipuler comme si elles √©taient des types de base. Cela donne de la s√©mantique √† nos structures.C'est int√©ressant de r√©utiliser les op√©rateurs entre eux. Par exemple, on peut d√©finir l'op√©rateur + en fonction de l'op√©rateur +=.L'expression *this permet de retourner une r√©f√©rence sur l'instance courante pour pouvoir faire des op√©rations en cha√Æne.Il est important de garder en t√™te que la surcharge d'op√©rateurs est une facilit√© et non une n√©cessit√©. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est pr√©f√©rable de d√©finir une m√©thode avec un nom explicite.On peut surcharger les op√©rateurs de flux &lt;&lt; et &gt;&gt; pour d√©finir comment afficher une structure ou la lire depuis un flux.Vous trouverez la page de documentation sur la surcharge d'op√©rateurs ici. ","version":"Next","tagName":"h2"},{"title":"Algorithmique et Programmation S1","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet","content":"","keywords":"","version":"Next"},{"title":"Aide pr√©liminaire‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#aide-pr√©liminaire","content":" Il faut inclure la biblioth√®que iostream pour utiliser std::cout et std::endl qui permettent respectivement d'afficher du texte et de passer √† la ligne.Il faut inclure respectivement les biblioth√®ques string, vector et array pour utiliser std::string, std::vector et std::array.Pour convertir un type en un autre (cast), il faut utiliser la syntaxe suivante:  std::static_cast&lt;type&gt;(variable)   Pour compiler manuellement un programme, il faut utiliser la commande g++ suivie du nom du fichier source et de l'option -o suivie du nom du fichier ex√©cutable √† g√©n√©rer (ex: g++ main.cpp -o main). Nous pr√©ciserons en plus l'option -Wall pour afficher les warnings (messages d'avertissement) et l'option -std=c++17 pour utiliser la version C++17 du langage.Ligne de compilation (pour un fichier ex02.cpp):  g++ ex02.cpp -o ex02 -Wall -std=c++17   ","version":"Next","tagName":"h2"},{"title":"Exercice 1 (questionnaire) (3Pts: 4 questions de 0.75)‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#exercice-1-questionnaire-3pts-4-questions-de-075","content":" Quelle est la diff√©rence entre un tableau statique et un tableau dynamique ?Quelle est la diff√©rence entre l'op√©rateur = et l'op√©rateur == ?Qu‚Äôentendez-vous par passage par copie et passage par r√©f√©rence(&amp;) ?A quoi servent les mots cl√©s const et unsigned ? Quand et pourquoi les utiliser ?  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (maximum) (2Pts)‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#exercice-2-maximum-2pts","content":" √âcrire une fonction max qui prend en param√®tre (par r√©f√©rence constante) un tableau d'entiers (tu es libre d'utiliser un tableau dynamique (std::vector) ou statique (std::array) ) et retourne la valeur maximale du tableau. Utiliser la fonction max pour afficher la valeur maximale des tableaux suivants: {1, 2, 3, 4, 5, 6, 7, 8, 9}{9, 8, 7, 6, 5, 4, 3, 2, 1}{1, 23, 7, 32, 5, 43}  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (voyelles) (3Pts)‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#exercice-3-voyelles-3pts","content":" √âcrire une fonction isVowel qui prend en param√®tre un caract√®re et retourne true si le caract√®re est une voyelle, false sinon. On consid√®re que le caract√®re est une voyelle si c'est un des caract√®res suivants: a, e, i, o, u ou y. Attention, il faut compter les voyelles en majuscules et en minuscules. On peut utiliser la fonction std::tolower (de la biblioth√®que cctype) pour convertir un caract√®re en minuscule. On peut √©galement utiliser la repr√©sentation ASCII.  Quelques codes ASCII utiles:  A ‚Üí\\rightarrow‚Üí Z\t0 ‚Üí\\rightarrow‚Üí 9\ta ‚Üí\\rightarrow‚Üí z65 ‚Üí\\rightarrow‚Üí 90\t48 ‚Üí\\rightarrow‚Üí 57\t97 ‚Üí\\rightarrow‚Üí 122  √âcrire une fonction countVowels qui prend en param√®tre une cha√Æne de caract√®res (std::string) et retourne le nombre de voyelles dans la cha√Æne.Afficher le nombre de voyelles dans les cha√Ænes suivantes: Hello World!Ceci est un testJe suis une phrase avec des voyelles  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (G√©om√©trie) (2,5Pts + 1Pts bonus)‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#exercice-4-g√©om√©trie-25pts--1pts-bonus","content":" On dispose de la structure Point suivante:  struct Point { float x; float y; };   √âcrire une fonction distance qui prend en param√®tre deux points et retourne la distance entre les deux points.  On utilisera la signature suivante:  float distance(Point const&amp; p1, Point const&amp; p2);   Pour rappel, la distance entre deux points p1 et p2 est √©gale √† la racine carr√©e de la somme des carr√©s des diff√©rences des coordonn√©es des points. distance=(p1.x‚àíp2.x)2+(p1.y‚àíp2.y)2\\text{distance} = \\sqrt{(p1.x - p2.x)^2 + (p1.y - p2.y)^2}distance=(p1.x‚àíp2.x)2+(p1.y‚àíp2.y)2‚Äã  Vous pouvez utiliser les fonctions sqrt et pow de la biblioth√®que cmath pour calculer la racine carr√©e et la puissance d'un nombre.  #include &lt;cmath&gt; float sqrt_test { std::sqrt(4) }; // racine carr√©e de 4 = 2 float pow_test { std::pow(2, 3) }; // 2^3 = 8   On consid√©rera que la fonction pr√©c√©dente fonctionne pour la suite de l'exercice si ce n'est pas le cas.  √âcrire une fonction isInCircle qui prend en param√®tre un point (p), le centre d'un cercle (center) et son rayon (radius) et retourne true si le point p est dans le cercle, false sinon.  On utilisera la signature suivante:  bool isInCircle(Point const&amp; p, Point const&amp; center, float radius);   Utiliser la fonction isInCircle pour afficher si les points suivants sont dans le cercle de centre (0, 1) et de rayon 2.4f: (0, 0)(1, 1)(3, 4) (BONUS) √âcrire une fonction isCirclesIntersect qui prend en param√®tre deux cercles (sous la forme de deux points et deux rayons) et retourne true si les deux cercles s'intersectent, false sinon.  Deux cercles s'intersectent si leurs centres sont √† une distance inf√©rieure √† la somme de leur rayon.  (BONUS) D√©finir un structure Circle qui contiendra les attributs suivants: center : centre du cercle (utiliser la structure Point)radius : rayon du cercle R√©√©crire les deux fonctions pr√©c√©dentes (surcharge) en utilisant la structure Circle √† la place des param√®tres Point et float. (BONUS) Utiliser la fonction isCirclesIntersect pour afficher si les deux cercles suivants s'intersectent: Cercle 1: centre (0, 0), rayon 1Cercle 2: centre (2, 0), rayon 1  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Robot) (7.5Pts (10 questions de 0.75) + 1Pts bonus)‚Äã","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/sujet#exercice-6-robot-75pts-10-questions-de-075--1pts-bonus","content":" Pour cet exercice, je vous fourni un dossier d√©di√© √† l'exercice.  Ce dossier contient un sous-dossier src avec les fichiers sources ainsi qu'un fichier CMakeLists.txt pour compiler le programme.  la structure du dossier ressemble √† √ßa:  robot/ L src/ | L main.cpp | L direction.cpp | L direction.hpp | L point.cpp | L point.hpp | L robot.cpp | L robot.hpp L CMakeLists.txt   Compilation manuelle avec cmake‚Äã Ouvrir un terminal dans le dossier robot contenant le fichier CMakeLists.txt et ex√©cuter les commandes suivantes: mkdir build : cr√©er un dossier build (qui va servir √† stocker les fichiers de compilation)cd build : se d√©placer dans le dossier buildcmake .. : g√©n√©rer les fichiers de compilation dans le dossier build √† partir du fichier CMakeLists.txt du dossier parentmake : compiler le programme (g√©n√©rer l'ex√©cutable √† partir des fichiers de compilation Makefile)./main : ex√©cuter le programme (remplacer main par le nom de l'ex√©cutable g√©n√©r√©) (dans notre cas le cmake est configur√© pour g√©n√©rer un ex√©cutable robot dans le dossier bin on peut donc ex√©cuter le programme depuis le dossier build avec la commande ../bin/robot) &quot;..&quot; signifie le dossier parent. &quot;.&quot; signifie le dossier courant.  Le fichier direction.hpp contient un enum Direction avec les valeurs suivantes : north (Nord)south (Sud)east (Est)west (Ouest) Cr√©er le prototype d'une fonction to_string dans le fichier direction.hpp qui prends en param√®tre une direction et retourne une cha√Æne de caract√®res (std::string) repr√©sentant cette Direction (ex: Direction::north ‚Üí\\rightarrow‚Üí &quot;north&quot;). Cr√©er la d√©finition de la fonction to_string dans le fichier direction.cpp. D√©finir une structure Point dans le fichier point.hpp. Elle contiendra les attributs suivants : x : position en x (utiliser le type int)y : position en y (utiliser le type int) La structure devra contenir les m√©thodes suivantes : void display() : affiche les coordonn√©es du point sous la forme (x, y).void move(Direction const d, unsigned int const n) : d√©place le point de n cases dans la direction d. Impl√©menter les m√©thodes de la structure Point dans le fichier point.cpp.  On consid√®re que la direction north correspond √† une augmentation de la coordonn√©e y (south une diminution de y) et que la direction east correspond √† une augmentation de la coordonn√©e x (west une diminution de x). y‚Üë‚Üíx\\begin{aligned} y &amp; \\\\ \\uparrow &amp; \\\\ &amp; \\rightarrow x \\\\ \\end{aligned}y‚Üë‚Äã‚Üíx‚Äã  Cr√©er une structure Robot dans le fichier robot.hpp qui contiendra les attributs suivants : name : nom du robot (std::string)position : position du robot (utiliser la structure Point)direction : direction du robot (utiliser l'enum Direction) La structure devra contenir les m√©thodes suivantes : void display() : affiche les informations du robot sous la forme name((x, y), direction).void turnLeft() : tourne le robot de 90¬∞ vers la gauche. (ex: north devient west)void turnRight() : tourne le robot de 90¬∞ vers la droite.void move(unsigned int const n) : d√©place le robot de n cases dans la direction du robot. Impl√©menter les m√©thodes de la structure Robot dans le fichier robot.cpp. Ajouter le prototype d'une fonction createRobotName dans le fichier robot.hpp, elle retournera un nom de robot g√©n√©r√© al√©atoirement sous la forme d'une cha√Æne de caract√®re avec un format contenant 2 lettres majuscules suivies de 3 chiffres al√©atoires. (ex: AB123). √âcrire la d√©finition de la fonction createRobotName dans le fichier robot.cpp.  Pour g√©n√©rer un nombre al√©atoire, on peut utiliser la fonction std::rand (elle retourne un nombre al√©atoire entre 0 et RAND_MAX).  On utilisera la fonction std::srand pour initialiser le g√©n√©rateur de nombres al√©atoires avec la fonction std::time pour que les nombres g√©n√©r√©s soient diff√©rents √† chaque ex√©cution du programme.  Pour g√©n√©rer une lettre al√©atoire, on peut utiliser la fonction rand et l'op√©rateur modulo (%) pour g√©n√©rer un nombre al√©atoire entre 0 et 25:  #include &lt;cstdlib&gt; // pour utiliser la fonction std::rand #include &lt;ctime&gt; // pour utiliser la fonction std::time int main() { // initialiser le g√©n√©rateur de nombres al√©atoires // A utiliser une seule fois dans le programme (dans le main par exemple) std::srand(std::time(nullptr)); // g√©n√©rer un nombre al√©atoire entre 0 et 25 (+1 pour inclure 25) int random_number { std::rand() % (25+1) }; return 0; }   On peut se servir de ce nombre pour g√©n√©rer une lettre majuscule (en utilisant la repr√©sentation ASCII des lettres majuscules). Quelques codes ASCII utiles sont indiqu√©s √† l'exercice 3.  Ajouter le prototype d'une fonction createRobot dans le fichier robot.hpp, elle prendra en param√®tre un point et une direction et retournera un robot avec les param√®tres pass√©s en argument. le nom du robot sera g√©n√©r√© al√©atoirement avec la fonction createRobotName. Compl√©ter la fonction main du fichier main.cpp pour effectuer les actions suivantes:  Cr√©er un robot avec la fonction createRobot √† la position (0, 0) et la direction initiale north.Afficher le robot avec la m√©thode display.Effectuer les actions suivantes et afficher la valeur du robot avec la m√©thode displayune fois les actions effectu√©es: Tourner le robot √† gaucheD√©placer le robot de 3 casesTourner le robot √† droiteD√©placer le robot de 5 casesD√©placer le robot de 2 casesTourner deux fois le robot √† gaucheD√©placer le robot de 1 caseTourner le robot √† droiteD√©placer le robot de 2 cases  Utiliser les m√©thodes de la structure Robot pour effectuer les actions.  (Bonus) Utiliser un tableau pour stocker les actions √† effectuer et les ex√©cuter dans une boucle.  Vous pouvez utiliser des caract√®res (avec une std::string (qui est un tableau de caract√®res) ou un std::vector) pour symboliser les actions √† effectuer: L : tourner √† gaucheR : tourner √† droite3 : d√©placer le robot de 3 cases (de m√™me pour tout les autres chiffres)Seulement les chiffres 1 √† 9 sont √† consid√©r√©s, ainsi &quot;12&quot; correspond √† un d√©placement de 1 case puis un autre de 2 cases. ","version":"Next","tagName":"h2"},{"title":"Algorithmes de tri, complexit√© et recherche dichotomique","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Sorting","content":"","keywords":"","version":"Next"},{"title":"Tri par comparaison‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-comparaison","content":" Les premiers algorithmes de tri que nous allons voir sont des algorithmes de tri par comparaison (Comparison based strategies).  Ils consistent √† comparer deux √† deux les √©l√©ments du tableau puis de les √©changer ou non en fonction du r√©sultat de la comparaison.  ","version":"Next","tagName":"h2"},{"title":"Tri par s√©lection (selection sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-s√©lection-selection-sort","content":" L'algorithme de tri par s√©lection est un algorithme de tri qui consiste √† trouver le plus petit √©l√©ment du tableau, et √† le placer en premi√®re position (ou le plus grand √©l√©ment en derni√®re position). On r√©p√®te cette op√©ration jusqu'√† ce que le tableau soit tri√©.  Un exemple, avec le tableau suivant [6, 2, 8, 1, 5, 3, 9]:  On, parcourt le tableau pour trouver le plus petit √©l√©ment qui est 1. Son indice est 3, on l'√©change avec l'√©l√©ment √† l'indice 0 (le premier √©l√©ment du tableau). 1\t2\t8\t6\t5\t3\t9 Le premier √©l√©ment du tableau est d√©sormais le plus petit √©l√©ment du tableau. On recommence l'op√©ration, mais en ignorant le premier √©l√©ment du tableau, car il est d√©j√† tri√©. info Toute l'astuce de cet algorithme est donc de trier un sous-tableau plus petit √† chaque it√©ration jusqu'√† ce que le tableau soit tri√©.  Voil√† les it√©rations suivantes:  Le deuxi√®me plus petit √©l√©ment est 2, il est d√©j√† √† la bonne place, on ne fait rien. 1\t2\t3\t6\t5\t8\t9 1\t2\t3\t5\t6\t8\t9 Il reste trois √©l√©ments √† trier ([6, 8, 9]), il sont d√©j√† tri√©s, on ne fait rien.  Voil√†, le tableau est tri√©.    ","version":"Next","tagName":"h3"},{"title":"Tri √† bulles (bubble sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-√†-bulles-bubble-sort","content":" Le tri √† bulles est un autre algorithme de tri tr√®s connu. Il consiste √† comparer deux √† deux les √©l√©ments du tableau, et √† les √©changer si ils ne sont pas dans le bon ordre. On r√©p√®te cette op√©ration jusqu'√† ce que le tableau soit tri√©.  remarque Cela va avoir pour effet de faire &quot;remonter&quot; les plus grands √©l√©ments du tableau vers la fin du tableau, comme des bulles d'air qui remontent √† la surface.  Un exemple, avec le m√™me tableau [6, 2, 8, 1, 5, 3, 9]:  On compare les deux premiers √©l√©ments du tableau, 6 et 2. Comme 6 est plus grand que 2, on les √©change. 2\t6\t8\t1\t5\t3\t9  On recommence l'op√©ration avec les deux √©l√©ments suivants, 6 et 8. Comme 6 est plus petit que 8, on ne fait rien. On proc√®de ainsi jusqu'√† la fin du tableau.  On obtient apr√®s un premier passage sur l'ensemble du tableau:  2\t6\t1\t5\t3\t8\t9  On recommence l'op√©ration, mais en ignorant le dernier √©l√©ment du tableau, car il est d√©j√† tri√©.  Voil√† les it√©rations suivantes:  2\t1\t5\t3\t6\t8\t9 1\t2\t3\t5\t6\t8\t9 Dernier passage, aucun √©change n'est effectu√©. Le tableau est tri√©.    ","version":"Next","tagName":"h3"},{"title":"Parlons un peu de complexit√©‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#parlons-un-peu-de-complexit√©","content":" La complexit√© d'un algorithme est une mesure de la quantit√© de ressources (temps, m√©moire, etc) que celui-ci va utiliser pour s'ex√©cuter.  En g√©n√©ral, on s'int√©resse √† la complexit√© en fonction de la taille des donn√©es en entr√©e de l'algorithme.  Il existe plusieurs types de complexit√©, la plus souvent utilis√©e est la complexit√© en temps.  Cela revient √† se poser la question:  Si je donne √† mon programme une entr√©e de taille n, quel est l'ordre de grandeur (en fonction de n) du nombre d'op√©rations qu'il va effectuer ?  remarque La complexit√© permet de quantifier la relation entre les conditions de d√©part et le temps effectu√© par l'algorithme.  ","version":"Next","tagName":"h2"},{"title":"Op√©rations de base‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#op√©rations-de-base","content":" Pour &quot;compter les op√©rations&quot;, il faut d√©cider de ce qu'est une op√©ration. Ce choix d√©pend du probl√®me (et m√™me de l'algorithme) consid√©r√©. Il faut en fait choisir soi-m√™me quelques petites op√©rations que l'algorithme effectue souvent, et que l'on veut utiliser comme op√©rations de base pour mesurer la complexit√©. Les op√©rations qui caract√©risent le mieux l'algorithme et repr√©sentent le mieux le temps d'ex√©cution de celui-ci. Les op√©rations de base sont souvent les op√©rations arithm√©tiques, les comparaisons, les affectations, etc. Par exemple, pour un algorithme de tri, on va compter le nombre de comparaisons et d'√©changes d'√©l√©ments du tableau.  En fonction des algorithmes, certaines op√©rations peuvent √™tre plus significatives que d'autres. Par exemple, la multiplication est plus co√ªteuse que l'addition, on peut donc ne consid√©rer que les op√©rations de multiplication pour mesurer la complexit√© d'un algorithme.  info On ne compte pas les op√©rations qui ne d√©pendent pas de la taille des donn√©es en entr√©e (comme l'initialisation de variables, etc). Ces op√©rations sont consid√©r√©es comme constantes et pas significatives pour la complexit√© en fonction de la taille des donn√©es en entr√©e.  ","version":"Next","tagName":"h3"},{"title":"Notation \"grand O\"‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#notation-grand-o","content":" On exprime la complexit√© en fonction de la taille des donn√©es en entr√©e avec la notation &quot;grand O&quot;. La notation &quot;grand O&quot; est une notion math√©matique qui permet d'exprimer un ordre de grandeur.  Par exemple, des algorithmes effectuant environ nnn op√©rations, 2n+202n+202n+20 op√©rations ou n/2n/2n/2 op√©rations ont tous la m√™me complexit√© : on la note O(n)O(n)O(n) (lire &quot;grand O de nnn&quot;). De m√™me, un algorithme en 3n2+4n+23n^2 + 4n + 23n2+4n+2 op√©rations aura une complexit√© de O(n2)O(n^2)O(n2) : on n√©glige les termes de plus faible degr√© (ici 4n4n4n et 222) et les coefficients (ici 333). On cherche seulement √† savoir comment √©volue le nombre d'op√©rations en fonction de la taille des donn√©es en entr√©e et on consid√®re le terme de plus haut degr√© qui est celui qui va cro√Ætre le plus vite en fonction de la taille des donn√©es en entr√©e.  VOil√† un graphique r√©capitulatif des diff√©rentes notations &quot;grand O&quot; communes:    ","version":"Next","tagName":"h3"},{"title":"Exemple de calcul de complexit√©‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#exemple-de-calcul-de-complexit√©","content":" Prenons l'exemple du tri par s√©lection.  Pour trier un tableau de taille nnn, premi√®rement on parcourt le tableau pour trouver le plus petit √©l√©ment, on va donc effectuer nnn comparaisons.  Ensuite, on va √©changer cet √©l√©ment avec le premier √©l√©ment du tableau, on va donc effectuer 111 √©change.  Ensuite on va recommencer l'op√©ration, mais en ignorant le premier √©l√©ment du tableau, car il est d√©j√† tri√©.  On va donc effectuer n‚àí1n-1n‚àí1 comparaisons et 111 √©change.  On va faire cela jusqu'√† ce que le tableau soit tri√©, donc jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment √† trier.  Pour r√©sumer, on va effectuer pour les diff√©rentes it√©rations:  nnn comparaisons et 111 √©changen‚àí1n-1n‚àí1 comparaisons et 111 √©changen‚àí2n-2n‚àí2 comparaisons et 111 √©change...111 comparaison et 111 √©change  On peut donc calculer le nombre total de comparaisons et d'√©changes effectu√©s par l'algorithme:  =(n+1)+((n‚àí1)+1)+((n‚àí2)+1)+...+(1+1)=(n+(n‚àí1)+‚ãØ+1)+(1+‚ãØ+1)=n(n+1)2+n=n2+3n2\\begin{align*} = &amp; (n+1) + ((n-1)+1) + ((n-2)+1) + ... + (1+1) \\\\ = &amp; (n + (n-1) + \\dots + 1) + (1 + \\dots + 1) \\\\ = &amp; \\frac{n(n+1)}{2} + n \\\\ = &amp; \\frac{n^2 + 3n}{2} \\\\ \\end{align*}====‚Äã(n+1)+((n‚àí1)+1)+((n‚àí2)+1)+...+(1+1)(n+(n‚àí1)+‚ãØ+1)+(1+‚ãØ+1)2n(n+1)‚Äã+n2n2+3n‚Äã‚Äã  Ici, j'ai compt√© de mani√®re exacte le nombre d'op√©rations effectu√©es par l'algorithme, mais en g√©n√©ral on s'int√©resse √† la complexit√© en fonction de la taille des donn√©es en entr√©e.  On va donc garder uniquement le terme de plus haut degr√©, ici n2n^2n2.  On dit que la complexit√© du tri par s√©lection est en O(n2)O(n^2)O(n2).  info On peut aussi √©valuer cette complexit√© sans calcul exact, mais plut√¥t en estimant le nombre d'op√©rations effectu√©es par l'algorithme. On peut voir que l'algorithme doit √† chaque it√©ration parcourir le tableau, c'est ce qui va prendre le plus de temps et d√©pendra de la taille du tableau. Chaque it√©ration va permettre de trier un √©l√©ment du tableau, donc on va effectuer nnn it√©rations. On peut donc estimer que la complexit√© du tri par s√©lection est en O(n√ón)=O(n2)O(n \\times n) = O(n^2)O(n√ón)=O(n2).  ","version":"Next","tagName":"h3"},{"title":"Complexit√© dans le pire des cas‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-dans-le-pire-des-cas","content":" Le nombre d'op√©rations effectu√©es par un algorithme peut d√©pendre de la taille des donn√©es en entr√©e, mais aussi des donn√©es elles-m√™mes.  Par exemple, dans le cadre d'un tri √† bulles, si le tableau est d√©j√† tri√©, on n'effectuera aucune op√©ration d'√©change, et seulement nnn comparaisons.  On peut donc dire que la complexit√© du tri √† bulles est en O(n)O(n)O(n) dans le meilleur des cas.  Mais si le tableau est tri√© dans l'ordre inverse, on va effectuer nnn comparaisons et nnn √©changes √† chaque it√©ration, et on va effectuer nnn it√©rations.  On peut donc dire que la complexit√© du tri √† bulles est en O(n√ón)=O(n2)O(n \\times n) = O(n^2)O(n√ón)=O(n2) dans le pire des cas.  remarque C'est int√©ressant de consid√©rer la complexit√© dans le pire des cas, car elle permet de savoir si l'algorithme est efficace pour toutes les donn√©es possibles. En g√©n√©ral pour des donn√©es quelconques, c'est en g√©n√©ral assez proche du comportement dans le pire des cas.  ","version":"Next","tagName":"h3"},{"title":"Complexit√© en moyenne‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-en-moyenne","content":" On peut aussi s'int√©resser √† la complexit√© en moyenne, c'est-√†-dire la complexit√© sur toutes les donn√©es possibles.  Par exemple, pour le tri √† bulles, la complexit√© en moyenne est en O(n2)O(n^2)O(n2).  Il existe des algorithmes qui ont une complexit√© en moyenne bien meilleure que leur complexit√© dans le pire des cas. Cela d√©pend du probl√®me consid√©r√© et demande une analyse plus fine de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Complexit√© en m√©moire‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-en-m√©moire","content":" On peut aussi s'int√©resser √† la complexit√© en m√©moire d'un algorithme. Autrement dit, combien de m√©moire va utiliser l'algorithme en fonction de la taille des donn√©es en entr√©e.  C'est aussi une mesure de la complexit√© pertinente.  Si par exemple on a besoin de trier un tableau de 1000 √©l√©ments, on peut se dire que la complexit√© en temps n'est pas tr√®s importante, car l'algorithme va s'ex√©cuter tr√®s rapidement. Mais si l'algorithme utilise beaucoup de m√©moire, cela peut poser probl√®me, car il peut ne pas avoir assez de m√©moire disponible pour ex√©cuter l'algorithme.  Dans la plupart des cas, la complexit√© en m√©moire est beaucoup plus simple √† calculer que la complexit√© en temps.  Mais dans des probl√®mes plus compliqu√©s, la complexit√© en m√©moire et la complexit√© en temps peuvent √™tre li√©es.  On peut par exemple choisir de sacrifier un peu de rapidit√© d'ex√©cution pour utiliser moins de m√©moire, ou au contraire d'augmenter la vitesse en augmentant la complexit√© en m√©moire de notre algorithme, par exemple en stockant dans un tableau les r√©sultats d√©j√† calcul√©s (c'est le principe de la mise en cache, appel√©e aussi memoization).  remarque De nos jours, la complexit√© en m√©moire est moins importante qu'avant, car les ordinateurs ont beaucoup de m√©moire disponible. Dans la majorit√© des cas, on va donc plut√¥t s'int√©resser √† la complexit√© en temps. Mais la complexit√© en m√©moire reste importante dans certains cas avanc√©s ou avec des donn√©es tr√®s volumineuses.  ","version":"Next","tagName":"h3"},{"title":"Limitation de la complexit√©‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#limitation-de-la-complexit√©","content":" La complexit√© d'un algorithme est donc une mesure d'ordre de grandeur en fonction de la taille des donn√©es en entr√©e.  Cependant, il est important de garder √† l'esprit que la complexit√© ne permet pas de savoir si un algorithme est rapide ou lent.  M√™me si un algorithme √† une complexit√© plus faible qu'un autre, il peut √™tre plus (beaucoup plus) lent √† s'ex√©cuter qu'un autre algorithme pour des tailles de donn√©es en entr√©e faibles.  ","version":"Next","tagName":"h3"},{"title":"Tri diviser pour r√©gner (Divide-and-Conquer paradigm)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-diviser-pour-r√©gner-divide-and-conquer-paradigm","content":" Il existe d'autres algorithmes de tri plus efficaces que les algorithmes de tri par comparaison. Ils sont bas√©s sur le principe de diviser pour r√©gner (divide and conquer en anglais). L'id√©e est de diviser le probl√®me en sous-probl√®mes plus petits, de r√©soudre les sous-probl√®mes, puis de fusionner les solutions des sous-probl√®mes pour r√©soudre le probl√®me initial.  ","version":"Next","tagName":"h2"},{"title":"Tri fusion (merge sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-fusion-merge-sort","content":" Le tri fusion est un algorithme de tri qui consiste √† diviser le tableau en deux parties √©gales, trier les deux parties, puis fusionner les deux parties tri√©es.  Il y a donc deux &quot;phases&quot; dans cet algorithme:  la phase de division du tableau en deux parties √©galesla phase de fusion des deux parties tri√©es    Phase de division‚Äã  Pour la phase de division, on va choisir de diviser et trier le tableau en deux parties √©gales pour maximiser l'efficacit√© de l'algorithme (ou presque √©gales si le tableau a une taille impaire).  Il existe deux fa√ßons de proc√©der pour cibler les deux parties du tableau:  Cr√©er des tableaux interm√©diaires pour stocker les deux parties du tableau √† trier.Utiliser des indices pour d√©finir les parties du tableau √† trier, et trier directement le tableau en place.  La premi√®re m√©thode est plus simple √† comprendre, mais utilise plus de m√©moire, car il faut cr√©er des tableaux interm√©diaires (allocation de m√©moire suppl√©mentaire).  En pratique, on privil√©gie donc la deuxi√®me m√©thode, et c'est celle que je vais d√©tailler ici.  Pour trier un tableau, on va donc utiliser deux indices, un indice de d√©but et un indice de fin, qui vont d√©finir la partie du tableau √† trier.  Par exemple, pour le tableau [6, 2, 8, 1, 5, 3, 9], les indices 0 et 6 vont d√©finir le tableau complet. On va calculer la taille de la partie du tableau √† trier, ici 6 (indice de fin) - 0 (indice de d√©but) + 1 (car on compte l'√©l√©ment √† l'indice de fin), soit 7.  On va ensuite diviser cette taille par deux, soit 3 (on peut arrondir √† l'entier inf√©rieur).  On va donc trier les deux parties [6, 2, 8, 1] (des indices 0 √† 3) et [5, 3, 9] (des indices 4 √† 6). Enfin, la fusion des deux parties tri√©es va permettre d'obtenir le tableau tri√©.  info Cela fonctionne √† condition que l'algo de tri que l'on va utiliser pour trier les deux sous-tableaux fonctionne &quot;in-place&quot;, c'est-√†-dire qu'il trie directement le tableau en place sans utiliser de tableau interm√©diaire.  Phase de fusion‚Äã  C'est la phase de fusion qui est la plus int√©ressante, car c'est elle qui va permettre r√©ellement de trier le tableau.  Dans cette phase de fusion il est plus simple de copier les √©l√©ments dans deux sous-tableaux interm√©diaires, puis d'√©crire les √©l√©ments tri√©s dans le tableau final directement.  info Il existe des m√©thodes pour effectuer cette fusion sans copier les √©l√©ments dans des tableaux interm√©diaires, mais elles sont bien plus complexes √† mettre en oeuvre.  Pour fusionner deux tableaux tri√©s, on va utiliser deux (autres) indices, un indice pour chaque sous-tableau, qui vont permettre de parcourir les deux tableaux et de pointer vers les √©l√©ments les plus petits des deux tableaux.  On va comparer les deux √©l√©ments les plus petits des deux tableaux, et ajouter le plus petit des deux dans le tableau final.  On va incr√©menter l'indice du tableau dont on a ajout√© l'√©l√©ment, et on recommence l'op√©ration jusqu'√† ce qu'on ait parcouru les deux tableaux.  attention Il faut faire attention √† ne pas d√©passer la taille des sous-tableaux avec les indices, sinon on va avoir une erreur en essayant d'acc√©der √† un √©l√©ment qui n'existe pas. Il faut donc v√©rifier que les indices sont bien inf√©rieurs √† la taille des sous-tableaux. Si l'un des deux indices est √©gal √† la taille du sous-tableau, cela veut dire qu'on a parcouru tout le sous-tableau, et qu'il ne reste plus qu'√† ajouter les √©l√©ments du deuxi√®me sous-tableau dans le tableau final.  On obtient ainsi un tableau tri√©.  info La condition d'arr√™t de la r√©cursion est quand la taille de la partie du tableau √† trier est inf√©rieure ou √©gale √† 1, car un tableau de taille 1 est d√©j√† tri√© (de m√™me pour un tableau vide).    R√©cursion‚Äã  Dans l'exemple pr√©c√©dent, je n'ai pas d√©taill√© la phase de tri des deux sous-tableaux, on pourrait par exemple utiliser un tri pr√©c√©demment vu comme le tri par s√©lection pour trier les deux sous-tableaux.  Cela am√©liorerait la complexit√© de l'algorithme mais pas la tendance asymptotique de l'algorithme. En reprenant les calculs pr√©c√©dents (o√π on avait n2+3n2\\frac{n^2 + 3n}{2}2n2+3n‚Äã comparaisons et d'√©changes), cela nous donnerait:  =(n2)2+3(n2)2‚àó2=n24+3(n2)\\begin{align*} = &amp; \\frac{(\\frac{n}{2})^2 + 3(\\frac{n}{2})}{2} * 2 \\\\ = &amp; \\frac{n^2}{4} + 3(\\frac{n}{2}) \\\\ \\end{align*}==‚Äã2(2n‚Äã)2+3(2n‚Äã)‚Äã‚àó24n2‚Äã+3(2n‚Äã)‚Äã  C'est bien inf√©rieur √† la complexit√© du tri par s√©lection initial, mais cela reste en O(n2)O(n^2)O(n2).  Mais on pourrait tr√®s bien de nouveau utiliser le tri fusion pour trier les sous-tableaux, et ainsi de suite.  L'algorithme de tri fusion est un algorithme r√©cursif, c'est-√†-dire qu'il s'appelle lui-m√™me pour trier les sous-tableaux.  Cela reviens √† diviser le tableau en deux parties √©gales, puis chaque partie en deux parties √©gales, etc, jusqu'√† ce qu'on ait des sous-tableaux de taille 1 ou 0 puis fusionner les sous-tableaux 2 √† 2 pour obtenir le tableau tri√©.  C'est un algorithme tr√®s efficace, en faisant cela, on va trier le tableau en O(nlog‚Å°n)O(n \\log n)O(nlogn) op√©rations, ce qui est beaucoup plus efficace que les algorithmes de tri par comparaison.  info Il est plus efficace cependant les copies effectu√©es pour l'√©tape de fusion des tableaux interm√©diaires tri√©s peuvent √™tre co√ªteuses et impacter la complexit√© (en m√©moire) de l'algorithme. On va d√©couvrir un autre algorithme de tri qui √† la m√™me complexit√© en temps que le tri fusion mais qui ne n√©cessite pas de copies interm√©diaires (En TDs, si vous les impl√©mentez tout les deux je vous sugg√®re de comparer les deux algorithmes pour vous rendre compte de la diff√©rence de performance).    ","version":"Next","tagName":"h3"},{"title":"Tri rapide (quick sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-rapide-quick-sort","content":" Le tri rapide est un algorithme de tri qui consiste √† choisir un √©l√©ment du tableau, appel√© pivot, et √† placer tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot.  On r√©p√®te ensuite l'op√©ration sur les deux sous-tableaux, jusqu'√† ce que le tableau soit tri√©.  De la m√™me mani√®re que pour le tri fusion, c'est un algorithme r√©cursif et on va donc utiliser des indices pour d√©finir les parties du tableau √† trier.  Il y a √©galement deux phases dans cet algorithme:  la phase de division du tableau en deux parties en fonction du pivotla phase de tri des deux parties  Phase de division‚Äã  Choix du pivot‚Äã  Le choix du pivot est tr√®s important, car il va d√©terminer la complexit√© de l'algorithme.  Si on choisit un pivot qui est toujours le plus petit √©l√©ment du tableau, on va avoir une complexit√© en O(n2)O(n^2)O(n2), car on va devoir parcourir tout le tableau √† chaque it√©ration (de m√™me si on choisit le plus grand √©l√©ment du tableau).  Il existe plusieurs m√©thodes pour choisir le pivot, la plus simple est de choisir le premier ou le dernier √©l√©ment du tableau. Mais cela peut √™tre probl√©matique si le tableau est d√©j√† tri√© car on va diviser le tableau en deux parties de tailles tr√®s diff√©rentes.  info L'id√©al est de choisir un pivot qui est proche de la valeur m√©diane du tableau, c'est-√†-dire qui va diviser le tableau en deux parties √©gales. Il existe plusieurs m√©thodes pour choisir un pivot proche de la valeur m√©diane du tableau, mais elles sont plus compliqu√©es √† mettre en oeuvre.  Partitionnement‚Äã  Une fois le pivot choisi, on va parcourir le tableau et placer tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot.  Il y a plusieurs approches pour g√©rer le pivot, dans notre cas, on va choisir de premi√®rement placer le pivot √† la fin du tableau. Ou tout simplement choisir le pivot comme √©tant le dernier √©l√©ment du tableau.  On va s'aider d'un indice qui va nous indiquer le premier √©l√©ment plus grand que le pivot et qui va nous permettre de placer le pivot √† sa place d√©finitive.  On va ensuite parcourir le tableau pour placer les √©l√©ments plus petits que le pivot √† gauche du pivot, et les √©l√©ments plus grands que le pivot √† droite du pivot.  Si l'√©l√©ment que l'on parcourt est plus petit que le pivot, on va l'√©changer avec l'√©l√©ment √† l'indice du premier √©l√©ment plus grand que le pivot, et on va incr√©menter l'indice du premier √©l√©ment plus grand que le pivot.  Une fois qu'on a parcouru tout le tableau, on va √©changer le pivot avec l'√©l√©ment √† l'indice du premier √©l√©ment plus grand que le pivot pour que le pivot soit √† sa place d√©finitive (entre les √©l√©ments plus petits et les √©l√©ments plus grands).  Enfin, on va renvoyer l'indice du pivot pour pouvoir appeler r√©cursivement l'algorithme sur les deux sous-tableaux.  R√©cursion‚Äã  On obtient ainsi un tableau avec le pivot √† sa place d√©finitive, et tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot et on conna√Æt l'indice du pivot.  On va donc pouvoir appeler r√©cursivement l'algorithme sur les deux sous-tableaux, en ignorant la place du pivot.  ","version":"Next","tagName":"h3"},{"title":"Tri par d√©nombrement (counting sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-d√©nombrement-counting-sort","content":" IL existe encore d'autres algorithmes de tri, mais ils sont plus sp√©cifiques et ne fonctionnent que dans certains cas. Je vais en pr√©senter un simple ici pour vous donner une id√©e de ce qui existe.  Le tri par d√©nombrement (ou counting sort en anglais) est tr√®s efficace, car il va permettre de trier un tableau en complexit√© lin√©aire, c'est-√†-dire en O(n)O(n)O(n). Il ne fonctionne cependant que pour des donn√©es enti√®res car il ne se base pas sur des comparaisons mais va compter le nombre d'occurrences de chaque valeur (de plus pour simplifier, on va supposer que les valeurs sont positives).  Le pr√©requis pour utiliser cet algorithme est donc de conna√Ætre la valeur maximale des donn√©es √† trier. Soit on conna√Æt cette valeur √† l'avance, soit on peut la calculer en parcourant le tableau une premi√®re fois.  L'algorithme consiste √† compter le nombre d'occurrences de chaque valeur dans le tableau, puis √† reconstruire le tableau en pla√ßant les valeurs dans l'ordre.  Par exemple, si on se fixe des valeurs enti√®res entre 0 et 9, on peut trier le tableau suivant [1, 4, 1, 2, 7, 5, 2] en proc√©dant ainsi:  On parcourt le tableau pour compter le nombre d'occurrences de chaque valeur.  valeur\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9nombre d'occurrences\t0\t2\t2\t0\t1\t1\t0\t1\t0\t0  On reconstruit le tableau en parcourant le tableau des occurrences et en ajoutant les valeurs dans l'ordre.  On ajoute 2 fois la valeur 1On ajoute 2 fois la valeur 2...  On obtient ainsi le tableau tri√© [1, 1, 2, 2, 4, 5, 7].  attention On remarque qu'il faut pouvoir stocker le nombre d'occurrences de chaque valeur, donc un tableau de taille 10 dans notre exemple. Il faut donc un tableau de taille kkk pour trier des donn√©es comprises entre 0 et k‚àí1k-1k‚àí1 ce qui augmente la complexit√© en m√©moire de l'algorithme. C'est √† prendre en compte si on veut utiliser cet algorithme car il peut √™tre tr√®s efficace en temps, mais peut aussi utiliser beaucoup de m√©moire si les valeurs sont tr√®s grandes. C'est un algorithme √† utiliser seulement dans le cas o√π on conna√Æt la valeur maximale des donn√©es √† trier et que cette valeur est raisonnable.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin:‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Tri par d√©nombrement stable‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-d√©nombrement-stable","content":" Details On peut am√©liorer le tri par d√©nombrement en le rendant stable. Cela signifie que si deux √©l√©ments ont la m√™me valeur, ils seront dans le m√™me ordre dans le tableau tri√© que dans le tableau initial. Cela ne semble pas tr√®s important √† premi√®re vue, mais cela permet de trier des donn√©es plus complexes en leur associant des valeurs enti√®res sur lesquelles on va effectuer le tri. Pour faire cela il faut modifier l√©g√®rement l'algorithme de tri par d√©nombrement. Une fois qu'on a compt√© le nombre d'occurrences de chaque valeur, on va calculer la somme partielle des occurrences de chaque valeur. Cela va nous permettre de conna√Ætre la position de chaque valeur dans le tableau tri√©. Par exemple, avec le tableau suivant [1, 4, 1, 2, 7, 5, 2] contenant des valeurs enti√®res entre 0 et 9: On compte le nombre d'occurrences de chaque valeur : [0, 2, 2, 0, 1, 1, 0, 1, 0, 0]On calcule la somme partielle des occurrences de chaque valeur : [0, 2, 4, 4, 5, 6, 6, 7, 7, 7] remarque On peut se resservir du tableau des occurrences pour stocker la somme partielle des occurrences de chaque valeur, ce qui permet de ne pas utiliser de tableau interm√©diaire suppl√©mentaire. On va construire un nouveau tableau de m√™me taille que le tableau initial, en parcourant le tableau initial pour ajouter les valeurs dans le nouveau tableau. On va ajouter la valeur √† la position indiqu√©e par la somme partielle des occurrences de la valeur, puis on va d√©cr√©menter la somme partielle des occurrences de la valeur. Par exemple, pour la valeur 1, on va ajouter la valeur 1 √† la position 2 du nouveau tableau, puis on va d√©cr√©menter la somme partielle des occurrences de la valeur 1 pour obtenir 1 (car il reste une occurrence de la valeur 1). On obtient ainsi le tableau tri√© [1, 1, 2, 2, 4, 5, 7]. L'inconv√©nient principal de cette m√©thode est qu'il faut un tableau interm√©diaire pour stocker le tableau tri√©, ce qui augmente la complexit√© en m√©moire de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Tri par base (radix sort)‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-base-radix-sort","content":" Details Le tri par d√©nombrement permet de trier des donn√©es enti√®res comprises entre 0 et k‚àí1k-1k‚àí1 en complexit√© lin√©aire. On va se servir de cet algorithme pour trier des donn√©es plus complexes, en associant √† chaque donn√©e une valeur enti√®re sur laquelle on va effectuer le tri (d'o√π l'int√©r√™t de rendre le tri par d√©nombrement stable). On va consid√©rer un tri de nombres entiers, mais cela peut s'appliquer √† d'autres types de donn√©es. Un nombre entier peut √™tre repr√©sent√© en base 10, c'est-√†-dire en utilisant les chiffres de 0 √† 9. Par exemple, le nombre 123 peut √™tre repr√©sent√© en base 10 par la suite de chiffres 1, 2 et 3. On va donc pouvoir trier des nombres entiers en triant les chiffres de leur repr√©sentation en base 10. Par exemple, pour trier les nombres [123, 456, 324, 682, 789, 118, 321, 654, 987], on va trier les chiffres des nombres, en commen√ßant par les unit√©s, puis les dizaines, puis les centaines. Cela permet de trier les nombres en complexit√© lin√©aire gr√¢ce au tri par d√©nombrement. Dans notre exemple, le nombre le plus grand est 987, il a donc 3 chiffres, on va donc effectuer 3 it√©rations de tri par d√©nombrement pour trier les nombres. remarque Cette information peut √™tre connue √† l'avance, mais on peut aussi la calculer en parcourant le tableau une premi√®re fois. On trie les unit√©s ce qui donne [321, 682, 123, 324, 654, 456, 987, 118, 789]On trie les dizaines ce qui donne [118, 321, 123, 324, 456, 654, 682, 987, 789]enfin, on trie les centaines ce qui donne [118, 123, 321, 324, 456, 654, 682, 789, 987]  ","version":"Next","tagName":"h3"},{"title":"Recherche dichotomique‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#recherche-dichotomique","content":" Avoir un tableau tri√© est tr√®s utile pour effectuer des recherches dans un tableau.  Par exemple, si on veut savoir si une valeur est pr√©sente dans un tableau, on peut le parcourir le tableau et comparer chaque √©l√©ment avec la valeur recherch√©e.  Mais si le tableau est tri√©, on peut utiliser une m√©thode plus efficace: la recherche dichotomique.  La recherche dichotomique consiste √† diviser le tableau en deux parties √©gales et √† ne garder que la partie qui contient la valeur recherch√©e. On r√©p√®te l'op√©ration jusqu'√† trouver la valeur ou jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment dans le tableau.  Exemple simple avec le tableau suivant [1, 2, 2, 4, 5, 8, 12] (nombre d'√©l√©ments: 7) et la valeur recherch√©e 8:  On calcule l'indice du milieu du tableau, soit 3. On compare la valeur √† l'indice 3 avec la valeur recherch√©e 8, comme 4 est plus petit que 8, on ne garde que la partie du tableau qui contient la valeur recherch√©e, c'est-√†-dire la partie du tableau √† partir de l'indice 4 (indice de d√©but: 4, indice de fin: 6). On recommence l'op√©ration avec la partie du tableau restante. Sous partie du tableau: [5, 8, 12] (nombre d'√©l√©ments: 3), indice du milieu: 5. On compare la valeur √† l'indice 5 avec la valeur recherch√©e 8, comme 8 est √©gal √† 8, on a trouv√© la valeur recherch√©e. On peut donc s'arr√™ter et renvoyer l'indice 5.    ","version":"Next","tagName":"h2"},{"title":"Complexit√©‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©","content":" La complexit√© de la recherche dichotomique est en O(log(n))O(log(n))O(log(n)).  (o√π logloglog est le logarithme en base 2 et pas lnlnln qui est le logarithme n√©p√©rien)  En effet, √† chaque it√©ration, on divise le tableau en deux parties √©gales, ce qui permet de r√©duire la taille du tableau √† chaque it√©ration.  On peut donc calculer le nombre d'it√©rations n√©cessaires pour trouver la valeur recherch√©e en fonction de la taille du tableau.  Par exemple, pour un tableau de taille 8, on va effectuer au maximum 3 it√©rations pour trouver la valeur recherch√©e.  On divise le tableau en deux parties √©gales, on ne garde que la partie qui contient la valeur recherch√©e, soit 4 √©l√©ments.On divise le tableau en deux parties √©gales, on ne garde que la partie qui contient la valeur recherch√©e, soit 2 √©l√©ments.In reste 2 elements (derni√®re it√©ration). On garde la valeur recherch√©e.  Ce qui fait un total de log2(8)=3log_2(8) = 3log2‚Äã(8)=3 it√©rations.  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#r√©sum√©","content":" Les algorithmes de tri sont tr√®s importants en informatique, car ils permettent de trier des donn√©es, ce qui est une op√©ration tr√®s courante.La complexit√© d'un algorithme est une mesure de la quantit√© de ressources (temps, m√©moire, etc) que celui-ci va utiliser pour s'ex√©cuter.La complexit√© en temps permet de quantifier la relation entre les conditions de d√©part (nombre d'√©l√©ments du tableau, valeurs des √©l√©ments, etc) et le temps effectu√© par l'algorithme.La complexit√© permet de savoir quel algorithme est le plus efficace quand on a un tr√®s grand nombre de donn√©es, mais ne permet pas de savoir si un algorithme est rapide ou lent pour un petit nombre de donn√©es (un algorithme avec une complexit√© en O(n2)O(n^2)O(n2) peut √™tre plus rapide qu'un algorithme avec une complexit√© en O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)) pour un petit nombre de donn√©es).Nous avons vu les algorithmes de tri suivants: Tri par s√©lection (selection sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par recherche successive du plus petit √©l√©ment du tableau. Tri √† bulles (bubble sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par comparaison successive de deux √©l√©ments cons√©cutifs du tableau. Tri fusion (merge sort): O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)) C'est un algorithme qui fonctionne par r√©cursion en divisant le tableau en deux parties √©gales, en triant les deux parties, puis en fusionnant les deux parties tri√©es. Tri rapide (quick sort): O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)) C'est un algorithme qui fonctionne par r√©cursion en choisissant un pivot, en divisant le tableau en deux parties en fonction du pivot, puis en triant les deux parties. Tri par d√©nombrement (counting sort): O(n)O(n)O(n) C'est un algorithme qui fonctionne en comptant le nombre d'occurrences de chaque valeur, puis en reconstruisant le tableau en pla√ßant les valeurs dans l'ordre. C'est un algorithme qui ne fonctionne que pour des donn√©es enti√®res et o√π la valeur maximale des donn√©es est connue √† l'avance et relativement petite. La recherche dichotomique est une m√©thode de recherche dans un tableau tri√© qui consiste √† diviser le tableau en deux parties √©gales et √† ne garder que la partie qui contient la valeur recherch√©e. On r√©p√®te l'op√©ration jusqu'√† trouver la valeur souhait√©e.  info Je t'invite √† regarder le fonctionnement des algorithmes sur ce site qui propose des visualisation ou encore ici. ","version":"Next","tagName":"h2"},{"title":"Retours G√©n√©raux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks","content":"","keywords":"","version":"Next"},{"title":"Bonnes pratiques en C++‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#bonnes-pratiques-en-c","content":" ","version":"Next","tagName":"h2"},{"title":"Dossier Build et Git‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#dossier-build-et-git","content":" Il est important de ne pas inclure le dossier build dans le d√©p√¥t Git. Ce dossier contient les fichiers temporaires g√©n√©r√©s lors de la compilation du projet (ex√©cutables, fichiers objets, ...). Ils sont propres √† chaque machine et ne doivent pas √™tre versionn√©s car cela prend de la place inutilement sur le d√©p√¥t Git.  De plus, un d√©veloppeur ne souhaite pas lancer un ex√©cutable inconnu (risque de piratage, virus, ...) et pr√©f√©rera compiler lui-m√™me le projet.  Cela peut se faire en ajoutant le dossier build dans le fichier .gitignore √† la racine du d√©p√¥t Git.  ","version":"Next","tagName":"h3"},{"title":"Tableau statique vs dynamique‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#tableau-statique-vs-dynamique","content":" Dans le projet TicTacToe, la grille est fixe (3x3). Cela signifie que la taille de la grille est connue √† la compilation et ne change pas pendant l'ex√©cution du programme. Dans ce cas, il est pr√©f√©rable d'utiliser un tableau statique (tableau de taille fixe) plut√¥t qu'un tableau dynamique (tableau de taille variable).  Un tableau statique est en g√©n√©ral plus performant qu'un tableau dynamique car il est allou√© en une seule fois et ne n√©cessite pas de gestion de la m√©moire √† l'ex√©cution (contrairement √† un tableau dynamique qui n√©cessite une allocation et une lib√©ration de la m√©moire si on veut changer sa taille).  Cependant j'ai vu certains d'entre vous utiliser les tableaux statiques du C (int grille[3][3]) plut√¥t que les tableaux statiques du C++ (std::array). Il est pr√©f√©rable d'utiliser std::array qui est plus pratique que les tableaux statiques du C.std::array permet de conna√Ætre sa taille (avec la m√©thode size()) et de passer des tableaux en param√®tre de fonction sans qu'ils se transforment en pointeurs (contrairement aux tableaux statiques du C).  Dans le cas o√π un pointeur vers un tableau est n√©cessaire (comme souvent on OpenGl par exemple), il est quand m√™me pr√©f√©rable d'utiliser un std::vector ou un std::array et d'utiliser la m√©thode data() pour obtenir un pointeur vers les donn√©es.  ","version":"Next","tagName":"h3"},{"title":"Namespace et header‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#namespace-et-header","content":" √âvitez d'utiliser using namespace std; dans les headers. Faire using namespace dans un header revient √† le faire dans tous les fichiers qui incluent ce header. C'est bien pratique pour √©viter les pr√©fixes std:: mais cela peut cr√©er des conflits de noms de variables ou de fonctions. Il est pr√©f√©rable de pr√©fixer les √©l√©ments de la STL avec std:: dans les headers pour √©viter ces conflits.  Il est possible d'utiliser using namespace std; dans les fichiers .cpp et dans ce cas de figure, le using namespace ne sera effectif que dans le fichier .cpp en question. Encore mieux, il est possible de faire un using dans un &quot;scope&quot; plus restreint (dans une fonction par exemple) pour √©viter d'importer tout le namespace std dans tout le fichier. Il est aussi possible de faire un using plus pr√©cis comme using std::string; pour n'importer que les √©l√©ments de la STL qui nous int√©ressent et pouvoir les utiliser sans pr√©fixe sans pour autant importer tout le namespace.  ","version":"Next","tagName":"h3"},{"title":"include guards‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#include-guards","content":" Les include guards sont des directives de pr√©processeur qui permettent d'√©viter les inclusions multiples d'un m√™me header. Cela permet de s'assurer que le header ne sera inclus qu'une seule fois afin d'√©viter les probl√®mes de liens multiples. Cela se fait en C++ en ajoutant la directive #pragma once au d√©but du header. (lien du cours).  Cependant, de part l'historique de C++ et sa r√©trocompatibilit√© avec le C, il est encore courant de voir des include guards √©crits de la mani√®re suivante :  #ifndef NOM_DU_HEADER_H #define NOM_DU_HEADER_H // Contenu du header #endif   En pratique (sauf dans de tr√®s rares cas), cela revient au m√™me que #pragma once mais est un peu plus verbeux et moins lisible. C'est pourquoi en C++ moderne, on pr√©f√®re utiliser #pragma once. Cela permet aussi de maintenir le code plus facilement, pas besoin de se soucier de trouver un nom unique pour les include guards, pas besoin de changer le nom de l'include guard si on change le nom du header, etc...  J'ai beaucoup vu cette forme d'include guards (avec #ifndef, #define, #endif) dans vos headers. Pour les prochains projets, je vous conseille plut√¥t d'utiliser #pragma once.  ","version":"Next","tagName":"h3"},{"title":"Header vide‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#header-vide","content":" J'ai vu que certains d'entre vous ont cr√©√© des headers vides (sans d√©claration de classe, fonction, variable, ...). Ce n'est pas n√©cessaire, surtout si vous n'avez rien √† d√©clarer dans le header car il s'agit d'un fichier vite qui n'apporte rien. Il n'est pas syst√©matique d'avoir toujours un header associ√© √† un fichier source.  ","version":"Next","tagName":"h3"},{"title":"Fonctions et headers‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#fonctions-et-headers","content":" Une fonction doit √™tre d√©clar√©e (et pas n√©cessairement impl√©ment√©e) avant d'√™tre utilis√©e. Cela signifie que si l'on appelle une fonction dans un fichier source, il faut que la d√©claration de la fonction soit pr√©sente avant l'appel de la fonction. Cela peut se faire en incluant le header qui contient la d√©claration de la fonction ou en impl√©mentant la fonction avant l'appel.  ‚ö†Ô∏è Cependant il ne faut pas mettre l'impl√©mentation de la fonction dans le header. Il faut seulement mettre la d√©claration de la fonction dans un header et l'impl√©mentation dans un fichier source. En effet, si on met l'impl√©mentation dans le header, cela signifie que le code sera copi√©-coll√© √† chaque inclusion du header. Cela peut cr√©er des probl√®mes de liens multiples (d√©finition multiple de la m√™me fonction ou variable pour l'√©tape de linkage) et potentiellement augmenter le temps de compilation.    De plus, une fonction n'a besoin d'√™tre d√©clar√©e dans un header que si elle est utilis√©e dans un autre fichier source. Si la fonction est utilis√©e uniquement dans le fichier source (.cpp), il n'est pas n√©cessaire de la d√©clarer dans le header. Par convention certains pr√©f√®rent tout de m√™me d√©clarer toutes les fonctions dans le header pour plus de clart√© mais ce n'est pas obligatoire.  Par exemple, si on a un fichier main.cpp qui contient la fonction main() et une fonction hello() qui est appel√©e dans main(), il n'est pas n√©cessaire de d√©clarer hello() dans un header main.hpp si hello() est utilis√©e uniquement dans main.cpp.  ","version":"Next","tagName":"h3"},{"title":"Gestion des includes‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#gestion-des-includes","content":" Il est important de bien g√©rer les inclusions dans les headers. En effet, si on inclut des headers inutilement, cela peut augmenter le temps de compilation et cr√©er des d√©pendances inutiles. Il est donc important d'inclure uniquement les headers n√©cessaires dans un header. Exemple, si dans un header une fonction retourne un std::vector il est n√©cessaire d'inclure le header #include &lt;vector&gt; pour que la signature de la fonction soit valide. Mais si l'on utilise un std::vector uniquement dans la fonction, il suffit d'inclure le header #include &lt;vector&gt; dans le fichier source (.cpp) et non dans le header.  ","version":"Next","tagName":"h3"},{"title":"inclusion relative‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#inclusion-relative","content":" Il n'est pas n√©cessaire d'inclure les headers avec le chemin complet. En effet, si les headers sont dans le m√™me dossier que le fichier source, il suffit d'inclure le header avec le chemin relatif par rapport au fichier source. Dans le cas de cmake, si le dossier include est bien configur√© (include_directories()), il suffit d'inclure le header avec #include &lt;nom_du_header.h&gt; par rapport au dossier include (ce dossier include peut √™tre le dossier src lui m√™me).  ","version":"Next","tagName":"h3"},{"title":"Variables globales‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#variables-globales","content":" Les variables globales sont des variables qui sont d√©clar√©es en dehors de toute fonction. Elles sont accessibles partout dans le fichier. Cela peut √™tre pratique pour partager des donn√©es entre plusieurs fonctions mais cela peut aussi rendre le code moins lisible et plus difficile √† maintenir.  Il est pr√©f√©rable d'√©viter les variables globales autant que possible. En effet, les variables globales peuvent √™tre modifi√©es de mani√®re inattendue par n'importe quelle fonction du programme. Cela peut rendre le code difficile √† comprendre et √† d√©boguer. Il est pr√©f√©rable de passer les variables en param√®tre des fonctions si elles sont utilis√©es par plusieurs fonctions.  De plus, quand elles sont utilis√©es dans des headers, elles sont copi√©es dans chaque fichier source qui inclut le header. Cela peut cr√©er des probl√®mes de liens multiples (d√©finition multiple de la m√™me variable) ou des comportements inattendus (on s'attend √† ce que la variable soit partag√©e entre les fichiers mais en fait chaque fichier a sa propre copie de la variable).  Il existe des mot cl√©s comme extern (ou encore static) qui permettent de d√©finir des variables &quot;globales&quot; partag√©es entre plusieurs fichiers sources. Mais c'est g√©n√©ralement signe d'un probl√®me d'architecture et il est pr√©f√©rable de passer par des param√®tres de fonctions ou des classes pour partager des donn√©es entre plusieurs parties du programme. Ou m√™me quand c'est n√©cessaire un singleton (mais c'est un autre sujet).  ","version":"Next","tagName":"h3"},{"title":"Condition bool√©enne‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#condition-bool√©enne","content":" J'ai souvent vu des conditions du type if (variable == true) ou if (variable == false). Cela n'est pas n√©cessaire car la condition est d√©j√† un bool√©en. Il est donc pr√©f√©rable d'√©crire directement if (variable) ou if (!variable). C'est √† mon sens plus court et plus lisible.  ","version":"Next","tagName":"h3"},{"title":"Al√©atoire‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#al√©atoire","content":" En informatique, on a souvent besoin de g√©n√©rer des nombres al√©atoires. Cela peut √™tre utile pour simuler des comportements al√©atoires, pour m√©langer des √©l√©ments, pour g√©n√©rer des donn√©es de test, ...  Mais le &quot;vrai&quot; al√©atoire n'existe pas en informatique. En effet, les ordinateurs sont des machines d√©terministes, c'est-√†-dire qu'ils ex√©cutent des instructions de mani√®re s√©quentielle et pr√©visible. Cela signifie que si on donne les m√™mes entr√©es √† un programme, on obtiendra toujours les m√™mes sorties (normalement üôÉ).  On parle alors de g√©n√©rateurs de nombres pseudo-al√©atoires (PRNG). Ces g√©n√©rateurs produisent une s√©quence de nombres qui semble al√©atoire mais qui est en fait d√©terministe. Cela signifie que si on donne la m√™me graine (seed) √† un g√©n√©rateur de nombres pseudo-al√©atoires, on obtiendra la m√™me s√©quence de nombres.  Pour g√©n√©rer des nombres al√©atoires on peut utiliser les fonctions rand() et srand() de la biblioth√®que standard.srand() permet de d√©finir la graine du g√©n√©rateur de nombres pseudo-al√©atoires et rand() permet de g√©n√©rer un nombre al√©atoire.  Pour initialiser le g√©n√©rateur de nombres pseudo-al√©atoires avec une graine al√©atoire, on peut utiliser la fonction time() de la biblioth√®que standard. Cette fonction renvoie le nombre de secondes √©coul√©es depuis le 1er janvier 1970. Cela permet d'initialiser le g√©n√©rateur avec une valeur qui change √† chaque ex√©cution du programme.  #include &lt;cstdlib&gt; #include &lt;ctime&gt; int main() { srand(time(nullptr)); // Initialisation du g√©n√©rateur de nombres pseudo-al√©atoires avec une graine al√©atoire int random_number { rand() }; // G√©n√©ration d'un nombre al√©atoire }   rand() nous donne un nombre al√©atoire entre 0 et RAND_MAX (une constante d√©finie dans la biblioth√®que standard). Pour obtenir un nombre al√©atoire dans un intervalle donn√©, on peut utiliser une formule du type rand() % (max - min + 1) + min.  Cependant, il faut faire attention √† ne pas appeler srand(time(nullptr)) √† chaque fois qu'on a besoin d'un nombre al√©atoire. Si on appelle srand(time(nullptr)) plusieurs fois dans la m√™me seconde, on obtiendra la m√™me graine et donc la m√™me s√©quence de nombres al√©atoires pour chaque appel √† rand().  Il est donc pr√©f√©rable d'appeler srand(time(nullptr)) par exemple au d√©but du programme pour initialiser le g√©n√©rateur de nombres pseudo-al√©atoires avec une graine al√©atoire.    En C++ moderne, on utilise plut√¥t la biblioth√®que &lt;random&gt; qui fournit des g√©n√©rateurs de nombres pseudo-al√©atoires plus puissants et plus flexibles que rand() et srand(). Cette biblioth√®que fournit des classes qui permettent de g√©n√©rer des nombres al√©atoires selon diff√©rentes distributions (uniforme, normale, ...).  Voici un exemple d'utilisation pour g√©n√©rer un nombre al√©atoire entre 0 et 100 :  #include &lt;random&gt; int main() { std::random_device rd {}; // Objet permettant de g√©n√©rer une graine al√©atoire (similaire √† srand(time(nullptr))) std::mt19937 gen(rd()); // G√©n√©rateur de nombres pseudo-al√©atoires Mersenne Twister (un des g√©n√©rateurs les plus performants) std::uniform_int_distribution&lt;&gt; dis(0, 100); // Distribution uniforme entre 0 et 100 int random_number { dis(gen) }; // G√©n√©ration d'un nombre al√©atoire }   C'est cette m√©thode que nous utiliserons principalement au second semestre.  ","version":"Next","tagName":"h3"},{"title":"Classe vs structure‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#classe-vs-structure","content":" Jusqu'√† pr√©sent, nous avons utilis√© uniquement des structures pour repr√©senter les donn√©es. Une structure est simplement un regroupement de donn√©es (membres) qui peuvent √™tre de diff√©rents types. Mais quand on parle de programmation orient√©e objet, on parle souvent de classe. Mais alors quelle est la diff√©rence entre une classe et une structure ? Nous n'avons pas encore vu la notion de visibilit√© des membres mais il est possible de d√©clarer des membres priv√©s et publics. Les membres priv√©s sont accessibles uniquement √† l'int√©rieur de la classe, alors que les membres publics sont accessibles de l'ext√©rieur de la classe (avec la syntaxe objet.membre).  En C++, la seule diff√©rence entre une classe et une structure est la visibilit√© par d√©faut des membres. Dans une classe, les membres sont priv√©s par d√©faut, alors que dans une structure, ils sont publics par d√©faut. Mais il est tout √† fait possible de d√©clarer une classe avec des membres publics et une struct avec des membres priv√©s. Cela n'a pas d'impact sur la performance du programme, c'est juste une question de style et de convention. En g√©n√©ral, on utilise une classe pour repr√©senter un objet avec des m√©thodes et des membres priv√©s (qui permettent d'encapsuler les donn√©es et masquer le comportement interne de l'objet) et une structure pour repr√©senter un simple regroupement de donn√©es (ou la majorit√© des membres et m√©thodes est publique). Vous d√©couvrirez le reste de la programmation orient√©e objet (h√©ritage, polymorphisme, ... ) l'ann√©e prochaine.  ","version":"Next","tagName":"h3"},{"title":"Architecture‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#architecture","content":" ","version":"Next","tagName":"h2"},{"title":"Tableau 1D vs 2D‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#tableau-1d-vs-2d","content":" Dans le projet TicTacToe, la grille √©tait repr√©sent√©e par un tableau 1D. Cela permet de simplifier l'acc√®s aux √©l√©ments de la grille (gr√¢ce √† une seule dimension) et de r√©duire la complexit√© de l'algorithme.  J'ai vu que certains d'entre vous ont utilis√© un tableau 2D pour repr√©senter la grille. Cela fonctionne aussi mais il faut travailler avec des coordonn√©es (ligne, colonne) pour acc√©der aux √©l√©ments de la grille (cela peut √™tre un avantage ou un inconv√©nient selon le contexte).  Cela va avoir un impact si vous utilisez un tableau dynamique (std::vector) pour repr√©senter la grille. Un tableau 2D est en fait un tableau de tableaux (un tableau de pointeurs vers des tableaux). Cela peut √™tre moins performant qu'un tableau 1D car les √©l√©ments de la grille ne sont pas contigus en m√©moire (contrairement √† un tableau 1D).  Il est donc pr√©f√©rable d'utiliser un tableau 1D pour repr√©senter la grille si vous voulez optimiser la performance de votre programme.  Dans notre cas c'est n√©gligeable car la grille est petite, mais c'est une bonne habitude √† prendre (c'est pour cela que je vous l'avais demand√©).  ","version":"Next","tagName":"h3"},{"title":"Faire des fonctions‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#faire-des-fonctions","content":" J'ai vu sur certains projets des fonctions (main) tr√®s longues (+ de 150 lignes). Cela rend le code difficile √† lire et √† maintenir. Il est pr√©f√©rable de d√©couper le code en fonctions plus petites et plus sp√©cialis√©es. Cela permet de mieux organiser le code, de le rendre plus lisible et de faciliter la r√©utilisation des fonctions.  Par exemple toute la boucle qui demande un coup au joueur et v√©rifie si le coup est valide pourrait √™tre mise dans une fonction ask_valid_position_from_user().  Si il y a une initialisation plus complexe √† faire, cela pourrait √™tre mis dans une fonction initialize_game() (pour choisir le premier joueur al√©atoirement par exemple, etc).  ","version":"Next","tagName":"h2"},{"title":"TicTacToe‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#tictactoe","content":" ","version":"Next","tagName":"h2"},{"title":"V√©rification de victoire‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#v√©rification-de-victoire","content":" J'ai vu beaucoup d'impl√©mentations de la v√©rification de victoire qui consiste √† v√©rifier toutes les lignes, colonnes et diagonales pour voir si un joueur a gagn√©. C'est une solution qui fonctionne mais qui est un peu &quot;r√©p√©titive&quot; et qui peut √™tre am√©lior√©e.  Une version plus √©l√©gante consiste √† v√©rifier uniquement la ligne, la colonne et la diagonale o√π le dernier coup a √©t√© jou√©. Cela permet de r√©duire le nombre de v√©rifications √† faire. En effet, si un joueur a gagn√©, c'est forc√©ment sur la ligne, la colonne ou la diagonale o√π le dernier coup a √©t√© jou√©.  Cela r√©duit le nombre de v√©rifications √† faire √† 3 ou 4 (ligne, colonne, 1 ou 2 diagonales) au lieu de 8 (3 lignes, 3 colonnes, 2 diagonales), c'est donc plus performant et plus simple √† impl√©menter (C'est d'autant plus vrai si la grille est plus grande comme pour un puissance 4).  ","version":"Next","tagName":"h3"},{"title":"Choix al√©atoire de l'IA‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/feedbacks#choix-al√©atoire-de-lia","content":" J'ai vu pas mal d'impl√©mentations de l'IA qui consistent √† choisir une position al√©atoire et recommencer si la position est d√©j√† occup√©e. C'est une solution qui fonctionne mais qui n'est pas tr√®s √©l√©gante. Si la grille est presque pleine, il y a de fortes chances que l'IA doive recommencer plusieurs fois (et possiblement tr√®s longtemps) avant de trouver une position libre. Il y a plusieurs fa√ßons d'√©viter cela.  On peut lister toutes les positions libres puis choisir parmi ces positions. Cela permet de garantir que l'IA choisira une position libre √† chaque coup.  Sinon il est possible de choisir une position al√©atoire puis, si la position est d√©j√† occup√©e, aller sur la position suivante (et ainsi de suite jusqu'√† trouver une position libre). Cela permet de garantir que l'IA choisira une position libre en un nombre fini de coups. ‚ö†Ô∏è Cette m√©thode est biais√© car la probabilit√© de choisir une position libre (parmi les restantes) n'est pas uniforme. ","version":"Next","tagName":"h3"},{"title":"Correction","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2026/S1/correction","content":"Correction Exercice 1 Quelle est la diff√©rence entre un tableau statique et un tableau dynamique ? Un tableau statique est un tableau dont la taille est connue √† la compilation, c'est √† dire que la taille du tableau est fixe et ne peut pas √™tre modifi√©e pendant l'ex√©cution du programme (std::array en C++). Un tableau dynamique est un tableau dont la taille peut varier pendant l'ex√©cution du programme (std::vector en C++). Pour cela, il faut utiliser de l‚Äôallocation dynamique de m√©moire. Quelle est la diff√©rence entre l'op√©rateur = et l'op√©rateur == ? L'op√©rateur = permet d'affecter une valeur √† une variable. int a {1}; int b {2}; a = b; // a vaut maintenant 2 L'op√©rateur == permet de comparer deux valeurs et retourne un bool√©en. int a {1}; int b {2}; bool c {a == b}; // c vaut false Qu‚Äôentendez-vous par passage par copie et passage par r√©f√©rence(&amp;) ? Le passage par copie consiste √† passer une copie de la variable en param√®tre de la fonction. C'est √† dire que la variable en param√®tre de la fonction est une copie de la variable pass√©e en param√®tre lors de l'appel de la fonction. void addOne(int x) { // Ici x est une variable locale √† la fonction addOne // x est une copie de la variable pass√©e en param√®tre lors de l'appel de la fonction x += 1; } int main() { int a {1}; addOne(a); // a vaut toujours 1 } Le passage par r√©f√©rence consiste √† passer une r√©f√©rence de la variable en param√®tre de la fonction. C'est √† dire que la variable en param√®tre de la fonction utilise le m√™me espace m√©moire que la variable pass√©e en param√®tre lors de l'appel de la fonction. Cela permet de modifier et manipuler directement la variable pass√©e en param√®tre lors de l'appel de la fonction. void addOne(int&amp; x) { // Ici x est un r√©f√©rence √† la variable pass√©e en param√®tre lors de l'appel de la fonction x += 1; } int main() { int a {1}; addOne(a); // a vaut maintenant 2 } A quoi servent les mots cl√©s const et unsigned ? Quand et pourquoi les utiliser ? Le mot cl√© const permet de d√©clarer une variable constante. C'est √† dire que la variable ne peut pas √™tre modifi√©e apr√®s son initialisation. int main() { const int a {1}; a = 2; // Erreur: a est une variable constante } Cela permet de s'assurer que la variable ne sera pas modifi√©e par erreur et rajoute de la s√©curit√© au programme. On peut √©galement pr√©ciser qu'une m√©thode ne modifie pas l'objet sur lequel elle est appel√©e en utilisant le mot cl√© const apr√®s la d√©claration de la m√©thode. struct Point { // ... void display() const; }; Cela permet de pouvoir utiliser la m√©thode sur un objet constant (sinon ce n'est pas possible). int main() { Point const p {1, 2}; p.display(); // OK } Le mot cl√© unsigned permet de d√©clarer une variable non sign√©e. C'est √† dire que la variable ne peut pas prendre de valeur n√©gative. Cela permet de s'assurer que la variable ne sera pas n√©gative lors de son utilisation. Cela a aussi l‚Äôavantage de doubler la valeur maximale que peut prendre la variable (comme il n'y a plus de valeur n√©gative √† stocker). En C++, size_t est un alias pour unsigned long long int (un entier non sign√©e) et est souvent utilis√© dans les boucles ou pour repr√©senter la taille d'un tableau ou d'un conteneur (c'est la taille maximale que peut prendre un tableau ou un conteneur). Exercice 2 #include &lt;iostream&gt; #include &lt;vector&gt; // Par r√©f√©rence constante pour √©viter de faire une copie du vecteur et pour pouvoir utiliser la fonction sur un vecteur constant int max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; // Ici je commence √† l'index 1 car j'ai d√©j√† initialis√© max avec la premi√®re valeur du tableau for (size_t i {1}; i &lt; vec.size(); ++i) { if (vec[i] &gt; max) { max = vec[i]; } } return max; } // Version alternative avec un &quot;Range-based for loop&quot; // int max(std::vector&lt;int&gt; const&amp; vec) { // int max = vec[0]; // for (int value: vec) // { // if (value &gt; max) // { // max = value; // } // } // return max; // } int main() { std::vector&lt;int&gt; v1 {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::cout &lt;&lt; max(v1) &lt;&lt; std::endl; std::vector&lt;int&gt; const v2 {9, 8, 7, 6, 5, 4, 3, 2, 1}; std::cout &lt;&lt; max(v2) &lt;&lt; std::endl; // Aussi par valeur comme on a bien une r√©f√©rence constante std::cout &lt;&lt; max({9, 8, 7, 6, 5, 4, 3, 2, 1}) &lt;&lt; std::endl; } D√©tail du &quot;Range-based for loop&quot; ici Exercice 3 #include &lt;iostream&gt; #include &lt;cctype&gt; bool isVowel(char c) { c = std::tolower(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; } // version alternative avec un tableau (cha√Æne de caract√®res) contenant les voyelles // bool isVowel(char c) { // c = std::tolower(c); // std::string const vowels {&quot;aeiouy&quot;}; // for (char vowel: vowels) // { // if (c == vowel) // { // return true; // } // } // return false; // } // Il existe aussi d'autres fa√ßon de faire comme avec la m√©thode find de la classe std::string size_t countVowels(std::string const&amp; str) { size_t count {0}; for(char c: str) { if(isVowel(c)) { count += 1; } } return count; } int main() { std::string helloWorldStr {&quot;Hello World!&quot;}; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; helloWorldStr &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;: &quot; &lt;&lt; countVowels(helloWorldStr) &lt;&lt; std::endl; std::string testStr {&quot;Ceci est un test&quot;}; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; testStr &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;: &quot; &lt;&lt; countVowels(testStr) &lt;&lt; std::endl; // Aussi possible par valeur comme on a bien une r√©f√©rence constante std::cout &lt;&lt; &quot;\\&quot;Je suis une phrase avec des voyelles\\&quot; : &quot; &lt;&lt; countVowels(&quot;Je suis une phrase avec des voyelles&quot;) &lt;&lt; std::endl; } Exercice 4 #include &lt;iostream&gt; #include &lt;cmath&gt; struct Point { float x {0f}; float y {0f}; }; float distance(Point const&amp; p1, Point const&amp; p2) { return std::sqrt(std::pow(p1.x - p2.x, 2) + std::pow(p1.y - p2.y, 2)); } // sans utiliser la fonction pow // float distance(Point const&amp; p1, Point const&amp; p2) { // float diff_x {p1.x - p2.x}; // float diff_y {p1.y - p2.y}; // return std::sqrt(diff_x*diff_x + diff_y*diff_y); // } bool isInCircle(Point const&amp; p, Point const&amp; center, float radius) { return distance(p, center) &lt; radius; } bool isCirclesIntersect(Point const&amp; c1, float r1, Point const&amp; c2, float r2) { return distance(c1, c2) &lt; (r1 + r2); } // BONUS struct Circle { Point center; float radius; }; bool isInCircle(Point const&amp; p, Circle const&amp; circle) { return distance(p, circle.center) &lt; circle.radius; } bool isCirclesIntersect(Circle const&amp; c1, Circle const&amp; c2) { return distance(c1.center, c2.center) &lt; (c1.radius + c2.radius); } int main() { Point circle_center {0, 1}; float circle_radius {2.4f}; // Optionnel: Permet d'afficher les bool√©ens sous forme de true/false (et pas 0/1) std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;(0, 0) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({0, 0}, circle_center, circle_radius) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(1, 1) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({1, 1}, circle_center, circle_radius) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(3, 4) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({3, 4}, circle_center, circle_radius) &lt;&lt; std::endl; // BONUS Circle c1 { p1, 1.2f}; Circle c2 { p2, 1.f}; std::cout &lt;&lt; &quot;c1 intersect c2 :&quot; &lt;&lt; isCirclesIntersect(c1, c2) &lt;&lt; std::endl; return 0; } Robot src/direction.hpp #pragma once #include &lt;string&gt; enum class Direction { north, east, south, west }; std::string to_string(Direction direction); src/direction.cpp #include &quot;direction.hpp&quot; std::string to_string(Direction direction) { switch (direction) { case Direction::north: return &quot;north&quot;; // break pas n√©cessaire ici car on utilise le mot cl√© return qui permet de sortir imm√©diatement de la fonction case Direction::east: return &quot;east&quot;; case Direction::south: return &quot;south&quot;; case Direction::west: return &quot;west&quot;; } } src/point.hpp #pragma once // J'ai besoin de la d√©claration de Direction pour pouvoir d√©clarer la m√©thode move #include &quot;direction.hpp&quot; struct Point { int x {0}; int y {0}; // BONUS: Ici la m√©thode peut √™tre d√©clar√©e comme const car elle ne modifie pas la structure void display() const; void move(Direction const d, unsigned int const n); }; src/point.cpp #include &quot;point.hpp&quot; #include &lt;iostream&gt; // Ici je n'ai pas afficher de retour √† la ligne afin de pouvoir r√©utiliser la m√©thode ensuite dans robot.cpp void Point::display() const { std::cout &lt;&lt; '(' &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; ')'; } void Point::move(Direction const d, unsigned int const n) { switch (d) { case Direction::north: y += n; break; case Direction::east: x += n; break; case Direction::south: y -= n; break; case Direction::west: x -= n; break; } } src/robot.hpp #pragma once #include &lt;string&gt; #include &quot;direction.hpp&quot; #include &quot;point.hpp&quot; struct Robot { std::string name; Point position; Direction direction; void display() const; void turnLeft(); void turnRight(); void move(unsigned int const n); }; std::string createRobotName(); Robot createRobot(Point position, Direction direction); src/robot.cpp #include &quot;robot.hpp&quot; #include &lt;cstdlib&gt; #include &lt;iostream&gt; void Robot::display() const { std::cout &lt;&lt; name &lt;&lt; '('; position.display(); std::cout &lt;&lt; &quot;, &quot; &lt;&lt; to_string(direction) &lt;&lt; ')'; } void Robot::turnLeft() { switch (direction) { case Direction::north: direction = Direction::west; break; case Direction::east: direction = Direction::north; break; case Direction::south: direction = Direction::east; break; case Direction::west: direction = Direction::south; break; } } void Robot::turnRight() { switch (direction) { case Direction::north: direction = Direction::east; break; case Direction::east: direction = Direction::south; break; case Direction::south: direction = Direction::west; break; case Direction::west: direction = Direction::north; break; } } void Robot::move(unsigned int const n) { position.move(direction, n); } std::string createRobotName() { std::string name {&quot;&quot;}; for(size_t i {0}; i &lt; 2; ++i) { name += 'A' + (std::rand() % (25+1)); } for(size_t i {0}; i &lt; 3; ++i) { name += '0' + (std::rand() % (9+1)); } return name; } Robot createRobot(Point position, Direction direction) { return Robot { createRobotName(), position, direction }; } src/main.cpp #include &lt;iostream&gt; #include &lt;ctime&gt; #include &quot;direction.hpp&quot; #include &quot;point.hpp&quot; #include &quot;robot.hpp&quot; int main() { // Initialisation du g√©n√©rateur de nombre al√©atoire std::srand(std::time(nullptr)); // Test direction Direction direction_test {Direction::north}; std::cout &lt;&lt; to_string(direction_test) &lt;&lt; std::endl; // Test point Point p1 {1, 2}; p1.display(); std::cout &lt;&lt; std::endl; p1.move(Direction::east, 3); p1.display(); std::cout &lt;&lt; std::endl; Robot robot {createRobot(Point{0, 0}, Direction::north)}; std::count &lt;&lt; &quot;Robot start value: &quot;; robot.display(); std::cout &lt;&lt; std::endl; robot.turnLeft(); robot.move(3); robot.turnRight(); robot.move(5); robot.move(2); robot.turnLeft(); robot.move(1); robot.turnRight(); robot.move(2); std::count &lt;&lt; &quot;Robot end value: &quot;; robot.display(); std::cout &lt;&lt; std::endl; // Version alternative avec boucle sur une cha√Æne de caract√®re pour indiquer les actions √† effectuer robot = createRobot(Point{0, 0}, Direction::north); for (char action : &quot;L3R52L1R2&quot;) { // number test if (action &gt;= 48 &amp;&amp; action &lt;= 57) { robot.move(static_cast&lt;int&gt;(action - '0')); } else if (action == 'R') { robot.turnRight(); } else if(action == 'L') { robot.turnLeft(); } else { if (action != '\\0') { std::cout &lt;&lt; &quot;unknown action :&quot; &lt;&lt; action; } } robot.display(); std::cout &lt;&lt; std::endl; } } CMakeLists.txt # la version de cmake √† utiliser cmake_minimum_required(VERSION 3.10) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # On souhaite placer l'ex√©cutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Le nom du projet project(Robot) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources # message(STATUS &quot;Found source files:&quot;) # foreach(SRC_FILE ${SRC_FILES}) # message(STATUS &quot; - ${SRC_FILE}&quot;) # endforeach() # On indique que l'on souhaite faire un ex√©cutable avec nos fichiers sources add_executable(robot ${SRC_FILES}) # le dossier contenant les fichiers d'en-t√™te pour notre executable target_include_directories(robot PUBLIC &quot;src/&quot;) ","keywords":"","version":"Next"},{"title":"Project TicTacToe","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet","content":"","keywords":"","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#introduction","content":" Pour mettre en pratique les notions de programmation vues au cours de ce semestre, je vous propose de r√©aliser un petit jeu dans le terminal : le TicTacToe (ou Morpion en fran√ßais).  Le projet est √† r√©aliser individuellementVous avez 3 semaines pour r√©aliser le projet (cf. section &quot;Rendu&quot;)  ","version":"Next","tagName":"h2"},{"title":"Objectifs du projet‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#objectifs-du-projet","content":" √âvaluer votre niveau en programmation en C++R√©aliser un projet de A √† Z, organiser vos id√©es, structurer vos fichiers et votre codeVous familiariser avec l'utilisation de Git et GitHub  ","version":"Next","tagName":"h3"},{"title":"Fonctionnalit√©s demand√©es (Cahier des charges)‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#fonctionnalit√©s-demand√©es-cahier-des-charges","content":" ","version":"Next","tagName":"h2"},{"title":"Structure de joueur‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#structure-de-joueur","content":" Vous devez r√©aliser une structure Player qui contient les informations suivantes :  name : nom du joueursymbol : symbole du joueur (e.g. 'X' ou 'O')  Cette structure doit √™tre utilis√©e pour stocker les informations des joueurs et plac√©e dans des fichiers d√©di√©s Player.hpp et Player.cpp.  Vous devez r√©aliser une fonction create_player qui ne prend aucun param√®tre et qui retourne une structure Player initialis√©e avec les informations du joueur. Cette fonction doit demander le nom du joueur √† l'utilisateur (std::cin) et lui demander de choisir un symbole (X ou O g√©n√©ralement mais vous pouvez choisir d'autres symboles si vous le souhaitez).  ","version":"Next","tagName":"h3"},{"title":"Affichage du plateau de jeu‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#affichage-du-plateau-de-jeu","content":" Vous devez r√©aliser une fonction draw_game_board (vous pouvez modifier l√©g√®rement le nom de la fonction si vous le souhaitez) qui prend en param√®tre un tableau de caract√®res (char) et affiche le plateau de jeu dans la terminal.  Le plateau de jeu doit √™tre affich√© de la mani√®re suivante :  | 1 | 2 | 3 | | 4 | 5 | 6 | | 7 | 8 | 9 |   o√π chaque chiffre repr√©sente une case du plateau de jeu.  Le plateau doit √™tre repr√©sent√© dans le code sous forme d'un tableau de caract√®res (char) repr√©sentant les symboles des joueurs ou un caract√®re &quot;vide&quot; (par exemple un .) pour une case vide.  ‚ö†Ô∏è Ici le nombre de cases du plateau est connu √† l'avance, vous devez donc de pr√©f√©rence utiliser un tableau statique plut√¥t qu'un tableau dynamique pour repr√©senter le plateau de jeu.  ","version":"Next","tagName":"h3"},{"title":"Mode de jeu‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#mode-de-jeu","content":" Deux joueurs‚Äã  Vous devez r√©aliser un mode de jeu o√π deux joueurs peuvent s'affronter sur le jeu.  Le jeu doit alterner entre les deux joueurs pour leur permettre de jouer un coup √† tour de r√¥le.  Un joueur et IA‚Äã  Vous devez r√©aliser un mode de jeu o√π un joueur affronte une IA (Intelligence Artificielle) qui joue al√©atoirement sur une case vide.  Dans ce cas de figure vous r√©utiliserez la structure Player pour l'IA en initialisant le nom de l'IA √† &quot;IA&quot; et un symbole pr√©-d√©fini (diff√©rent de celui du joueur).  Le jeu doit alterner entre le joueur et l'IA pour leur permettre de jouer un coup √† tour de r√¥le.  Il est possible d'am√©liorer l'IA mais ce n'est pas requis (voir section &quot;Am√©liorations possibles&quot;).  ","version":"Next","tagName":"h3"},{"title":"Menu de d√©marrage‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#menu-de-d√©marrage","content":" Vous devez r√©aliser un menu de d√©marrage qui permet √† l'utilisateur de choisir le mode de jeu (deux joueurs ou un joueur contre l'IA).  Exemple:  Bienvenue dans le jeu du TicTacToe Veuillez choisir un mode de jeu : 1. Deux joueurs 2. Un joueur contre l'IA   ","version":"Next","tagName":"h3"},{"title":"Fin de partie‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#fin-de-partie","content":" Le jeu doit v√©rifier si un joueur a align√© 3 symboles sur une ligne, une colonne ou une diagonale. Si c'est le cas, le jeu doit afficher le nom du joueur gagnant et terminer la partie.  Si aucun joueur n'a align√© 3 symboles et que le plateau de jeu est complet, le jeu doit afficher un message de fin de partie indiquant que c'est un match nul.  astuce Id√©alement, vous devez √©crire une fonction de v√©rification de victoire qui ne d√©pend pas des symboles, pour pouvoir r√©utiliser cette fonction peu importe le symbole des joueurs.  ","version":"Next","tagName":"h3"},{"title":"Am√©liorations possibles‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#am√©liorations-possibles","content":" Pour les plus motiv√©s, voici quelques am√©liorations que vous pouvez r√©aliser pour obtenir des points bonus.  ‚ö†Ô∏è Attention, pour toute am√©lioration, vous devez r√©aliser le jeu de base avant de commencer √† ajouter des fonctionnalit√©s suppl√©mentaires.  ","version":"Next","tagName":"h2"},{"title":"Am√©liorer l'IA‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#am√©liorer-lia","content":" Il existe plusieurs fa√ßons de r√©aliser une IA pour le jeu du TicTacToe, vous pouvez choisir de r√©aliser (par ordre de difficult√© croissante) :  Une IA capable de bloquer les coups de l'adversaire: l'ordinateur joue un coup al√©atoire sur une case vide, mais si l'adversaire a 2 symboles align√©s, l'ordinateur joue sur la case restante pour bloquer l'adversaireUne IA bas√©e sur un algorithme de recherche: l'ordinateur envisage beaucoup (ou toutes) les possibilit√©s, et joue le meilleur coup trouv√© (cf. les algos minimax, alpha-beta pruning, etc.)  ","version":"Next","tagName":"h3"},{"title":"Ajouter une interface graphique‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#ajouter-une-interface-graphique","content":" Vous pouvez r√©aliser une interface graphique pour le jeu du TicTacToe en utilisant une biblioth√®que graphique comme SFML, SDL, raylib, etc.  ‚ö†Ô∏è Attention, l'interface graphique n'est pas requise pour ce projet, Cela peut √™tre int√©ressant mais vous √™tes responsables de la gestion de l'interface graphique et du temps que cela vous prendra. Vous devez r√©aliser le jeu en terminal avant de commencer √† ajouter une interface graphique. Concernant la compatibilit√©, si vous √™tes sur MacOS, venez m'en parler avant de vous lancer dans cette am√©lioration que je sois bien en mesure de corriger votre projet.  ","version":"Next","tagName":"h3"},{"title":"√âvolution vers un jeu plus complexe‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#√©volution-vers-un-jeu-plus-complexe","content":" Vous avez la possibilit√© de r√©aliser un jeu similaire au TicTacToe mais avec des r√®gles plus complexes (plateau de jeu plus grand, alignement de symboles plus grand, etc.)  Si vous partez sur un jeu plus complexe, vous devez r√©aliser le nouveau jeu dans des fichiers s√©par√©s du jeu de base pour ne pas impacter la r√©alisation du jeu de base.  Dans ce cas, une IA n'est pas requise et vous pouvez r√©aliser seulement un mode deux joueurs.  Quelques exemples de jeux plus complexes :  Gomoku (aligner 5 symboles)Puissance 4 (aligner 4 symboles)Ultimate tic-tac-toe (Tic-tac-toe imbriqu√© sur 2 niveaux (plateau de jeu de 9x9 cases))  ","version":"Next","tagName":"h3"},{"title":"Librairies‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#librairies","content":" Si vous voulez utiliser des librairies tierces, demandez-moi avant pour que je puisse valider votre choix.  ","version":"Next","tagName":"h2"},{"title":"Manipuler le terminal‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#manipuler-le-terminal","content":" Ce n'est pas requis mais si vous voulez pouvoir effacer enti√®rement le terminal (entre chaque tour de jeu par exemple) ou d√©placer le curseur dans le terminal, vous pouvez utiliser cette librairie que j'ai r√©alis√©e pour vous : Terminal Ctrl.  Voil√† comment l'ajouter au projet via CMake:  include(FetchContent) FetchContent_Declare( terminal_ctrl GIT_REPOSITORY https://github.com/dsmtE/terminal_ctrl GIT_TAG &quot;origin/main&quot; ) FetchContent_MakeAvailable(terminal_ctrl) target_link_libraries(${PROJECT_NAME} PUBLIC terminal_ctrl)   Voil√† un exemple d'utilisation de la librairie:  #include &lt;terminal_ctrl/terminal_ctrl.h&gt; int main() { terminal_ctrl::clear_terminal(); terminal_ctrl::move_cursor(1, 3); std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Rendu‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#rendu","content":" Le projet est √† rendre sur GitHub(ou Gitlab), vous devez m'envoyer le lien de votre d√©p√¥t avant la date limite de rendu: le Jeudi 19 D√©cembre 23h59.  ‚ö†Ô∏è Seul les commits avant la date limite seront pris en compte pour la notation.  Un document vous sera partag√© pour que vous puissiez noter le lien de votre d√©p√¥t.  (√âvidemment je dois avoir acc√®s √† votre d√©p√¥t pour pouvoir le consulter, faites bien attention √† ce qu'il soit en public (ou, si vous tenez √† le garder priv√©, ajoutez moi en collaborateur (dsmtE))).  Vous devez ajouter un fichier README.md √† la racine de votre d√©p√¥t et qui fera office de rapport et contiendra :  Des indications pour ex√©cuter votre programme si n√©cessaire (librairies, syst√®me d'exploitation test√©).Des explications sur l'organisation de votre code (fichiers, structure, fonctions, etc.) et vos choix d'impl√©mentation.Si am√©liorations il y a, une description des fonctionnalit√©s suppl√©mentaires que vous avez r√©alis√©es (et comment les utiliser si besoin).Un rapide bilan sur les probl√®mes rencontr√©s et solutions trouv√©es.  ‚ö†Ô∏è Attention: Un commit unique la veille de la date limite ne sera pas accept√©, vous devez montrer que vous avez travaill√© r√©guli√®rement sur le projet.  ","version":"Next","tagName":"h2"},{"title":"Post-mortem‚Äã","type":1,"pageTitle":"Project TicTacToe","url":"/Learn--cpp_programming/Subjects/IMAC2027/S1/Sujet#post-mortem","content":" Apr√®s avoir √©tablie le bar√®me de notation pour le sujet, j'ai d√©cid√© de tenir compte des am√©liorations pour obtenir la meilleure note de 20/20 afin de valoriser les √©l√®ves ayant r√©alis√© des fonctionnalit√©s suppl√©mentaires. Il √©tait donc n√©cessaire de r√©aliser le jeu de base ainsi qu'une petit am√©lioration √† minima pour obtenir la note maximale. ","version":"Next","tagName":"h2"},{"title":"IMAC TOWER DEFENSE","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet","content":"","keywords":"","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#introduction","content":" Il est temps de mettre en pratique les connaissances acquises en programmation et en synth√®se d'images.  Dans ce projet, vous allez cr√©er un jeu de type tower defense en utilisant OpenGL. Le Tower Defense est une cat√©gorie de jeu vid√©o qui consiste √† prot√©ger un lieu, un objet ou une personne √† l‚Äôaide de tours qui vont attaquer des vagues d‚Äôennemies. Vous trouverez quelques cl√©s pour comprendre cette cat√©gorie de jeu dans cette vid√©o Youtube.    Exemple de Tower Defense; source: pinterest    ","version":"Next","tagName":"h2"},{"title":"Cahier des charges‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#cahier-des-charges","content":" Voici les indications que vous devez respecter pour ce projet. Il s‚Äôagit des consignes du client. N√©anmoins, si vous souhaitez modifier certains points, vous devez au pr√©alable nous demander et nous convaincre des changements. Certains points seront explicit√©s dans les parties suivantes.  ","version":"Next","tagName":"h2"},{"title":"Fonctions/Gameplay‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#fonctionsgameplay","content":" Carte: Le jeu affiche une carte ou l‚Äôon peut identifier clairement le ou les d√©part.s des ennemies, leur destination (votre √©l√©ment √† prot√©ger) et plusieurs chemins qu‚Äôils peuvent emprunter. Tours: L‚Äôutilisateur peut poser des tours en dehors des √©l√©ments cit√©s au-dessus. Ces tours vont agir lorsqu‚Äôun ennemie passe √† proximit√©, par d√©faut, il va attaquer pour l‚Äôemp√™cher d‚Äôatteindre l‚Äôobjectif, mais vous pouvez imaginer d‚Äôautres comportements. Vague Ennemies: L‚Äôutilisateur peut d√©clencher les vagues d‚Äôattaques des ennemies. Un certain nombre d‚Äôennemies vont se succ√©der pour atteindre l‚Äôobjectif. Ils apparaissent dans les diff√©rents d√©parts et avancent en utilisant les chemins les plus pertinents. Fin: Lorsque l‚Äôutilisateur r√©ussit √† repousser les vagues d‚Äôattaques ou si un certain nombres d‚Äôennemis atteint leur destination, le jeu affiche un √©cran de fin (victoire ou d√©faite)  ","version":"Next","tagName":"h3"},{"title":"Projet‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#projet","content":" Structure du projet : Vous devez organiser votre code en fichiers et dossiers s√©par√©s. Nous recommandons l'utilisation d'un syst√®me de compilation CMake pour la compilation. Initialisation de la carte : Vous devez √™tre capable de charger une carte √† partir d'un fichier image et un fichier (texte) de configuration. Algorithmique : Vous devez mettre en place un graphe pour repr√©senter les chemins de la carte. Vous devez √©galement impl√©menter un algorithme de plus court chemin pour que les ennemies puissent trouver leur chemin vers la sortie. Synth√®se d'image : Vous devez afficher les √©l√©ments du jeu (carte, tours, ennemies) en utilisant des sprites (textures) et la biblioth√®que OpenGL. Gestion de Projet: Vous devez utiliser Git pour stocker/partager votre code et nous le rendre. Compilation: Un syst√®me de compilation Cmake devra √™tre int√©gr√© √† votre projet, d'autant que vous aurez √† utiliser des biblioth√®ques (opengl, lecture d'images, ...). votre projet devra contenir tout ce qui permet de le compiler et fonctionner sur Linux ou Windows (plateforme de d√©veloppement √† pr√©ciser dans le rapport). Si d√©veloppement sur macOS, pensez √† tester votre programme sur une autre machine afin que l'on puisse le compiler sur Linux ou Windows afin de le tester.  Le projet est √† faire par bin√¥me ou trin√¥mes. Les trin√¥mes devront obligatoirement r√©aliser deux fonctionnalit√©s suppl√©mentaires par rapport aux bin√¥mes. Si vous choisissez une am√©lioration qui n'est pas dans la liste des am√©liorations sugg√©r√©es, vous devrez nous en faire part pour validation.  ","version":"Next","tagName":"h3"},{"title":"Rapport‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#rapport","content":" Il contiendra une description des fonctionnalit√©s impl√©ment√©es de l'application (r√®gles du jeu, etc), un guide succinct d'utilisation, et des captures d'√©cran.  √âventuellement, si vous souhaitez mettre en avant Un bout de code pour sa performance ou parce qu‚Äôil s‚Äôagit d‚Äôune id√©e int√©ressante, vous pouvez l'int√©grer dans le rapport.  Post mortem: analyser le travail fourni, qu‚Äôest ce qui a bien fonctionn√©, quels ont √©t√© les probl√®mes rencontr√©s, comment vous les avez surmont√©s, auriez vous fait diff√©remment ? Avec plus de temps, qu‚Äôest ce que vous pourriez ajouter ?  Ne nous faites pas des romans, vous pouvez faire court, par exemple 2 √† 4 pages sans les illustrations.  ","version":"Next","tagName":"h3"},{"title":"Notation‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#notation","content":" Ce projet est commun aux mati√®res : Programmation et algorithmique C++ et Synth√®se d'images I. Le projet en lui-m√™me poss√®de deux aspects : une partie algorithmique et une partie infographie. Il y aura une base commune puis une note distinctive pour chaque mati√®re.  Exemple: note commune: 8, note algo: 6, note SI: 5 = note finale algo 14, note finale SI 13    ","version":"Next","tagName":"h2"},{"title":"Structure de votre programme‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#structure-de-votre-programme","content":" Dans ce projet complexe, il est hors de question de n'utiliser qu'un seul fichier. Il vous faut donc s√©parer l'application en diff√©rents fichiers .cpp et .hpp. La d√©coupe des fichiers est laiss√©e √† votre appr√©ciation mais doit √™tre logique. Globalement, le projet √©tant scind√© en deux parties, il serait logique que la partition des fichiers en tienne compte.  Un syst√®me de compilation Cmake devra √™tre int√©gr√© √† votre projet, d'autant que vous aurez √† utiliser des biblioth√®ques (opengl, lecture d'images, ...).  Note importante : Tout rendu de projet sans possibilit√© de le compiler sur Linux ou windows entra√Ænera un 0 ! (sauf si vous avez une raison valable et que vous avez pr√©venu vos enseignants).  Votre projet devra √™tre organis√© √† minima dans un r√©pertoire suivant la structure suivante :  NomDuProjet/ \\-- src/ \\-- lib/ \\-- data/ \\-- images/ \\-- doc/ \\-- CMakeLists.txt   Le r√©pertoire src contient les fichiers sources .cpp et .hpp (Vous avez la libert√© de placer plut√¥t les fichiers d'ent√™te .hpp dans un r√©pertoire include si vous pr√©f√©rez ce type de structure de projet mais vous devrez alors adapter votre CMakeLists.txt).(Optionnel) Le r√©pertoire lib contiendra les fichiers de vos biblioth√®ques ainsi que tout le n√©cessaire pour les compiler ou les inclure dans votre projet (Vous pouvez √©galement utiliser des fetch Cmake pour inclure des librairies).Le r√©pertoire data contient les fichiers .itd des niveaux (expliqu√©s plus loin dans le sujet) et autres fichiers de donn√©es utiles pour votre jeu.Le r√©pertoire images contient toutes les images du projet (sprite, niveaux, ...).Le r√©pertoire doc contiendra toute la documentation, dont votre rapport.Enfin, un CMakeLists.txt permettant de compiler le projet.(Optionnel) un r√©pertoire bin dans lequel sera export√© l'ex√©cutable compil√© du projet (le fichier ex√©cutable ne doit pas √™tre inclus dans le d√©p√¥t git).Tout dossier temporaire build (utilis√© par cmake par exemple) ne devra pas √™tre inclus sur git (.gitignore)  ","version":"Next","tagName":"h2"},{"title":"Carte et Fichier de description‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#carte-et-fichier-de-description","content":" Pour ce projet nous allons utiliser une carte √† base de cases (tile-based). C'est √† dire que la carte est segment√©e de cases de m√™me taille. Il y a diff√©rents types de cases: chemin, zone d'entr√©e, zone de sortie et case vide.  ","version":"Next","tagName":"h2"},{"title":"Donn√©es de la carte sous forme d'image‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#donn√©es-de-la-carte-sous-forme-dimage","content":" Pour repr√©senter la carte, nous utilisons une image en couleur au format .png afin d'indiquer visuellement o√π sont situ√©s les chemins, la/les zones d'entr√©es ainsi que la zone de sortie.  Attention il ne s'agit pas l√† de l'illustration de la carte, cans cette image, chaque pixel repr√©sente une case de la carte et la couleur du pixel indique une certaine information (le type entre autre). Ainsi, une image de 10x10 pixels repr√©sente une carte de 10x10 cases.  Voil√† un exemple d'une carte de 8x8 pixels :    Chaque case devra √™tre d'une couleur pr√©cise permettant d'associer √† cette case le type de zone. Ici les couleurs utilis√©es sont :  Chemin : Blanc (255, 255, 255)Zone d'entr√©e : Bleu (0, 0, 255)Zone de sortie : Rouge (255, 0, 0)  Ces couleurs sont √† pr√©ciser dans le fichier de description de la carte (voir section suivante) et permettront de d√©terminer de lire l'image et de d√©terminer le type de chaque case.  ","version":"Next","tagName":"h3"},{"title":"Chemin sous forme de graphe‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#chemin-sous-forme-de-graphe","content":" Pour permettre aux ennemies de se d√©placer sur la carte, nous allons utiliser une repr√©sentation des chemins sous forme de graphe. Chaque n≈ìud du graphe repr√©sente une intersection, un coude. La zone de sortie et d'entr√©e seront aussi des n≈ìuds. Les arr√™tes du graphe repr√©sentent les chemins reliant ces n≈ìuds. Par soucis de facilit√©, nous allons consid√©rer des lignes purement verticales ou horizontales.    Nous utiliserons ce graphe pour calculer le chemin le plus court entre la zone d'entr√©e et la zone de sortie pour les ennemies.  ","version":"Next","tagName":"h3"},{"title":"Fichier de description .itd‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#fichier-de-description-itd","content":" Les √©l√©ments constitutifs d'une carte sont regroup√©s dans un fichier texte de configuration simple d'extension .itd.  ‚ÑπÔ∏è Les extensions : L'extension ne change pas la nature d'un fichier, il s'agit surtout d'un prefix qui permet au syst√®me d'exploitation (grossi√®rement parlant) de rapidement savoir si un fichier est de tel ou tel type sans regarder le contenu. Ici on choisit un prefix &quot;.itd&quot; (Imac Tower Defense), on aurait pu choisir &quot;.toto&quot;  Ce fichier sera en fait un simple fichier texte. Il indiquera les diff√©rents param√®tres n√©cessaires pour charger les donn√©es d'un niveau, notamment les informations relatives √† la carte.  ITD # ligne de commentaire map fichier.png # Blanc path 255 255 255 # Bleu in 0 0 255 # Rouge out 255 0 0 graph 8 node 0 1 1 1 node 1 6 1 2 node 2 6 3 3 node 3 4 3 4 node 4 4 4 5 node 5 2 4 6 node 6 2 6 7 node 7 6 6   La premi√®re ligne est constitu√© d'un mot cl√© (pour ce projet, ce sera toujours &quot;ITD&quot;) indiquant qu'il s'agit d'un fichier de description de carte ITD.  Les lignes d'apr√®s seront ordonn√©es selon la position dans le tableau suivant (et donc lu dans un ordre donn√©) et constitu√©es de deux √©l√©ments : un mot cl√© et une valeur.  Mot cl√©\tDescription\tType de valeurmap\tNom du fichier image repr√©sentant la carte\tcha√Æne de caract√®res path\tCouleur repr√©sentant les cases de chemin\tTriplet R,V,B (0-255) in\tCouleur repr√©sentant la/les zone(s) d'entr√©e(s)\tTriplet R,V,B (0-255) out\tCouleur repr√©sentant la zone de sortie\tTriplet R,V,B (0-255) graph\tNombre de noeuds du graphe\tentier node\tDescription d'un noeud du graphe\tVoir ci-dessous  Les mots cl√©s permettent de se rep√©rer, de v√©rifier que les lignes sont dans le bon ordre lors de la lecture du fichier et donc d'indiquer si le fichier est mal format√© lors de sa lecture.  De plus, chaque ligne commen√ßant par un &quot;#&quot; sera consid√©r√© comme une ligne de commentaire et ignor√© pour la lecture du fichier (uniquement l√† pour des annotations si besoin comme dans l'exemple ci-dessus).  Comme vous pouvez le constater, le fichier contient la description du graphe repr√©sentant les chemins de la carte.  Un n≈ìud est d√©crit par un mot cl√© node suivi de plusieurs valeurs :  Un entier positif ou nul indiquant l'indice de ce n≈ìud.Deux coordonn√©es x, y indiquant la position (en cases) de ce n≈ìud dans l'image/carte (1 pixel = 1 case).Enfin, une liste d'indices repr√©sentant les n≈ìuds connect√©s.  Exemple node 1 6 1 2 corresponds au n≈ìud d'indice 1 de position en cases (6, 1) et connect√© au n≈ìud d'indice 2.  Ces n≈ìuds sont de natures diff√©rentes (Zone d'entr√©e des ennemies, zone de sortie, chemin) et cette nature est repr√©sent√©e dans l'image de la carte par un pixel d'une couleur particuli√®re. On pourra donc en d√©duire le type de n≈ìud en fonction de la couleur du pixel central de la case correspondante.  ","version":"Next","tagName":"h3"},{"title":"Validit√© du fichier‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#validit√©-du-fichier","content":" Plusieurs conditions doivent √™tre remplies pour qu'une carte soit valide pour le jeu. Votre application devra √™tre capable, lors du chargement, de v√©rifier si le fichier et donc la carte est valide ou non et d'indiquer √† l'utilisateur si ce n'est pas le cas (par un message d'erreur par exemple).  Vous devez v√©rifier les √©l√©ments suivants :  toutes les lignes n√©cessaires sont pr√©sentes et dans le bon ordre.Triplet RGB valide pour les couleurs (comprises entre 0 et 255).Fichier image existant.Les coordonn√©es des noeuds sont valides (dans l'image).Existence d'au moins une zone d'entr√©e et de sortie (cette v√©rification pourra se faire implicitement lors de la recherche du chemin des ennemies).Existence d'au moins un chemin entre la zone d'entr√©e et de sortie (cette v√©rification pourra se faire implicitement lors de la recherche du chemin des ennemies).  Vous n'avez pas √† v√©rifier que les arr√™tes du graphe passent bien par des cases de chemin, Cela pourrait √™tre une s√©curit√© suppl√©mentaire pour assurer une coh√©rence visuelle entre la carte et le graphe pr√©cis√© dans le fichier mais ce n'est pas obligatoire (cf am√©liorations sugg√©r√©s). Vous devez par contre faire attention lors de la cr√©ation de votre fichier pour que cela soit le cas auquel cas vous observerez des comportements inattendus (ennemis ne trouvant pas de chemin par exemple).  ","version":"Next","tagName":"h3"},{"title":"Affichage de la carte‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#affichage-de-la-carte","content":" Pour la partie graphique, vous devez afficher la carte √† l'√©cran.  Mais au lieu de simplement afficher les pixels de l'image, vous devez afficher des cases textur√©es en fonction du type de case (chemin, zone d'entr√©e, zone de sortie). Ces textures/images sont g√©n√©ralement appel√©es des sprites. Vous devez donc charger des sprites pour chaque type de case et les afficher √† la place des pixels de l'image.    Exemple de rendu en rempla√ßant les cases par des sprites  Il faudra tenir compte de la taille de vos sprites pour placer correctement les sprites et afficher la carte correctement.  ","version":"Next","tagName":"h3"},{"title":"√âl√©ments du jeu‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#√©l√©ments-du-jeu","content":" ","version":"Next","tagName":"h2"},{"title":"D√©roulement d'une partie‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#d√©roulement-dune-partie","content":" Au d√©but de la partie, le joueur dispose d'une certaine somme d'argent initiale pour construire des tours de d√©fense. Ces tours sont l√† pour d√©truire des ennemis, arrivant par vagues, et qui cherchent √† atteindre la zone de sortie. Si un ennemi parvient √† atteindre la zone de sortie la partie est perdue. Autrement, au bout d'un certain nombre de vagues, si aucun ennemie n'a atteint la zone de sortie, le joueur a gagn√©.  Chaque ennemie d√©truit par les tours rapporte de l'argent au joueur. Cet argent permet au joueur de construire des nouvelles tours.  ","version":"Next","tagName":"h3"},{"title":"Les chemins‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#les-chemins","content":" Comme √©voqu√© pr√©c√©demment, les chemins sont repr√©sent√©s par des pixels d'une certaine couleur dans l'image de la carte mais surtout par un graphe dans le fichier .itd.  Ce graphe est utilis√© pour calculer le chemin le plus court entre la zone d'entr√©e et la zone de sortie pour les ennemies.  Vous devez donc impl√©menter une structure de graphe pond√©r√© pour repr√©senter les chemins de la carte.  Pond√©r√© car les arr√™tes du graphe ont une longueur (en nombre de cases) qui correspond √† la distance entre deux n≈ìuds. Le poids d'une arr√™te est la distance entre les deux n≈ìuds en nombre de cases.  Les ennemies se d√©placent en utilisant le plus court chemin entre la zone d'entr√©e et leur destination. Vous devez impl√©menter l'algorithme de Dijkstra(recherche de chemin) pour trouver ce chemin.  ","version":"Next","tagName":"h3"},{"title":"Les ennemis‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#les-ennemis","content":" Un ennemi a 3 caract√©ristiques:  Des points de vie, ils se r√©duisent lorsqu'il est attaqu√© et lorsque ces points tombent √† 0, l'ennemie meurt et se retire de la carte.Une vitesse indiquant combien de cases il parcourt en un temps donn√©.Une r√©compense indiquant combien d'argent le joueur gagne en l‚Äô√©liminant.  Les ennemis arrivent par vagues. Id√©alement, le niveau de difficult√© du jeu devrait augmenter au fur et √† mesure que le joueur progresse (nombre d'ennemies par vague, points de vie des ennemies, argent gagn√©, ...).  S'il y a plusieurs zones d'entr√©e, vous √™tes libre de choisir comment les ennemies arrivent sur la carte (al√©atoirement, en alternance, ...).  Les ennemis doivent se d√©placer le long des chemins de la carte en continu. Par continuit√©, on entend que les ennemies ne se d√©placent pas de case en case mais de mani√®re &quot;fluide&quot;. Vous devez impl√©menter un algorithme de d√©placement pour les ennemis pour faire en sorte qu'ils se d√©placent de mani√®re fluide le long du chemin trouv√© par l'algorithme de recherche de chemin.  Astuce: Vous pouvez tout simplement utiliser des interpolations lin√©aires pour faire se d√©placer un ennemi d'arr√™te en arr√™te.  Graphiquement, vous devez √©galement repr√©senter les ennemies par des sprites.  ","version":"Next","tagName":"h3"},{"title":"Les tours‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#les-tours","content":" Le joueur peut cr√©er des tours de d√©fense qui tireront sur les ennemies. Les tours ont trois caract√©ristiques :  La puissance indique les d√©g√¢ts effectu√©s par la tour.La port√©e indique en cases la distance (discr√®te) √† laquelle la tour peut tirer (Cette distance sera mesur√©e avec la m√©thode de Chebyshev).  La distance de Chebyshev correspond √† ce que l'on appelle la 8 connexit√©s en traitement d'image. C'est une distance qui tient compte des d√©placements en diagonale.  La cadence indique en nombre de dixi√®me de secondes l'intervalle entre deux tirs.  Les diff√©rents param√®tres de ces diff√©rentes tours (puissance, port√©e, cadence) sont laiss√©s √† votre appr√©ciation. Chaque tour a √©galement un co√ªt d'achat pour pouvoir √™tre plac√©e dans la carte.  Voil√† des exemples de types de tours :  Des tours avec une bonne port√©e, une cadence de tir √©lev√©e mais une puissance de tir faible.Des tours avec une puissance de tir √©lev√©e mais une cadence tr√®s lente et une distance de tir moyenne.Des tours avec une port√©e tr√®s courte mais avec une cadence de tir √©lev√©e et une puissance moyenne....  Les tours sont √©galement repr√©sent√©es graphiquement par des sprites.  Les tours ne peuvent pas √™tre plac√©es sur un chemin, ni sur une autre tour. Il faut donc v√©rifier que le placement de la tour est valide en regardant le type de case et son contenu.  ","version":"Next","tagName":"h3"},{"title":"Interface graphique (IHM)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#interface-graphique-ihm","content":" Votre application contiendra au minimum une fen√™tre d'affichage contenant la carte et une fen√™tre contenant au moins un bouton permettant de quitter l'application.  Lors du lancement de l'application, une fois le fichier .itd charg√©, le jeu peut commencer apr√®s une action de l'utilisateur (bouton, touche, ...).  Le jeu fonctionne en &quot;continu&quot; c'est-√†-dire que c'est le temps qui rythme la succession des √©v√©nements (tirs des tours, d√©placement des ennemies, ...).  L'utilisateur peut par contre construire une tour quand il le souhaite. L'application doit indiquer visuellement si la case peut recevoir une tour.  Le joueur doit pouvoir mettre en pause l'application ou quitter le jeu √† tout moment (via un bouton ou une touche).  Votre interface devra permettre de visualiser les √©l√©ments suivants :  la carte, les ennemies et les toursIndiquer l'argent restant disponibleIndiquer le prix des toursS√©lectionner une tour √† construire (cela peut se faire par des boutons, des raccourcis clavier, ...)Placer cette tour dans la carte  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#r√©sum√©","content":" Pour r√©sumer, voici les √©l√©ments que vous devez impl√©menter dans votre jeu :  ITD : Chargement d'un fichier (texte) de description de carte.Sprites : Des images pour repr√©senter les √©l√©ments du jeu (carte, tours, ennemies).Graphes : Un graphe pond√©r√© pour repr√©senter les chemins de la carte.Ennemis : Des ennemis qui se d√©placent le long des chemins de la carte pour atteindre la zone de sortie. Minimum 2 types.D√©placement des ennemies : Un algorithme pour faire se d√©placer les ennemies de mani√®re &quot;fluide&quot;.Dijkstra : Un algorithme de recherche de chemin pour les ennemies.Tours : Des tours de d√©fense qui tirent sur les ennemies. Minimum 2 types.Tirs des tours : Les tours tirent sur les ennemies √† intervalle r√©gulier (la cadence de tir). Les tours tirent sur l'ennemi le plus proche d'elle.Placement des tours : Un syst√®me pour placer des tours sur une case valide.Argent : Un syst√®me d'argent pour acheter des tours. Les ennemies tu√©s rapportent de l'argent.Fin : Un √©cran de fin indiquant une d√©faite ou une victoire.IHM : Une interface graphique pour visualiser les √©l√©ments du jeu (argent, points de vie, ...). Le joueur doit pouvoir mettre en pause le jeu ou quitter √† tout moment.  ","version":"Next","tagName":"h2"},{"title":"Bonus et am√©liorations sugg√©r√©s‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#bonus-et-am√©liorations-sugg√©r√©s","content":" Tout outils, sp√©cifications ou fonctionnalit√©s suppl√©mentaires seront r√©compens√©s. Nous vous sugg√©rons les am√©liorations suivantes qui nous semblent int√©ressantes pour ce projet.  ","version":"Next","tagName":"h2"},{"title":"Zones constructibles pour les tours (algorithmique)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#zones-constructibles-pour-les-tours-algorithmique","content":" Mettons en place des zones constructibles pour les tours. Ces zones sont des cases de la carte o√π les tours peuvent √™tre plac√©es. Les zones constructibles sont repr√©sent√©es par des pixels d'une certaine couleur dans l'image de la carte.  Dans le fichier .itd, vous devrez ajouter une nouvelle ligne pour indiquer la couleur des zones constructibles.  Vous devrez √©galement v√©rifier que le placement de la tour est valide en regardant si la case sous la tour est bien constructible lors de la construction de la tour.  ","version":"Next","tagName":"h3"},{"title":"A* pour la recherche de chemin (algorithmique)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#a-pour-la-recherche-de-chemin-algorithmique","content":" Vous pouvez remplacer l'algorithme de Dijkstra par l'algorithme A* pour la recherche de chemin. L'algorithme A* est un algorithme de recherche de chemin plus efficace que Dijkstra qui utilise une heuristique pour guider la recherche.  ","version":"Next","tagName":"h3"},{"title":"Placement intelligent des sprites de chemin (algorithmique et synth√®se d'image)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#placement-intelligent-des-sprites-de-chemin-algorithmique-et-synth√®se-dimage","content":" Pour l'affichage de la carte, vous devez utiliser des sprites pour repr√©senter les √©l√©ments de la carte. Vous pouvez am√©liorer l'affichage en utilisant des auto-tiles. L'id√©e est d'afficher des sprites diff√©rents en fonction des cases adjacentes pour repr√©senter les chemins de mani√®re plus esth√©tique (au lieu de r√©p√©ter la m√™me sprite pour chaque case de chemin).    Exemple de rendu avec des auto-tiles  On peut remarquer qu'il a 4 adjacences (cas simple sans tenir compte des diagonales) pour une case (haut, bas, gauche, droite) et donc 16 possibilit√©s de sprites diff√©rents pour une case de chemin.  Vous pouvez utiliser ce qu'on appel un masque binaire (bitmask) pour repr√©senter les adjacences et donc les diff√©rentes possibilit√©s de sprites et choisir le bon sprite √† afficher en fonction de ce bitmask (dans un tableau de sprites, dans un tileset, ...).  Un bitmask est un nombre dont chaque bit repr√©sente une information. Par exemple, pour les auto-tiles, on peut utiliser un bitmask de 4 bits pour repr√©senter les 4 adjacences d'une case de chemin. le premier bit repr√©sente l'adjacence du haut, le deuxi√®me bit l'adjacence de gauche, le troisi√®me bit l'adjacence du droite et le quatri√®me bit l'adjacence du bas.    Exemple de tileset utilis√© pour g√©n√©rer l'exemple pr√©c√©dent  Plus d'explications sur cet article: https://code.tutsplus.com/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts--cms-25673t    Il est m√™me possible d'aller plus loin en utilisant des algorithmes d'auto-tiling plus complexes qui tiennent compte des diagonales ou d'ajouter d'autres r√®gles pour afficher des sprites suppl√©mentaires en fonction de valeurs al√©atoires ou de conditions particuli√®res.  Cela peut se faire √† l'aide de r√®gles de placement de tiles successives (au lieu d'utiliser la technique du bitmask). Le bitmak est une technique simple et efficace pour commencer mais pourrait se remplacer par une succession de 16 r√®gles de placement de tiles (si voisin haut et gauche alors sprite 1, si voisin haut et droite alors sprite 2, ...).  un exemple avec l'ajout d'herbes et arbres sur les cases qui ne sont pas des chemins de mani√®re al√©atoire :    ","version":"Next","tagName":"h3"},{"title":"Sprite anim√© (synth√®se d'image)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#sprite-anim√©-synth√®se-dimage","content":" Pour les ennemies, vous pouvez ajouter une animation pour les ennemies. Par exemple, vous pouvez faire en sorte que les ennemies aient une animation de marche lorsqu'ils se d√©placent.  Cela peut se faire en utilisant plusieurs sprites pour repr√©senter les diff√©rentes √©tapes de l'animation. Ces sprites sont affich√©s les uns apr√®s les autres pour donner l'illusion du mouvement.  Les diff√©rentes sprites sont g√©n√©ralement regroup√©es dans une seule image appel√©e sprite sheet.  Exemple de sprite sheet pour un effet de feu :    ","version":"Next","tagName":"h3"},{"title":"Generation du graphe √† partir de l'image (algorithmique)‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#generation-du-graphe-√†-partir-de-limage-algorithmique","content":" On peut se rendre compte que d√©tailler le graphe dans un fichier texte peut √™tre fastidieux et source d'erreur. Cela fait donc sens de g√©n√©rer ce graphe √† partir de l'image de la carte. Cela rendrait la cr√©ation de niveaux plus simple et plus rapide et √©viterait les erreurs de saisie.  L'image √©tant relativement simple, il est possible de parcourir l'image pixel par pixel (et donc case par par case) pour trouver les noeuds et les arr√™tes du graphe.  L'id√©e est de parcourir l'image et de trouver dans un premier temps un noeud √©vident (zone d'entr√©e, zone de sortie) puis √† partir de ce noeud it√©rer dans les 4 directions pour trouver les autres noeuds et les arr√™tes du graphe (chemins) de proche en proche. Cela peut se faire de mani√®re r√©cursive ou it√©rative c'est √† vous de voir.  Si vous d√©cidiez d'impl√©menter cette am√©lioration, vous pourrez donc omettre la partie graph et node du fichier .itd. Il faudra le g√©rer dans votre code (d√©tecter l'absence de ces lignes et g√©n√©rer le graphe √† partir de l'image ou introduire un nouveau mot cl√© dans le fichier .itd pour indiquer que le graphe doit √™tre g√©n√©r√© √† partir de l'image).  Si vous avez des questions sur cette am√©lioration, n'h√©sitez pas √† demander √† vos enseignants d'algorithmie pour plus de d√©tails.  ","version":"Next","tagName":"h3"},{"title":"Autres am√©liorations possibles‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#autres-am√©liorations-possibles","content":" On peut penser notamment √† :  Diff√©rents types de ennemies avec des caract√©ristiques diff√©rentes.Diff√©rents types de tours avec des caract√©ristiques diff√©rentes.D√©placement stochastique des ennemies : d√©placement al√©atoire √† chaque noeud rencontr√©.Diff√©rents types de terrain pour les chemins ralentissant ou acc√©l√©rant les ennemies.Visualisation des tirs des tours sur les ennemies.S√©lection des ennemies et affichage de leurs propri√©t√©s.Dans le cas de diff√©rents types de tours, avoir une r√©sistance propre √† chacun des types de tours pour les ennemies.Cr√©er une zone de sortie ayant des points de vie, encaissant les d√©g√¢ts des ennemies avant de perdre la partie.Strat√©gies diff√©rentes pour les tours (priorit√© sur les ennemies les plus proches, les plus faibles, les plus forts, ...).Fonctionnalit√© de sauvegarde et de chargement de partie....  N√©anmoins, si une nouvelle fonctionnalit√© modifiait m√™me de mani√®re l√©g√®re les sp√©cifications, notamment le format des fichiers .itd, pr√©sentes dans cette description de projet alors cette nouvelle fonctionnalit√© devra √™tre valid√©e par vos enseignants. Elle devra aussi √™tre indiqu√©e clairement dans le rapport.  ","version":"Next","tagName":"h3"},{"title":"Conseils et remarques‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#conseils-et-remarques","content":" Ce sujet de projet constitue un cahier des charges de l'application. Tout changement √† propos des sp√©cifications du projet doit √™tre valid√©e par vos enseignants. Le temps qui vous est imparti n'est pas de trop pour r√©aliser ce projet. N'attendez pas le dernier mois pour commencer √† coder. Il est tr√®s important que vous r√©fl√©chissiez avant de commencer √† coder aux principaux modules, algorithmes et aux principales structures de donn√©es que vous utiliserez pour votre application. Il faut √©galement que vous vous r√©partissiez le travail et que vous d√©terminiez les t√¢ches √† r√©aliser en priorit√©. Ne r√©digez pas le rapport √† la derni√®re minute sinon il sera b√¢cl√©. Il est imp√©ratif que chacun d'entre vous travaille sur une partie et non pas tous &quot;en m√™me temps&quot; (plusieurs qui regardent un travailler). Sinon, vous n'aurez pas le temps de tout faire. C'est encore plus vrai pour les trin√¥mes. Rappel: Les trin√¥mes devront obligatoirement r√©aliser des fonctionnalit√©s suppl√©mentaires (expliqu√©es dans la section projet) par rapport aux bin√¥mes. Utilisez la biblioth√®que standard C++ pour les structures du type listes (std::vector), piles (std::stack), files (std::queue). N'oubliez pas de tester votre application √† chaque sp√©cification impl√©ment√©e. Il est impensable de tout coder puis de tout v√©rifier apr√®s. Pour les tests, confectionnez-vous tout d'abord de petites cartes (taille 5 par 5 par exemple) avec un chemin extr√™mement simple. Si cela marche, vous pouvez passer √† plus gros ou plus complexe. Vos charg√©s de TD et CM sont l√† pour vous aider. Si vous ne comprenez pas un algorithme ou avez des difficult√©s sur un point (probl√®me technique, compr√©hension du sujet, etc), n'attendez pas la soutenance pour nous en parler ! Vous ne devez utiliser que des assets libres de droit pour votre projet. Vous devez citer les sources des assets utilis√©s dans votre rapport. Vous pouvez bien s√ªr cr√©er vos propres assets.  ","version":"Next","tagName":"h2"},{"title":"Sources‚Äã","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/sujet#sources","content":" Assets utilis√©s pour les illustrations :  kenney: pixel-shmupbrullov: fire-animation  Logiciel utilis√© pour cr√©er les images :  Ldtk ","version":"Next","tagName":"h2"},{"title":"Retours G√©n√©raux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks","content":"","keywords":"","version":"Next"},{"title":"C++‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#c","content":" ","version":"Next","tagName":"h2"},{"title":"\"Using namespace\" dans les headers‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#using-namespace-dans-les-headers","content":" J'en ai d√©j√† parl√© au retour des projets du premier semestre ici mais je le r√©p√®te ici : Il ne faut pas utiliser using namespace dans les headers, car cela va polluer l'espace de nommage de tous les fichiers qui incluent ce header. C'est envisageable dans les fichiers sources, mais interdit dans les headers.  ","version":"Next","tagName":"h3"},{"title":"Variables globales‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#variables-globales","content":" L'utilisation de variables globales est √† √©viter autant que possible. Cela peut rendre le code difficile √† comprendre et √† maintenir, car les variables globales peuvent √™tre modifi√©es n'importe o√π dans le programme, ce qui peut entra√Æner des comportements impr√©visibles. Plus de d√©tails ici.  ","version":"Next","tagName":"h3"},{"title":"Utilisation de static, mutable ou extern ...‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#utilisation-de-static-mutable-ou-extern-","content":" J'ai remarqu√© que certains d'entre vous utilisaient des mots cl√©s C++ que nous n'avons pas vu en cours, comme static, mutable, extern, inline, etc. Pourquoi pas, mais attention √† ne pas les utiliser de mani√®re inappropri√©e ou sans en comprendre le fonctionnement.  extern par exemple est un mot cl√© qui permet de d√©clarer une variable ou une fonction dans un fichier source. Elle peut √™tre utilis√©e dans d'autres fichiers sources de sorte que la variable devient globale et accessible depuis n'importe quel fichier source qui inclut le header o√π elle est d√©clar√©e. Cela peut sembler pratique, mais cela peut aussi causer des probl√®mes de confusion et de maintenance du code et c'est g√©n√©ralement √† √©viter et une mauvaise pratique. C'est pourquoi nous n'avons pas vu ces mots cl√©s en cours, car ils ne sont pas n√©cessaires pour la plupart des projets que nous avons r√©alis√©s. A votre √©chelle de projet leur usage n'est pas un probl√®me majeur, mais c'est une mauvaise habitude.  L'alternative ici est de passer en param√®tre les variables n√©cessaires aux fonctions ou aux classes, plut√¥t que de les d√©clarer globales. Ou alors de cr√©er une structure pour grouper ces variables et de passer cette structure en param√®tre plus facilement.  ","version":"Next","tagName":"h3"},{"title":"Utilisation du d√©bogueur‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#utilisation-du-d√©bogueur","content":" Je vous conseille de toujours compiler et ex√©cuter votre programme en mode d√©bogage, m√™me si vous n'avez pas besoin de d√©boguer. Cela vous permettra de d√©tecter plus facilement les erreurs et de comprendre le comportement de votre programme. Un crash dans un programme sans d√©bogage peut √™tre difficile √† comprendre, alors qu'en mode d√©bogage, vous pouvez voir exactement o√π et pourquoi cela s'est produit car les informations sont conserv√©es et parfois la ligne exacte o√π le probl√®me se produit est indiqu√©e.  ","version":"Next","tagName":"h3"},{"title":"Optimisation pr√©matur√©e‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#optimisation-pr√©matur√©e","content":" Il est important de ne pas se pr√©cipiter dans l'optimisation pr√©matur√©e de votre code. Optimiser c'est bien mais vouloir le faire avant d'avoir un code fonctionnel peut vous amener √† des choix de conception qui compliquent inutilement votre code et le rendent plus difficile √† comprendre et √† maintenir.  Il est pr√©f√©rable de se concentrer d'abord sur le fonctionnement et la lisibilit√© du code, puis de tester pour identifier les parties du code qui sont co√ªteuses en termes de performance afin de comprendre le probl√®me et √©ventuellement les optimiser par la suite si c'est n√©cessaire.  Quelques vid√©os int√©ressantes √† ce sujet que je vous recommande :  The Premature Optimization FallacyPremature Optimization  ","version":"Next","tagName":"h3"},{"title":"Nommage des variables‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#nommage-des-variables","content":" J'ai encore vu beaucoup de noms de variables peu explicites ou trop courts, comme x, p, isC, ... C'est parfois acceptable pour des variables temporaires ou des boucles (i pour l'it√©rateur d'une boucle), ou des abr√©viations tr√®s communes (pos pour position, vel pour v√©locit√©, dir pour direction, etc.), mais il est pr√©f√©rable d'utiliser des noms de variables clairs.  Exemple de nommages que j'ai rencontr√© dans un projet dans le monde professionnel (stage sur le logiciel open-source Meshroom):  ci pour facetCellIndexlpi pour lastPointIntersectionop pour originPoint  J'ai pass√© plus de temps √† essayer de comprendre ce que ces variables signifiaient qu'√† √©crire du code.  Je vous conseille donc de toujours utiliser des noms de variables explicites et significatifs, qui d√©crivent clairement leur r√¥le et leur contenu. Cela rendra votre code plus lisible et plus facile √† comprendre pour vous et pour les autres d√©veloppeurs qui pourraient travailler sur votre code √† l'avenir ou m√™me vous-m√™me dans quelques jours/mois (m√™me si cela semble √©vident sur le moment).  Il m'est arriv√© √† plusieurs reprises de passer plus de 30min √† discuter avec un coll√®gue pour comprendre ce que faisait une variable mal nomm√©e dans le code puis pour lui trouver un nom plus explicite et pertinent. Ce n'est pas juste pour vous emb√™ter, c'est quelque chose de tr√®s important surtout dans le monde professionnel.   ","version":"Next","tagName":"h3"},{"title":"Orient√© objet et Getters/Setters‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#orient√©-objet-et-getterssetters","content":" On a pas vu l'orient√© objet en C++ dans le cours, mais certains d'entre vous l'ont utilis√© dans leur projet. C'est tr√®s courant, mais attention √† ne pas tomber dans les pi√®ges de l'orient√© objet, comme l'utilisation excessive de getters et setters. Un getter est une m√©thode qui permet d'acc√©der √† une variable d'une classe, quand elle est priv√©e ou prot√©g√©e, et un setter est une m√©thode qui permet de modifier cette variable. L'utilisation de getters et setters est une bonne pratique pour encapsuler les donn√©es et prot√©ger l'int√©grit√© des objets. Cependant, il ne faut pas en abuser et ne pas cr√©er des getters et setters pour chaque variable d'une classe.  Si ces getters et setters ne font que retourner ou modifier la variable sans aucune logique suppl√©mentaire, cela peut rendre le code plus verbeux et moins lisible.  C'est tout de m√™me une bonne pratique pour pouvoir v√©rifier ou modifier la valeur d'une variable avant de la retourner ou de la modifier, mais il est pr√©f√©rable de le faire uniquement lorsque cela est n√©cessaire.  ","version":"Next","tagName":"h3"},{"title":"Vecteur 1D vs 2D‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#vecteur-1d-vs-2d","content":" L'objet std::vector a un fonctionnement particulier en C++ en ce qui concerne la m√©moire. Un std::vector est un tableau dynamique qui stocke des √©l√©ments contigus en m√©moire et qui peut √™tre redimensionn√©. Mais lorsqu'on utilise un std::vector dans un std::vector, les √©l√©ments ne sont pas contigus en m√©moire (les std::vector imbriqu√©s sont eux-m√™mes des pointeurs vers d'autres tableaux).  Cela peut poser des probl√®mes de performance et de m√©moire, car l'acc√®s aux √©l√©ments d'un std::vector imbriqu√© peut √™tre plus lent que l'acc√®s aux √©l√©ments d'un tableau contigu.  Cependant, c'est en effet plus simple d'utilisation d'acc√©der √† un √©l√©ment en 2D en faisant vec[i][j]. Or, il est quand m√™me possible de repr√©senter en m√©moire notre information 2D comme un tableau 1D et en utilisant une formule pour acc√©der aux √©l√©ments. Voici un exemple de code pour acc√©der √† un √©l√©ment d'un tableau 2D stock√© dans un std::vector 1D :  float&amp; getElement(std::vector&lt;float&gt;&amp; vec, const size_t width, const size_t x, const size_t y) { return vec[y * width + x]; }   Ou m√™me d'encapsuler cela dans une structure pour stocker les dimensions et faciliter l'acc√®s aux √©l√©ments (exemple d'utilisation d'une structure pour un tableau 2D) :  struct Array2D { std::vector&lt;float&gt; data; size_t width; size_t height; Array2D(size_t w, size_t h) : width(w), height(h), data(w * h) {} float&amp; get(size_t x, size_t y) { return data[y * width + x]; } }; // Exemple d'utilisation Array2D array(10, 10); array(5, 5) = 42.0f; // Acc√®s √† l'√©l√©ment (5, 5)   Cela permet donc de profiter des avantages de performance et de m√©moire en utilisant un tableau 1D tout en gardant une interface simple pour acc√©der aux √©l√©ments en 2D.  ","version":"Next","tagName":"h3"},{"title":"OpenGL‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#opengl","content":" ","version":"Next","tagName":"h2"},{"title":"Probl√®me d'encapsulation (constructeurs/destructeurs)‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#probl√®me-dencapsulation-constructeursdestructeurs","content":" Certains d'entre vous ont rencontr√© des probl√®mes avec l'encapsulation des ressources OpenGL, notamment avec les constructeurs et destructeurs des classes qui g√®rent les ressources OpenGL.  Lors de la cr√©ation et destruction d'un objet OpenGL, il est important de s'assurer que les ressources sont correctement allou√©es et lib√©r√©es. Or, dans votre cas, la classe responsable de la cr√©ation des ressources OpenGL n'√©tait pas correctement encapsul√©e et pouvait √™tre copi√©e (par assignation ou retour de variable par valeur), ce qui entra√Ænait des probl√®mes de lib√©ration des ressources pr√©matur√©e ou de double lib√©rations.  Pour √©viter cela, il est recommand√© d'utiliser des m√©canismes similaires aux pointeurs intelligents en C++ (comme std::unique_ptr ou std::shared_ptr) pour g√©rer la dur√©e de vie des ressources OpenGL, ou d'utiliser des classes qui ne peuvent pas √™tre copi√©es (en d√©clarant le constructeur de copie et l'op√©rateur d'assignation comme delete).  Ce n'est pas de votre faute, mais pour vous rendre compte de ces probl√®mes il est important de penser √† lancer votre programme dans un environnement de d√©bogage et de v√©rifier les erreurs OpenGL avec glGetError() par exemple ou la validit√© des ID de buffers, textures, etc. pour d√©tecter les probl√®mes de gestion des ressources.  Vous pouvez aussi par exemple ajouter un &quot;breakpoint&quot; dans le destructeur de votre classe pour v√©rifier s'il est appel√© au moment o√π vous vous y attendez (si c'est appel√© trop t√¥t ou trop tard c'est un signe que quelque chose ne va pas).  Enfin, pensez √† contacter le professeur concern√© si vous avez des questions ou des probl√®mes avec les fichiers partag√©s pour le projet.  ","version":"Next","tagName":"h3"},{"title":"Gestion de la m√©moire CPU / GPU‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#gestion-de-la-m√©moire-cpu--gpu","content":" Quand on utilise une application graphique, il y a un √©change de donn√©es entre le CPU (processeur central) et le GPU (processeur graphique). Un mesh est cr√©√© sur le CPU, puis envoy√© au GPU pour √™tre affich√©. Cet √©change de donn√©es entre le CPU et le GPU est co√ªteux en termes de performance. Il est donc pr√©f√©rable de modifier le mesh uniquement lorsque c'est n√©cessaire.  Si on souhaite d√©placer un √©l√©ment dans la sc√®ne, il ne faut pas modifier le mesh directement , mais utiliser des transformations (comme des translations, rotations, etc.) pour d√©placer l'√©l√©ment dans la sc√®ne. C'est le r√¥le des matrices de transformation (et variables uniformes) dans OpenGL.  ","version":"Next","tagName":"h3"},{"title":"Autres‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#autres","content":" ","version":"Next","tagName":"h2"},{"title":"Lire le sujet‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#lire-le-sujet","content":" Il est important de lire attentivement le sujet du projet et de comprendre les attentes et les contraintes avant de commencer √† coder. Cela vous permettra de mieux comprendre les objectifs du projet et de ne pas perdre de temps √† coder des fonctionnalit√©s qui ne sont pas demand√©es ou qui ne sont pas pertinentes. Il faut avant tout se concentrer sur les fonctionnalit√©s demand√©es avant de vouloir ajouter des fonctionnalit√©s suppl√©mentaires ou de modifier le sujet. Si vous avez des questions ou des doutes sur le sujet, n'h√©sitez pas √† en discuter.  ","version":"Next","tagName":"h3"},{"title":"Modifications du sujet‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#modifications-du-sujet","content":" Si vous avez des suggestions ou des modifications √† apporter au sujet, il faut en discuter avec le professeur concern√©. Il faut faire valider les modifications et v√©rifier qu'elles ne vont pas √† l'encontre des objectifs du projet. Il ne faut pas remplacer la fonctionnalit√© par une autre sans en parler car cela peut √™tre mal per√ßu ou m√™me sanctionn√©.  ","version":"Next","tagName":"h3"},{"title":"Fichiers fournis‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#fichiers-fournis","content":" Si vous √™tes bloqu√© par ce que l'on vous fournit, allez poser des questions au professeur concern√©. Vous devez √™tre en mesure de comprendre comment les utiliser dans votre projet. N'attendez pas la derni√®re minute pour poser des questions ou demander de l'aide, car cela peut retarder votre projet et vous emp√™cher de le terminer √† temps.  ","version":"Next","tagName":"h3"},{"title":"Pr√©sentation‚Äã","type":1,"pageTitle":"Retours G√©n√©raux","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/Feedbacks#pr√©sentation","content":" Lors de votre pr√©sentation, concentrez vous sur le fonctionnement de votre programme et les choix techniques que vous avez faits, plut√¥t que de pr√©senter le code en d√©tail. La pr√©sentation n'est pas l√† pour montrer chaque ligne de code, mais pour expliquer comment votre programme fonctionne et comment vous avez r√©solu les probl√®mes que vous avez rencontr√©s. Vous pouvez parler de ce qui ne fonctionne pas mais il ne faut pas s'attarder dessus, et plut√¥t parler de ce qui a √©t√© r√©alis√© et comment vous avez surmont√© les obstacles. Imaginez que vous pr√©sentez votre projet √† un client ou √† un employeur, et que vous devez leur expliquer comment votre programme fonctionne et pourquoi il est int√©ressant. Un client ne voudra pas &quot;acheter&quot; un produit si on lui r√©p√®te que √ßa ne fonctionne pas, mais plut√¥t s'il est convaincu de l'int√©r√™t du produit et de la qualit√© du travail fourni. ","version":"Next","tagName":"h3"},{"title":"Retours","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks","content":"","keywords":"","version":"Next"},{"title":"Rendu Projet‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#rendu-projet","content":" Envoyer uniquement le minimum n√©cessaire pour compiler et lancer l'executable:  code source du projet S‚Äôil y a du code mort (qui n‚Äôest utilis√© nulle part) ou des lignes de codes comment√©es, nettoyer avant le rendu. les utilitaires de compilation (Makefile, CMakelist, librairies ou autre)ressources/assets du projet (textures, son, polices ...)  Ne pas envoyer:  les executables et les dossiers compil√©s (.o et autres fichiers g√©n√©r√©s par cmake)Si vous pouvez, √©viter les fichiers lourds (son/video pas compress√©.e, ...)  git Il est important de ne pas inclure les fichiers compil√©s dans le d√©p√¥t git car ils sont propres √† chaque machine et configuration (compilateur, structure de dossier personnelle, etc). Il est pr√©f√©rable de les ajouter dans le fichier .gitignore pour ne pas les inclure dans le d√©p√¥t git. De plus ces fichier sont g√©n√©r√©s automatiquement √† partir des fichiers sources, il n'est donc pas n√©cessaire de les inclure dans le d√©p√¥t git et cela permet de garder le d√©p√¥t git propre.  ","version":"Next","tagName":"h2"},{"title":"Soutenance‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#soutenance","content":" Pr√©parer le d√©roul√© de la soutenance Si d√©mo, faire en sorte que votre sc√©nario de d√©mo mette en valeur les fonctionnalit√©s qui fonctionnent le mieux Ne montrer pas de code (ou tr√®s peu) Si vous voulez montrer l‚Äôarchitecture ou des algos, soyez sch√©matique Si vous voulez d√©crire des fonctionnalit√©s, utiliser surtout la d√©mo pour les montrerVous pouvez parler des difficult√©s rencontr√©s mais il ne faut pas √ßa p√®se sur le reste de la soutenance. Vous √™tes l√† pour montrez le meilleur de vous m√™me et le travail accompli.  ","version":"Next","tagName":"h2"},{"title":"Gestion de Projet‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#gestion-de-projet","content":" ","version":"Next","tagName":"h2"},{"title":"√âtapes‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#√©tapes","content":" Commencer par vous approprier les ‚Äúspecs‚Äù/le cahier des charges Reprendre avec vos mots et assurez vous d‚Äôavoir compris ce qui est attenduFaire une veille et voir l‚Äô√©tat de l‚Äôart selon le projet. Si c‚Äôest un jeu de type Tower Defense, voir ce qui existe comme jeu de ce type.D√©couper le projet en petite tache, Exemple: Faire l‚Äôaffichage d‚Äôune carte diviser en plusieurs tiles.Lire un fichier ITD et en tirer des informations utilisables.Faire bouger un Ennemie d‚Äôun bout √† l‚Äôautre de la carte.‚Ä¶ R√©fl√©chir √† la DA, le level design, l‚Äôexp√©rience utilisateur, ‚Ä¶ Cette √©tape est moins importante dans le cadre d‚Äôun projet informatique, √©tant donn√© le temps qui vous est imparti, ne passez pas trop de temps dessus √âvaluer la temporalit√© de ces t√¢ches. Il vous est compliqu√© pour l‚Äôinstant d‚Äô√©valuer le temps que va prendre une tache mais d√©terminer au moins quelle tache doit √™tre fait avant quelle autre et s‚Äôil y a des taches parall√©lisable. En gestion de projet, il s‚Äôagit de faire un diagramme de Gant (vous n‚Äô√™tes pas oblig√© d‚Äôaller aussi loin) Tout au long du projet, r√©fl√©chir, √† c√¥t√©, √† ce qui peut √™tre int√©ressant √† garder/documenter pour la soutenance/le rapportR√©fl√©chir collectivement √† l‚Äôorganisation du code et √† la base de celui ci. Faire un sch√©ma ou une mind map pour clarifier vos id√©es. Attribuer les t√¢ches √† chacun selon les envies et les expertises. ‚ö†Ô∏è Pour un projet dans le cadre d‚Äôun cours informatique, il faut que chacun soit impliqu√© dans le code, il s‚Äôagit avant tout d‚Äôune √©valuation de vos comp√©tences. D√©velopper Concevoir des tests it√©ratif qui valide la fonctionnalit√© que vous d√©veloppez.D√©velopper sans GUI lorsque la fonctionnalit√© n‚Äôest pas directement li√© √† celle ci. Exemple: D√©placement d‚Äôun ennemie selon un graphe, afficher la position dans la console et v√©rifier que la position est raccord avec le graphVous pouvez bien s√ªr vous aider de la GUI pour vous rendre compte de la fonctionnalit√© dans son √©tat final mais elle ne doit pas vous bloquer Expliquer succinctement votre code √† vos collaborateursRaccorder votre code au reste du projet Faire les assets et le level design Selon la DA choisi, trouver ou cr√©er les assets (textures, sons, police‚Ä¶) dont votre jeu/programme a besoin.  ","version":"Next","tagName":"h3"},{"title":"Outils Kanban‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#outils-kanban","content":" Pour organiser vos t√¢ches, vous pouvez utiliser des outils comme:  TrelloNotionGitHub / GitlabMeistertask  ","version":"Next","tagName":"h3"},{"title":"Architecture logiciel‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#architecture-logiciel","content":" ","version":"Next","tagName":"h2"},{"title":"Variables Globales‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#variables-globales","content":" √âviter les variables globales, d√©j√† pour une question de suivi et de lecture de code, pour savoir d'o√π vient une variable et o√π est elle initialis√©e.  Par ailleurs si on multiplie les variables globales, on risque m√©langer des variables locales avec celles-l√†.  Si j'ai une variable mur globale et que je veux nommer une variable locale mur, soit le compilateur va m'envoyer chier soit le programme va avoir des comportements inattendu parce que les variables se confondent.  Et une autre raison qui vous emp√™che tout simplement de le faire, le compilateur, lorsqu'il atteint la compilation des fichiers interm√©diaires, il peut √™tre amen√© √† vous afficher une erreur de variable multiple multiple declaration of machin.  Solutionüí°: Faire une structure ou une classe qui va contenir les donn√©es dont vous avez besoin dans beaucoup d'endroit et qui sont uniques √† une execution du programme. Vous pouvez ensuite passer cette structure (par r√©f√©rence) dans vos fonctions pou acc√©der √† l'√©tat de votre jeu et des variables partag√©s. struct Game { BallsList balls; Wall walls[10]; int walls_count; std::string background_color; } Une autre solution est de cr√©er une classe et de lui ajouter une fonction (statique) qui va cr√©er une instance unique et la renvoyer √† chaque fois, c'est ce qu'on appelle un singleton. attention Attention, les singletons gardent les m√™me travers que les variables globales en terme de suivi de donn√©es. il faut donc les utiliser avec parcimonie.  class Game { private: // Constructeur priv√© pour rendre la classe impossible √† instancier manuellement sans passer par la m√©thode get_instance Game() {} // Un singleton est une instance unique de la classe donc on ne peut pas la copier Game(Game const&amp;) = delete; void operator=(Game const&amp;) = delete; public: // M√©thode publique pour r√©cup√©rer l'instance unique de la classe (et la cr√©er si elle n'existe pas) static Game&amp; get_instance() { static Game instance; return instance; } // ... }   quelques liens pour approfondir le sujet:  Singleton Design PatternMeyers SingletonSingleton Pattern  ","version":"Next","tagName":"h3"},{"title":"Dirty pattern‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#dirty-pattern","content":" J'ai vu plusieurs d'entre vous utiliser un pattern tr√®s utilis√© dans les moteurs de jeux, que je vais appeler le &quot;dirty pattern&quot;. C'est une technique qui consiste √† marquer un √©l√©ment (structure, classe) comme &quot;dirty&quot; pour savoir si il faut mettre √† jour certaines donn√©es qui lui sont associ√©es. C'est une technique tr√®s utilis√©e dans les moteurs de jeux pour savoir si il faut recalculer certaines donn√©es (comme le chemin d'un ennemi par exemple). Cela permet d'√©viter de recalculer des donn√©es qui n'ont pas chang√©. Par exemple, si vous avez un monstre qui se d√©place sur une carte, vous pouvez marquer le monstre comme &quot;dirty&quot; si il a chang√© de position. Ainsi, vous savez que vous devez recalculer le chemin du monstre pour le d√©placer √† sa nouvelle position. Si le monstre n'a pas boug√©, vous n'avez pas besoin de recalculer le chemin. C'est une technique tr√®s efficace pour √©viter de recalculer des donn√©es inutilement.  ","version":"Next","tagName":"h3"},{"title":"Orient√© objet‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#orient√©-objet","content":" C'est bien d'avoir pens√© √† l'orient√© objet, mais attention √† ne pas tomb√© dans le pi√®ge de l'orient√© objet pour l'orient√© objet. C'est une notion que vous d√©couvrez plus l'ann√©e prochaine mais il est possible de d√©finir la visibilit√© des attributs et m√©thodes d'une structure ou classe (public, protected, private). Cela permet de prot√©ger les attributs et de ne pas permettre de les modifier directement (pour l'utilisateur de la classe). C'est une bonne pratique de les mettre en private et de cr√©er des m√©thodes pour les modifier (setter) et les r√©cup√©rer (getter). Cela permet de contr√¥ler l'acc√®s aux attributs et de garantir l'int√©grit√© des donn√©es.  mais il ne faut pas tomber dans l'exc√®s, si c'est pour juste retourner et r√©cup√©rer la value d'un attribut (autant qu'il soit public dans ce cas).  #include &lt;string&gt; class Monster { public: float get_max_health(); float get_health_points(); std::string get_name(); // ... void set_max_health(float const max_health); void set_health_points(float const health_points); void set_name(std::string const&amp; name); // ... private: float max_health; float health_points; std::string name; // ... }; float Monster::get_max_health() { return this-&gt;max_health; } float Monster::get_health_points() { return this-&gt;health_points; } std::string Monster::get_name() { return this-&gt;name; } // ... void Monster::set_max_health(float const max_health) { this-&gt;max_health = max_health; } void Monster::set_health_points(float const health_points) { this-&gt;health_points = health_points; } void Monster::set_name(std::string const&amp; name) { this-&gt;name = name; } // ...   Ici, il serait pr√©f√©rable de mettre certains attributs en public (si ils sont juste des valeurs modifiable sans contr√¥le par l'utilisateur) et d'autres en private (si ils sont des donn√©es interne √† la classe). Par exemple, le maximum de vie d'un monstre ne devrait pas √™tre modifi√© directement par l'utilisateur mais set une seule fois √† la cr√©ation du monstre (√† l'aide d'un constructeur par exemple). En revanche, la vie actuelle du monstre peut √™tre modifi√©e par l'utilisateur (lorsqu'il est attaqu√© par exemple). L'int√©r√™t de faire un setter pour la vie actuelle est de pouvoir v√©rifier que la vie ne d√©passe pas le maximum de vie du monstre par exemple.  Dans l'exemple ci-dessous on v√©rifie donc que la vie actuelle est bien comprise entre 0 et le maximum de vie. Le nom du monstre peut √™tre modifi√© par l'utilisateur(pas de v√©rification particuli√®re), je laisse l'attribut en public pour √©viter d'avoir √† cr√©er un getter et un setter pas tr√®s utile pour cet attribut.  #include &lt;string&gt; class Monster { public: // Constructeur Monster(float const max_health, std::string const&amp; name); // ... void set_health_points(float health_points); void get_health_points(); // ... // Attributs publics std::string name; // ... private: // Attributs priv√©s float max_health; float health_points; }; Monster::Monster(float max_health, std::string const&amp; name) { this-&gt;max_health = max_health; // On initialise la vie actuelle du monstre √† son maximum this-&gt;health_points = max_health; this-&gt;name = name; } void Monster::set_health_points(float health_points) { if (health_points &gt; this-&gt;max_health) { this-&gt;health_points = this-&gt;max_health; } else if (health_points &lt; 0) { this-&gt;health_points = 0; } else { this-&gt;health_points = health_points; } } float Monster::get_health_points() { return this-&gt;health_points; }   ","version":"Next","tagName":"h3"},{"title":"Propret√© du code‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#propret√©-du-code","content":" C'est quoi d√©j√† la propret√© du code ? il faudrait peut √™tre plus parler de rangement du code. Comme pour un classeur ou un bureau, mieux c'est rang√©, mieux on s'y retrouve (m√™me si certains s'y retrouve mieux dans le chaos). On peut ranger le code sur certains aspect pour mieux s'y retrouver et le lire plus facilement.  ","version":"Next","tagName":"h2"},{"title":"Convention de casses‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#convention-de-casses","content":" Je fais une petite parenth√®se pour parler de casses, c‚Äôest √† dire du fait d‚Äôavoir des majuscules ou des minuscules et des undescores ou non. Je vous renvoie sur ce site pour un petit r√©sum√© des diff√©rentes type de casses.  Most Common Programming Case Types  Dans ce document vous allez me voir √©crire en snake_case pour les variables et fonctions, c‚Äôest ma d√©formation professionnelle venant de mes habitudes python et rust. En C++, le consensus se tourne vers le camelCase, pareil pour le C# (Unity notamment) mais on retrouve du PascalCase pour les fonctions. Mais √™tes libre √† niveau l√†, mais je vous conseille de suivre la convention du langage car vous serez souvent amen√©s √† utiliser des librairies, des packages, des frameworks‚Ä¶ et par soucis d‚Äôuniformit√©, il vaut mieux faire comme les standards.  L'important c'est de choisir une convention et de s'y tenir pour garder une coh√©rence dans le code.  ","version":"Next","tagName":"h3"},{"title":"Nommage des variables et fonctions‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#nommage-des-variables-et-fonctions","content":" plus vos noms sont explicites plus votre code est &quot;straightforward&quot;, ont comprend le comportement du code rien qu'en le lisant.  bool shape_is_closed(Shape* shape) { int sum_of_angles {0}; const int points_count { shapes-&gt;points.size() }; for (int i {0}; i&lt;points_count-2; i++) { const Vector current_vector = make_vector_from_points(shapes-&gt;points[i], shapes-&gt;points[i+1]); const Vector next_vector = make_vector_from_points(shapes-&gt;points[i+1], shapes-&gt;points[i+2]); angle = process_angle_from_vectors(current_vector, next_vector); sum_of_angles += angle; } const Vector last_vector = make_vector_from_points(shapes-&gt;points[points_count-1], shapes-&gt;points[0]); const Vector first_vector = make_vector_from_points(shapes-&gt;points[0], shapes-&gt;points[1]); last_angle = process_angle_from_vectors(last_vector, first_vector); sum_of_angles += last_angle; if (sum_of_angles % 360 == 0) return true; else return false; }   Le code est plus long mais il est plus verbeux et on comprend ce que fais le code en lisant les variables et fonctions.  la fonction s'appelle shape_is_closed, il va s√ªrement d√©terminer si une forme est ferm√©e. La premi√®re ligne d√©finie la variable sum_of_angles qu'on retrouve √† la fin avant le return, ok √ßa fait la somme des angles pour d√©terminer si c'est ferm√©.  Il y a un for dans lequel on calcul un angle √† partir d'un segment et celui qui le suit, apr√®s √ßa on recalcule un angle entre le dernier segment et le premier.  Dans ce code, j'exag√®re la verbosit√© pour avoir une lecture tr√®s litt√©rale, on peut trouver un juste milieu.  ","version":"Next","tagName":"h3"},{"title":"Faites des fonctions‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#faites-des-fonctions","content":" Avoir des fonctions ne permet pas seulement de capitaliser sur un ensemble d‚Äôinstruction, on peut les utiliser pour structurer le code, notamment en rassemblant des instructions r√©pondant √† un besoin particulier sous un m√™me bloc ‚Äúnomm√©‚Äù. par exemple si vous calculer des collisions, faites une fonction check_collisions , on saura que le bout de code √† l‚Äôint√©rieur vise √† calculer une collision et quand vous appelez cette fonction dans votre programme on sait que vous souhaitez faire un calcul de collision √† cette endroit.  Posez vous la question de la longueur de vos fonctions, si elles sont trop longues, divisez les en sous fonctions. Les plus stricts d√©veloppeurs diront qu‚Äôune bonne fonction ne doit pas d√©passer 10 lignes, je trouve personnellement √ßa trop contraignant, mais cette r√®gle me sert au moins de base pour ma r√©flexion. A chaque dizaines de lignes que je d√©passe, je dois me poser la question ‚Äúest ce que je peux bouger des instructions dans une fonction d√©di√©e ?‚Äù  Je vois par exemple un main qui fait une centaine de lignes et qui contient √ßa   Wall walls[MAX]; Vector2 position; bool horizontal; for (int i = 0; i&lt;walls_count;i++) { position.x = 150 + rand() % (SCREEN_WIDTH-150); position.y = 150 + rand() % (SCREEN_HEIGHT-150); int taille = 150 + rand() % 200; if (randomNumber(1, 2) == 1) { horizontal = true; } else { horizontal = false; } walls[i].initialize(horizontal, taille, position); }   Je pourrais faire une fonction initialize_walls ou une m√©thode initialize_random dans la structure/classe Wall.  ","version":"Next","tagName":"h3"},{"title":"L‚Äôindentation et les espaces‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#lindentation-et-les-espaces","content":" L‚Äôindentation vous permet de bien situer les blocs (les if/else, for/while, switch, structures‚Ä¶).  dans ce code  for(int i {0}; i &lt; codes; i++) { for(int j {0}; j &lt; lines; j++) { if(forme) my_code = is_good + is_better; else my_code = is_good; a_result = call_a_function(); make_it_better(a_result) while(something_call) { if(someone_here()) { answer() } else{ answer_everyone(); take_a_moment(); person = find_someone(); } } } while(yolo) { make(toto) } while(doing_wrong) { error = watch_code(codes); call_a_formater(codes, errors); } }   Il est plus compliqu√© de terminer la limite de chaque bloc compar√© √† ce code l√†  for(int i {0}; i &lt; codes; i++) { for(int j {0}; j &lt; lines; j++) { if(forme) my_code = is_good + is_better; else my_code = is_good; a_result = call_a_function(); make_it_better(a_result) while(something_call) { if(someone_here()) { answer() } else{ answer_everyone(); take_a_moment(); person = find_someone(); } } } while(yolo) { make(toto) } while(doing_wrong) { error = watch_code(codes); call_a_formater(codes, errors); } }   En plus de l‚Äôindentation, veillez √† espacer votre code pour souligner la proximit√© de certaines instructions  void main() { Window* window = new Window(); SoundSystem* sound_system = new SoundSystem(); ResourcesManager resources = new ResourcesManager(); window.resize(720, 1080); window.set_title(&quot;Ma fenetre&quot;); window.add_button(&quot;Mon Bouton&quot;); sound_system.register_sound(&quot;le_message_de_paix.mp3&quot;); sound_system.register_sound(&quot;le_code.mp3&quot;); sound_system.play_loop(&quot;le_message_de_paix.mp3&quot;); resources.register_image(&quot;yolo.png&quot;) resources.register_image(&quot;toto.png&quot;) window.open(); }   Vous √©crivez un code avant tout pour vous et pour les autres et pas pour la machine. La machine se fiche de savoir si vous avez mis un espace avant ou apr√®s un op√©rateur, si vous avez mis une ligne vide entre deux blocs de code. Mais pour vous et pour les autres, c‚Äôest plus facile de lire un code bien espac√© et indent√©.  Dans d'autres languages comme le python, l'indentation est obligatoire pour d√©finir les blocs de code, en C++ l'indentation est une convention mais en pratique tout le monde se force √† l'appliquer pour rendre le code plus lisible.  ","version":"Next","tagName":"h3"},{"title":"La longueur des lignes‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#la-longueur-des-lignes","content":" √âviter les lignes trop longue. La convention actuelle conseille de ne pas d√©passer 80 caract√®res dans une m√™me ligne. Ceci dans l‚Äôoptique de pouvoir diviser sa fen√™tre en 2 pour pouvoir comparer du code, voir des signatures de fonctions,‚Ä¶ ou bien de pouvoir mettre son √©cran √† la vertical.  Je trouve personnellement que 80 caract√®res est assez contraignant. Je me permet des √©carts √† 90 voire 100 grand maximum.  Pour √©viter les lignes trop longues, il suffit tout simplement de diviser les instructions longues en plusieurs ligne. Il y a certaines conventions pour faire √ßa, en g√©n√©ral votre IDE vous aide √† le faire.  Dans l‚Äôexemple pr√©c√©dent j‚Äôai des lignes d√©passant les 80 caract√®res, reformatons √ßa  bool shape_is_closed(Shape* shape) { int sum_of_angles {0}; const int points_count { shapes-&gt;points.size() }; for (int i {0}; i&lt;points_count-2; i++) { const Vector current_vector = make_vector_from_points( shapes-&gt;points[i], shapes-&gt;points[i+1] ); const Vector next_vector = make_vector_from_points( shapes-&gt;points[i+1], shapes-&gt;points[i+2] ); angle = process_angle_from_vectors(current_vector, next_vector); sum_of_angles += angle; } const Vector last_vector = make_vector_from_points( shapes-&gt;points[points_count-1], shapes-&gt;points[0] ); const Vector first_vector = make_vector_from_points( shapes-&gt;points[0], shapes-&gt;points[1] ); last_angle = process_angle_from_vectors(last_vector, first_vector); sum_of_angles += last_angle; if (sum_of_angles % 360 == 0) return true; else return false; }   Le code est plus long en vertical mais on s‚Äôassure que ce soit lisible en toute circonstance. Si vous ne suivez pas la convention, assurez vous au moins d‚Äôavoir des lignes qui se lisent sur votre IDE sans avoir √† scroller horizontalement.  ","version":"Next","tagName":"h3"},{"title":"Organisation des fichiers‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#organisation-des-fichiers","content":" √âviter au maximum d‚Äôavoir un main.cpp qui d√©passe 100 lignes. Le main.cpp et la fonction main() doivent √™tre l√† que pour faire l‚Äôinitialisation des variables et lancer la fonction principale (dans un projet, en TP √ßa peut contenir le corps du programme).  Cependant ne mettez pas tout le code que aviez pr√©vu dans le main.cpp dans un seul autre fichier, essayez le plus possible de disperser le code dans diff√©rents fichiers. Le plus souvent on fait un couple header/source par structure. Dans le cas du projet on pourrait avoir ball.h/ball.cpp , wall.h/wall.cpp et game.h/game.cpp. On peut aussi avoir des ‚Äúutilitaires‚Äù tant que vous d√©finissez bien la nature de chaque utilitaire, par exemple ici physics.h/physics.cpp et drawing.h/drawing.cpp.  Pour des projets √† plus large echelles, je vous invite √† faire des dossiers pour regrouper vos fichiers, la hi√©rarchie de fichiers d√©pendra de la logique utilis√©s. Pour un jeu on pourra par exemple avoir des dossiers principaux core, render_engine, the_game  ","version":"Next","tagName":"h2"},{"title":"Attributs ou Variable ?‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#attributs-ou-variable-","content":" class App { // ... GLuint texture_path; std::unordered_map&lt;std::string, GLuint&gt; tile_texture_mapping; // ... } // init this-&gt;texture_path = loadTexture(path); this-&gt;tile_texture_mapping.insert({&quot;path&quot;, this-&gt;texture_path}); // draw draw_quad_with_texture(tile_texture_mapping[&quot;path&quot;], w, h, taille);   Si vous d√©clarez un attribut (ici _texturepath) mais qu‚Äôil n‚Äôest utilis√© qu‚Äôune seule fois, il n‚Äôest peut √™tre pas n√©cessaire d‚Äôavoir un attribut et √©valuez si une variable n‚Äôest pas suffisante  class App { // ... std::unordered_map&lt;std::string, GLuint&gt; tile_texture_mapping; // ... } // init GLuint texture_path{loadTexture(path)}; this-&gt;tile_texture_mapping.insert({&quot;path&quot;, texture_path}); // draw draw_quad_with_texture(tile_texture_mapping[&quot;path&quot;], w, h, taille);   ","version":"Next","tagName":"h3"},{"title":"Variables en dur‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#variables-en-dur","content":" Attention aux donn√©es en dur dans le code. Par exemple, dans le code ci-dessous, il y a des conditions sur les coordonn√©es x et y qui sont en dur dans le code.  if (x &gt; 11) { return; } else if (y == 1 &amp;&amp; (x &lt; 5 || (x &gt; 6 &amp;&amp; x &lt; 11))) { return; } else if (y == 2 &amp;&amp; (x == 4 || x == 7 || x == 10)) { return; } else if (y == 3 &amp;&amp; ((x &gt;3 &amp;&amp; x&lt;8) || x == 10)) { return; } else if (y == 4 &amp;&amp; x==10 ) { return; } else if (y == 5 &amp;&amp; ((x &gt;0 &amp;&amp; x&lt;5) || (x &gt;7 &amp;&amp; x&lt;11))) { return; } else if (y == 6 &amp;&amp; (x == 1 || x == 4 || x == 8)) { return; } else if (y == 7 &amp;&amp; (x == 1 || x == 4 || (x &gt;7 &amp;&amp; x&lt;11)) ) { return; } else if (y == 8 &amp;&amp; (x == 4 || x == 10 || x&lt;2 ) ) { return; } else if (y == 9 &amp;&amp; (x == 4 || x == 10 )) { return; } else if (y == 10 &amp;&amp; (x &gt;3 &amp;&amp; x&lt;11)) { return; } // ...   C'est une mauvaise pratique car si vous voulez changer la fa√ßon dont vos coordonn√©es sont g√©r√©es, vous devrez changer ce code et cela peut √™tre fastidieux. Il est pr√©f√©rable de stocker ces donn√©es dans un fichier de configuration par exemple pour pouvoir les modifier facilement. Ou alors de les stocker dans une structure de donn√©es (comme une map ou un tableau par exemple) pour pouvoir les modifier plus facilement. L'id√©al est de ne pas avoir de donn√©es en dur mais de les d√©duire d'autres donn√©es (comme une image par exemple) pour faciliter la maintenance et l'√©volutivit√© du code.  Ici, cela ressemble des conditions de validit√© pour des cases d'une grille 2D (placement des tours sur une carte). Il serait donc pr√©f√©rable de d√©duire ces conditions de la carte elle-m√™me (par exemple, si la case est une herbe, on peut placer une tour dessus, ect).  ","version":"Next","tagName":"h3"},{"title":"Erreurs propre aux C++‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#erreurs-propre-aux-c","content":" ","version":"Next","tagName":"h2"},{"title":"Op√©ration Bool√©enne‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#op√©ration-bool√©enne","content":" Vous mettez parfois dans le code des testes pour d√©finir une variable bool√©enne ou pour retourner une valeur bool√©enne.  Par exemple  bool bidule(int const x) { if (x &gt; 10) { return true; } return false; }   N‚Äôoubliez pas que vous ce que vous mettez dans le if est une op√©ration bool√©enne qui va calculer soit Vrai soit Faux. Et ce r√©sultat peut donc √™tre directement utilis√© comme valeur de retour.  bool bidule(int const x) { return x &gt; 10; }   astuce Si vous devez inverser le r√©sultat, vous pouvez utiliser l‚Äôop√©rateur ! qui va inverser le r√©sultat d‚Äôune op√©ration bool√©enne.  ","version":"Next","tagName":"h3"},{"title":"Pragma once vs ifndef‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#pragma-once-vs-ifndef","content":" #pragma once #ifndef PATH_HPP #define PATH_HPP   Les deux fa√ßon de prot√©ger des inclusions de header sont redondantes, il faut choisir l'une ou l'autre (pr√©f√©rence pour #pragma once en C++ moderne). Petit rappel ici  Si vous ne devez retenir qu'une chose, c'est ajouter un #pragma once en haut de vos fichiers headers.  ","version":"Next","tagName":"h3"},{"title":"Pointeurs‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#pointeurs","content":" Globalement un pointeur fait r√©f√©rence √† un objet dans m√©moire. Mais il peut faire r√©f√©rence √† deux types d‚Äôobjets:  un objet pr√©vu dans la m√©moire initiale (dans la Pile)un nouvel objet allou√© pendant l‚Äôex√©cution (dans le Tas)  !https://media.geeksforgeeks.org/wp-content/uploads/20201210222125/Untitled4-660x361.png  https://media.geeksforgeeks.org/wp-content/uploads/20201210222125/Untitled4-660x361.png  Je vais apporter une petite subtilit√©, il y a deux types de pointeurs (ou d‚Äôusage plut√¥t)  ‚ÄúIl y a le bon et le mauvais pointeur ?‚Äù  ‚ÄúNon, silence‚Ä¶‚Äù  Celui qui d√©tient l‚Äôadresse original d‚Äôun objetCelui qui fait r√©f√©rence √† un objet initialis√© ailleurs  Et pour bien comprendre cette distinction, voyons un bout de code qui ne la fait pas  Ellipse* current = new Ellipse; current = liste.first; while (current != nullptr) { // ... }   La premi√®re ligne de cette fonction va cr√©er un objet, il va l‚Äôallouer dans la m√©moire gr√¢ce √† new. On parle ici d‚Äôinstanciation, nous y reviendrons.  La deuxi√®me quant √† elle va faire pointer current vers un objet existant ailleurs (dans liste.first).  L‚Äôerreur vient surement d‚Äôune confusion sur l‚Äôinitialisation d‚Äôun pointeur:  info üí° new permet de cr√©er un nouvel objet dans la m√©moire et pas de cr√©er un pointeur.  un pointeur est cr√©√© √† partir du moment o√π vous d√©clarer une variable avec * et vous devez distinguer le ‚Äúpointeur‚Äù de l‚Äùinstance‚Äù.  ‚ÄúAh mais qu‚Äôest ce que c‚Äôest donc qu‚Äôune instance ?‚Äù  ‚ÄúMerci personne al√©atoire que je n‚Äôai pas pay√© pour poser cette question‚Äù  ","version":"Next","tagName":"h3"},{"title":"Instance‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#instance","content":" J‚Äôai parl√© ci-dessus d‚Äô‚Äùobjet‚Äù, on pourrait aussi parler d‚Äô‚Äùinstance‚Äù (d√©sol√© il n‚Äôy a pas de mot bien d√©finis pour ce dont je vais parler).  En programmation (on va parler de C++ ici), il y a des ‚Äútypes‚Äù de donn√©es. On peut retrouver des types natives (ou fondamentaux) qui viennent directement avec le langage (int, bool, float, string‚Ä¶) et des types qu‚Äôon peut cr√©er et qui va contenir un ensemble de donn√©es (des structures ou des classes mais aussi des enum).  Ces types d√©crivent comment une donn√©e (en binaire) va prendre forme. Et quand je d√©clare une variable d‚Äôun certain type, je veux cr√©er une donn√©e qui doit prendre cette forme. On dit qu‚Äôon cr√©e une instance de ce type. L‚Äôinstance est un √©l√©ment unique l√† o√π le type d√©crit une donn√©e g√©n√©rique.  Quand je d√©clare des variables  int a; string nom_etudiant1; Human steeve;   a est une instance de int, nom_etudiant1 est une instance de string et steeve est une instance d‚Äôune structure Human.  Bon o√π je veux en venir avec tout √ßa ? (non c‚Äôest une vrai question, qu‚Äôest ce que je voulais faire ?)  Bon c‚Äôest pas grave, faisant une parenth√®se pour ceux qui n‚Äôont pas encore appr√©hend√© les structures, voyons ce code:  Parenth√®se:  struct Human { string first_name; string last_name; } void display_human_name(Human human) { cout &lt;&lt; ?; }   Ici je veux afficher le nom d‚Äôun humain, et d‚Äôun humain sp√©cifique, pas de l‚Äôentit√© ‚Äúhumain‚Äù (pas de l‚Äôhumanit√©). Je vais donc manipuler human et pas Human. On manipule l‚Äôinstance, pas le type.  Je pourrais reformater le code:  void display_human_name(Human a_specific_human) { cout &lt;&lt; a_specific_human.first_name; }   Je ferme la parenth√®se, dite moi si c‚Äôest pas claire ou √† l‚Äôinverse si c‚Äôest trop obvious.  Oui donc les instances au final pour les pointeurs. Reprenons l‚Äôerreur que j‚Äôavais soulign√©.  void parcours_liste(List* list) { Ellipse* current = new Ellipse; current = list-&gt;first; while (current != nullptr) { // ... current = current-&gt;next; } } int main() { List l; Ellipse ellipse1; Ellipse ellipse2; l.first = &amp;ellipse1; ellipse1.next = &amp;ellipse2; parcours_liste(l); }   new Ellipse va cr√©er une nouvelle instance du type Ellipse. Or il existe d√©j√† des instances d‚Äôellipses, celles qu‚Äôon veut parcourir. Ces instances sont celles cr√©√©s dans le main. Le pointeur current ne va servir qu‚Äô√† parcourir ces instances d‚Äôellipses et en aucun cas les recr√©er. C‚Äôest ce qu‚Äôon appelle un ‚Äúit√©rateur‚Äù, c‚Äôest un pointeur qui permet de se balader dans une structure de donn√©es.  Modifions un peu le code  int main() { List l; l.first = new Ellipse; l.first-&gt;next = new Ellipse; parcours_liste(l); }   Le code fait exactement la m√™me chose, sauf que le j‚Äôalloue de la m√©moire ‚Äú√† la volet‚Äù pour cr√©er les ellipses de la liste. Je les instancie d‚Äôune autre mani√®re. Les instances se cr√©e dans le Tas et pas dans la pile.  üí° En java, C#, javascript, python‚Ä¶ toutes les instances/tous les objets sont instanci√©.e.s ‚Äú√† la volet‚Äù  ","version":"Next","tagName":"h3"},{"title":"Optimisation‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#optimisation","content":" ","version":"Next","tagName":"h2"},{"title":"chaines de caract√®res VS entiers (√©num√©ration)‚Äã","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Subjects/IMAC2026/S2/Feedbacks#chaines-de-caract√®res-vs-entiers-√©num√©ration","content":" Comparer des chaines de caract√®res n√©cessite plus de calcul que comparer des entiers. En effet, une cha√Æne de caract√®re est une suite de caract√®res qui n√©cessite d‚Äô√™tre parcouru (enti√®rement ou partiellement) pour √™tre compar√©. Alors qu‚Äôun entier est une valeur num√©rique qui peut √™tre compar√© directement.  Dans le cas o√π vous avez des chaines de caract√®res qui repr√©sentent des modes, des √©tats, des types ... que l'on conna√Æt √† l'avance, il est pr√©f√©rable de les comparer en utilisant des entiers plut√¥t que de passer par des chaines de caract√®res.  void move_player(Player &amp; player, string const&amp; direction) { if (direction == &quot;left&quot;) { // ... } else if (direction == &quot;right&quot;) { // ... } else if (direction == &quot;up&quot;) { // ... } else if (direction == &quot;down&quot;) { // ... } else { // ... ? } }   Mais on peut utiliser une √©num√©ration pour d√©finir les diff√©rent cas et les comparer directement (chaque valeur de l‚Äô√©num√©ration est repr√©sent√© par un entier).  enum class Direction { Left, Right, Up, Down, } void move_player(Player &amp; player, Direction const direction) { if (direction == Direction::Left) { // ... } else if (direction == Direction::Right) { // ... } else if (direction == Direction::Up) { } else // if (direction == Direction::Down) { // ... } // Ou encore mieux avec un switch case switch (direction) { case Direction::Left: // ... break; case Direction::Right: // ... break; case Direction::Up: // ... break; case Direction::Down: // ... break; } }   Cela permet de r√©duire le temps de calcul et de rendre le code plus lisible. Mais cela permet aussi de limiter la gestion des erreurs. Si vous avez une cha√Æne de caract√®re qui n‚Äôest √©gale √† aucun des cas il faudra g√©rer le cas ou il pourrait y avoir un comportement inattendu. Avec un enum, vous √™tes s√ªr que la valeur est l‚Äôune de celles que vous avez d√©fini. De plus l'utilisation du switch case n'est pas possible avec des chaines de caract√®res.  info Comparer des chaines de quelques caract√®res ne repr√©sente rien pour un processeur de nos jours mais si la vitesse d'ex√©cution du programme est un crit√®re important C'est tout de m√™me quelques chose √† prendre ne compte. ","version":"Next","tagName":"h3"},{"title":"IMAC DIGGER","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet","content":"","keywords":"","version":"Next"},{"title":"Projet‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#projet","content":" Structure du projet : Vous devez organiser votre code en fichiers et dossiers s√©par√©s. Nous recommandons l'utilisation d'un syst√®me de compilation CMake pour la compilation.  Synth√®se d'images : Vous devez afficher les √©l√©ments du jeu (carte, ennemis) en utilisant des sprites (textures) et la biblioth√®que OpenGL.  Gestion de Projet: Vous devez utiliser Git pour stocker/partager votre code et nous le rendre.  Compilation: Un syst√®me de compilation CMake devra √™tre int√©gr√© √† votre projet, d'autant que vous aurez √† utiliser des biblioth√®ques (OpenGL, lecture d'images, ...). Votre projet devra contenir tout ce qui permet de le compiler et fonctionner sur Linux ou Windows (plateforme de d√©veloppement √† pr√©ciser dans le rapport). Si d√©veloppement sur macOS, pensez √† tester votre programme sur une autre machine afin que l'on puisse le compiler sur Linux ou Windows afin de le tester.  Le projet est √† faire par bin√¥me ou trin√¥me. Les trin√¥mes devront obligatoirement r√©aliser une fonctionnalit√© suppl√©mentaire par rapport aux bin√¥mes. Si vous choisissez une am√©lioration qui n'est pas dans la liste des am√©liorations sugg√©r√©es, vous devrez nous en faire part pour la faire valider.  ","version":"Next","tagName":"h2"},{"title":"Th√®me du jeu‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#th√®me-du-jeu","content":" Vous n'√™tes pas oblig√© de respecter le th√®me du jeu (un mineur qui cherche des gemmes) mais vous devez respecter les sp√©cifications du projet. Vous √™tes libres de choisir un autre th√®me, exemple :  Un pirate qui cherche des tr√©sors (au milieu des squelettes).Un explorateur qui cherche des artefacts (au milieu des momies).Un voleur qui cherche des objets de valeur (au milieu des gardes).Un astronaute qui cherche des cristaux (au milieu des aliens).Une sorci√®re qui cherche des ingr√©dients (au milieu des monstres).  ","version":"Next","tagName":"h2"},{"title":"Rapport‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#rapport","content":" Il contiendra une description des fonctionnalit√©s impl√©ment√©es (r√®gles du jeu, etc), un guide succinct d'utilisation, et des captures d'√©cran.  √âventuellement, si vous souhaitez mettre en avant un bout de code pour sa performance ou parce qu‚Äôil s‚Äôagit d‚Äôune id√©e int√©ressante, vous pouvez l'int√©grer dans le rapport (mais rester succinct).  Ajoutez enfin une partie &quot;Post mortem&quot; pour analyser le travail fourni, qu'est ce qui a bien fonctionn√©, quels ont √©t√© les probl√®mes rencontr√©s, comment vous les avez surmont√©s, auriez-vous fait diff√©remment ? Avec plus de temps, qu'est ce que vous pourriez ajouter ?  Ne nous faites pas des romans, vous pouvez faire court, par exemple 2 √† 4 pages sans les illustrations.  ","version":"Next","tagName":"h2"},{"title":"Notation‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#notation","content":" Ce projet est commun aux mati√®res : Programmation et algorithmique C++ et Synth√®se d'images I. Il y aura une base commune puis une note distinctive pour chaque mati√®re.  Exemple: note commune: 8, note algo: 6, note SI: 5 = note finale algo 14, note finale SI 13    Structure de votre programme  Dans ce projet complexe, il est hors de question de n'utiliser qu'un seul fichier. Il vous faut donc s√©parer l'application en diff√©rents fichiers .cpp et .hpp. La d√©coupe des fichiers est laiss√©e √† votre appr√©ciation mais doit √™tre logique. Globalement, le projet √©tant scind√© en deux parties, il serait logique que la partition des fichiers en tienne compte.  Un syst√®me de compilation CMake devra √™tre int√©gr√© √† votre projet, d'autant que vous aurez √† utiliser des biblioth√®ques (OpenGL, lecture d'images, ...).  Note importante : Tout rendu de projet sans possibilit√© de le compiler sur Linux ou Windows entra√Ænera un 0 ! (sauf si vous avez une raison valable et que vous avez pr√©venu vos enseignants).  Votre projet devra √™tre organis√© √† minima dans un r√©pertoire suivant la structure suivante :  NomDuProjet/ \\-- src/ \\-- lib/ \\-- images/ \\-- CMakeLists.txt \\-- README.md \\-- .gitignore   Le r√©pertoire src contient les fichiers sources .cpp et .hpp (Vous avez la libert√© de placer plut√¥t les fichiers d'ent√™te .hpp dans un r√©pertoire include si vous pr√©f√©rez ce type de structure de projet mais vous devrez alors adapter votre CMakeLists.txt).(Optionnel) Le r√©pertoire lib contiendra les fichiers de vos biblioth√®ques ainsi que tout le n√©cessaire pour les compiler ou les inclure dans votre projet (Vous pouvez √©galement utiliser des fetch Cmake pour inclure des librairies).Le r√©pertoire images contient toutes les images du projet (sprite, ...).Le r√©pertoire doc contiendra toute la documentation, dont votre rapport.Enfin, un CMakeLists.txt permettant de compiler le projet.(Optionnel) un r√©pertoire bin dans lequel sera export√© l'ex√©cutable compil√© du projet (le fichier ex√©cutable ne doit pas √™tre inclus dans le d√©p√¥t git).Un fichier README.md contenant les instructions pour compiler et ex√©cuter le projet. Votre rapport de projet peut √™tre int√©gr√© √† ce fichier ou dans un fichier s√©par√© (ex: doc/rapport.pdf).Tout dossier temporaire build (utilis√© par CMake par exemple) ou ex√©cutable (.exe) ne devra pas √™tre inclus sur git (.gitignore) sous peine de p√©nalit√©.  Carte  Pour ce projet nous allons utiliser une carte √† base de cases (tile-based). C'est √† dire que la carte est segment√©e de cases de m√™me taille. Il devra y avoir diff√©rents types de cases:  Bloc vide: case vide, sans objet ni ennemi ou le joueur peut se d√©placer librement.Bloc plein: case pleine, le joueur ne peut pas se d√©placer dessus mais peut d√©truire cette case (ex: un bloc de terre).Objet: case contenant un objet √† collecter (ex: une gemme, une pi√®ce d'or, une pomme, ...).Obstacle: case pleine qui ne peut pas √™tre d√©truite (ex: un mur, une pierre, ...).Pi√®ge: case pleine qui ne peut pas √™tre d√©truite mais qui fait perdre le joueur (ex: un trou, une flamme, ...).  Ces cases sont repr√©sent√©es par des sprites (images) qui sont affich√©es √† l'√©cran. Vous devez donc cr√©er ou trouver des sprites pour repr√©senter ces cases.  ","version":"Next","tagName":"h2"},{"title":"G√©n√©ration de la carte‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#g√©n√©ration-de-la-carte","content":" Vous devez g√©n√©rer la carte de mani√®re proc√©durale (c'est √† dire que la carte est g√©n√©r√©e al√©atoirement selon des r√®gles d√©finies et n'est pas pr√©d√©finie).  Il existe de nombreux algorithmes de g√©n√©ration proc√©durale mais pour ce projet nous allons utiliser un algorithme de g√©n√©ration proc√©durale de type cellular automata. Cet algorithme est relativement simple √† mettre en place et s'adapte tr√®s bien √† la g√©n√©ration de cartes de type cave (donc avec des cases pleines et vides).  ","version":"Next","tagName":"h2"},{"title":"Description de l'algorithme‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#description-de-lalgorithme","content":" L'algorithme de g√©n√©ration proc√©durale de type cellular automata fonctionne de la mani√®re suivante:  On initialise la carte avec des cases vides et pleines de mani√®re al√©atoire (ex: 50% de cases pleines et 50% de cases vides). (Vous pouvez faire varier la probabilit√©)On met √† jour les √©tats des cases de la carte en fonction de l'√©tat actuel selon les r√®gles suivantes: Si une case est pleine et a au moins 4 cases pleines voisines, elle reste pleine sinon elle devient vide.Si une case est vide et a plus de 4 cases pleines voisines, elle devient pleine.  Autrement dit: Une case sera pleine √† l'√©tape suivante si le nombre de cases pleines voisines (en se comptant elle m√™me) est sup√©rieur ou √©gal √† 5, sinon elle sera vide.  On r√©p√®te l'√©tape 2 un certain nombre de fois (ex: 4 fois) pour affiner la carte.  Exemple de 4 it√©rations de l'algorithme:    Ensuite, vous pouvez ajouter des objets (ex: gemmes) et cases pi√®ges sur la carte de mani√®re al√©atoire. Vous pouvez √©galement ajouter des ennemis sur la carte en fonction de la taille de la carte (ex: 1 ennemi pour 20 cases vides).  Vous pouvez √©galement placer le point d'apparition du joueur al√©atoirement sur la carte (id√©alement pas trop proche d'un ennemi par exemple).  ","version":"Next","tagName":"h3"},{"title":"Flow field pathfinding‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#flow-field-pathfinding","content":" Pour pouvoir faire se d√©placer les ennemis sur la carte, il nous faut un algorithme de recherche de chemin. Nous allons utiliser un algorithme de type flow field pathfinding.  L'id√©e de cet algorithme est de cr√©er un &quot;champ de direction&quot; (notre Flow field) qui indique la direction √† prendre pour atteindre la destination. Chaque case contient la direction √† prendre (sous la forme de la prochaine case sur laquelle se rendre) pour atteindre la destination.  Une fois ce flow field cr√©√©, il suffit de faire se d√©placer les ennemis dans la direction indiqu√©e par la case sur laquelle ils se trouvent (ou mieux une interpolation lin√©aire des directions des cases adjacentes si il se trouve entre plusieurs cases).  Pour arriver √† g√©n√©rer ce champ de direction nous utiliserons un algorithme de type Breadth First Search (BFS) qui en partant d'une case de destination (le joueur) va remplir toutes les cases adjacentes avec la direction √† prendre pour atteindre cette case.  Le principe de l'algorithme est le suivant:  On initialise une file de cases √† explorer (ex: la case du joueur) et on initialise toutes les cases avec une direction nulle.Tant qu'il nous reste des cases √† explorer on prend la derni√®re et pour chaque case adjacente on assigne une direction (la case d'o√π l'on vient) et on les ajoute √† la file des cases √† explorer (si elles ne sont pas d√©j√† explor√©es).On r√©p√®te l'√©tape 2 jusqu'√† ce que toutes les cases soient explor√©es et les directions assign√©es.  Vous trouverez des explications suppl√©mentaires et des animations sur le site de RedBlobGames.  Ce genre d'algorithmes s'applique g√©n√©ralement sur des graphes. On peut voir notre carte 2D comme un graphe o√π chaque case est un noeud et les cases adjacentes sont les ar√™tes du graphe. On peut donc utiliser les algorithmes de recherche de chemin sur ce &quot;graphe&quot; simplifi√©.  Il suffit de g√©n√©rer le flow field uniquement lorsque c'est n√©cessaire (ex: lorsque le joueur se d√©place ou que la carte change). C'est pourquoi c'est tr√®s efficace quand le nombre d'ennemis est important et/ou que la carte ne change pas ou pas trop souvent car il n'est pas n√©cessaire de recalculer le meilleur chemin pour chaque ennemi. (type A* ou Dijkstra par exemple).  ","version":"Next","tagName":"h2"},{"title":"Le joueur‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#le-joueur","content":" Le joueur doit √™tre repr√©sent√© par un sprite (image) et doit pouvoir se d√©placer de mani√®re fluide. (Il est recommand√© d'utiliser une taille du joueur identique √† celle des cases de la carte mais ce n'est pas obligatoire).  Les d√©placements devront √™tre fluides et non pas en &quot;case par case&quot;. Bien que la carte soit compos√©e de cases, les positions du joueur et des ennemis ne seront donc pas forc√©ment align√©es sur les positions des cases. (vous pouvez utiliser les fl√®ches du clavier ou des touches ZQSD).  Le joueur doit pouvoir &quot;miner&quot; c'est √† dire pouvoir se d√©placer sur un bloc plein et le d√©truire (cette case deviendra alors un bloc vide). Il peut √©galement se d√©placer sur objet (ex: une gemme) pour le r√©cup√©rer. Le joueur ne peut pas d√©truire un ennemi.  ","version":"Next","tagName":"h2"},{"title":"Les ennemis‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#les-ennemis","content":" Les ennemis doivent se d√©placer en empruntant le chemin trouv√© par l'algorithme de recherche de chemin. Il doivent se d√©placer de mani√®re fluide (pas case par case) en fonction de leur vitesse (ex: 1 case par seconde).  Graphiquement, vous devez √©galement repr√©senter les ennemis par des sprites.  Interface graphique (IHM)  Votre application contiendra au minimum une fen√™tre d'affichage contenant la carte et au moins un bouton permettant de quitter l'application.  Vous devez faire un menu de d√©marrage qui permet de lancer le jeu. Ce menu doit contenir au moins un bouton pour d√©marrer le jeu et un bouton pour quitter l'application.  Vous devez aussi afficher un √©cran de fin (victoire ou d√©faite). Lorsque le joueur r√©ussit √† r√©cup√©rer tous les objets de la carte, il a gagn√©. Si un ennemi atteint le joueur, il a perdu.  Le jeu fonctionne en &quot;continu&quot; c'est-√†-dire que c'est le temps qui rythme la succession des √©v√©nements (d√©placement des ennemis, ...).  L'utilisateur peut par se contre d√©placer quand il le souhaite. Il doit pouvoir se d√©placer √† l'aide des fl√®ches (ou des touches ZQSD) du clavier.  Le joueur doit pouvoir mettre en pause l'application ou quitter le jeu √† tout moment (via un bouton ou une touche).  Votre interface devra permettre de visualiser les √©l√©ments suivants :  la carte, les ennemis et les objetsIndiquer le nombre d'objets √† collecter (ex: 3 gemmes restantes)  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#r√©sum√©","content":" Pour r√©sumer, voici les √©l√©ments que vous devez impl√©menter dans votre jeu :  Sprites : Des images pour repr√©senter les √©l√©ments du jeu (carte, ennemis, ...). Carte : Une carte √† base de cases (tile-based) avec des cases de m√™me taille. G√©n√©ration proc√©durale : Un algorithme de g√©n√©ration proc√©durale pour g√©n√©rer la carte (type cellular automata). Flow Field pathfinding : Un algorithme de recherche de chemin utilisant une grille. Ennemis : Des ennemis qui se d√©placent en suivant le chemin trouv√© par l'algorithme de recherche de chemin. Minimum 2 ennemis sur la carte. Minage : Le joueur peut d√©truire des blocs pleins et collecter des objets (ex: gemmes). D√©placements : D√©placement fluide (pas case par case) du joueur et des ennemis. Fin : Un √©cran de fin indiquant une d√©faite ou une victoire. IHM : Une interface graphique pour visualiser les √©l√©ments du jeu (nombre d'objets √† collecter, ...). Le joueur doit pouvoir mettre en pause le jeu ou quitter √† tout moment.  Bonus et am√©liorations sugg√©r√©s  Nous vous sugg√©rons les am√©liorations suivantes qui nous semblent int√©ressantes pour ce projet.  ","version":"Next","tagName":"h2"},{"title":"Types de terrain additionnels (algorithmique)‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#types-de-terrain-additionnels-algorithmique","content":" Vous pouvez ajouter un ou plusieurs autres types de terrain: Ralentissement: une case qui ralentit le joueur et les ennemis (ex: un mar√©cage, une flaque d'eau, ...).Acc√©l√©ration: une case qui acc√©l√®re le joueur et les ennemis (ex: un chemin de terre, une route, ...).T√©l√©portation: une case qui t√©l√©porte le joueur ou les ennemis √† un autre endroit de la carte (ex: un trou, une porte, ...).Bloc plein double: une case pleine qui peut √™tre d√©truite mais demande deux destructions avant de devenir vide (avec un √©tat interm√©diaire lors de la destruction)....  ","version":"Next","tagName":"h2"},{"title":"Placement intelligent des sprites (algorithmique et synth√®se d'images)‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#placement-intelligent-des-sprites-algorithmique-et-synth√®se-dimages","content":" Pour l'affichage de la carte, vous devez utiliser des sprites pour repr√©senter les √©l√©ments de la carte.  carte √©tat plein/vide Sprites sur les cases pleines  Vous pouvez am√©liorer l'affichage en utilisant des auto-tiles. L'id√©e est d'afficher des sprites diff√©rents en fonction des cases adjacentes pour repr√©senter les cases de mani√®re plus esth√©tique (au lieu de r√©p√©ter la m√™me sprite pour chaque case).  Exemple de rendu avec des auto-tiles  Vous pouvez utiliser ce qu'on appelle un masque binaire (bitmask) pour repr√©senter les adjacences (cas simple sans tenir compte des diagonales: haut, bas, gauche, droite) et donc les diff√©rentes possibilit√©s de sprites et choisir le bon sprite √† afficher en fonction de ce bitmask (dans un tableau de sprites, dans un tileset, ...).  Un bitmask est un nombre dont chaque bit repr√©sente une information. Par exemple, pour les auto-tiles, on peut utiliser un bitmask de 4 bits pour repr√©senter les 4 adjacences d'une case. le premier bit repr√©sente l'adjacence du haut, le deuxi√®me bit l'adjacence de gauche, le troisi√®me bit l'adjacence de droite et le quatri√®me bit l'adjacence du bas.    Exemple de tileset utilis√© pour g√©n√©rer l'exemple pr√©c√©dent  Plus d'explications sur cet article: https://code.tutsplus.com/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts--cms-25673t    Il est m√™me possible d'aller plus loin en utilisant des algorithmes d'auto-tiling plus complexes qui tiennent compte des diagonales ou d'ajouter d'autres r√®gles pour afficher des sprites suppl√©mentaires en fonction de valeurs al√©atoires ou de conditions particuli√®res.  ","version":"Next","tagName":"h2"},{"title":"Sprite anim√© (synth√®se d'images)‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#sprite-anim√©-synth√®se-dimages","content":" Vous pouvez ajouter une animation pour vos sprites. Par exemple, vous pouvez faire en sorte que les ennemis aient une animation de marche lorsqu'ils se d√©placent.  Cela peut se faire en utilisant plusieurs sprites pour repr√©senter les diff√©rentes √©tapes de l'animation. Ces sprites sont affich√©s les uns apr√®s les autres pour donner l'illusion du mouvement.  Les diff√©rentes sprites sont g√©n√©ralement regroup√©es dans une seule image appel√©e sprite sheet.  Exemple de sprite sheet pour un effet de feu :    ","version":"Next","tagName":"h2"},{"title":"Niveau de difficult√© et ennemis‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#niveau-de-difficult√©-et-ennemis","content":" Vous pouvez ajouter un niveau de difficult√© au jeu en ajoutant des types ennemis suppl√©mentaires ou en augmentant la vitesse de d√©placement des ennemis.  Dans ce cas, il faudra un minimum de 3 types d'ennemis diff√©rents.  Vous pouvez √©galement ajouter des niveaux de difficult√© qui modifient la taille de la carte, le nombre de collectibles et ajouter des cases de type obstacle.  Dans ce cas, il faudra au minimum 3 niveaux de difficult√© diff√©rents et que la carte soit g√©n√©r√©e diff√©remment en fonction du niveau de difficult√©.  ","version":"Next","tagName":"h2"},{"title":"G√©n√©ration proc√©durale am√©lior√©e (algorithmique)‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#g√©n√©ration-proc√©durale-am√©lior√©e-algorithmique","content":" Vous pouvez am√©liorer la g√©n√©ration proc√©durale de la carte en ajoutant des algorithmes de g√©n√©ration proc√©durale plus avanc√©s pour avoir des cartes plus vari√©es et des &quot;salles&quot;, &quot;biomes&quot;, &quot;zones&quot; plus int√©ressantes.  Ou encore ajouter une √©tape de filtrage pour √©viter les zones inaccessibles (flood fill filtering).  Il est aussi possible de faire varier les r√®gles et regarder l'√©tat de la g√©n√©ration 2 it√©rations en arri√®re au lieu de seulement 1 it√©ration. Ou encore de r√©p√©ter l'algorithme de g√©n√©ration plusieurs fois avec des r√®gles diff√©rentes (pour filtrer les √Ælots constitu√©s d'une seule case pleine par exemple).  Cette source mentionne une telle variation de l'algorithme.  ","version":"Next","tagName":"h2"},{"title":"Champ de vision limit√© (synth√®se d'images)‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#champ-de-vision-limit√©-synth√®se-dimages","content":" Comme on peut le voir dans l'exemple de jeu diamond-digger, il est possible d'ajouter un effet qui masque une partie de l'√©cran pour rendre le jeu plus int√©ressant (g√©n√©ralement appel√© fog of war dans les jeux vid√©o). Dans cet exemple de jeu, le champ de vision s'agrandit au fur et √† mesure que le joueur trouve des objets &quot;torches&quot; pour √©clairer la carte. A vous de trouver comment impl√©menter cette fonctionnalit√©.  ","version":"Next","tagName":"h2"},{"title":"Autres am√©liorations possibles‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#autres-am√©liorations-possibles","content":" On peut penser notamment √† :  Utilisation de &quot;pouvoir&quot; pour le joueur (ex: ralentir les ennemis, d√©truire un ennemi, placer un bloc, ...).Fonctionnalit√© de sauvegarde et de chargement de partie.Ajout d'un syst√®me de score (ex: en fonction du temps, du nombre d'ennemis tu√©s, ...).Ajout d'un syst√®me de vie (ex: le joueur a 3 vies et perd une vie lorsqu'il est touch√© par un ennemi).Ajout d'un syst√®me de progression (ex: le joueur gagne des niveaux et d√©bloque des comp√©tences ou des objets qu'il peut r√©utiliser dans de nouvelles parties).  N√©anmoins, si une nouvelle fonctionnalit√© modifiait m√™me de mani√®re l√©g√®re les sp√©cifications alors cette nouvelle fonctionnalit√© devra √™tre valid√©e par vos enseignants. Elle devra aussi √™tre indiqu√©e clairement dans le rapport.  ","version":"Next","tagName":"h2"},{"title":"Conseils et remarques‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#conseils-et-remarques","content":" Ce sujet de projet constitue un cahier des charges de l'application. Tout changement √† propos des sp√©cifications du projet doit √™tre valid√© par vos enseignants. Le temps qui vous est imparti n'est pas de trop pour r√©aliser ce projet. N'attendez pas le dernier moment pour commencer √† coder. Il est tr√®s important que vous r√©fl√©chissiez avant de commencer √† coder aux principaux modules, algorithmes et aux principales structures de donn√©es que vous utiliserez pour votre application. Il faut √©galement que vous vous r√©partissiez le travail et que vous d√©terminiez les t√¢ches √† r√©aliser en priorit√©. Ne r√©digez pas le rapport √† la derni√®re minute sinon il sera b√¢cl√©. Il est imp√©ratif que chacun d'entre vous travaille sur une partie et non pas tous &quot;en m√™me temps&quot; (plusieurs qui regardent un travailler). Sinon, vous n'aurez pas le temps de tout faire. C'est encore plus vrai pour les trin√¥mes. Rappel: Les trin√¥mes devront obligatoirement r√©aliser au minimum une fonctionnalit√© suppl√©mentaire (expliqu√©es dans la section Projet) par rapport aux bin√¥mes. Utilisez la biblioth√®que standard C++ pour les structures du type listes (std::vector), piles (std::stack), files (std::queue). N'oubliez pas de tester votre application √† chaque sp√©cification impl√©ment√©e. Si cela marche, vous pouvez passer √† plus gros ou plus complexe. Vos charg√©s de TD et CM sont l√† pour vous aider. Si vous ne comprenez pas un algorithme ou avez des difficult√©s sur un point (probl√®me technique, compr√©hension du sujet, etc), n'attendez pas la soutenance pour nous en parler ! Vous ne devez utiliser que des assets libres de droit pour votre projet. Vous devez citer les sources des assets utilis√©s dans votre rapport. Vous pouvez bien s√ªr cr√©er vos propres assets.  ","version":"Next","tagName":"h2"},{"title":"Sources‚Äã","type":1,"pageTitle":"IMAC DIGGER","url":"/Learn--cpp_programming/Subjects/IMAC2027/S2/sujet#sources","content":" Algorithmes de g√©n√©ration proc√©durale:  roguebasin: Cellular Automata Method for Generating Random Cave-Like Levelsgenerativelandscapes: cave cellular automaton algorithm  Recherche de chemin:  RedBlobGames: Flow Field Pathfinding  Autres ressources:  tilesetter: outil de cr√©ation de tilesetceleste exemple d'auto-tilingtilekit: outil d'auto-tiling avanc√©  Assets utilis√©s pour les illustrations :  kenney: pixel-shmupbrullov: fire-animation  Logiciel utilis√© pour cr√©er les images :  Ldtk ","version":"Next","tagName":"h2"},{"title":"TD4 - Tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (min & max)‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-1-min--max","content":" Des nains partent en exp√©dition dans les montagnes. Ils transportent chacun une certaine quantit√© de provisions (exprim√©e en calories).  Votre mission est de d√©terminer la quantit√© de provisions la plus grande transport√©e par un nain.  Je vous donne le programme suivant qui g√©n√®re la liste des calories transport√©es par chaque nain:  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; int main() { size_t const dwarf_count { 20 }; std::vector&lt;float&gt; calories {}; // std::srand permet de fixer la &quot;seed&quot; du g√©n√©rateur al√©atoire (pour avoir des r√©sultats reproductibles) std::srand(42); calories.reserve(dwarf_count); // Pour optimiser, on dit √† l'avance au tableau combien d'√©l√©ments vont √™tre ajout√©s, afin qu'il puisse allouer la m√©moire n√©cessaire en une seule fois. Si on ne fait pas √ßa, √† chaque push_back dans la boucle le tableau va √™tre oblig√© d'allouer de la m√©moire suppl√©mentaire pour contenir le nouvel √©l√©ment, ce qui est plus lent. for (size_t i { 0 }; i &lt; dwarf_count; ++i) { // G√©n√©ration d'un nombre al√©atoire entre 100 et 24000 float const random_01 { static_cast&lt;float&gt;(rand()) / static_cast&lt;float&gt;(RAND_MAX) }; calories.push_back(100.f + (24000.f-100.f) * random_01); } // affichage optionnel des calories transport√©es par chaque nain for (float const c : calories) { std::cout &lt;&lt; c &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // TODO: afficher la quantit√© de provisions la plus grande transport√©e par un nain return 0; }   Trouver la quantit√© de provisions la plus grande transport√©e par un nain. Trouver la quantit√© de provisions la plus petite transport√©e par un nain (arrivez vous √† le faire sans utiliser de boucle suppl√©mentaire ?). Essayez de faire fonctionner le programme avec plus de nains, par exemple 200, 2000 ou m√™me 20000 nains. (Attention, il ne faut pas afficher les calories transport√©es par chaque nain dans ce cas). Si vous avez eu besoin de changer autre chose que la variable dwarf_count pour r√©pondre √† la question pr√©c√©dente, essayez de trouver une solution qui fonctionne avec n'importe quel nombre de nains sans avoir √† modifier le code. Pour aller plus loin: Trouver les trois nains transportant le plus de provisions et afficher la somme des provisions transport√©es par ces trois nains.  info Exercice inspir√© de de l'√©dition 2022 de l'advent of code: https://adventofcode.com/2022/day/1C'est un √©v√®nement annuel qui propose un probl√®me de code par jour sous forme de calendrier de l'avent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Palindrome)‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-2-palindrome","content":" Un palindrome est un mot qui peut √™tre lu de la m√™me mani√®re de gauche √† droite et de droite √† gauche.  Par exemple, kayak est un palindrome.  √âcrire un programme qui demande √† l'utilisateur de saisir un mot et qui affiche si ce mot est un palindrome ou non.  astuce Une cha√Æne de caract√®res est un tableau de caract√®res.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Comptage)‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-3-comptage","content":" √âcrire un programme qui demande un nombre entier positif (sup√©rieur √† 1 000 000) √† l'utilisateur et qui remplit un tableau avec les chiffres de ce nombre. Le programme doit ensuite compter le nombre d'occurrences de chiffre et afficher le chiffre qui appara√Æt le plus souvent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Points d'√©nergie)‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-4-points-d√©nergie","content":" Dans un jeu vid√©o de type RPG, d√®s que le joueur termine un niveau, il gagne des points d‚Äô√©nergie.  Les points d'√©nergie sont calcul√©s en fonction du niveau termin√© et du nombre et du niveau de difficult√© des ennemis tu√©s.  Le nombre de points d'√©nergie gagn√©s est calcul√© de la mani√®re suivante:  Pour chaque ennemi tu√©, trouver tous les multiples de son niveau de difficult√© inf√©rieurs au niveau termin√© par le joueur.Combiner tous les multiples trouv√©s pour chaque ennemi tu√© en supprimant les doublons.Additionnez tous les nombres restants pour obtenir le nombre de points d'√©nergie gagn√©s.  Voici un exemple:  Le joueur termine le niveau 20.Il tue 2 ennemis de niveau 3, 5.  Les multiples de 3 inf√©rieurs √† 20 sont: 3, 6, 9, 12, 15, 18. Les multiples de 5 inf√©rieurs √† 20 sont: 5, 10, 15.  En supprimant les doublons, nous obtenons: 3, 5, 6, 9, 10, 12, 15, 18.  En additionnant tous les nombres, nous obtenons 78 points d'√©nergie.  Vous devez √©crire un programme qui demande √† l'utilisateur de saisir le niveau termin√© et le nombre et le niveau de difficult√© des ennemis tu√©s et qui affiche le nombre de points d'√©nergie gagn√©s.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Suppression et tassement)‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-5-suppression-et-tassement","content":" √âcrire un programme qui demande √† l'utilisateur de saisir 10 entiers compris entre 0 et 5 et qui les stocke dans un tableau. (vous pouvez aussi demander √† l'utilisateur de saisir un nombre puis le d√©composer en chiffres et stocker les chiffres dans un tableau).  Vous devez ensuite supprimer toutes les valeurs valant 3 dans le tableau en d√©calant tous les √©l√©ments vers la gauche et en compl√©tant le tableau avec des 0.  Tableau avant:  [1, 3, 2, 3, 3, 4, 5, 3, 0, 2]   Tableau apr√®s:  [1, 2, 4, 5, 0, 2, 0, 0, 0, 0]   ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus‚Äã","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercices-bonus","content":" Algorithmes de Luhn Le num√©ro de carte bancaire est un nombre de 16 chiffres. Il est compos√© de 4 groupes de 4 chiffres s√©par√©s par un espace. Tous les num√©ros de carte bancaire ne sont pas valides et il existe des algorithmes pour le v√©rifier. Cela permet de v√©rifier rapidement si un num√©ro de carte bancaire est valide ou non sans avoir √† contacter la banque et permet de d√©tecter rapidement certaines erreurs de saisie (comme l'inversion de deux chiffres par exemple). L'algorithme de Luhn est l'un de ces algorithmes. Son principe est de calculer, √† partir d'un nombre (ou une suite de chiffres), une cl√© de contr√¥le (appel√©e checksum) qui permet de v√©rifier que le num√©ro est correct (car la cl√© est un nombre qui est d√©pendant des autres et doit respecter certaines conditions). Dans notre cas, la cl√© de contr√¥le est calcul√©e de la mani√®re suivante: On multiplie un chiffre sur deux par 2 (en commen√ßant par le deuxi√®me chiffre).Si le r√©sultat de la multiplication est sup√©rieur √† 9, on additionne les chiffres du r√©sultat (par exemple, 8 * 2 = 16, 1 + 6 = 7).On additionne tous les chiffres (y compris ceux qui n'ont pas √©t√© multipli√©s par 2). Si le r√©sultat (la cl√© de contr√¥le) est un multiple de 10, alors le num√©ro est valide. Un exemple Prenons le num√©ro de carte bancaire suivant: 1234 5678 9002 3456. On multiplie un chiffre sur deux par 2 (en commen√ßant par le dernier chiffre): 1 2 3 4 5 6 7 8 9 0 0 2 3 4 5 6 x2 x2 x2 x2 x2 x2 x2 x2 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 On additionne les chiffres du r√©sultat si le r√©sultat est sup√©rieur √† 9: 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 On additionne tous les chiffres: 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 1 + 4 + 3 + 8 + 5 + 3 + 7 + 7 + 9 + 0 + 0 + 4 + 3 + 8 + 5 + 3 = 70 La cl√© de contr√¥le est 70. 70 est un multiple de 10, donc le num√©ro de carte bancaire est valide. Vous devez √©crire un programme qui demande √† l'utilisateur de saisir un num√©ro de carte bancaire et qui affiche si ce num√©ro est valide ou non. Pour la saisie, vous √™tes libre de choisir le format ou syntaxe que vous voulez (via une cha√Æne de caract√®res, avec ou sans espaces, un nombre ou une boucle sur plusieurs chiffres). astuce Convertissez premi√®rement la cha√Æne de caract√®res en un tableau de chiffres.Pour convertir un caract√®re en un nombre, vous pouvez utiliser la fonction std::stoi (string to integer) ou la valeur ASCII du caract√®re. (voir l'Exercice 5 du TD2). ","version":"Next","tagName":"h2"},{"title":"TD3 - Conditions et boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Positif ou n√©gatif)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-1-positif-ou-n√©gatif","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier et affiche si cet entier est positif ou n√©gatif.  Exemples d‚Äôex√©cution:  Saisir un entier : 42 42 est positif   Saisir un entier : -5 -5 est n√©gatif   Modifier le programme pour utiliser une condition ternaire.  ternaire Un ternaire est une expression conditionnelle qui permet de faire un test comme un if/else et de retourner une valeur en fonction du r√©sultat du test. const bool is_student{true}; // condition ? valeur si vrai : valeur si faux const int price {is_student ? 10 : 20}; // price = 10 C'est r√©serv√© aux cas simples qui peuvent s'√©crire sur une seule ligne. Il ne faut pas abuser des ternaires car cela peut rendre le code illisible.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Somme d'entiers positifs)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-2-somme-dentiers-positifs","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir des entiers positifs (s‚Äôarr√™te d√®s que l‚Äôutilisateur saisit un entier n√©gatif)  G√©rer l'entr√©e utilisateur (et son arr√™t) √† l'aide d'une boucle while ou do while.Afficher la somme des entiers positifs saisis par l‚Äôutilisateur.Modifier le programme pour qu'il affiche √©galement la moyenne des entiers positifs saisis par l‚Äôutilisateur.  info Pour calculer la moyenne, il faut compter le nombre d'entiers positifs saisis par l'utilisateur puis diviser la somme par ce nombre. Vous n'avez pas √† stocker les entiers saisis par l'utilisateur (vous d√©couvrirez comment faire cela dans le prochain chapitre) vous pouvez simplement stocker la somme et le nombre d'entiers saisis.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Pair ou impair)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-3-pair-ou-impair","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier et affiche :  si cet entier est pair, tous les nombres positifs pairs inf√©rieurs √† cet entiersi il est impair, tous les nombres positifs divisibles par 3 inf√©rieurs √† cet entier  astuce Vous pourrez utiliser std::cin pour demander le nombre √† l'utilisateur (aucune gestion d'une √©ventuelle erreur de saisie n'est demand√©e ici).  astuce Vous pouvez utiliser l'op√©rateur modulo % qui donne le reste de la division enti√®re.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Majeur ou mineur)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-4-majeur-ou-mineur","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir son √¢ge (un nombre entier) et aÔ¨Äiche s‚Äôil est majeur ou mineur.  G√©rer la saisie d'un √¢ge √† stocker dans une variable.G√©rer le cas o√π l‚Äôutilisateur saisit un √¢ge n√©gatif et afficher un message d‚Äôerreur dans ce cas.G√©rer le cas o√π l‚Äôutilisateur saisit un √¢ge avec des lettres et afficher et g√©rer l‚Äôerreur.  info Apr√®s avoir utilis√© std::cin &gt;&gt; x, il est possible de tester si la saisie a √©chou√© avec std::cin.fail() qui renvoie true si la saisie a √©chou√© et false sinon. Dans notre cas, si l'utilisateur saisit un √¢ge avec des lettres, la saisie √©choue et la variable √¢ge n'est pas modifi√©e. Dans le cas o√π la saisie a √©chou√©, il faut r√©initialiser la saisie de l'utilisateur pour pouvoir saisir √† nouveau un √¢ge : std::cin.clear() restaure std::cin √† un √©tat fonctionnel, sans erreur.std::cin.ignore() permet d‚Äôignorer un nombre d√©fini de caract√®res, soit jusqu‚Äô√† un nombre maximum (exemple 500), soit jusqu‚Äô√† un caract√®re pr√©cis (exemple '\\n' ou 'a'). Dans notre cas, nous allons utiliser ceci‚ÄØpour r√©initialiser la saisie de l'utilisateur si on a rencontr√© une erreur : std::cin.clear(); // On remet std::cin dans un √©tat fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caract√®res m√©moris√©s.   ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Le juste prix)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-5-le-juste-prix","content":" Un nombre entier est tir√© au hasard entre 1 et 100 (inclus).  Le joueur doit deviner ce nombre en un minimum de tentatives.  √Ä chaque tentative, le programme indique au joueur si le nombre √† deviner est plus grand ou plus petit que celui qu‚Äôil a propos√©.  Le programme s‚Äôarr√™te lorsque le joueur a trouv√© le nombre myst√®re.  info Pour g√©n√©rer un nombre al√©atoire, vous pouvez utiliser la fonction rand() de la biblioth√®que cstdlib. Elle retourne un nombre entier al√©atoire entre 0 et RAND_MAX (une constante d√©finie dans la biblioth√®que cstdlib). Pour obtenir un nombre al√©atoire entre 1 et 100, on peut utiliser l'op√©rateur modulo % : std::rand() % 100 + 1 Pour que le g√©n√©rateur de nombres al√©atoires ne g√©n√®re pas toujours la m√™me s√©quence de nombres, il faut l‚Äôinitialiser avec une valeur diff√©rente √† chaque ex√©cution du programme. C'est avec la fonction srand(). On peut utiliser la fonction time() de la biblioth√®que ctime pour obtenir l'heure actuelle en secondes et l'utiliser comme valeur d'initialisation du g√©n√©rateur de nombres al√©atoires. #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; int main() { // Initialisation du g√©n√©rateur de nombres al√©atoires avec la fonction time() std::srand(std::time(nullptr)); int random_variable { std::rand() }; std::cout &lt;&lt; &quot;Random value between 0 and &quot; &lt;&lt; RAND_MAX &lt;&lt; &quot; : &quot; &lt;&lt; random_variable &lt;&lt; std::endl; } NB : Il existe une fa√ßon plus moderne de g√©n√©rer des nombres al√©atoires √† partir de C++11, nous d√©couvrirons cela au prochain semestre.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (ASCII art)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-6-ascii-art","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif et affiche un triangle rectangle de hauteur n comme dans l‚Äôexemple ci-dessous.  exemple d'ex√©cution Entrez un entier positif : 5 * ** *** **** *****   Essayer d'afficher un sapin de no√´l, autrement dit un triangle rectangle isoc√®le de hauteur n et dont le sommet est compos√© d'une seule √©toile.  exemple d'ex√©cution Entrez un entier positif : 3 * *** *****   Essayer d'afficher les contours d'un carr√© de c√¥t√© n comme dans l‚Äôexemple ci-dessous.  exemple d'ex√©cution Entrez un entier positif : 5 ***** * * * * * * *****   ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (conjecture de Syracuse)‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-7-conjecture-de-syracuse","content":" √âcrire un programme qui, √† partir d‚Äôun entier positif saisi par l‚Äôutilisateur, affiche le nombre de termes de la suite de Syracuse n√©cessaires pour atteindre 1 (on inclut le terme de d√©part dans le d√©compte).  La suite de Syracuse est une suite d'entiers dans laquelle chaque terme est obtenu en appliquant une fonction √† son terme pr√©c√©dent. Cette fonction est d√©finie comme suit:  si le terme est pair, le terme suivant est √©gal √† la moiti√© du terme pr√©c√©dent. (x/2)si le terme est impair, le terme suivant est √©gal √† 3 fois le terme pr√©c√©dent plus 1 (3x+1).  Par exemple, si le terme de d√©part est 7, la suite est :  7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1, ...  Ici, la suite atteint la valeur 1 au bout de 17 termes (incluant le terme de d√©part).  Vous remarquez qu‚Äô√† la fin, une fois qu‚Äôon est tomb√© sur 1, la suite finit par r√©p√©ter ind√©finiment le cycle 4, 2, 1.  Il est conjectur√© que cette suite atteint toujours la valeur 1 quelque soit le terme de d√©part. Cela a d'ailleurs d√©j√† √©t√© v√©rifi√©e num√©riquement jusqu‚Äô√† 10^20 (par Tomas Oliveira e Silva).  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus‚Äã","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercices-bonus","content":" Soldes : Conditions et gestion de l'entr√©e utilisateur C'est les soldes ! Cr√©er un programme qui demande √† l'utilisateur : le type de produit (√† stocker dans un enum)le prix du produit (un nombre flottant)s'il a une carte de fid√©lit√© (boolean)son age (un nombre entier) En fonction des informations saisies, le programme affiche le prix final apr√®s r√©duction. Vous disposez des informations suivantes: Type d'article\tR√©duction\tR√©duction avec carte de fid√©lit√©Alimentation\t5%\t8% V√™tements\t10%\t15% Chaussures\t12%\t18% Autre\t0%\t0% S'il √† moins de 26 ans, il a 10% de r√©duction suppl√©mentaire sur tous les articles apr√®s r√©duction. Je vous fourni le code suivant pour l'√©num√©ration et la gestion de la saisie de l'utilisateur: enum class Article { Alimentation, Vetements, Chaussures, Autre }; // C'est un m√©canisme avanc√©, vous n'avez pas besoin de comprendre comment √ßa marche. // On en reparlera au second semestre. // retenez juste que √ßa permet de convertir une entr√©e de l'utilisateur en Article. std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } Cela nous permet d'utiliser l'op√©rateur &gt;&gt; pour lire un enum comme on pourrait le faire avec un int ou un float. Sans cela, on aurait d√ª utiliser une variable interm√©diaire de type string ou int pour stocker la saisie de l'utilisateur et faire la conversion nous-m√™me. Exemple de saisie d'un enum #include &lt;iostream&gt; enum class Article { Alimentation, Vetements, Chaussures, Autre }; std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } int main() { Article article; std::cin &gt;&gt; article; // On v√©rifie si la saisie a √©chou√©. if (std::cin.fail()) { std::cout &lt;&lt; &quot;Erreur de saisie, il faut saisir un type d'article valide (\\&quot;Alimentation\\&quot;, \\&quot;Vetements\\&quot;, \\&quot;Chaussures\\&quot; ou \\&quot;Autre\\&quot;)&quot; &lt;&lt; std::endl; std::cin.clear(); // On remet std::cin dans un √©tat fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caract√®res m√©moris√©s. // le programme s'arr√™te si on a rencontr√© une erreur de saisie et renvoie 1 pour indiquer une erreur. return 1; } if (article == Article::Alimentation) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Alimentation&quot; &lt;&lt; std::endl; } else if (article == Article::Vetements) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Vetements&quot; &lt;&lt; std::endl; } else if (article == Article::Chaussures) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Chaussures&quot; &lt;&lt; std::endl; } else if (article == Article::Autre) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Autre&quot; &lt;&lt; std::endl; } return 0; } Demander √† l'utilisateur de saisir le type d'article, le prix, s'il a une carte de fid√©lit√© et son √¢ge. G√©rer les cas o√π l'utilisateur saisit des informations incorrectes (enum incorrect, prix ou √¢ge n√©gatif, etc.) et afficher un message d'erreur dans ce cas. Vous pouvez reprendre mon exemple de saisie d'un enum. Calculer le prix final en fonction des informations saisies et afficher le r√©sultat. L'enseigne offre √©galement un bon d'achat de 10% du montant total du ticket de caisse, √† valoir sur un prochain achat. Le bon d'achat ne peut pas √™tre sup√©rieur √† 30‚Ç¨. Calculer le montant du bon d'achat et l'afficher en fin de programme. ","version":"Next","tagName":"h2"},{"title":"TD6 - D√©bogueur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/DebuggerAndErrors","content":"TD6 - D√©bogueur Ce TD a pour but de vous familiariser avec l'utilisation du d√©bogueur en C++. Il n'y a pas d'exercices √† proprement parler, je vous invite √† tester les diff√©rentes fonctionnalit√©s du d√©bogueur sur des exercices des TDs pr√©c√©dents ou vous aider du d√©bogueur pour corriger et rattraper des exercices des TDs pr√©c√©dents. Quelques suggestions d'exercices √† d√©boguer: Fonction r√©cursives: FibonacciVous pouvez observer le comportement de la fonction r√©cursive de Fibonacci en mettant un point d'arr√™t conditionnel sur la valeur de n et inspecter la pile d'appels. Conjecture de SyracuseVous pouvez observer le comportement de la conjecture de Syracuse si le nombre devient trop grand par exemple. Tableaux Vous pouvez vous servir des watch pour observer les valeurs des √©l√©ments d'un tableau comme dans l'exercice de comptage ou de suppression et tassement","keywords":"","version":"Next"},{"title":"TD8 - Headers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/headers","content":"TD8 - Headers Le but de ce TD est de manipuler plusieurs fichiers sources et de les compiler ensemble pour cr√©er un programme. Nous allons cr√©er une structure qui permet de repr√©senter une couleur avec trois composantes red, green et blue. Cr√©er un fichier color.hpp qui contiendra un espace de nom Color avec la d√©finition de la structure Rgb et les prototypes des fonctions et m√©thodes suivantes : La structure devra s'appeler Rgb et contenir trois entiers nomm√©s red, green et blue de type unsigned int avec une valeur par d√©faut initialis√©e √† 0.La structure devra contenir une m√©thode display qui permet d'afficher (std::cout) la couleur sous la forme rgb(red, green, blue). info On pourrait aussi utiliser un type unsigned char pour les composantes de couleur mais √ßa va nous poser des probl√®mes pour les calculs et pour l'affichage. En effet, les types char s'affichent comme des caract√®res ASCII et non comme des entiers. De plus, les calculs avec des char peuvent poser des probl√®mes de d√©bordement de capacit√©. Cr√©er un fichier color.cpp qui contiendra les d√©finitions des m√©thodes et fonctions. Maintenant que nous avons notre structure Color::Rgb, nous allons ajouter des fonctions pour pouvoir manipuler nos couleurs pour en obtenir de nouvelles. Cr√©er un nouveau fichier color_utils.hpp qui contiendra les prototypes des fonctions suivantes : mix qui permet de m√©langer deux couleurs en faisant la moyenne des composantes red, green et blue. Elle retourne la couleur r√©sultante et prend en param√®tre deux couleurs (r√©f√©rences constantes).luminance qui permet de calculer la luminance d'une couleur en utilisant la formule 0.2126‚àóred+0.7152‚àógreen+0.0722‚àóblue0.2126 * \\text{red} + 0.7152 * \\text{green} + 0.0722 * \\text{blue}0.2126‚àóred+0.7152‚àógreen+0.0722‚àóblue (‚ö†Ô∏è il faudra convertir au pr√©alable les composantes enti√®res [0,255][0, 255][0,255] en flottants [0,1][0, 1][0,1]) et retourner le r√©sultat sous forme d'un nombre flottant entre 0 et 1.invert qui permet d'inverser les composantes d'une couleur (255 - composante) et de retourner la couleur invers√©e.grayscale qui permet de convertir une couleur en une couleur en niveaux de gris. (Une couleur en niveaux de gris a ses composantes red, green et blue √©gales √† la luminance de la couleur). Cr√©er un nouveau fichier color_utils.cpp qui contiendra les d√©finitions des fonctions. Cr√©er un nouveau couple de fichiers color_hex.cpp et color_hex.hpp dans lesquels vous allez ajouter des fonctions pour manipuler des couleurs en hexad√©cimal. Le fichier contiendra les fonctions suivantes (toujours dans l'espace de nom Color): Rgb Rgb_from_hex(unsigned int const hex) qui permet de convertir un entier hexad√©cimal en une couleur.unsigned int rgb_to_hex_int(Rgb const&amp; color) qui permet de convertir une couleur en un entier hexad√©cimal. couleur en hexad√©cimal Pour convertir un entier hexad√©cimal en composantes red, green et blue, vous pouvez utiliser des op√©rations de d√©calage binaire (&gt;&gt;) et des AND binaires (&amp;) pour extraire les composantes. En effet, un entier hexad√©cimal est compos√© de 3 octets (24 bits) o√π les 8 premiers bits repr√©sentent la composante red, les 8 bits suivants la composante green et les 8 derniers bits la composante blue. Par exemple, le nombre 0xff0000 se d√©coupe en 3 octets ff, 00 et 00 qui correspondent respectivement √† red, green et blue. En binaire, cela donne 11111111, 00000000 et 00000000. Ici, le pr√©fixe 0x indique que l'on parle d'un nombre hexad√©cimal et pas d'une cha√Æne de caract√®res, de la m√™me mani√®re que le suffixe f pour les nombre flottants par exemple. Pour extraire la composante red, il faut utiliser des op√©rations de d√©calage binaires et de masquage. Par exemple 10100101 &amp; 11110000 donne 10100000 (masquage) et 10100000 &gt;&gt; 4 donne 00001010 (d√©calage). Ici on peut utiliser ce m√©canisme pour extraire les composantes red, green et blue de l'entier hexad√©cimal. 0xe812f0 &amp; 0xff0000 donne 0xe80000 et 0xe80000 &gt;&gt; 16 donne 0x0000e8 qui correspond √† la composante red de la couleur. Pour obtenir la composante green, il faut faire un masquage avec 0x00ff00 et un d√©calage de 8 bits (&gt;&gt; 8). Ce qui donne avec les op√©rations binaires combin√©es : (0xe812f0 &amp; 0x00ff00) &gt;&gt; 8 = 0x000012. Pour obtenir la composante blue, il faut faire un masquage avec 0x0000ff et un d√©calage de 0 bit (qui ne change rien et est donc optionnel) ce qui donne : 0xe812f0 &amp; 0x0000ff = 0x0000f0. Il est aussi possible de faire un d√©calage puis un masquage (0xe812f0 &gt;&gt; 16 &amp; 0x0000ff donne aussi 0x0000e8 (la composante red de la couleur)). Ajouter les prototypes et d√©finitions des fonctions suivantes permettant de manipuler des cha√Ænes de caract√®res repr√©sentant des couleurs en hexad√©cimal : Rgb Rgb_from_hex(std::string const&amp; hex) qui permet de convertir une cha√Æne de caract√®res repr√©sentant un entier hexad√©cimal en une couleur.std::string rgb_to_hex_string(Rgb const&amp; color) qui permet de convertir une couleur en une cha√Æne de caract√®res repr√©sentant la couleur en hexad√©cimal. astuce Vous pouvez utiliser la fonction std::stoi pour convertir une cha√Æne de caract√®res en entier. Pour cela, vous devez sp√©cifier la base de conversion en troisi√®me param√®tre pour que la fonction puisse interpr√©ter la cha√Æne correctement avec un entier hexad√©cimal. Par exemple, std::stoi(&quot;ff&quot;, nullptr, 16) retourne 255. Pour la fonction rgb_to_hex_string, il faudra donc convertir au pr√©alable la couleur en nombre hexad√©cimale (fonction rgb_to_hex_int) et convertir ce nombre en cha√Æne de caract√®re. Je vous laisse regarder comment convertir un entier hexad√©cimal en cha√Æne de caract√®res mais voil√† quelques pistes: std::stringstream avec le manipulator std::hex pour convertir un entier en hexad√©cimal.std::format(&quot;{:x}&quot;, 42) pour formater un entier en hexad√©cimal (C++20).Directement remplir une cha√Æne de caract√®res avec des op√©rations de d√©calage et de masquage (plus compliqu√© et d√©conseill√©). Cr√©er un fichier main.cpp dans lequel vous allez inclure les fichiers n√©cessaires pour manipuler les couleurs et tester les diff√©rentes fonctions que vous avez cr√©√©es. L'id√©e est de cr√©er un m√©langeur de couleur qui demande √† l'utilisateur de saisir deux couleurs en hexad√©cimal et qui affiche la couleur r√©sultante du m√©lange(format rgb et hexad√©cimal) ainsi que sa luminance et sa couleur invers√©e. exemple de r√©sultat attendu: Entrez la premi√®re couleur en hexad√©cimal: ff0000 Entrez la deuxi√®me couleur en hexad√©cimal: 00ff00 Couleur 1: rgb(255, 0, 0) hex: ff0000 Couleur 2: rgb(0, 255, 0) hex: 00ff00 Couleur m√©lang√©e: rgb(127, 127, 0) hex: 7f7f00 Luminance: 0.462081 Couleur m√©lang√©e invers√©e: rgb(128, 128, 255) hex: 8080ff info La gestion des pr√©fixes 0x pour les entiers hexad√©cimaux (pour indiquer que l'on parle d'un nombre hexad√©cimal) ou m√™me # pour les couleurs en hexad√©cimal (que l'on rencontre souvent en CSS) est optionnelle. Vous pouvez les g√©rer ou non dans votre programme dans les fonctions de conversion. Pour faire au plus simple vous pouvez les ignorer.","keywords":"","version":"Next"},{"title":"TD5 - Fonctions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Somme)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-1-somme","content":" √âcrire une fonction somme qui retourne la somme de deux entiers.  Utiliser des param√®tres par copie et le prototype suivant: int somme(int a, int b); Utiliser des param√®tres constants pour les arguments de la fonction. Utiliser des r√©f√©rences pour les arguments de la fonction. V√©rifier que cela fonctionne aussi bien avec des variables que des litt√©raux dans le cas des r√©f√©rences.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Factorielle)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-2-factorielle","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif.√âcrire une fonction r√©cursive qui retourne la factorielle de n. info La factorielle d'un entier n est le produit des nombres entiers strictement positifs inf√©rieurs ou √©gaux √† n :2√ó3√ó4√ó‚ãØ√ó(n‚àí1)√ón2 \\times 3 \\times 4 \\times \\dots \\times (n-1) \\times n2√ó3√ó4√ó‚ãØ√ó(n‚àí1)√ón Afficher le r√©sultat.G√©rer les cas d'erreur (nombre n√©gatif, nombre trop grand (limiter arbitrairement la valeur de n √† 12 par exemple), etc.).Utiliser une fonction it√©rative (non r√©cursive).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Fibonacci)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-3-fibonacci","content":" √âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif.√âcrire une fonction r√©cursive qui retourne le terme n de la suite de Fibonacci. info La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le pr√©c√®dent. Ses premiers termes sont 0 et 1. Afficher les n premiers termes de la suite de Fibonacci √† l'aide de la fonction pr√©c√©dente. Par exemple, si l‚Äôutilisateur saisit 7, le programme affichera 0, 1, 1, 2, 3, 5, 8.Pour aller plus loin: Essayer de trouver une solution it√©rative (non r√©cursive).Pour aller plus loin: Essayer de faire une fonction it√©rative qui au lieu de retourner seulement le n-i√®me terme, retourne les n premiers termes de la suite de Fibonacci dans un tableau std::vector.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Surcharges)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-4-surcharges","content":" √âcrire une fonction qui permet de calculer la moyenne d'un tableau d'entiers.√âcrire une fonction surcharg√©e portant le m√™me nom qui permet de calculer la moyenne d'un tableau de flottants.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Pangramme)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-5-pangramme","content":" √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne true si la cha√Æne est un pangramme, false sinon.  Il faut faire attention √† la casse (majuscules/minuscules), un m√™me lettre majuscule et minuscule compte pour la m√™me lettre.  info Un pangramme est une phrase contenant toutes les lettres de l'alphabet au moins une fois.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (String)‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-6-string","content":" √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui modifie cette cha√Æne en rempla√ßant les lettres minuscules par des lettres majuscules et vice-versa. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne le nombre de voyelles de cette cha√Æne. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne le nombre de mots de cette cha√Æne. On consid√®re que les mots sont s√©par√©s par un ou plusieurs espaces. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne la m√™me cha√Æne √©crite √† l'envers. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne true si la cha√Æne est un nombre entier. astuce L'id√©e est de parcourir la cha√Æne de caract√®res et de v√©rifier si chaque caract√®re est un chiffre ou non. Pour tester si un caract√®re est un chiffre vous pouvez comparer la valeur ASCII du caract√®re avec les valeurs ASCII des chiffres (voir l'Exercice 5 du TD2). Il existe aussi la fonction std::isdigit (voir la documentation) qui permet de tester si un caract√®re est un chiffre ou non.  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus‚Äã","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercices-bonus","content":" Suite √âcrire sous forme r√©cursive les fonctions UnU_nUn‚Äã et VnV_nVn‚Äã conform√©ment √† la description suivante: U0=1U_0 = 1U0‚Äã=1 et Un+1=3Un+2VnU_{n+1} = 3U_n + 2V_nUn+1‚Äã=3Un‚Äã+2Vn‚ÄãV0=2V_0 = 2V0‚Äã=2 et Vn+1=2Vn+Un+1V_{n+1} = 2V_n + U_n + 1Vn+1‚Äã=2Vn‚Äã+Un‚Äã+1 Afficher les dix premiers termes de chacune des suites. Vous devez obtenir les r√©sultats suivants: U0 = 1 et V0 = 2 U1 = 7 et V1 = 6 U2 = 33 et V2 = 20 U3 = 139 et V3 = 74 U4 = 565 et V4 = 288 U5 = 2271 et V5 = 1142 U6 = 9097 et V6 = 4556 U7 = 36403 et V7 = 18210 U8 = 145629 et V8 = 72824 U9 = 582535 et V9 = 291278  ","version":"Next","tagName":"h2"},{"title":"TD9 - M√©moire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Allocation dynamique)‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-1-allocation-dynamique","content":" √âcrire un programme qui alloue dynamiquement une variable de type int avec le mot-cl√© new (sans initialisation).Demander √† l'utilisateur de saisir une valeur pour cette variable et modifier la valeur de la variable avec cette saisie.√âcrire une fonction qui prend en param√®tre un pointeur sur un int et qui affiche la valeur de la variable point√©e.Afficher la valeur de la variable avec la fonction pr√©c√©dente.Afficher l'adresse de la variable.Lib√©rer cette variable avec le mot-cl√© delete.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-2","content":" √âcrire un programme qui g√©n√®re un tableau (std::vector) de 100 entiers al√©atoires compris entre 0 et 100. info Vous pouvez utiliser la fonction rand() pour g√©n√©rer un nombre al√©atoire. Je vous renvoie √† l'Exercice 1 du TD5 pour plus d'informations. √âcrire une fonction qui retourne un pointeur sur le premier √©l√©ment du tableau qui est sup√©rieur √† 90, ou nullptr si le tableau ne contient pas de tels √©l√©ments. √âcrire une fonction qui prend en param√®tre un pointeur sur un emplacement m√©moire contigu√´ d'entiers et sa taille et qui retourne la somme des √©l√©ments du tableau. Utiliser les fonctions pr√©c√©dentes pour afficher la somme des √©l√©ments du tableau, et le premier √©l√©ment &gt; 90 (pensez √† g√©rer le cas nullptr !). astuce On peut r√©cup√©rer un pointeur sur le premier √©l√©ment d'un std::vector avec la m√©thode data(). Sinon il est aussi possible d'utiliser l'op√©rateur &amp; sur le premier √©l√©ment du std::vector. Completer la fonction sum suivante pour qu'elle retourne un pointeur sur la somme des √©l√©ments du tableau pass√© en param√®tre. int* sum(std::vector&lt;int&gt; const&amp; v) { int sum {0}; // boucle for // TODO } Utiliser la fonction sum pour afficher la somme des √©l√©ments du tableau. En fonction du r√©sultat obtenu, que pouvez-vous en d√©duire sur le fonctionnement de la fonction sum ? Si elle ne fonctionne pas, corriger la fonction sum pour qu'elle fonctionne correctement.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Split)‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-3-split","content":" Dans cet exercice, on ne doit pas utiliser de std::vector.  Allouer dynamiquement un tableau de 100 flottants al√©atoires compris entre 0 et 100 (utiliser l'allocation dynamique pour des emplacements m√©moire contigu√´s). info Vous pouvez utiliser la fonction rand() pour g√©n√©rer un nombre al√©atoire. Pour g√©n√©rer un nombre flottant al√©atoire vous pouvez utiliser la fonction rand() et la diviser par RAND_MAX (qui est une constante d√©finie dans la biblioth√®que cstdlib) ce qui permet d'obtenir un nombre flottant al√©atoire entre 0 et 1. Il ne vous reste plus qu'√† multiplier ce nombre par 100 pour obtenir un nombre flottant al√©atoire entre 0 et 100. √âcrire une fonction qui prend en param√®tre un tableau de flottants (sous la forme d'un pointeur sur le premier √©l√©ment du tableau) et sa taille et qui retourne un pointeur sur le plus grand √©l√©ment du tableau. On souhaite cr√©er une fonction qui permet de cr√©er un nouveau tableau compos√© des √©l√©ments du tableau pass√© en param√®tre qui sont sup√©rieurs √† un certain seuil. √âcrire une fonction thresholdFilter qui prend en param√®tre un tableau de flottants, sa taille, un seuil et une r√©f√©rence sur un entier qui contiendra la taille du nouveau tableau et qui retourne un pointeur sur le premier √©l√©ment du nouveau tableau. Voil√† la signature de la fonction: float* thresholdFilter(float const* const array, size_t const size, float const threshold, size_t&amp; new_size); info Vous pouvez remarquer que j'ai √©crit float const* const array au lieu de float* array. Le premier const signifie que l'on ne peut pas modifier les valeurs point√©es par le pointeur array et le deuxi√®me const signifie que l'on ne peut pas modifier l'adresse point√©e par le pointeur array. ","version":"Next","tagName":"h2"},{"title":"TD1 - Mise en place","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Setup","content":"","keywords":"","version":"Next"},{"title":"Premier programme‚Äã","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#premier-programme","content":" Une fois que vous avez install√© les outils, vous pouvez cr√©er votre premier programme.  Je vous invite √† regarder la page suivante pour avoir les instructions : Premier programme  ","version":"Next","tagName":"h2"},{"title":"Plusieurs ex√©cutables‚Äã","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#plusieurs-ex√©cutables","content":" Comme je l'ai expliqu√©, il ne doit y avoir qu'un seul point d'entr√©e dans un programme C++ et donc une seule fonction main.  Cependant, dans le cadre des TDs, il est parfois utile de pouvoir tester plusieurs fonctions main diff√©rentes, une par exercice par exemple.  Pour cela, nous allons utiliser une fonctionnalit√© de CMake qui permet de cr√©er plusieures targets ou ex√©cutables.  Je vous invite √† cr√©er deux fichiers td01_ex01.cpp et td01_ex02.cpp dans un dossier src et √† y mettre le contenu suivant :  src/td01_ex01.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 01&quot; &lt;&lt; std::endl; return 0; }   src/td01_ex02.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 02&quot; &lt;&lt; std::endl; return 0; }   Ensuite, nous allons cr√©er un fichier CMakeLists.txt √† la racine du projet avec le contenu suivant :  CMakeLists.txt cmake_minimum_required(VERSION 3.10) set(CMAKE_CXX_STANDARD 17) project(TD01) # On indique que l'on veut cr√©er un ex√©cutable &quot;ex01&quot; compil√© √† partir du fichier td01_ex01.cpp add_executable(ex01 src/td01_ex01.cpp) # On indique que l'on veut cr√©er un ex√©cutable &quot;ex02&quot; compil√© √† partir du fichier td01_ex02.cpp add_executable(ex02 src/td01_ex02.cpp)   Vous devriez avoir une arborescence de fichiers qui ressemble √† √ßa:  td01 ‚îú‚îÄ‚îÄ CMakeLists.txt ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ td01_ex01.cpp ‚îî‚îÄ‚îÄ td01_ex02.cpp   Ouvrez ensuite le dossier td01 avec VSCode, il devrait vous proposer de configurer CMake comme pour le premier programme.  Pour que CMake vous affiche la liste des diff√©rentes targets disponibles, il faut aller changer un param√®tre : ouvrez les settings de VSCode, cherchez &quot;cmake visibility&quot; et mettez l'option √† &quot;compact&quot; :  Vous devriez ensuite avoir deux targets dans la barre √† droite du bouton &quot;Run&quot; en bas :    Cela vous permet de choisir quelle target vous voulez ex√©cuter pour travailler sur plusieurs ex√©cutables dans le m√™me projet.  info C'est la m√™me chose pour les t√¢ches de compilation (√† droite du bouton &quot;Build&quot;).  Bravo, vous √™tes maintenant pr√™t √† faire du C++ sur vos propres machines ! ü•≥  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin avec CMake‚Äã","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#pour-aller-plus-loin-avec-cmake","content":" Pour en apprendre plus sur CMake, vous pouvez aller lire ce petit cours sur CMake (au moins jusqu'aux sections Setting your C++ version et GLOB).  Il vous apprendra notamment ce que c'est qu'une target dans CMake, et quelles sont les bonnes pratiques autour des targets pour √©crire un CMake qui marche bien.  Une fois que vous aurez lu ce cours, vous pouvez reprendre le CMake que vous avez √©crit pr√©c√©demment dans ce TP, et essayer de l'am√©liorer gr√¢ce √† ce que vous avez appris. Vous pouvez notamment remplacer le set(CMAKE_CXX_STANDARD 17), et aussi √©viter de devoir lister manuellement tous les fichiers .cpp de votre projet (certes vous n'en avez qu'un par target pour l'instant, mais le jour o√π vous en aurez plusieurs vous serez bien contents de ne pas avoir √† tous les lister un par un). ","version":"Next","tagName":"h2"},{"title":"TD7 - Structures","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 : d√©placements‚Äã","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-1--d√©placements","content":" Vous √™tes le pilote d'un sous-marin, vous avez re√ßu des ordres de mouvement sous la forme d'une instruction et d'une distance √† parcourir. Vous devez √©crire un programme qui permet de calculer la position du sous-marin apr√®s avoir effectu√© les mouvements re√ßus.  Votre position initiale est (0, 0) et vous pouvez vous d√©placer dans les directions suivantes: Up, Down, Forward, Backward.  √âcrire une structure Position qui permet de stocker les coordonn√©es du sous-marin. √âcrire un enum Direction qui permet de stocker les directions possibles. √âcrire une structure Move qui repr√©sente un mouvement sous la forme d'une direction et d'une distance √† parcourir. √âcrire une fonction moveSubmarine qui permet de d√©placer le sous-marin en fonction d'un mouvement. La fonction ne doit rien retourner et doit modifier la position du sous-marin pass√©e en param√®tre. √âcrire une fonction display qui permet d'afficher la position du sous-marin pass√©e en param√®tre.  Le but est d'indiquer la position du sous-marin apr√®s avoir effectu√© les mouvements suivants:  Forward 10Down 5Backward 3Up 2Forward 5Down 1Backward 2Forward 3Down 1Up 3Forward 1Down 5Backward 2Forward 6  Vous pouvez repr√©senter les mouvements sous la forme d'un vecteur de Move:  std::vector&lt;Move&gt; moves = { {Direction::Forward, 10}, {Direction::Down, 5}, {Direction::Backward, 3}, {Direction::Up, 2}, {Direction::Forward, 5}, {Direction::Down, 1}, {Direction::Backward, 2}, {Direction::Forward, 3}, {Direction::Down, 1}, {Direction::Up, 3}, {Direction::Forward, 1}, {Direction::Down, 5}, {Direction::Backward, 2}, {Direction::Forward, 6} };   info Exercice inspir√© de de l'√©dition 2021 de l'advent of code: https://adventofcode.com/2021/day/2  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 : combats de Pok√©mons‚Äã","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-2--combats-de-pok√©mons","content":" Un pok√©mon a un Nom, des Points de Vie, une Attaque et une Vitesse. Un combat entre deux Pok√©mons se d√©roule ainsi:  √Ä chaque tour, le pok√©mon avec la plus grande vitesse commence (si √©galit√©, on choisit au hasard lequel de deux commence ce tour)Le pok√©mon attaquant r√©duit les Points de Vie de l'autre d'un montant √©gal √† son attaque. Puis, si le deuxi√®me pok√©mon n'est pas encore KO (Points de Vie encore &gt; 0), il attaque √† son tour.  Faites une structure repr√©sentant un Pok√©mon, puis √©crivez une fonction faisant le combat entre deux Pok√©mons. Par exemple:  Pokemon pokemon1{&quot;Poke1&quot;, 50, 10, 8}; Pokemon pokemon2{&quot;Poke2&quot;, 30, 20, 3}; combat(pokemon1, pokemon2);   doit afficher :  Tour 1: Poke1 attaque, il reste 20 PV √† Poke2. Poke2 attaque, il reste 30 PV √† Poke1. Tour 2: Poke1 attaque, il reste 10 PV √† Poke2. Poke2 attaque, il reste 10 PV √† Poke1. Tour 3: Poke1 attaque, il reste 0 PV √† Poke2. Poke2 est KO, il ne peut pas attaquer. Poke1 gagne!   Un dresseur a un Nom et 3 pok√©mons. Dans un combat entre deux dresseurs, ils font combattre leurs pok√©mons les uns apr√®s les autres, jusqu'√† ce que tous les pok√©mons d'un des dresseurs soient KOs. (Attention, quand on Pokemon entame son deuxi√®me combat, il doit garder les points de vie qu'il avait √† la fin du premier combat, il ne doit pas recommencer avec ses points de vie max !)   Cr√©er une structure Dresseur et une surcharge de la fonction combat pour faire combattre deux dresseurs.   Par exemple:  Dresseur dresseur1{&quot;Dresseur1&quot;, { Pokemon{&quot;Dresseur1_Poke1&quot;, 5, 10, 8}, Pokemon{&quot;Dresseur1_Poke2&quot;, 5, 10, 8}, Pokemon{&quot;Dresseur1_Poke3&quot;, 5, 10, 8}, }}; Dresseur dresseur2{&quot;Dresseur2&quot;, { Pokemon{&quot;Dresseur2_Poke1&quot;, 20, 10, 3}, Pokemon{&quot;Dresseur2_Poke2&quot;, 20, 10, 3}, Pokemon{&quot;Dresseur2_Poke3&quot;, 20, 10, 3}, }}; combat(dresseur1, dresseur2);   doit afficher par exemple :  Tour 1: Dresseur1_Poke1 attaque, il reste 10 PV √† Dresseur2_Poke1. Dresseur2_Poke1 attaque, il reste 0 PV √† Dresseur1_Poke1. Dresseur2_Poke1 gagne! Tour 2: Dresseur1_Poke2 attaque, il reste 0 PV √† Dresseur2_Poke1. Dresseur2_Poke1 est KO, il ne peut pas attaquer. Dresseur1_Poke2 gagne! Tour 3: Dresseur1_Poke2 attaque, il reste 10 PV √† Dresseur2_Poke2. Dresseur2_Poke2 attaque, il reste 0 PV √† Dresseur1_Poke2. Dresseur2_Poke2 gagne! etc... Dresseur 2 a gagn√©!  ","version":"Next","tagName":"h2"},{"title":"TD4 - D√©duction de type et biblioth√®que standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Vector and Algorithm)‚Äã","type":1,"pageTitle":"TD4 - D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-1-vector-and-algorithm","content":" Remplir un std::vector avec des nombres entiers al√©atoires compris entre 0 et 100.Utiliser les it√©rateurs et les m√©thodes begin et end pour afficher les valeurs du vecteur √† l'aide d'une boucle for.Chercher si un nombre saisi par l'utilisateur est pr√©sent dans le vecteur √† l'aide de la fonction std::find et afficher un message adapt√©.Utiliser la fonction std::count pour compter le nombre d'occurrences d'un nombre entier dans le vecteur. Vous pouvez trouver la documentation de la fonction std::count ici.Utiliser la fonction std::sort pour trier le vecteur.Utiliser la fonction std::accumulate pour calculer la somme des √©l√©ments du vecteur (par d√©faut, la fonction std::accumulate utilise l'op√©rateur + entre les √©l√©ments).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (String)‚Äã","type":1,"pageTitle":"TD4 - D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-2-string","content":" √âtant donn√©e une phrase compos√©e de mots s√©par√©s par des espaces.  Nous avons utilis√© dans le TD pr√©c√©dent une astuce avec les stream C++ qui permet de s√©parer les mots d'une phrase. L'id√©e est de coder une autre fa√ßon d'arriver au m√™me r√©sultat sans utiliser les stream.  Je vous donne la fonction lambda suivante qui permet de savoir si un caract√®re est un espace:  auto const is_space = [](char letter){ return letter == ' '; };   Le mot cl√© auto ici permet de stocker la &quot;fonction&quot; dans une variable pour la passer en param√®tre. (En r√©alit√© se cache derri√®re ce auto une struct g√©n√©r√©e automatiquement par le compilateur, et qui va se comporter comme une fonction car elle surcharge l'op√©rateur ().)  Cela va permettre d'utiliser les fonctions std::find_if_not et find_if (qui retournent des it√©rateurs) pour rechercher les espaces dans une cha√Æne de caract√®re.  √âcrire une fonction (√† l'aide des fonctions std::find et std::distance) qui prendre en param√®tre une r√©f√©rence constante sur une std::string et qui retourne le nombre de lettres du premier mot de la phrase.  info Vous allez avoir besoin de la fonction std::distance, qui retourne la distance entre deux it√©rateurs, sous forme d‚Äôun nombre entier.  √âcrire une fonction qui permet de d√©couper la phrase en mots et de les stocker dans un std::vector de std::string. Voil√† le prototype de la fonction :  std::vector&lt;std::string&gt; split_string(std::string const&amp; str);   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Palindrome)‚Äã","type":1,"pageTitle":"TD4 - D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-3-palindrome","content":" √âcrire une fonction qui prend en param√®tre une r√©f√©rence constante sur une std::string et qui retourne true si la cha√Æne de caract√®res est un palindrome (qui peut se lire dans les deux sens), false sinon.  Utiliser la fonctions std::equal pour comparer les valeurs de deux it√©rateurs. Utiliser les fonctions std::begin, std::end et std::rbegin, std::rend pour obtenir les it√©rateurs de d√©but et de fin d'une cha√Æne de caract√®res et de sa version invers√©e.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin (lambda)‚Äã","type":1,"pageTitle":"TD4 - D√©duction de type et biblioth√®que standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#pour-aller-plus-loin-lambda","content":" √âcrire une fonction qui prend en param√®tre un std::vector et retourne la somme du carr√© de ses √©l√©ments. Vous devez utiliser la fonction std::accumulate et une fonction lambda.√âcrire une fonction qui prend en param√®tre un std::vector et retourne le produit de ses √©l√©ments pairs. Vous ne devez pas filtrer les √©l√©ments du vecteur, mais utiliser une fonction lambda pour d√©terminer si un √©l√©ment est pair ou non et si oui, le prendre en compte dans le produit. Vous devez utiliser la fonction std::accumulate et une fonction lambda. ","version":"Next","tagName":"h2"},{"title":"TD2 - Variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (op√©rations)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-1-op√©rations","content":" Cr√©er une variable de type int et initialiser la avec une valeur de votre choix. Appliquer les op√©rations suivantes sur cette variable et afficher le r√©sultat de chaque op√©ration: Incr√©menter la variable de 1 (avec la m√©thode de votre choix).Multiplier la variable par 3.Diviser la variable par 2.  astuce Utiliser la fonction std::cout pour afficher la valeur de la variable.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (entr√©e utilisateur)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-2-entr√©e-utilisateur","content":" Cr√©er un programme qui demande √† l'utilisateur de saisir trois valeurs flottantes (de type float).  Calculer la somme de ces trois valeurs et stocker le r√©sultat dans une variable de type float.Calculer de m√™me la moyenne de ces trois valeurs.Afficher le r√©sultat de la somme et de la moyenne.  astuce Utiliser la fonction std::cin pour lire la valeur saisie par l'utilisateur.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (cast)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-3-cast","content":" Cr√©er une variable enti√®re (de type int) et l'initialiser avec la valeur 11. Afficher la valeur de cette variable. Afficher la valeur de cette variable divis√©e par 2.  Vous devriez obtenir une valeur de 5 et non 5.5. Pourquoi ?  Utiliser un cast pour convertir la variable en un type flottant. Afficher la valeur de la variable divis√©e par 2.0f  astuce static_cast&lt;type&gt;(variable) permet convertir une variable en un autre type.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (conversion)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-4-conversion","content":" √âcrire un programme qui demande un nombre de jours √† l'utilisateur et affiche le nombre d'ann√©es, de mois et de jours correspondant √† ce nombre de jours.  L‚ÄôaÔ¨Äichage se fera sous la forme : &quot;J jours correspondent √†: xx siecle xx annee xx mois xx semaine xx jours&quot;  info Pour simplifier le probl√®me, on consid√©rera que tous les mois ont 30 jours et toutes les ann√©es 360 jours.  exemple d'ex√©cution Entrez un nombre de jours : 4096 4096 jours correspondent √† : 0 siecle 11 annee 4 mois 2 semaine 2 jours   ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (ASCII)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-5-ascii","content":" Demander √† l'utilisateur de saisir un nombre entier entre 1 et 26 et afficher la lettre correspondante dans l'alphabet.  exemple d'ex√©cution Entrez un nombre entre 1 et 26 : 5 La lettre correspondante est : E   info Le type char permet de stocker un caract√®re. Il est possible de faire des op√©rations sur les caract√®res comme si c'√©tait des entiers. Le code ASCII associe les caract√®res √† des entiers. Par exemple, le caract√®re 'A' est associ√© √† l'entier 65, 'B' √† 66, etc. En ce qui nous concerne, nous allons utiliser le fait que les lettres majuscules sont associ√©es aux entiers de 65 √† 90 et les lettres minuscules aux entiers de 97 √† 122. Vous pouvez trouver la table de correspondance ASCII compl√®te ici.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (probl√®me de compilation et d'ex√©cution)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-6-probl√®me-de-compilation-et-dex√©cution","content":" #include &lt;iotream&gt; int main() { float const pi {3.141592} int a {pi*3}; // je veux le r√©sultat de pi (environ 3.141592) fois 3 int const b {8}; a += &quot;20&quot;; // je veux ajouter le nombre 20 √† la valeur de a b = b * 15; // je veux modifier la valeur de b en la multipliant par 15 std::cout &lt;&lt; &quot;a: &quot; &lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl return 0; }   V√©rifier que le code ne compile pas et essayez de corriger les erreurs.  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercices-bonus","content":" Cuisine Un cuisinier doit aller au march√© pour r√©cup√©rer ses l√©gumes. Il a besoin de sacs de pommes de terre, de carottes et de salades. Vous avez les informations suivantes : Un sac de pommes de terre p√®se 2kg.Le prix d'un kg de pommes de terre est de 1.5‚Ç¨.Une carotte p√®se 150g.Le prix d'un kg de carottes est de 2.5‚Ç¨.Une salade co√ªte 1.2‚Ç¨. √âcrire un programme qui demande √† l'utilisateur de saisir le nombre de sacs de pommes de terre, de carottes et de salades qu'il souhaite acheter. Le programme doit ensuite calculer le prix total de la commande et l'afficher. exemple d'ex√©cution Entrez le nombre de sacs de pommes de terre : 2 Entrez le nombre de carottes : 3 Entrez le nombre de salades : 1 Le prix total de la commande est de 8.325 ‚Ç¨ Bonus En bonus, afficher le d√©tail de la commande. ... Le prix total de la commande est de 8.325 ‚Ç¨ d√©tails: - 2 sacs de pommes de terre : 6 ‚Ç¨ - 3 carottes : 1.125 ‚Ç¨ - 1 salade : 1.2 ‚Ç¨  ","version":"Next","tagName":"h2"},{"title":"TD8 - Encodage et compression","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Run-length encoding)‚Äã","type":1,"pageTitle":"TD8 - Encodage et compression","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression#exercice-1-run-length-encoding","content":" √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res compos√©e uniquement de caract√®res alphab√©tiques et qui retourne une cha√Æne de caract√®res encod√©e en utilisant le run-length encoding. Par exemple, si la cha√Æne de caract√®res en entr√©e est AAAABBBCCDAA, la cha√Æne de caract√®res encod√©e est 4A3B2C1D2A. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res encod√©e en utilisant le run-length encoding et qui retourne la cha√Æne de caract√®res d√©cod√©e. Am√©liorer la fonction pr√©c√©dente pour qu'elle puisse d√©coder une cha√Æne de caract√®res m√™me si cette cha√Æne de caract√®res contient des nombres √† plusieurs chiffres. Par exemple, si la cha√Æne de caract√®res en entr√©e est 12A3B2C1D2A, la cha√Æne de caract√®res d√©cod√©e est AAAAAAAAAAAABBBCCDAA. √âcrire une fonction qui permet d'encoder en utilisant un caract√®re sp√©cial (caract√®re de contr√¥le) suivit d'un nombre pour indiquer le nombre de fois qu'un caract√®re doit √™tre r√©p√©t√©. Par exemple, en se donnant le caract√®re de contr√¥le *, si la cha√Æne de caract√®res en entr√©e est AAAABBBCCDAA, la cha√Æne de caract√®res encod√©e est *4A*3B*2CD*2A. Am√©liorer la fonction pr√©c√©dente pour rendre le caract√®re de contr√¥le param√©trable et retourner la cha√Æne de caract√®res originale si la longueur de la cha√Æne de caract√®res encod√©e est plus grande que la cha√Æne de caract√®res originale. √âcrire une fonction qui permet de d√©coder une cha√Æne de caract√®res encod√©e en utilisant un caract√®re de contr√¥le.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Huffman encoding)‚Äã","type":1,"pageTitle":"TD8 - Encodage et compression","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression#exercice-2-huffman-encoding","content":" √âcrire une fonction frequency qui prend en param√®tre une cha√Æne de caract√®res et retourne un std::unordered_map&lt;char, size_t&gt; qui associe √† chaque caract√®re le nombre d'occurrences de ce caract√®re dans la cha√Æne de caract√®res.  Donnons nous la structure suivante pour la suite de l'exercice:  struct Node { char character; size_t frequency; Node* left { nullptr }; Node* right { nullptr }; };   attention Ce warning s'adresse √† ceux qui ont essay√© d'utiliser des smart pointers (std::unique_ptr) sur le TD pr√©c√©dent sur les arbres binaires et qui souhaitent continuer √† utiliser des smart pointers pour cet exercice. Ici, on ne veut pas utiliser de std::unique_ptr pour simplifier l'√©criture des fonctions. En effet, l'utilisation de std::unique_ptr impose de passer par des std::move (notion que l'on a pas encore vu) pour transf√©rer la propri√©t√© d'un pointeur intelligent. Cela rendrait l'√©criture des fonctions plus complexe et cela nous forcerait m√™me √† cr√©er notre propre file de priorit√© (priority_queue) pour pouvoir les utiliser dans une file de priorit√©. Ce n'est pas l'objet de cet exercice on se limitera donc √† des pointeurs classiques.  Surcharger l'op√©rateur &lt; pour la structure Node de telle sorte que l'op√©rateur &lt; retourne true si la fr√©quence du n≈ìud de gauche est inf√©rieure √† la fr√©quence du n≈ìud de droite. √âcrire une fonction createNode qui prend en param√®tre un caract√®re et une fr√©quence et qui retourne un Node*. √âcrire une fonction createSymbolNode qui prend en param√®tre (par valeur) deux Node* et qui retourne un Node* dont le caract√®re est '\\0' (caract√®re nul sp√©cial) et la fr√©quence est la somme des fr√©quences des deux n≈ìuds pass√©s en param√®tre et les deux n≈ìuds pass√©s en param√®tre sont les fils du n≈ìud retourn√©. Cette fonction va √™tre utilis√©e pour cr√©er un n≈ìud qui repr√©sente un &quot;symbole&quot; (un ensemble de caract√®res) et qui va √™tre utilis√© pour construire l'arbre de Huffman. √âcrire une fonction build_huffman_tree qui prend en param√®tre (r√©f√©rence constante) un std::unordered_map&lt;char, size_t&gt; et qui retourne un Node* qui repr√©sente l'arbre de Huffman. Cet arbre va √™tre construit en utilisant une std::priority_queue qui va permettre de trier les n≈ìuds (symboles) en fonction de leur fr√©quence. Pour construire l'arbre, on va retirer les deux n≈ìuds de plus petite fr√©quence de la file de priorit√©, cr√©er un nouveau n≈ìud dont la fr√©quence est la somme des fr√©quences des deux n≈ìuds retir√©s et dont les fils sont les deux n≈ìuds retir√©s, et ajouter ce nouveau n≈ìud √† la file de priorit√©. √âcrire une fonction build_encoding_table qui prend en param√®tre le sommet de l'arbre de Huffman et qui retourne un std::unordered_map&lt;char, std::string&gt; qui associe √† chaque caract√®re le code de Huffman correspondant.  Pour construire le code de Huffman, on va parcourir l'arbre de Huffman en ajoutant un '0' √† une cha√Æne de caract√®re √† chaque fois qu'on descend √† gauche et un '1' √† chaque fois qu'on descend √† droite. On va s'arr√™ter lorsqu'on arrive √† une feuille et on va associer la cha√Æne de caract√®re obtenue √† la feuille.  Il faudra utiliser une fonction interm√©diaire fill_encoding_table qui prend en param√®tre un n≈ìud, la cha√Æne de caract√®res associ√©e avec repr√©sentation binaire du n≈ìud et qui remplit ta table (std::unordered_map&lt;char, std::string&gt;) pass√©e par r√©f√©rence. C'est cette fonction qui va √™tre appel√©e r√©cursivement pour parcourir l'arbre de Huffman et remplir la table.  Voil√† les signatures des fonctions:  void fill_encoding_table(Node const* node, std::unordered_map&lt;char, std::string&gt;&amp; table, std::string const&amp; str); std::unordered_map&lt;char, std::string&gt; build_encoding_table(Node const* root);   √âcrire une fonction encode qui prend en param√®tre une cha√Æne de caract√®res et un std::unordered_map&lt;char, std::string&gt; et qui retourne une cha√Æne de caract√®res repr√©sentant la cha√Æne de caract√®res encod√©e en utilisant le code de Huffman.  std::string encode(std::string const&amp; str, std::unordered_map&lt;char, std::string&gt; const&amp; table);   √âcrire une fonction decode qui prend en param√®tre une cha√Æne de caract√®res encod√©e en utilisant le code de Huffman et le sommet de l'arbre de Huffman et qui retourne une cha√Æne de caract√®res repr√©sentant la cha√Æne de caract√®res d√©cod√©e.  std::string decode(std::string const&amp; str, Node const* huffman_tree_root);   √âcrire une fonction delete_huffman_tree qui prend en param√®tre le sommet de l'arbre de Huffman et qui lib√®re la m√©moire allou√©e pour l'arbre.  Culture - Aller plus loin:  Dans la r√©alit√©, on ne souhaite pas encoder le caract√®res a par une cha√Æne de caract√®re (par exemple 110). Sinon on se retrouverait avec une cha√Æne de caract√®res plus grande que la cha√Æne de caract√®res originale. On va plut√¥t utiliser des bits. Par exemple, on va encoder le caract√®re a par les bits 110 (soit le nombre 6 en d√©cimal).  Pour faire cela il faut manipuler des bits. En C++, on peut manipuler des bits en utilisant les op√©rateurs &lt;&lt; (d√©calage √† gauche), &gt;&gt; (d√©calage √† droite), | (ou binaire), &amp; (et binaire), ^ (ou exclusif binaire), ~ (non binaire).  Pour ensuite pouvoir √©crire en binaire dans un fichier on va utiliser des octets. Un octet est un ensemble de 8 bits. En C++, on peut manipuler des octets en utilisant le type unsigned char (ou uint8_t).  Ensuite, au lieu de retourner une cha√Æne de caract√®res, on va retourner un std::vector&lt;uint8_t&gt; qui contient les octets compos√©s des bits de chaque caract√®re mis bout √† bout. C'est un jeu d'operation binaire et de d√©calage qui permet de mettre bout √† bout les octets pour obtenir la repr√©sentation binaire de la cha√Æne de caract√®res encod√©e.  On obtient ensuite un std::vector&lt;uint8_t&gt; qui contient la repr√©sentation binaire de la cha√Æne de caract√®res encod√©e. On peut ensuite √©crire cet std::vector&lt;uint8_t&gt; dans un fichier.    Si l'on souhaite faire un programme qui compresse de bout en bout une cha√Æne de caract√®res dans un fichier, il faut pouvoir √©crire dans un fichier la repr√©sentation binaire de la cha√Æne de caract√®res encod√©e. Pour cela, on peut utiliser la classe std::ofstream qui permet d'√©crire dans un fichier. Il suffira d'√©crire octet par octet dans le fichier.  Afin, de pouvoir d√©coder ce fichier, il faut pouvoir lire les octets du fichier et les transformer en une repr√©sentation binaire. Cela se fait en utilisant la classe std::ifstream qui permet de lire dans un fichier. Il suffira de lire octet par octet et de transformer chaque octet en une repr√©sentation binaire.  Enfin, pour d√©coder totalement et retrouver la cha√Æne originale, il faut non seulement avoir la repr√©sentation binaire de la cha√Æne de caract√®res encod√©e, mais √©galement avoir l'arbre de Huffman pour pouvoir d√©coder la repr√©sentation binaire en caract√®res et ainsi retrouver la cha√Æne de caract√®res originale. Il faudra donc ajouter √† ce fichier la repr√©sentation de l'arbre de Huffman pour pouvoir d√©coder totalement la cha√Æne de caract√®res encod√©e.  Je ne vous demande pas de faire cela, mais c'est pour vous donner une id√©e de ce √† quoi cela peut servir en pratique et comment cela peut √™tre utilis√©. ","version":"Next","tagName":"h2"},{"title":"Arbres binaires de recherche","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/binaryTree","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Impl√©mentation)‚Äã","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-1-impl√©mentation","content":" Donnons nous pour commencer la structure suivante pour repr√©senter un n≈ìud d'un arbre binaire :  struct Node { int value; Node* left { nullptr }; Node* right { nullptr }; };   astuce Je vous conseil de cr√©er un fichier node.hpp et d'y mettre la structure Node ainsi que le prototype des fonctions et m√©thodes que vous allez √©crire. Avec une organisation de fichier comme celle-ci: src/ L main.cpp L node.hpp L node.cpp CMakeLists.txt   Affichage dans la console Je vous fourni une fonction qui permet d'afficher une repr√©sentation ASCII dans la console d'un arbre binaire: void pretty_print_left_right(Node const&amp; node, std::string const&amp; prefix, bool is_left) { if (node.right) { pretty_print_left_right(*node.right, prefix + (is_left ? &quot;| &quot; : &quot; &quot;), false); } std::cout &lt;&lt; prefix &lt;&lt; (is_left ? &quot;+-- &quot; : &quot;+-- &quot;) &lt;&lt; node.value &lt;&lt; std::endl; if (node.left) { pretty_print_left_right(*node.left, prefix + (is_left ? &quot; &quot; : &quot;| &quot;), true); } } void pretty_print_left_right(Node const&amp; node) { pretty_print_left_right(node, &quot;&quot;, true); }   √âcrire une fonction create_node qui prend en param√®tre une valeur et permet de cr√©er (sur la heap avec new) un n≈ìud contenant cette valeur et dont les fils sont pointeur nuls.  Node* create_node(int value);   √âcrire une m√©thode is_leaf sur la structure Node qui retourne vrai si le n≈ìud est une feuille (c'est √† dire si ses deux fils sont nuls).  bool is_leaf() const;   √âcrire une m√©thode insert √† la structure Node qui prend en param√®tre une valeur et qui ins√®re un nouveau n≈ìud contenant cette valeur dans l'arbre binaire. On ins√©rera le n≈ìud √† gauche si la valeur est inf√©rieure √† la valeur du n≈ìud courant et √† droite sinon.  void Node::insert(int value);   astuce On utilisera la fonction create_node pour cr√©er le nouveau n≈ìud.  √âcrire une m√©thode height qui retourne la hauteur de l'arbre binaire (c'est √† dire la longueur du plus long chemin entre la racine et une feuille) (On va se donner la convention qu'un arbre binaire contenant un seul n≈ìud a une hauteur de 1)  int Node::height() const;   astuce On peut utiliser de la r√©cursivit√© pour calculer la hauteur de l'arbre.  √âcrire une fonction delete_children sur la structure Node qui permet de supprimer les fils d'un n≈ìud (et de lib√©rer la m√©moire).  void Node::delete_children();   astuce On peut utiliser de la r√©cursivit√© pour supprimer les n≈ìuds de l'arbre.  √âcrire une m√©thode display_infix qui affiche les valeurs des n≈ìuds parcourus dans l'ordre infixe.  void Node::display_infix() const;   √âcrire une m√©thode prefix qui retourne un vecteur contenant des pointeurs vers les n≈ìuds de l'arbre binaire parcourus en prefixe.  std::vector&lt;Node const*&gt; Node::prefix() const;   astuce Pour le faire par r√©cursivit√© on pourra utiliser la m√©thode insert du std::vector qui permet d‚Äôins√©rer plusieurs √©l√©ments √† l'aide d‚Äôit√©rateurs. auto left_nodes {left-&gt;prefix()}; nodes.insert(nodes.end(), left_nodes.begin(), left_nodes.end()); Cela va permettre de concat√©ner dans un seul vecteur les n≈ìuds des sous arbres gauche et droit.  (BONUS) De m√™me, √©crire une autre m√©thode postfix qui retournent les n≈ìuds parcourus dans l'ordre postfixe.  BONUS: It√©ratif Si tu le souhaites, tu peux essayer de le faire de mani√®re it√©rative (sans r√©cursivit√©). Pour faire cela tu peux utiliser une pile (std::stack) pour stocker les n≈ìuds √† parcourir. L'id√©e est de parcourir l'arbre en commen√ßant par la racine (premier √©l√©ment de la pile). Puis, de d√©piler un n≈ìud de la pile, s'il a un fils droit, on le met dans la pile et on recommence. Sinon, s'il a un fils gauche, on le met dans la pile et on recommence. Enfin s'il n'a pas de fils, on le traite (on peut l'ajouter √† un vecteur par exemple). Il faut aussi faire attention √† conserver un pointeur vers le n≈ìud pr√©c√©dent afin de savoir si on remonte ou si on descend dans l'arbre. Exemple: Si on a l'arbre suivant: 5 / \\ 3 7 / \\ / \\ on va commencer par mettre le n≈ìud 5 dans la pile. (le n≈ìud pr√©c√©dent est nul) On va lire le n≈ìud 5 et se rendre compte qu'il a un fils gauche, on le met dans la pile et on recommence (le n≈ìud pr√©c√©dent est 5). On va lire le n≈ìud 3 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le n≈ìud pr√©c√©dent est 3). On va lire de nouveau le n≈ìud 5 mais comme on a d√©j√† trait√© le fils gauche (on le sait car le n≈ìud pr√©c√©dent est le n≈ìud 3), on va mettre le fils droit dans la pile et recommencer. (le n≈ìud pr√©c√©dent devient 5). On va lire le n≈ìud 7 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le n≈ìud pr√©c√©dent est 7). On va lire de nouveau le n≈ìud 5 mais comme on a d√©j√† trait√© le fils droit (on le sait car le n≈ìud pr√©c√©dent est le n≈ìud 7), on va enfin traiter le n≈ìud 5 et le retirer de la pile. Ce qui nous donne l'ordre postfixe: 3, 7, 5. C'est un peu plus compliqu√© que la version r√©cursive mais c'est un bon exercice pour comprendre le fonctionnement des arbres binaires et des m√©canismes de pile. Voil√† un bout de code pour vous aider √† d√©marrer: std::vector&lt;Node const*&gt; Node::postfix() const { std::vector&lt;Node const*&gt; nodes {}; std::stack&lt;Node const*&gt; to_process {}; Node const* previous {nullptr}; to_process.push(this); while (!to_process.empty()) { Node const* current { to_process.top() }; // Si on est en train de descendre dans l'arbre if (previous == nullptr || (previous-&gt;left == current || previous-&gt;right == current)) { if(/* ? */) { to_process.push(current-&gt;left); } else if(/* ? */) { // todo } else { // on traite le n≈ìud (ajouter au vecteur) et on le retire de la pile // todo } // Si l'on remonte dans l'arbre en venant de la gauche }else if (/* ? */) { if(/* ? */) { // todo } else { // todo } // Si l'on remonte dans l'arbre en venant de la droite } else if (/* ? */) { // todo } previous = current; } return nodes; }   √âcrire une fonction most_left qui retourne une r√©f√©rence vers le pointeur du n≈ìud le plus √† gauche de l'arbre binaire.   Node*&amp; most_left(Node*&amp; node);   ‚ö†Ô∏è Pourquoi retourner une r√©f√©rence vers un pointeur(*&amp;) ? Car on va ensuite utiliser cette fonction dans la fonction removeNode pour supprimer une valeur (donc un n≈ìud) de l'arbre binaire. Mais dans certains cas on va devoir modifier le pointeur du n≈ìud parent pour qu'il ne pointe plus vers le n≈ìud que l'on veut supprimer. la r√©f√©rence va permettre de modifier directement le pointeur du n≈ìud parent.  √âcrire une fonction remove qui permet de supprimer une valeur de l'arbre binaire dont le n≈ìud racine est pass√© en param√®tre. La fonction retourne vrai si la valeur a √©t√© supprim√©e et faux sinon.  bool remove(Node*&amp; node, int value);   Prendre en param√®tre une r√©f√©rence vers un pointeur permet de modifier directement le pointeur du n≈ìud parent si le n≈ìud est supprim√©. C'est important dans le cas par exemple o√π l'on supprime une feuille de l'arbre il faut pouvoir r√©assigner le pointeur du n≈ìud parent vers un pointeur nul pour √©viter d'avoir un pointeur qui pointe vers un n≈ìud supprim√©.  if (value == node-&gt;value &amp;&amp; node-&gt;is_leaf()) { // On supprime le n≈ìud courant delete node; // Comme on a une r√©f√©rence sur le pointeur du n≈ìud courant, on le met √† jour avec nullptr // Ainsi le parent du n≈ìud courant aura un pointeur vers nullptr node = nullptr; // on retourne true car la suppression a √©t√© effectu√©e return true; }   astuce Il existe trois cas de figure lorsqu'on supprime un n≈ìud d'un arbre binaire: Le n≈ìud n'a pas de fils: on peut le supprimer directement (exemple pr√©c√©dent).Le n≈ìud a un seul fils: on peut le supprimer et le remplacer par son fils.Le n≈ìud a deux fils: Il faut remplacer la valeur du n≈ìud √† supprimer par une valeur pour pr√©server l'ordre de l'arbre. Pour cela, on utilisera la fonction most_left qui permettent de trouver le n≈ìud le plus √† gauche d'un arbre binaire (autrement dit, le n≈ìud de valeur minimale). Il faut ensuite remplacer la valeur du n≈ìud √† supprimer par la valeur du n≈ìud trouv√© pr√©c√©demment et supprimer ce dit n≈ìud pour ne pas avoir de doublon. (cela revient √† intervertir les deux n≈ìuds sans avoir √† modifier les pointeurs puis √† supprimer le n≈ìud dont la valeur a √©t√© copi√©e). Ce troisi√®me cas est le plus compliqu√© √† g√©rer. N'h√©sitez pas √† demander de l'aide et prendre le temps de faire des sch√©mas pour comprendre le fonctionnement. Il faudra utiliser la fonction most_left pour trouver le n≈ìud le plus √† gauche de l'arbre binaire.  attention Il faut faire attention √† bien lib√©rer la m√©moire des n≈ìuds supprim√©s, avec delete.  √âcrire une fonction delete_tree qui permet de supprimer un arbre binaire (et de lib√©rer la m√©moire).  void delete_tree(Node* node);   (BONUS) √âcrire des m√©thodes min et max qui retournent respectivement les valeurs minimales et maximales de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utilisation)‚Äã","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-2-utilisation","content":" Testons maintenant notre impl√©mentation en cr√©ant un programme qui permet de cr√©er un arbre binaire et d'effectuer diff√©rentes op√©rations dessus.  Cr√©er un arbre binaire et ins√©rer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0. Afficher les valeurs des n≈ìuds de l'arbre binaire dans l'ordre infixe. (BONUS) Afficher la valeur minimale et maximale de l'arbre. Afficher la somme des valeurs des n≈ìuds de l'arbre binaire en utilisant la fonction prefix qui retourne un vecteur contenant les n≈ìuds parcourus dans l'ordre prefixe. Afficher la hauteur de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Aller plus loin‚Äã","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Pointeurs intelligents) (Bonus)‚Äã","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-3-pointeurs-intelligents-bonus","content":" Nous allons maintenant am√©liorer et simplifier notre code en utilisant des pointeurs intelligents. En effet la partie la plus compliqu√©e de notre code est la gestion de la m√©moire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous d√©barrasser de cette gestion et de nous passer de la fonction delete_tree par exemple.  Copier-coller votre fichier pour garder une version de votre code pr√©c√©dent et cr√©er un nouveau fichier smartNode.hpp dans lequel vous allez r√©√©crire votre code en utilisant des pointeurs intelligents. Renommer la structure Node en SmartNode pour pouvoir faire la diff√©rence entre les deux versions et remplacer les pointeurs &quot;bruts&quot; par des pointeurs intelligents std::unique_ptr dans la structure SmartNode.  Je vous donne le contenu du fichier smartNode.hpp:  #pragma once #include &lt;vector&gt; struct SmartNode { int value; std::unique_ptr&lt;SmartNode&gt; left { nullptr }; std::unique_ptr&lt;SmartNode&gt; right { nullptr }; bool is_leaf() const; void insert(int value); size_t height() const; int min() const; int max() const; }; std::unique_ptr&lt;SmartNode&gt; create_smart_node(int value); std::unique_ptr&lt;SmartNode&gt;&amp; SmartNode::most_left(std::unique_ptr&lt;SmartNode&gt;&amp; node); bool remove(std::unique_ptr&lt;SmartNode&gt;&amp; node, int value);   Modifier la fonction is_leaf pour utiliser le fait qu'un pointeur intelligent peut √™tre converti implicitement en bool√©en (il vaut false si le pointeur est nul et true sinon).  std::unique_ptr&lt;float&gt; ptr {nullptr}; if (ptr) { // ptr est diff√©rent de nullptr } else { // ptr est √©gal √† nullptr }   Renommer et modifier la fonction create_node (en create_smart_node) pour qu'elle retourne un pointeur intelligent std::unique_ptr au lieu d'un pointeur brut (on utilisera la fonction std::make_unique pour cr√©er le pointeur).  Elle s'utilise de la mani√®re suivante:  std::unique_ptr&lt;float&gt; ptr {std::make_unique&lt;float&gt;(3.14f)};   Modifier la m√©thode most_left pour qu'elle retourne une r√©f√©rence vers un pointeur intelligent au lieu d'un pointeur brut. Modifier la m√©thode insert pour qu'elle utilise des pointeurs intelligents. Modifier la m√©thode remove pour qu'elle utilise des pointeurs intelligents.  astuce C'est un peu plus compliqu√© car il faut utiliser des r√©f√©rences vers des pointeurs intelligents pour pouvoir les modifier. On peut utiliser les m√©thodes reset et release (allez lire la documentation pour voir la diff√©rence entre les deux !) pour g√©rer la m√©moire et les pointeurs intelligents. Ou utiliser un concept plus avanc√© std::move pour transf√©rer la propri√©t√© d'un pointeur intelligent d'un objet √† un autre. Si vous voulez essayer, n'h√©sitez pas √† demander de l'aide.  ","version":"Next","tagName":"h3"},{"title":"Exercice 4 (Encapsulation) (Bonus)‚Äã","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-4-encapsulation-bonus","content":" Le but est de cr√©er une structure BinaryTree qui encapsule la structure Node ou SmartNode et qui permet d'utiliser les m√™me m√©thodes sans conna√Ætre la structure interne de l'arbre binaire. Cela permet aussi de g√©rer le cas o√π l'arbre binaire est vide (c'est √† dire que la racine est un pointeur nul).  C'est moins pertinent dans notre cas pour ce TD mais lorsque vous d√©couvrirez la notion de visibilit√© (public / priv√©) vous comprendrez l'int√©r√™t de cette encapsulation.  Voil√† le contenu du fichier binaryTree.hpp:  #pragma once #include &lt;memory&gt; #include &quot;smartNode.hpp&quot; struct BinaryTree { std::unique_ptr&lt;SmartNode&gt; root { nullptr }; void insert(int value); bool remove(int value); void clear(); size_t height() const; };   Cr√©er un fichier binaryTree.cpp et impl√©menter les m√©thodes de la structure BinaryTree.  info C'est gr√¢ce √† cette encapsulation que l'on peut changer la structure interne de l'arbre binaire sans avoir √† modifier le code qui l'utilise. Nous pourrions par exemple changer la structure SmartNode par une structure Node sans avoir √† modifier le code qui utilise la structure BinaryTree. Ici avec l'utilisation des pointeurs intelligents, la m√©moire va √™tre g√©r√©e automatiquement √† la destruction de l'objet BinaryTree et il n'y a plus besoin de la fonction delete_tree. C'est un grand avantage des pointeurs intelligents et permet d'√©viter les erreurs de fuites m√©moires. ","version":"Next","tagName":"h3"},{"title":"TD2 - Structures de donn√©es","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Evaluation NPI)‚Äã","type":1,"pageTitle":"TD2 - Structures de donn√©es","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-1-evaluation-npi","content":" Le but de cet exercice est d'√©crire un programme qui permet d'√©valuer une expression math√©matique.  Nous allons nous int√©resser √† une notation particuli√®re, la notation polonaise invers√©e (NPI) (ou Reverse Polish Notation (RPN) en anglais).  C'est une notation diff√©rente de la notation &quot;classique&quot; que l'on utilise en math√©matiques (que l'on appelle la notation infixe).  En effet dans la notation infixe, les op√©rateurs sont plac√©s entre les op√©randes, et l'ordre des op√©rations est d√©termin√© par les parenth√®ses et les r√®gles de priorit√© des op√©rateurs.  Par exemple, l'expression 3 + 4 * 2 s'interpr√®te comme 3 + (4 * 2) = 11. Ou encore l'expression (3 + 4) * 2 s'interpr√®te comme (3 + 4) * 2 = 14.  Cela rend compliqu√© l'√©valuation d'une expression, car il faut g√©rer les parenth√®ses et les priorit√©s des op√©rateurs.    La notation polonaise invers√©e est une notation math√©matique qui permet d'exprimer des expressions arithm√©tiques sans utiliser de parenth√®ses ni de priorit√© d'op√©rateurs. Elle a √©t√© invent√©e par le math√©maticien polonais Jan Lukasiewicz en 1924.  On dit que cette notion est une notation postfixe car l'op√©rateur est plac√© apr√®s les deux op√©randes. Par exemple, l'expression 3 + 4 s'√©crit 3 4 + en NPI.  Ce qui permet ensuite d'interpr√©ter l'expression de gauche √† droite, en empilant les op√©randes sur une pile, et en d√©clenchant l'op√©ration lorsque l'on rencontre un op√©rateur.  Par exemple, l'expression 3 4 + s'interpr√®te comme suit :  On empile 3On empile 4On rencontre +, on d√©pile 4 et 3, on calcule 3 + 4 = 7, et on empile le r√©sultat 7On a termin√©, le r√©sultat est 7  On va donc pouvoir se servir d'une pile (std::stack) pour √©valuer une expression en NPI.  info Il faut cependant faire attention aux op√©rateurs non commutatifs, comme - ou /. 3 4 / ne s'interpr√®te pas comme 4 / 3, mais comme 3 / 4. Il faut donc √©crire 3 4 / pour √©valuer 3 / 4. Dans l'algorithmique de l'√©valuation, le premier √©l√©ment d√©pil√© de la pile sera l'op√©rande de droite et le deuxi√®me √©l√©ment d√©pil√© sera l'op√©rande de gauche.  Voil√† un exemple plus complexe avec l'expression 1 * 5 + 4 + (8 + 6) / (9 - 2) qui s'√©crit en NPI 1 5 * 4 + 8 6 + 9 2 - / + :    Le but de cet exercice est d'√©crire un programme qui permet d'√©valuer une expression en NPI sous forme d'une cha√Æne de caract√®res (les diff√©rents √©l√©ments de l'expression sont s√©par√©s par des espaces), et retourner le r√©sultat de l'expression.  remarque Par simplicit√©, on se limitera √† des expressions contenant des nombres (flottants), et les op√©rateurs +, -, * et / (Dans une expression en NPI il n'y a plus de parenth√®ses (( et )) car l'ordre des op√©rations est d√©termin√© par l'ordre des op√©rateurs dans l'expression).  Je vous donne plusieurs expressions et leur √©quivalent en NPI pour vous permettre de tester votre programme:  1 * 5 + 4 + (8 + 6) / (9 - 2) =&gt; 1 5 * 4 + 8 6 + 9 2 - / + = 113 + 4 =&gt; 3 4 + = 72 + 12 * 5 =&gt; 2 12 5 * + = 624 + 6 / ( 1 + 2 ) =&gt; 4 6 1 2 + / + = 6  √âcrire un programme qui permet de saisir une expression arithm√©tique en notation polonaise invers√©e (NPI) en tant que cha√Æne de caract√®re.  astuce Vous pouvez utiliser getline pour r√©cup√©rer d'un flux (comme std::cin) une cha√Æne de caract√®res comportant des espaces.  On veut ensuite que les √©l√©ments de cette expression soient s√©par√©s (par des espaces) pour pouvoir les traiter. Je vous donne le code suivant qui permet √† l'aide d'une particularit√© des streams de s√©parer les √©l√©ments (mots) de la cha√Æne de caract√®res en utilisant les espaces comme s√©parateurs :  #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iterator&gt; std::vector&lt;std::string&gt; split_string(std::string const&amp; s) { std::istringstream in(s); // transforme une cha√Æne en flux de caract√®res, cela simule un flux comme l'est std::cin // l‚Äôit√©rateur va lire chaque element de &quot;in&quot;, comme un flux d'entr√©e, chaque √©l√©ment est s√©par√© par un espace return std::vector&lt;std::string&gt;(std::istream_iterator&lt;std::string&gt;(in), std::istream_iterator&lt;std::string&gt;()); }   Utilisez ce code pour s√©parer les √©l√©ments de l'expression en NPI entr√©e par l'utilisateur et cr√©er un std::vector&lt;std::string&gt; qui repr√©senterons les √©l√©ments (tokens) de l'expression en NPI.  √âcrire une fonction qui prends un token (sous forme de cha√Æne de caract√®res) et permet de dire si celui-ci repr√©sente un nombre flottant ou non (NB : on ne fait pas la distinction avec les nombres entiers : &quot;3&quot; sera consid√©r√© comme un nombre flottant, tout comme &quot;3.14&quot;). On utilisera le prototype suivant :  bool is_floating(std::string const&amp; s);   astuce Pour y arriver il faut parcourir la cha√Æne de caract√®res et de tester si chaque caract√®re est un chiffre ou un point . (pour g√©rer les nombres flottants). Si c'est le cas, on continue, sinon on retourne false. Vous pouvez utiliser la fonction std::isdigit de la biblioth√®que &lt;cctype&gt; qui permet de tester si un caract√®re repr√©sente un chiffre.  Cela va √™tre utile pour distinguer si un token (sous forme d'une cha√Æne de caract√®re) est un nombre (op√©randes) ou un op√©rateur dans l'expression en NPI.  solution C++17 Il existe une fonction plus r√©cente qui permet de faire cela, la fonction std::from_chars de la biblioth√®que &lt;charconv&gt;. Elle permet de convertir une cha√Æne de caract√®res en nombre, et de retourner un pointeur sur le premier caract√®re non converti, ainsi qu'un code d'erreur si la conversion a √©chou√©. #include &lt;system_error&gt; #include &lt;charconv&gt; #include &lt;string&gt; bool is_floating(std::string const&amp; s) { float value; auto [p, ec] = std::from_chars(s.data(), s.data() + s.size(), value); return ec == std::errc() &amp;&amp; p == s.data() + s.size(); } Vous pouvez utiliser cette fonction si vous le souhaitez pour confirmer votre solution. Mais il est important de faire soi-m√™me l'impl√©mentation de la fonction is_floating pour apprendre √† manipuler les cha√Ænes de caract√®res.  √âcrire une fonction qui prend en param√®tre un vecteur de cha√Ænes de caract√®res repr√©sentant les tokens de l'expression en NPI, et qui retourne le r√©sultat de l'expression.  On utilisera le prototype suivant:  float npi_evaluate(std::vector&lt;std::string&gt; const&amp; tokens);   Utilisez une pile (std::stack) pour √©valuer l'expression comme dans l'exemple pr√©c√©dent.  Fonctionnement de l'algorithme L'algorithme va parcourir les √©l√©ments de l'expression en NPI (tokens) de gauche √† droite. Lorsque l'on rencontre un nombre, on l'empile sur la pile des valeurs.Lorsque l'on rencontre un op√©rateur, on d√©pile les deux derniers nombres, on effectue l'op√©ration, et on empile le r√©sultat. Voil√† un bout de code pour vous aider dans cette √©tape pour effectuer une op√©ration: // Je r√©cup√®re l'√©l√©ment en haut de la pile float rightOperand { stack.top() }; // Je l'enl√®ve de la stack (la m√©thode top ne fait que lire l‚Äô√©l√©ment en dessus de la pile) stack.pop(); float leftOperand { stack.top() }; stack.pop(); // Il faut ensuite en fonction de l'op√©rateur calculer le r√©sultat pour le remettre dans la pile float result { /* TODO */}; stack.push(result); l'algorithme se termine lorsque l'on a parcouru tous les √©l√©ments de l'expression, et que la pile ne contient plus qu'un seul √©l√©ment, qui est le r√©sultat de l'expression.  Expression invalide Si il reste plus d'un √©l√©ment dans la pile √† la fin de l'algorithme, cela signifie que l'expression en NPI est invalide. En effet, si l'expression est correcte, il ne doit rester qu'un seul √©l√©ment dans la pile. Chaque op√©rateur binaire s'applique √† deux nombres ainsi il doit normalement y avoir pour nnn nombres dans l'expression n‚àí1n-1n‚àí1 op√©rateurs.  astuce En utilisant la fonction is_floating de la question pr√©c√©dente, on peut d√©terminer si un √©l√©ment de l'expression est un nombre ou un op√©rateur. Il faut ensuite utiliser la fonction std::stof de la biblioth√®que &lt;string&gt; pour convertir la cha√Æne de caract√®res en nombre flottant si c'est le cas.  Enfin, utiliser les fonctions pr√©c√©dentes pour afficher le r√©sultat d'une expression en NPI entr√©e par l'utilisateur.  Vous pouvez tester avec les expressions suivantes:  3 + 4 =&gt; 3 4 + = 72 + 12 + 5 =&gt; 2 12 + 5 + = 193 + 4 / ( 11 + 5 ) =&gt; 3 4 11 5 + / + = 3.254 + 5 * 2 =&gt; 4 5 2 * + = 14  (une plus complexe avec l'op√©rateur puissance en plus pour l'exemple si vous voulez ajouter cette fonctionnalit√© plus tard)  3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 =&gt; 3 4 2 ^ 1 5 - 6 ^ / + = 3.00391  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utiliser une structure et des √©num√©rations)‚Äã","type":1,"pageTitle":"TD2 - Structures de donn√©es","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-2-utiliser-une-structure-et-des-√©num√©rations","content":" Le but est de r√©√©crire le programme pr√©c√©dent en utilisant un enum pour repr√©senter les diff√©rents op√©rateurs ainsi qu'une structure pour repr√©senter un token (un √©l√©ment de l'expression) avec un champ pour le type (op√©rateur ou op√©rande) et des champs pour les valeurs (op√©rateur ou op√©rande).  enum class Operator { ADD, SUB, MUL, DIV}; enum class TokenType { OPERATOR, OPERAND }; struct Token { TokenType type; float value; Operator op; };   info Il existe des fonctionnalit√©s plus avanc√©s qui permettraient de faire √ßa plus proprement, et de se passer de l'enum TokenType dans la structure Token (les std::variant). Vous pouvez vous renseigner ou me demander si vous voulez en savoir plus.  Cr√©er deux fonctions (surcharg√©es) qui permettent de construire la structure Token √† partir d'un nombre flottant ou de la valeur de l‚Äô√©num√©ration Operator.  Token make_token(float value) Token make_token(Operator op);   Cr√©er une fonction tokenize qui prends en param√®tre un vecteur de cha√Æne de caract√®res (repr√©sentant les &quot;mots&quot; d'une phrase, nos anciens tokens) et retourne un vecteur de Token.  std::vector&lt;Token&gt; tokenize(std::vector&lt;std::string&gt; const&amp; words);   Cr√©er une nouvelle fonction npi_evaluate qui utilise cette fois un vecteur de Token au lieu de manipuler directement des cha√Ænes de caract√®res.  float npi_evaluate(std::vector&lt;Token&gt; const&amp; tokens);   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Conversion en NPI) (Optionnel)‚Äã","type":1,"pageTitle":"TD2 - Structures de donn√©es","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-3-conversion-en-npi-optionnel","content":" Nous avons pr√©c√©demment vu comment √©valuer une expression en NPI. Mais comment faire pour convertir une expression en notation infixe (c'est-√†-dire de mani√®re &quot;classique&quot; avec des parenth√®ses) en une expression en NPI ?  Pour cela, il existe un algorithme appel√© Shunting-yard algorithm (litt√©ralement &quot;algorithme de la cour de triage&quot;).  Son principe est d'utiliser √©galement une pile pour stocker les op√©rateurs rencontr√©s, et de les d√©piler lorsque l'on rencontre un op√©rateur de priorit√© sup√©rieure.  info On va devoir tenir compte des parenth√®ses pour d√©terminer l'ordre des op√©rations. On peut donc les ajouter √† notre enum Operator pour les traiter comme des op√©rateurs. enum class Operator { ADD, SUB, MUL, DIV, OPEN_PAREN, CLOSE_PAREN};   Voil√† comment il fonctionne :  On parcourt l'expression de gauche √† droite Si on rencontre un nombre, on l'ajoute √† la sortie Si on rencontre un op√©rateur: Si on rencontre une parenth√®se ouvrante ((), on la met sur la pile des op√©rateursSi on rencontre une parenth√®se fermante ()), on d√©pile les op√©rateurs jusqu'√† ce qu'on rencontre une parenth√®se ouvrante, et on ajoute les op√©rateurs d√©pil√©s √† la sortieTant qu'il y a un op√©rateur sur la pile des op√©rateurs de priorit√© sup√©rieure ou √©gale √† l'op√©rateur courant, on d√©pile les op√©rateurs et on les ajoute √† la sortie. Puis on ajoute l'op√©rateur courant √† la pile des op√©rateurs. Enfin, on d√©pile les op√©rateurs restants et on les ajoute √† la sortie.  Voici un exemple d'application de l'algorithme avec l'expression 3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 :  Entr√©e\tSortie\tPile des op√©rateurs\tcommentaire3\t3 on ajoute 3 √† la sortie +\t3\t+\ton ajoute + √† la pile des op√©rateurs 4\t3 4\t+\ton ajoute 4 √† la sortie ^\t3 4\t+ ^\ton ajoute ^ √† la pile des op√©rateurs 2\t3 4 2\t+ ^\ton ajoute 2 √† la sortie /\t3 4 2 ^\t+\ton d√©pile ^ et on l'ajoute √† la sortie car / a une priorit√© inf√©rieure √† ^ (\t3 4 2 ^\t+ / (\ton ajoute ( √† la pile des op√©rateurs 1\t3 4 2 ^ 1\t+ / (\ton ajoute 1 √† la sortie -\t3 4 2 ^ 1\t+ / ( -\ton ajoute - √† la pile des op√©rateurs 5\t3 4 2 ^ 1 5\t+ / ( -\ton ajoute 5 √† la sortie )\t3 4 2 ^ 1 5 -\t+ /\ton d√©pile les op√©rateurs jusqu'√† ( et on les ajoute √† la sortie ^\t3 4 2 ^ 1 5 -\t+ / ^\ton ajoute ^ √† la pile des op√©rateurs 6\t3 4 2 ^ 1 5 - 6\t+ / ^\ton ajoute 6 √† la sortie 3 4 2 ^ 1 5 - 6 ^\t+ /\ton d√©pile le reste des op√©rateurs et on les ajoute √† la sortie  R√©sultat final : 3 4 2 ^ 1 5 - 6 ^ / +  info La suite de l'exercice est pr√©sent√© en utilisant les fonctions et structures de l'exercice pr√©c√©dent. Si vous n'avez pas fait l'exercice 2 vous pouvez tout aussi bien travailler avec un vecteur de cha√Ænes de caract√®res sans utiliser la structure Token.  √âcrire une fonction operator_precedence qui prends en param√®tre un Operator et retour sous forme d'un nombre entier positif la priorit√© de cet op√©rateur.  int operator_precedence(Operator const op);   √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res repr√©sentant une expression en notation infixe, qui retourne un tableau de Token repr√©sentant l'expression en NPI.  std::vector&lt;Token&gt; infix_to_npi_tokens(std::string const&amp; expression);   astuce On utilisera la m√™me structure Token que dans l'exercice pr√©c√©dent et les fonctions tokenize et split_string pour r√©cup√©rer dans un premier temps une repr√©sentation de l'expression en notation infixe sous forme d'une liste de Token (dont les parenth√®ses ici). C'est ici que parenth√®ses en tant qu'op√©rateur vont √™tre utile mais elles ne devrons pas se retrouver dans la liste de Token en NPI.  Maintenant que nous savons √©valuer une expression en NPI et que nous savons convertir une expression en notation infixe en NPI, nous pouvons r√©aliser une calculatrice.  Essayez de r√©aliser un programme qui permet de lire une expression en notation infixe, de la convertir en NPI, de l'√©valuer et d'afficher le r√©sultat. ","version":"Next","tagName":"h2"},{"title":"TD7 - Graphes","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/graphs","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (construire un graphe)‚Äã","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#exercice-1-construire-un-graphe","content":" Impl√©menter la m√©thode add_vertex qui prend en param√®tre un identifiant de sommet et ajoute un sommet au graphe si il n'existe pas d√©j√†. Il faut donc tester si le sommet existe d√©j√† avant de cr√©er la liste des edges. (vous pouvez utiliser la m√©thode find de std::unordered_map pour cela). Impl√©menter la m√©thode add_directed_edge qui ajoute une arr√™te dans le graphe en prenant en param√®tre les IDs des deux n≈ìuds √† connecter (source vers destination) et le poids de l'arr√™te.  remarque Si le n≈ìuds de destination n'existe pas (comme cl√© du tableau associatif adjacency_list) il est possible et recommand√© de l'ajouter au passage (en utilisant add_vertex). Ainsi, tout les sommets du graphe sont ajout√©s automatiquement lors de l'ajout d'une arr√™te.  Impl√©menter la m√©thode add_undirected_edge en utilisant add_directed_edge pour ajouter deux edges dans les deux sens pour connecter deux n≈ìuds pass√©s en param√®tre. Impl√©menter la fonction build_from_adjacency_matrix qui prend en param√®tre une matrice d'adjacence (sous la forme d'un vecteur de vecteurs d'entiers) et qui retourne un graphe.  Exemple Exemple pour le graphe suivant: Repr√©sent√© par la matrice d'adjacence suivante: [0100200240000100000600000]\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 2 \\\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 6 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{bmatrix}‚Äã00000‚Äã10000‚Äã02000‚Äã04100‚Äã20060‚Äã‚Äã la liste d'adjacence correspondante est la suivante: std::unordered_map&lt;int, std::vector&lt;WeightedGraphEdge&gt;&gt; adjacency_list { {0, {{1, 1.0f}, {4, 2.0f}}}, {1, {{2, 2.0f}, {3, 4.0f}}}, {2, {{3, 1.0f}}}, {3, {{4, 6.0f}}}, {4, {}}, };   √âcrire dans la fonction main un exemple d'utilisation de la fonction build_from_adjacency_matrix pour cr√©er un graphe √† partir d'une matrice d'adjacence et cr√©er un deuxi√®me graphe en utilisant les m√©thodes add_vertex et add_undirected_edge pour ajouter les m√™mes sommets et les m√™mes arr√™tes que dans le premier graphe. Ensuite, comparer les deux graphes pour v√©rifier qu'ils sont √©gaux.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (traverser un graphe)‚Äã","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#exercice-2-traverser-un-graphe","content":" Impl√©menter la m√©thode print_DFS qui prend en param√®tre l'id du sommet de d√©part et qui affiche les sommets du graphe en utilisant un parcours en profondeur (DFS) √† partir du sommet de d√©part (depth-first search). Impl√©menter la m√©thode print_BFS qui utilise cette fois-ci un parcours en largeur (BFS) √† partir du sommet de d√©part (breadth-first search). (Bonus) Impl√©menter le parcours en profondeur (BFS) √† prenant en param√®tre une fonction de callback pour chaque sommet visit√©. L'id√©e est de ne pas contraindre l'utilisateur √† afficher les sommets mais de lui donner la possibilit√© de faire ce qu'il veut avec les sommets visit√©s. Voil√† la signature de la m√©thode √† impl√©menter:  void DFS(int const start, std::function&lt;void(int const)&gt; const&amp; callback) const;   std::function (#include &lt;functional&gt;) est un objet qui peut &quot;stocker&quot; n'importe quelle fonction qui a la m√™me signature que celle donn√©e en param√®tre (entre &lt; et &gt; ). Cela permet de passer une fonction en param√®tre d'une autre fonction. C'est tr√®s utile pour faire des fonctions g√©n√©riques qui peuvent √™tre utilis√©es de diff√©rentes mani√®res. On peut passer en param√®tre une fonction d√©finie dans le code ou une fonction lambda (une fonction anonyme). C'est comme cela que fonctionnent les fonctions std::sort, std::find_if, std::accumulate, ... de la STL.  Voil√† √† quoi ressemble l'appel de cette m√©thode avec une fonction lambda qui affiche les sommets visit√©s (pour reproduire le comportement de la m√©thode print_DFS):  std::cout &lt;&lt; &quot;DFS from node 0:&quot; &lt;&lt; std::endl &lt;&lt; &quot;Visited nodes: &quot;; graph.DFS(0, [](int const node_id) { std::cout &lt;&lt; node_id &lt;&lt; &quot; &quot;; }); std::cout &lt;&lt; std::endl;   ","version":"Next","tagName":"h2"},{"title":"Dijkstra: algorithme de plus court chemin‚Äã","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#dijkstra-algorithme-de-plus-court-chemin","content":" L'algorithme de Dijkstra permet de trouver le plus court chemin entre un sommet de d√©part et un sommet d'arriv√©e dans un graphe pond√©r√©.  Je vous invite √† relire l'explication du cours ici.  Donnons nous le graphe suivant:    √âcrivez les diff√©rentes √©tapes de l'algorithme de Dijkstra selon le m√™me mod√®le que l'illustration du cours pour trouver le plus court chemin entre le sommet A et le sommet E.  (BONUS) En se donnant un bout de code pour d√©marrer l'impl√©mentation de l'algorithme de Dijkstra, compl√©tez le code pour impl√©menter l'algorithme de Dijkstra.(BONUS) Testez votre impl√©mentation avec le graphe donn√© en exemple pour trouver le plus court chemin entre le sommet A et le sommet E.  std::unordered_map&lt;int, std::pair&lt;float, int&gt;&gt; dijkstra(WeightedGraph const&amp; graph, int const&amp; start, int const end) { // On cr√©e un tableau associatif pour stocker les distances les plus courtes connues pour aller du sommet de d√©part √† chaque sommet visit√© // La cl√© est l'identifiant du sommet et la valeur est une paire (distance, sommet pr√©c√©dent) std::unordered_map&lt;int, std::pair&lt;float, int&gt;&gt; distances {}; // On cr√©e une file de priorit√© pour stocker les sommets √† visiter // la paire contient la distance pour aller jusqu'au sommet et l'identifiant du sommet // Ce type compliqu√© permet d'indiquer que l'on souhaite trier les √©l√©ments par ordre croissant (std::greater) et donc les √©l√©ments les plus petits seront au d√©but de la file (top) (C'est ce qu'on appelle un &quot;Min heap&quot;) std::priority_queue&lt;std::pair&lt;float, int&gt;, std::vector&lt;std::pair&lt;float, int&gt;&gt;, std::greater&lt;std::pair&lt;float, int&gt;&gt;&gt; to_visit {}; // 1. On ajoute le sommet de d√©part √† la liste des sommets √† visiter avec une distance de 0 (on est d√©j√† sur le sommet de d√©part) // Tant qu'il reste des sommets √† visiter while (!to_visit.empty()) { // 2. On r√©cup√®re le sommet le plus proche du sommet de d√©part dans la liste de priorit√© to_visit // 3.Si on atteins le point d'arriv√©, on s'arr√™te if (/* TODO */) { return distances; } // 3. On parcoure la liste des voisins du n≈ìud courant (gr√¢ce √† la liste d'adjacence) for (/* TODO */) { // 4. on regarde si le n≈ìud existe dans le tableau associatif (si oui il a d√©j√† √©t√© visit√©) auto find_node { /* TODO */ }; bool const visited { /* TODO */ }; if (!visited) { // 5. Si le n≈ìud n'a pas √©t√© visit√©, on l'ajoute au tableau associatif en calculant la distance pour aller jusqu'√† ce n≈ìud (la distance actuelle + le point de l'arr√™te) // 6. On ajoute √©galement le n≈ìud de destination √† la liste des n≈ìuds √† visiter (avec la distance √©galement pour prioriser les n≈ìuds les plus proches) }else { // 7. Si il a d√©j√† √©t√© visit√©, on teste si la distance dans le tableau associatif est plus grande // Si c'est le cas on a trouv√© un chemin plus court, on met √† jour le tableau associatif et on ajoute de nouveau le sommet de destination dans la liste √† visiter if (/* TODO */) { } } } } return distances; }  ","version":"Next","tagName":"h2"},{"title":"TD1 - Op√©rateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/operators","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (op√©rations)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-1-op√©rations","content":" Transformer les m√©thodes add, sub, mul et div en surcharge des op√©rateurs +, -, * et / pour pouvoir utiliser les op√©rateurs avec des fractions.  On peut appliquer une simplification sur les fractions retourn√©es par les op√©rateurs pour √©viter d'avoir des fractions non simplifi√©es.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (affichage)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-2-affichage","content":" Transformer la fonction display en surcharge de l'op√©rateur &lt;&lt; pour pouvoir afficher une fraction avec std::cout (op√©rateurs de flux).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (√©galit√©)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-3-√©galit√©","content":" Ajouter l'op√©rateur == pour comparer deux fractions.Ajouter l'op√©rateur != en se basant sur l'op√©rateur ==.  astuce Attention, cela ne fonctionnera pas si on compare deux fractions non simplifi√©es. (ex: 1/2 == 2/4) Une autre solution serait de simplifier les fractions dans l'op√©rateur avant de les comparer. Il existe une autre fa√ßon de faire en comparant les produits en croix des fractions: (ex: a/b == d/c &lt;=&gt; a * c == b * d)  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (comparaison)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-4-comparaison","content":" Ajouter l'op√©rateur &lt; pour comparer deux fractions.Ajouter les op√©rateurs &lt;=, &gt; et &gt;= en se basant sur l'op√©rateur &lt;.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (op√©rations d'affectation)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-5-op√©rations-daffectation","content":" Ajouter les op√©rateurs d'affectation +=, -=, *= et /=.R√©√©crire les op√©rateurs +, -, * et / en utilisant les op√©rateurs affectation afin d'√©viter de dupliquer le code (deux-en-un) (Commenter l'ancienne version des op√©rateurs par exemple)  astuce Il est possible d'utiliser la fonction simplify sur l'objet courant dans une m√©thode en utilisant this qui est le pointeur vers &quot;moi-m√™me&quot;: Exemple: void Fraction::operator+=(Fraction const&amp; f) { numerator = numerator * f.denominator + f.numerator * denominator; denominator = denominator * f.denominator; *this = simplify(*this); // Ou alors la version simplify_ref qui prend une r√©f√©rence d'une fraction √† modifier // simplify_ref(*this); } Ici *this est donc une r√©f√©rence vers &quot;moi-m√™me&quot; que je peux donc passer en param√®tre √† la fonction simplify. Enfin, je me sers du r√©sultat pour l'assigner √† moi-m√™me avec l'op√©rateur d'affectation &quot;=&quot; (toujours avec &quot;*this&quot;).  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (conversion)‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-6-conversion","content":" D√©finir et impl√©menter une m√©thode to_float qui retourne la valeur de la fraction sous forme de float.  Il est aussi possible de d√©finir des op√©rateurs de conversion pour convertir une fraction en un autre type.  La syntaxe est la suivante :  operator type() const { // code de conversion }   Ajouter l'op√©rateur de conversion float pour pouvoir convertir une fraction en float en utilisant la m√©thode to_float.  Le prototype de la m√©thode pour notre structure Fraction sera le suivant:  Fraction::operator float() const;   Gr√¢ce √† cet op√©rateur, on pourra convertir une fraction en float de la mani√®re suivante:  Fraction f1 {1, 2}; float d1 {static_cast&lt;float&gt;(f1)}; // conversion explicite avec static_cast   remarque On pourrait tr√®s bien mettre directement le code de la conversion dans l'op√©rateur float sans passer par une m√©thode to_float. Mais je vous demande de le faire pour l'exercice et pour avoir la possibilit√© de r√©utiliser la m√©thode to_float ailleurs.  ","version":"Next","tagName":"h2"},{"title":"Aller plus loin‚Äã","type":1,"pageTitle":"TD1 - Op√©rateurs","url":"/Learn--cpp_programming/TDs/S2/operators#aller-plus-loin","content":" Ajouter des fonction libres pour les op√©rateurs +, -, * et / afin de pouvoir faire des op√©rations avec des fractions et des entiers. exemple: Fraction f1 {1, 2}; int i {2}; Fraction f2 {f1 + i}; Fraction operator+(Fraction const&amp; f, int const i); Fraction operator+(int const i, Fraction const&amp; f); astuce Pour que ce soit commutatif, il faut aussi d√©finir la fonction avec l'entier en premier param√®tre. R√©utiliser la fonction pr√©c√©dente pour √©viter de dupliquer le code. Ajouter des m√©thodes pour appliquer des op√©rations math√©matiques sur les fractions. abs: valeur absolueceil: arrondi sup√©rieurfloor: arrondi inf√©rieurround: arrondi ","version":"Next","tagName":"h2"},{"title":"Planning","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Planning","content":"","keywords":"","version":"Next"},{"title":"Lundi‚Äã","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#lundi","content":"  Cours : Introduction Prise en main de la lib Exercices de niveau 1 (‚≠ê) et/ou 2 (‚≠ê‚≠ê)  ","version":"Next","tagName":"h2"},{"title":"Mardi‚Äã","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#mardi","content":"  Cours : Pr√©sentation de git Test et prise en main de git (l'un push quelque chose et l'autre le pull par exemple) Mettre sur le repository les exercices que vous avez fait hier Autonomie, avancer dans les exercices  ","version":"Next","tagName":"h2"},{"title":"Mercredi‚Äã","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#mercredi","content":"  Cours : Si besoin, point de rappel sur une notion mal acquise (N'h√©sitez pas √† me demander si vous voulez que je r√©explique quelque chose en particulier, que ce soit en C++ ou sur le sujet du workshop) Autonomie, avancer dans les exercices  ","version":"Next","tagName":"h2"},{"title":"Jeudi‚Äã","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#jeudi","content":"  Cours : Si besoin, point de rappel sur une notion mal acquise (N'h√©sitez pas √† me demander si vous voulez que je r√©explique quelque chose en particulier, que ce soit en C++ ou sur le sujet du workshop) Autonomie, avancer dans les exercices  ","version":"Next","tagName":"h2"},{"title":"Vendredi‚Äã","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#vendredi","content":"  Cours : Pr√©sentation de Markdown pour l'√©criture du rapport √âcriture du rapport (Vous avez jusqu'√† samedi 23h59 pour le rendre) Pr√©paration de la pr√©sentation pour celleux concern√©.es Pr√©sentations l'apr√®s-midi ","version":"Next","tagName":"h2"},{"title":"TD3 - Algorithmes de tri","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/sorting","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (tri it√©ratif)‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-1-tri-it√©ratif","content":" Dans cet exercice, vous devez √©crire une fonction qui prend en param√®tre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Vous avez le choix entre deux algorithmes de tri:  tri √† bulletri par s√©lection  Voil√† les prototypes des fonctions:  void bubble_sort(std::vector&lt;int&gt; &amp; vec); void selection_sort(std::vector&lt;int&gt; &amp; vec);   ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (tri r√©cursif)‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-2-tri-r√©cursif","content":" De nouveau, vous devez √©crire une fonction qui prend en param√®tre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Cette fois-ci, vous devez utiliser un algorithme de tri r√©cursif.  Vous avez le choix entre deux algorithmes de tri:  tri fusiontri rapide  Voil√† les prototypes des fonctions √† utiliser et impl√©menter:  size_t quick_sort_partition(std::vector&lt;int&gt; &amp; vec, size_t left, size_t right); void quick_sort(std::vector&lt;int&gt; &amp; vec, size_t const left, size_t const right); void quick_sort(std::vector&lt;int&gt; &amp; vec) { quick_sort(vec, 0, vec.size() - 1); } void merge_sort_merge(std::vector&lt;int&gt; &amp; vec, size_t const left, size_t const middle, size_t const right); void merge_sort(std::vector&lt;int&gt; &amp; vec, size_t const left, size_t const right); void merge_sort(std::vector&lt;int&gt; &amp; vec) { merge_sort(vec, 0, vec.size() - 1); }   Dans ces deux algorithmes, on va trier des plages du tableau par r√©cursivit√©. C'est pour cela que les fonctions prennent en param√®tre les indices de d√©but et de fin de la plage √† trier (left et right). De plus, dans les deux algorithmes, on va utiliser une fonction auxiliaire pour s√©parer le tableau en deux parties (quick_sort_partition) ou pour fusionner deux tableaux tri√©s (merge_sort_merge).  astuce Pour l'√©tape de merge du merge sort (merge_sort_merge), il faudra copier les valeurs dans des vecteurs temporaires pour stocker les deux parties du tableau √† fusionner. Il existe plusieurs fa√ßons de copier les valeurs d'un vecteur dans un autre. La plus simple est de donner √† la construction du vecteur les it√©rateurs de d√©but et de fin du vecteur √† copier. Cela fonctionne de la mani√®re suivante: std::vector&lt;int&gt; vec1 {1, 2, 3, 4, 5}; // copie de vec1 dans vec2 std::vector&lt;int&gt; vec2(vec1.begin(), vec1.end()); // copie des √©l√©ments de vec1 dans vec3 √† partir de l'√©l√©ment d'indice 2 std::vector&lt;int&gt; vec3(vec1.begin() + 2, vec1.end()); // copie des √©l√©ments de vec1 dans vec4 √† partir de l'√©l√©ment d'indice 1 jusqu'√† l'√©l√©ment d'indice 3 std::vector&lt;int&gt; vec4(vec1.begin() + 1, vec1.begin() + 4); // il est √©galement possible de copier un vecteur dans un autre √† l'aide de la fonction std::copy std::vector&lt;int&gt; vec5(vec1.size()); std::copy(vec1.begin(), vec1.end(), vec5.begin()); // il faut que le vecteur de destination ait la bonne taille pour pouvoir copier les valeurs // ou √† l'aide de la m√©thode assign std::vector&lt;int&gt; vec6; vec6.assign(vec1.begin(), vec1.end());   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Comparaison des algorithmes de tri)‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-3-comparaison-des-algorithmes-de-tri","content":" Une fois nos algorithmes de tri impl√©ment√©s, nous allons les comparer en terme de complexit√© temporelle.  Je vous fournis une fonction qui permet de g√©n√©rer un tableau d'entiers al√©atoires.  #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; std::vector&lt;int&gt; generate_random_vector(size_t const size, int const max = 100) { std::vector&lt;int&gt; vec(size); std::generate(vec.begin(), vec.end(), [&amp;max]() { return std::rand() % max;} ); return vec; }   Je vous fournis √©galement une structure chronom√®tre, il suffit de t√©l√©charger le fichier ScopedTimer.hpp et le copier dans le dossier de votre projet et de l'inclure dans votre fichier source:  #include &quot;ScopedTimer.hpp&quot;   Elle fonctionne de la mani√®re suivante:  { ScopedTimer timer(&quot;nom du chronom√®tre&quot;); // code √† chronom√©trer }   Elle affichera le temps √©coul√© entre sa cr√©ation et sa destruction (c'est-√†-dire √† la fin du bloc de code, c'est pourquoi il est d√©clar√© dans un bloc entre accolades (Scope) dans l'exemple ci-dessus).  ","version":"Next","tagName":"h2"},{"title":"Biblioth√®que standard‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#biblioth√®que-standard","content":" La biblioth√®que standard de C++ fournit une fonction de tri std::sort qui permet de trier des conteneurs (incluse dans la biblioth√®que &lt;algorithm&gt;)  Vous pouvez l'utiliser de la mani√®re suivante:  std::vector&lt;int&gt; array {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::sort(array.begin(), array.end());   remarque begin et end sont des m√©thodes de std::vector qui permettent de r√©cup√©rer des it√©rateurs sur le d√©but et la fin du conteneur. Nous verrons les it√©rateurs plus tard dans le cours.  Avec cette fonction, vous pouvez comparer les temps d'ex√©cution de vos algorithmes de tri avec celui de la biblioth√®que standard.  Que constatez-vous ?Que pouvez-vous en dire ?  ","version":"Next","tagName":"h3"},{"title":"Exercice 4 (dichotomie)‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-4-dichotomie","content":" √âcrire une fonction search qui prend en param√®tre un tableau d'entiers (std::vector) tri√© par ordre croissant et une valeur enti√®re et retourne l'indice de la valeur dans le tableau. Si la valeur n'est pas pr√©sente dans le tableau, la fonction retournera -1 (on pourrait utiliser quelques chose de plus propre comme std::optional que l'on d√©couvrira dans le prochain cours pour √©viter de retourner -1 pour indiquer que l'on ne trouve pas la valeur).  La fonction devra utiliser l'algorithme de recherche dichotomique.  astuce On utilisera deux indices pour d√©finir la partie du tableau √† traiter: left : indice du premier √©l√©ment de la partie du tableau √† traiterright : indice du dernier √©l√©ment de la partie du tableau √† traiter Exemple simple avec le tableau suivant [1, 2, 2, 3, 4, 8, 12] (nombre d'√©l√©ments: 7) et la valeur recherch√©e 8: left = 0 et right = 6 (indice du premier et dernier √©l√©ment du tableau)middle = (left + right) / 2 = (0 + 6) / 2 = 3 (indice de l'√©l√©ment au milieu du tableau) la valeur au milieu du tableau est 3 qui est inf√©rieure √† la valeur recherch√©e 8, on ne garde que la partie droite du tableau.left devient middle + 1 = 3 + 1 = 4 (indice du premier √©l√©ment de la partie droite du tableau)left = 4 et right = 6middle = (left + right) / 2 = (4 + 6) / 2 = 5la valeur au milieu du tableau est 8 qui est √©gale √† la valeur recherch√©e, on retourne l'indice 5 de la valeur dans le tableau.  Tester la fonction search avec les tableaux suivants et afficher le r√©sultat de la recherche: [1, 2, 2, 3, 4, 8, 12] (valeur recherch√©e: 8)[1, 2, 3, 3, 6, 14, 12, 15] (valeur recherch√©e: 15)[2, 2, 3, 4, 5, 8, 12, 15, 16] (valeur recherch√©e: 16)[5, 6, 7, 8, 9, 10, 11, 12, 13] (valeur recherch√©e: 6)[1, 2, 3, 4, 5, 6, 7, 8, 9] (valeur recherch√©e: 10)  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin: Counting sort‚Äã","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#pour-aller-plus-loin-counting-sort","content":" Le counting sort est un algorithme de tri qui permet de trier un tableau d'entiers en temps lin√©aire (c'est √† dire en O(n)O(n)O(n)). Il est cependant limit√© par le fait qu'il ne peut trier que des entiers (&quot;positifs&quot; pour le cas le plus simple) et que la valeur maximale des entiers du tableau doit √™tre connue (√† calculer avant le tri ou connue en fonction du contexte).  Essaye d'impl√©menter cet algorithme de tri. Voil√† le prototype de la fonction:  void counting_sort(std::vector&lt;int&gt; &amp; vec, int const max);  ","version":"Next","tagName":"h2"},{"title":"TD5 - Hachage et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Fonction de hachage)‚Äã","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-1-fonction-de-hachage","content":" √âcrire une fonction de hachage qui prend en param√®tre une cha√Æne de caract√®res, fait la somme des valeurs ASCII des caract√®res et renvoie un entier compris entre 0 et un maximum donn√© nomm√© max (le type de retour du hash doit √™tre size_t).  Nous utiliserons une simple somme des codes ASCII des caract√®res suivie d'un modulo pour obtenir un entier compris entre 0 et max.  size_t folding_string_hash(std::string const&amp; s, size_t max);   hash(s)=(‚àëi=0n‚àí1s[i])mod m\\text{hash}(s) = (\\sum_{i=0}^{n-1} s[i]) \\mod mhash(s)=(i=0‚àën‚àí1‚Äãs[i])modm Avec: sss la cha√Æne de caract√®resnnn la taille de la cha√Æne de caract√®ress[i]s[i]s[i] le code ASCII du caract√®re √† l'index iii dans la cha√Æne de caract√®res  Ce que nous venons de faire s'appelle la technique dite de folding (pliage en fran√ßais). Cela consiste √† d√©couper notre donn√©e en plusieurs parties, calculer une valeur (hash) pour chacune de ces parties, sommer ces valeurs et enfin appliquer un modulo pour obtenir un entier compris entre 0 et max. Ici on traite une cha√Æne de caract√®re, on va donc faire la somme des valeurs de hachage de chaque caract√®re.  info On veux se ramener √† un entier compris entre 0 et max car cette valeur hach√©e sert g√©n√©ralement d'index dans un tableau (table de hachage). Hors on souhaite un tableau de taille &quot;raisonnable&quot; en m√©moire, donc on limite la taille de ce tableau √† max. Le choix de max d√©pend du contexte d'utilisation de la table de hachage, g√©n√©ralement on choisit une valeur qui est une puissance de 2 (par exemple 1024, 2048, 4096, etc.).  attention Dans l'implementation concr√®te (utilisant une boucle for pour sommer les valeurs ASCII), on pr√©f√©rera appliquer le modulo √† chaque it√©ration plut√¥t qu'√† la fin de la boucle. En effet, si la cha√Æne de caract√®res est tr√®s longue, la somme des valeurs ASCII peut d√©passer la taille maximale d'un entier (overflow). En appliquant le modulo √† chaque it√©ration, on √©vite ce probl√®me et on s'assure que la valeur hach√©e reste dans les limites de size_t. Le r√©sultat sera identique car le modulo est distributif par rapport √† l'addition: (a+b)mod m=((amod m)+(bmod m))mod m(a+b) \\mod m = ((a \\mod m) + (b \\mod m)) \\mod m(a+b)modm=((amodm)+(bmodm))modm Cela va √™tre d'autant plus important pour les questions suivantes o√π l'on va devoir faire des multiplications suppl√©mentaires et donc des risques d'overflow plus importants.  √âcrire une nouvelle fonction de hachage sur une cha√Æne de caract√®res pour laquelle l'ordre des caract√®res a de l'importance. Par exemple, les cha√Ænes de caract√®res &quot;abc&quot; et &quot;cba&quot; ne doivent pas avoir la m√™me valeur hach√©e. Ce qui est le cas avec la fonction de hachage pr√©c√©dente.  Utiliser par exemple la somme des codes ASCII des caract√®res multipli√©e par leur position dans la cha√Æne de caract√®res.  size_t folding_string_ordered_hash(std::string const&amp; s, size_t max);   hash(s)=(‚àëi=0n‚àí1s[i]√ó(i+1))mod m\\text{hash}(s) = (\\sum_{i=0}^{n-1} s[i] \\times (i+1)) \\mod mhash(s)=(i=0‚àën‚àí1‚Äãs[i]√ó(i+1))modm Ici j'utilise i+1 pour √©viter que la position 0 (le 1er caract√®re) ne soit pas prise en compte dans le calcul du hash car multipli√©e par 0.  √âcrire une fonction de hachage sur une cha√Æne de caract√®res utilisant la technique de polynomial rolling hash.  Voila le prototype de la fonction √† √©crire:  size_t polynomial_rolling_hash(std::string const&amp; s, size_t p, size_t m);   Nous allons utiliser la technique dite de polynomial rolling hash. Cette technique consiste √† calculer le hash d'une cha√Æne de caract√®res en incorporant la position d'une mani√®re plus complexe pour √©viter les collisions. On va donc multiplier la valeur de chaque caract√®re par une puissance de p qui d√©pend de la position du caract√®re dans la cha√Æne de caract√®res. Pour cela, nous allons utiliser la formule suivante: hash(s)=(‚àëi=0n‚àí1s[i]√ópi)mod m\\text{hash}(s) = (\\sum_{i=0}^{n-1} s[i] \\times p^i) \\mod mhash(s)=(i=0‚àën‚àí1‚Äãs[i]√ópi)modm Avec: ppp un nombre (g√©n√©ralement un nombre premier)mmm un nombre (g√©n√©ralement une puissance de 2)  attention On ne veux pas utiliser la fonction std::pow de la biblioth√®que standard car elle est &quot;lente&quot; et fonctionne avec des flottants (ce qui nous ferait faire des conversions inutiles). De plus on ne veux pas recalculer la puissance de p √† chaque it√©ration car c'est des calculs inutiles. Admettons qu'il faille n‚àí1n-1n‚àí1 multiplications pour calculer pnp^npn (p√óp√óp=p3p \\times p \\times p = p^3p√óp√óp=p3) et que l'on recalculait √† chaque fois la puissance. Pour une cha√Æne de taille nnn on ferait donc 1+2+‚Ä¶+(n‚àí2)+(n‚àí1)1 + 2 + \\ldots + (n-2) + (n-1)1+2+‚Ä¶+(n‚àí2)+(n‚àí1) multiplications. On peut simplifier cette somme en n(n‚àí1)/2n(n-1)/2n(n‚àí1)/2 ce qui est de l'ordre de n2n^2n2 multiplications. On veut √©viter √ßa. On va donc nous m√™me faire les multiplications. Pour calculer pip^ipi on peut simplement multiplier par p le r√©sultat de pi‚àí1p^{i-1}pi‚àí1 c'est √† dire la valeur de la puissance √† l'it√©ration pr√©c√©dente. On va donc utiliser une variable power (initialis√©e √† 1 au d√©but) et multiplier cette variable par p √† chaque it√©ration pour obtenir les puissances de p.  choix de p et m Le choix de p et m va influencer la qualit√© (probabilit√© de collision) et les performances de notre fonction de hachage. Sans rentrer dans les d√©tails, on choisit g√©n√©ralement p un nombre premier et m un nombre suffisamment grand pour √©viter les collisions tout en restant petit pour rester performant et √©viter des erreur num√©riques. Par exemple, on peut choisir p = 31 et m = 10^9 + 9 (que l'on peut noter 1e9 + 9 en C++ ou tout simplement 1000000009).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Analyse du nombre d'insectes)‚Äã","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-2-analyse-du-nombre-dinsectes","content":" L'id√©e de cet exercice est d'utiliser une table associative pour r√©soudre un probl√®me.  Vous √™tes un entomologiste qui a pour mission de recenser les insectes dans un jardin afin de v√©rifier la biodiversit√© de ce jardin et confirmer vos hypoth√®ses sur la pr√©sence de certaines esp√®ces (probabilit√© de pr√©sence de certaines esp√®ces, etc.).  Vous disposez d'une liste d'insectes que vous pouvez rencontrer dans ce jardin (sous forme d'√©num√©ration):  enum class Insect { ClassicBee, Ladybug, Butterfly, Dragonfly, Ant, Grasshopper, Beetle, Wasp, Caterpillar, Spider, GuimielBee };   Je vous fournis √©galement une liste des valeurs de l'√©num√©ration Insect sous forme de vecteur (pour pouvoir it√©rer sur les valeurs de l'√©num√©ration et √©viter de faire des static_cast pour obtenir les valeurs de l'√©num√©ration √† partir d'un entier (index) ou encore avoir le nombre d'√©l√©ments de l'√©num√©ration). Rappels sur les cast avec enum ici.  #include &lt;vector&gt; std::vector&lt;Insect&gt; const insect_values { Insect::ClassicBee, Insect::Ladybug, Insect::Butterfly, Insect::Dragonfly, Insect::Ant, Insect::Grasshopper, Insect::Beetle, Insect::Wasp, Insect::Caterpillar, Insect::Spider, Insect::GuimielBee };   Ainsi qu'un tableau associatif qui permet de convertir une valeur de l'√©num√©ration Insect en une cha√Æne de caract√®res (pour pouvoir afficher le nom de l'insecte):  info Il n'existe pas de fonction dans la biblioth√®que standard C++ pour obtenir le nom d'une valeur d'une √©num√©ration. L'astuce est donc de cr√©er un tableau associatif pour faire cette correspondance. Il existe des biblioth√®ques comme Magic Enum qui permettent de manipuler plus facilement les √©num√©rations mais nous n'utiliserons pas de biblioth√®que dans cet exercice.  #include &lt;unordered_map&gt; #include &lt;string&gt; std::unordered_map&lt;Insect, std::string&gt; const insect_to_string = { {Insect::ClassicBee, &quot;ClassicBee&quot;}, {Insect::Ladybug, &quot;Ladybug&quot;}, {Insect::Butterfly, &quot;Butterfly&quot;}, {Insect::Dragonfly, &quot;Dragonfly&quot;}, {Insect::Ant, &quot;Ant&quot;}, {Insect::Grasshopper, &quot;Grasshopper&quot;}, {Insect::Beetle, &quot;Beetle&quot;}, {Insect::Wasp, &quot;Wasp&quot;}, {Insect::Caterpillar, &quot;Caterpillar&quot;}, {Insect::Spider, &quot;Spider&quot;}, {Insect::GuimielBee, &quot;GuimielBee&quot;} };   Enfin, vous disposez d'une liste de comptage d'insectes attendus pour un √©chantillon de 1000 insectes (obtenue en faisant la moyenne des observations de plusieurs entomologistes): Cette liste se pr√©sente sous forme d'un vecteur avec les nombres d'individus attendus pour chaque esp√®ce d'insecte (dans le m√™me ordre que l'√©num√©ration Insect):  #include &lt;vector&gt; std::vector&lt;int&gt; const expected_insect_counts { 75, // ClassicBee 50, // Ladybug 100, // Butterfly 20, // Dragonfly 400, // Ant 150, // Grasshopper 60, // Beetle 10, // Wasp 40, // Caterpillar 90, // Spider 5, // GuimielBee };   Vous avez un grand nombre d'insectes √† recenser et vous avez besoin d'une m√©thode pour compter le nombre d'apparitions de chaque insecte.  Le plus simple pour vous est juste de noter au fur et √† mesure vos observations (esp√®ce et nombre d'individus observ√©s) et de faire le compte √† la fin. (par exemple, vous notez &quot;2 abeilles&quot; lorsque vous voyez 2 abeilles et &quot;1 coccinelle&quot; lorsque vous voyez une coccinelle).  Voil√† une fonction qui g√©n√®re une liste d'observations al√©atoires pour simuler vos observations:  #include &lt;functional&gt; #include &lt;random&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; std::vector&lt;std::pair&lt;Insect, int&gt;&gt; get_insect_observations( size_t const number_of_observations, std::vector&lt;float&gt; const&amp; insect_probabilities, unsigned int const seed = std::random_device{}() ) { // Create a random engine with a given seed std::default_random_engine random_engine{seed}; auto rand_insect_index { std::bind(std::discrete_distribution&lt;size_t&gt;{insect_probabilities.begin(), insect_probabilities.end()}, random_engine) }; std::vector&lt;std::pair&lt;Insect, int&gt;&gt; observations {}; observations.reserve(number_of_observations); for(size_t i {0}; i &lt; number_of_observations; ++i) { size_t const random_insect_index { rand_insect_index() }; Insect const random_insect { insect_values[random_insect_index] }; // If we have already seen the same insect, increment the count on the last observation if(!observations.empty() &amp;&amp; observations.back().first == random_insect) { observations.back().second++; i -= 1; } else { observations.push_back({random_insect, 1}); } } return observations; }   Cr√©er une fonction std::vector&lt;float&gt; probabilities_from_count(std::vector&lt;int&gt; const&amp; counts) qui prend en param√®tre un vecteur de comptages et retourne un vecteur de probabilit√©s √† partir de ces comptages. (on divise chaque comptage par la somme de tous les comptages pour obtenir une probabilit√© normalis√©e). Utiliser la fonction get_insect_observations pour g√©n√©rer une liste suffisamment grande d'observations (par exemple 10000 observations) puis utiliser une table de hachage std::unordered_map pour compter le nombre d'apparitions de chaque insecte dans les observations pr√©c√©demment g√©n√©r√©es et afficher le r√©sultat (le nombre d'individus observ√©s pour chaque insecte).  astuce On utilisera la valeur de l'√©num√©ration Insect comme cl√© dans la table de hachage et le nombre d'individus observ√©s (initialis√© √† 0) comme valeur associ√©e √† cette cl√© (std::unordered_map&lt;Insect, int&gt;).  info Le param√®tre seed de la fonction get_insect_observations permet de fixer la graine du g√©n√©rateur de nombres al√©atoires. Cela permet de reproduire les m√™mes observations √† chaque ex√©cution du programme. Si vous ne sp√©cifiez pas de graine, le g√©n√©rateur de nombres al√©atoires utilisera une graine al√©atoire √† chaque ex√©cution du programme.  Utiliser de nouveau la fonction probabilities_from_count pour obtenir les probabilit√©s des insectes observ√©s. Il faudra au pr√©alable convertir le r√©sultat de la table de hachage en un vecteur de comptage pour pouvoir utiliser la fonction probabilities_from_count. Afficher et comparer les probabilit√©s des insectes observ√©s avec les probabilit√©s initiales. Si la diff√©rence entre les probabilit√©s observ√©es et les probabilit√©s initiales est trop grande, indiquer que les observations ne sont pas conformes aux probabilit√©s initiales. On pourra se fixer un seuil de 1% (0.01) pour consid√©rer que les observations sont conformes.  exemple de pr√©sentation des r√©sultats:  Probabilities of observed insects vs expected probabilities ClassicBee : 0.076 vs 0.075 OK Ladybug : 0.048 vs 0.050 OK Butterfly : 0.100 vs 0.100 OK Dragonfly : 0.035 vs 0.020 BAD ...   info Avec un grand nombre d'observations, on s'attend √† ce que les probabilit√©s observ√©es se rapprochent des probabilit√©s initiales. C'est le principe des lois des grands nombres. Plus on a d'observations, plus les probabilit√©s observ√©es se rapprocheront des probabilit√©s initiales. Avec 10 000 vous devriez √™tre sous le seuil de 1% pour chaque insecte (OK).  astuce Vous pouvez utiliser l'include &lt;iomanip&gt; pour formater l'affichage des nombres √† virgule flottante. Ajouter std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3); avant d'afficher les nombres pour afficher les nombres avec 3 chiffres apr√®s la virgule.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Hash sur une structure)‚Äã","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-3-hash-sur-une-structure","content":" Donnons nous les enums et structures suivantes:  enum class CardKind { Heart, Diamond, Club, Spade, }; enum class CardValue { Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace, }; struct Card { CardKind kind; CardValue value; };   L'id√©e de cet exercice est de cr√©er une fonction de hachage pour la structure Card pour que l'on puisse utiliser cette structure comme cl√© dans une table de hachage.  La biblioth√®que standard C++ fournit une fonction de hachage pour les types de base (entiers, flottants, etc.) et les cha√Ænes de caract√®res. Mais elle ne fournit pas de fonction de hachage pour nos structures.  De la m√™me fa√ßon que l'on a surcharg√© les op√©rateurs pour nos structures, on va pouvoir surcharger la fonction de hachage de notre structure.  Il faut deux choses pour pouvoir utiliser une structure comme cl√© dans une table de hachage:  un op√©rateur == pour comparer deux structuresune fonction de hachage de cette structure  Surchargez l'op√©rateur == pour la structure Card (deux cartes sont √©gales si elles ont la m√™me valeur et la m√™me couleur). √âcrire une m√©thode hash constante pour la structure Card qui retourne un entier.  Vous pouvez utiliser la m√©thode de hachage que vous souhaitez et qui vous semble la plus adapt√©e. Mais je vous donne un indice pour trouver une fonction de hachage parfaite pour notre structure Card dans la question suivante (vous pouvez donc passer √† la question suivante si vous le souhaitez).  Trouvez un moyen simple (√† l'aide d'une multiplication et de static_cast) d'am√©liorer la fonction de hachage de notre structure Card pour quelle soit parfaite.  astuce Trouver une bonne fonction de hachage de notre structure Card revient √† trouver une fa√ßon de transformer une carte en un entier unique. Il y a de nombreuses fa√ßons de s'y prendre comme on l'a vu pr√©c√©demment. Mais pour ce cas pr√©cis, il existe une fonction de hachage dite parfaite. On peut se rendre compte qu'il y a seulement 52 cartes diff√©rentes. On peut donc utiliser une fonction de hachage qui retourne un entier compris entre 0 et 51 avec un nombre diff√©rent pour chaque carte et donc sans collision.    Je vous donne ensuite le code suivant qui permet de faire en sorte que la biblioth√®que standard utilise notre m√©thode hash pour la structure Card:  namespace std { template&lt;&gt; struct hash&lt;Card&gt; { size_t operator()(Card const&amp; card) const { return card.hash(); } }; }   Je ne vous demande pas de comprendre ce code, il y a des notions plus complexes que vous d√©couvrirez l'ann√©e prochaine. Gardez simplement en t√™te que ce code permet de faire en sorte que la biblioth√®que standard utilise notre m√©thode hash pour la structure Card. (Notamment les tables associatives ont besoin de √ßa pour indexer les objects). On aurait pu √©crire le contenu de la fonction hash directement ici mais je pr√©f√®re que vous ayez une m√©thode hash dans la structure Card pour que vous puissiez l'utiliser ailleurs (en appelant card.hash()).  attention ‚ö†Ô∏è Votre m√©thode hash doit √™tre const pour pouvoir √™tre appel√©e dans cette fonction qui est const.  Je vous donne √©galement une fonction qui permet de g√©n√©rer une liste de cartes al√©atoires:  #include &lt;vector&gt; std::vector&lt;Card&gt; get_cards(size_t const size) { std::vector&lt;Card&gt; cards {}; cards.reserve(size); for (size_t i {0}; i &lt; size; ++i) { cards.push_back({static_cast&lt;CardKind&gt;(rand() % 4), static_cast&lt;CardValue&gt;(rand() % 13)}); } return cards; }   Utiliser la fonction get_cards pour g√©n√©rer une liste de 100 cartes al√©atoires. Utiliser une table de hachage std::unordered_map pour compter le nombre de fois que chaque carte appara√Æt dans la liste et afficher le r√©sultat.  Pour pouvoir afficher, je vous donne la fonction suivante qui permet d'obtenir une repr√©sentation sous forme de cha√Æne de caract√®res de notre structure Card:  std::string card_name(Card const&amp; card) { std::string name {}; unsigned int card_value {(static_cast&lt;unsigned int&gt;(card.value)+2) % 14}; if (card_value &lt; 10) { name += '0' + std::to_string(card_value); }else if (card_value == 10) { name += &quot;10&quot;; }else if (card_value == 11) { name += 'J'; }else if (card_value == 12) { name += 'Q'; }else if (card_value == 13) { name += 'K'; } name += &quot; of &quot;; if (card.kind == CardKind::Heart) { name += &quot;Heart&quot;; }else if (card.kind == CardKind::Diamond) { name += &quot;Diamond&quot;; }else if (card.kind == CardKind::Club) { name += &quot;Club&quot;; }else if (card.kind == CardKind::Spade) { name += &quot;Spade&quot;; } return name; }  ","version":"Next","tagName":"h2"},{"title":"Sujet","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Sujet","content":"","keywords":"","version":"Next"},{"title":"Pitch‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#pitch","content":" Durant ce workshop vous aller apprendre √† coder des effets sur des images. (Comme on peut en trouver dans Photoshop, les filtres Instagram, etc.). Ce sera une premi√®re introduction √† certains concepts de synth√®se d'image, et une bonne occasion de vous entra√Æner en C++ !     ","version":"Next","tagName":"h2"},{"title":"Attendus‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#attendus","content":" Ce projet est √† faire en solo.  Nous allons vous proposer une liste d'exercices, plus ou moins difficiles (la difficult√© est indiqu√©e par le nombre d'√©toiles ‚≠ê). Nous ne nous attendons pas √† ce que vous fassiez tous les exercices, mais faites en un maximum ! Et il faudra au minimum faire un exercice de niveau 3 ou plus (‚≠ê‚≠ê‚≠ê). Vous √™tes aussi les bienvenu.es pour inventer vos propres effets ou en faire que vous avez vu quelque part, m√™me si ils ne sont pas dans la liste !  Vous √™tes √©valu√©.es non seulement sur la qualit√© du travail rendu, mais aussi ‚Äì de mani√®re tout aussi importante ‚Äì sur votre s√©rieux et votre implication tout au long de la semaine de workshop.  √Ä la fin de la semaine il y aura une mini-soutenance (optionnelle, et qui est plus un exercice de vulgarisation qu'autre chose), et il faudra rendre un mini-rapport.  ","version":"Next","tagName":"h2"},{"title":"Pour bien d√©marrer‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#pour-bien-d√©marrer","content":" Voici le template √† utiliser. Vous pouvez t√©l√©charger √ßa et coder dedans, tout est d√©j√† setup (CMake, librairies, images de test, etc.)Nous utiliserons la librairie sil pour lire, √©diter et sauvegarder les images. Elle est tr√®s simple √† utiliser et n'expose que le minimum n√©cessaire. Vous pouvez trouver sa documentation sur GitHub.Utilisez des images relativement petites (500x500 max), pour que le rendu soit quasi-instantan√©. Au moins pendant que vous faites vos tests. Vous avez d√©j√† &quot;images/logo.png&quot; et &quot;images/photo.jpg&quot; dispos dans le template de projet. Certains effets marchent mieux sur une photo, et d'autres mieux sur une image flat, donc choisissez en fonction de l'effet sur quelle image l'appliquer. Vous pouvez aussi mettre vos propres images si vous voulez.Vous pouvez afficher l'image de sortie dans VSCode pour facilement voir le r√©sultat en m√™me temps que vous codez :Deux mani√®res pour it√©rer sur l'image :  // On passe sur tous les x et tous les y, et on acc√®de au pixel correspondant : for (int x{0}; x &lt; image.width(); x++) { for (int y{0}; y &lt; image.height(); y++) { image.pixel(x, y).r = 0.f; } } // Ou alors, si on n'a pas besoin de conna√Ætre le x et le y, on a une syntaxe plus concise pour it√©rer sur tous les pixels : for (glm::vec3&amp; color : image.pixels()) { color.r = 0.f; }   Nos couleurs sont stock√©es dans des glm::vec3 color: On peut acc√©der aux composantes rouge, verte et bleue avec color.r, color.g et color.b.Les valeurs vont de 0 √† 1. Par exemple un rouge pur sera glm::vec3{1, 0, 0}, du blanc sera glm::vec3{1, 1, 1} et du noir glm::vec3{0, 0, 0}.Pour cr√©er une couleur avec les trois composantes identiques (donc un niveau de gris), la syntaxe glm::vec3{grey} est √©quivalente √† glm::vec3{grey, grey, grey}.Vous pouvez g√©n√©ralement faire vos op√©rations directement sur les couleurs, pas besoin de les faire 3 fois sur chacun des canaux :  glm::vec3 color1{}; glm::vec3 color2{}; glm::vec3 final_color{}; final_color = color1 + color2; // √©quivalent √† : // final_color.r = color1.r + color2.r; // final_color.g = color1.g + color2.g; // final_color.b = color1.b + color2.b;   Pour faire les diff√©rents exos, je vous conseille de faire une fonction par exo, et de tout mettre dans le m√™me fichier main.cpp. C'est le plus simple, et tant que le fichier ne devient pas trop gros et bord√©lique je pense que c'est une bonne solution. Par exemple :  void keep_green_only(sil::Image&amp; image) // Prend l'image par r√©f√©rence pour pouvoir la modifier { // ... } void channels_swap(sil::Image&amp; image) // Prend l'image par r√©f√©rence pour pouvoir la modifier { // ... } int main() { { sil::Image image{&quot;images/logo.png&quot;}; // Lis l'image keep_green_only(image); // Utilise la fonction pour modifier l'image image.save(&quot;output/keep_green_only.png&quot;); // Sauvegarde l'image } { sil::Image image{&quot;images/logo.png&quot;}; // Lis l'image channels_swap(image); // Utilise la fonction pour modifier l'image image.save(&quot;output/channels_swap.png&quot;); // Sauvegarde l'image } }   ","version":"Next","tagName":"h2"},{"title":"HELP mon effet ne fait rien !‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#help-mon-effet-ne-fait-rien-","content":" Est-ce que vous n'avez pas oubli√© une r√©f√©rence (&amp;) quelque part ?Est-ce que vous sauvegardez bien la bonne image ?Est-ce qu'il n'y a pas un crash ? Lancez avec le debugger pour savoir !Est-ce que vous ne faites pas une division entre entiers, du genre 1 / image.width() qui retourne toujours 0 parce que le r√©sultat serait entre 0 et 1 et se retrouve arrondi ?  ","version":"Next","tagName":"h2"},{"title":"Rendu et Rapport‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#rendu-et-rapport","content":" √Ä rendre avant samedi √† 23h59. Pour le rendu, il suffit de mettre votre lien git ici. Attention, v√©rifiez bien que votre repo est en public, ou si il est en priv√©, pensez √† m'inviter dessus (julesfouchy).  Pour le rapport, faites une section par exercice que vous avez fait. Montrez une image avant et apr√®s application de l'effet (comme c'est fait dans l'√©nonc√© des exercices). Si vous jugez cela utile, vous pouvez mettre un petit texte expliquant des sp√©cificit√©s de l'algo que vous avez impl√©ment√©, et les pi√®ges potentiels dans lesquels il ne faut pas tomber.  √Ä faire en Markdown obligatoirement (Si vous ne connaissez pas c'est l'occasion de d√©couvrir, c'est super utile. Je vous montre tout √ßa vendredi).  √Ä mettre directement en tant que ReadMe.md √† la racine du repo.  ","version":"Next","tagName":"h2"},{"title":"Soutenance‚Äã","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#soutenance","content":" Pr√©sentez un des algos avanc√©s que vous avez fait, en 5-10 minutes. C'est de la vulgarisation, il faut que tous vos camarades puissent comprendre. Expliquez l'algo dans les grandes lignes, et parlez des petits pi√®ges de code auxquels il faut faire attention.  PS : la soutenance est optionnelle, on va essayer de ne pas pr√©senter plusieurs fois le m√™me algo, donc vous n'√™tes pas oblig√©.es de passer. Et si plusieurs groupes souhaitent passer sur le m√™me algo, on va essayer de vous regrouper pour que vous fassiez une seule pr√©sentation, ensemble. ","version":"Next","tagName":"h2"},{"title":"Exercices","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Exercices","content":"","keywords":"","version":"Next"},{"title":"‚≠ê Ne garder que le vert‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-ne-garder-que-le-vert","content":"   Indice Mettre le rouge et le bleu √† 0.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê √âchanger les canaux‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-√©changer-les-canaux","content":"   Par exemple, √©changez le canal rouge et le canal bleu.  Indice Il existe std::swap(a, b) pour √©changer deux valeurs.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê Noir & Blanc‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-noir--blanc","content":"   Indice N'h√©sitez pas √† aller chercher la formule sur internet si besoin !  ","version":"Next","tagName":"h2"},{"title":"‚≠ê N√©gatif‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-n√©gatif","content":"   Indice Il faut trouver une formule simple, qui transforme le noir en blanc et le blanc en noir (i.e. qui transforme 0 en 1 et 1 en 0).  ","version":"Next","tagName":"h2"},{"title":"‚≠ê D√©grad√©‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-d√©grad√©","content":"   info Vous pouvez cr√©er une image noire avec sil::Image image{300/*width*/, 200/*height*/}; puis it√©rer sur les pixels pour les colorer.  Indice La couleur de chaque pixel doit d√©pendre de son x uniquement.  Indice 2 Quelle formule permettrait d'avoir 0 (noir) quand x vaut 0 (gauche), et 1 (blanc) quand x vaut image.width() - 1 (droite) ?  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê Miroir‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-miroir","content":"   Indice On cherche une formule qui, quand x vaut 0, le transforme en image.width() - 1, quand x vaut 1, le transforme en image.width() - 2, etc.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê Image bruit√©e‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-image-bruit√©e","content":"   info Pour obtenir des nombres al√©atoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple √† utiliser, et utilisent des g√©n√©rateurs al√©atoires de meilleure qualit√©. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la m√™me suite de nombres al√©atoires √† chaque fois que vous relancez votre programme, vous pouvez d√©finir une seed avec set_random_seed(0) au d√©but de votre main() (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).  Indice Remplacez quelques pixels au hasard par une couleur al√©atoire.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê Rotation de 90¬∞‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rotation-de-90","content":"   La formule g√©n√©rique pour un angle quelconque est un peu plus compliqu√©e, mais pour 90¬∞ il y a une formule plus simple, essayez de la trouver !  Indice Cr√©ez une nouvelle image avec sil::Image new_image{new_width, new_height}; pour stocker le r√©sultat de votre effet, car elle n'aura pas la m√™me taille que l'image originale.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê RGB split‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rgb-split","content":"   ‚ö†Ô∏è Pi√®ge √† √©viter Cr√©ez une nouvelle image et travaillez sur celle-ci. Il ne faut pas modifier l'image originale pendant que vous bouclez pour appliquer l'effet, sinon certains pixels n'utiliseront pas la bonne couleur de l'image originale, mais plut√¥t la couleur d√©j√† modifi√©e par un pixel pr√©c√©dent, ce qui pourrait vous donner ce genre de rendu moins int√©ressant :  Indice Chaque pixel va prendre comme couleur le rouge d'un pixel un peu √† sa droite, son propre vert, et le bleu d'un pixel un peu √† sa gauche.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê Luminosit√©‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-luminosit√©","content":"  Image originale\tApr√®s √©claircissement\tApr√®s assombrissement  Indice On voudrait des courbes comme celles-ci, qui diminuent tous les nombres entre 0 et 1 (courbe bleue) (c-√†-d assombrisse), ou les augmentent (courbe verte) (c-√†-d √©claircisse), tout en gardant 0 √† 0 et 1 √† 1 (afin de garder la plage dynamique de l'image, pour conserver des noirs purs et des blancs purs).  Indice 2 Les fonctions puissance font exactement ce qu'on veut ! La preuve : https://www.desmos.com/calculator/c3ztk51mng  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê(‚≠ê) Disque‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-disque","content":"   info Vous pouvez cr√©er une image noire avec sil::Image image{500/*width*/, 500/*height*/}; puis it√©rer sur les pixels pour les colorer.  Indice Quelle est l'√©quation d'un disque ? Comment peut on s'en servir pour savoir si un pixel est √† l'int√©rieur ou √† l'ext√©rieur du disque ?  ","version":"Next","tagName":"h2"},{"title":"‚≠ê Cercle‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-cercle","content":"   En reprenant et modifiant l√©g√®rement votre code pour le disque, √©crivez le code qui donne un cercle. (Son contour aura une √©paisseur donn√©e thickness).  ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê Animation‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-animation","content":"   Pour faire une animation, on va exporter plein d'images les unes apr√®s les autres, en faisant l√©g√®rement bouger le disque entre deux images. Vous pouvez ensuite utiliser un outil externe pour assembler ces images en une vid√©o / gif. Par exemple Ezgif.  ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê‚≠ê Rosace‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rosace","content":"   Maintenant que vous savez dessiner un cercle, dessinez-en plusieurs sur la m√™me image, √† des positions bien choisies, de sorte √† dessiner une rosace. (PS : il va s√ªrement falloir faire de la trigo!)  Indice Comment passer de coordonn√©es polaires (angle et rayon) √† des coordonn√©es cart√©siennes (x et y) ?  ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê Animation‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-animation-1","content":"   Pour faire une animation, on va exporter plein d'images les unes apr√®s les autres, en faisant l√©g√®rement bouger le disque entre deux images. Vous pouvez ensuite utiliser un outil externe pour assembler ces images en une vid√©o / gif. Par exemple Ezgif.  ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê Mosa√Øque‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-mosa√Øque","content":"   Indice Une mani√®re concise de faire √ßa est d'utiliser un modulo (%) quelque part.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê Mosa√Øque miroir‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-mosa√Øque-miroir","content":" Inversez une image sur deux :    ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê‚≠ê Glitch‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-glitch","content":"   info Pour obtenir des nombres al√©atoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple √† utiliser, et utilisent des g√©n√©rateurs al√©atoires de meilleure qualit√©. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la m√™me suite de nombres al√©atoires √† chaque fois que vous relancez votre programme, vous pouvez d√©finir une seed avec set_random_seed(0) au d√©but de votre main() (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).  Indice Prendre un rectangle de pixels et l'intervertir avec un autre rectangle de pixels, ailleurs dans l'image. Faire √ßa plusieurs fois.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê Tri de pixels‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-tri-de-pixels","content":"   Voici une bonne vid√©o expliquant l'algorithme (vous pouvez ignorer le d√©but sp√©cifique √† Processing o√π on voit comment afficher l'image) :      Utilisez image.pixels() pour r√©cup√©rer le tableau contenant tous les pixels de l'image et le trier.  Ensuite, au lieu de trier tous les pixels de l'image, triez par colonne (ou par ligne) pour un effet plus joli. (Il faudra trier des sous-parties du tableau image.pixels().) Ou encore, triez des sous-parties prises al√©atoirement dans l'image.  info Pour trier un tableau, vous pouvez utiliser std::sort. Vous verrez √ßa plus en d√©tail au S2, mais voici une br√®ve explication : std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin(), v.end()); // Trie un tableau du d√©but √† la fin // {1, 3, 5, 8} std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin(), v.begin() + 2); // Trie les deux premiers √©l√©ments du tableau, c'est comme si on lui avait pass√© le tableau {8, 5} // {5, 8, 3, 1} std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin() + 1, v.begin() + 3); // Trie le sous-tableau {5, 3} // {8, 3, 5, 1} Et vous pouvez aussi choisir selon quel crit√®re de comparaison les √©l√©ments seront tri√©s : std::vector&lt;glm::vec3&gt; v{/*...*/}; std::sort(v.begin(), v.end(), [](glm::vec3 const&amp; color1, glm::vec3 const&amp; color2) { return color1.r &lt; color2.r; // Trie selon la composante rouge }); std::vector&lt;glm::vec3&gt; v{/*...*/}; std::sort(v.begin(), v.end(), [](glm::vec3 const&amp; color1, glm::vec3 const&amp; color2) { return brightness(color1) &lt; brightness(color2); // Trie selon la luminosit√© des couleurs (NB : c'est √† vous de coder la fonction `brightness`) }); On passe ce qu'on appelle une lambda en 3√®me argument : c'est une fonction d√©finie en plein milieu du code. Elle doit prendre en param√®tre deux √©l√©ments du tableau (deux vec3 en l'occurrence) et retourner un bool√©en indiquant qui est le plus petit des deux √©l√©ments.  info Pour obtenir des nombres al√©atoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple √† utiliser, et utilisent des g√©n√©rateurs al√©atoires de meilleure qualit√©. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la m√™me suite de nombres al√©atoires √† chaque fois que vous relancez votre programme, vous pouvez d√©finir une seed avec set_random_seed(0) au d√©but de votre main() (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê D√©grad√©s dans l'espace de couleur Lab‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-d√©grad√©s-dans-lespace-de-couleur-lab","content":" Pour commencer, repartez de l'exo ‚≠ê D√©grad√© et adaptez-le pour faire un d√©grad√© de couleur :    Indice Vous pouvez utiliser la fonction glm::mix pour m√©langer deux couleurs en fonction d'un pourcentage.  Maintenant, on peut remarquer que ce d√©grad√© n'est pas super, et que la couleur au milieu est tr√®s sombre par rapport aux couleurs aux extr√©mit√©s. Le probl√®me c'est que nos couleurs sont exprim√©es dans l'espace de couleur sRGB, qui n'est pas adapt√© pour ce genre d'op√©rations de m√©lange entre couleurs. D'autres espaces de couleur ont √©t√© d√©velopp√©s expr√®s pour √ßa, notamment Lab :      Voici l'article original introduisant Oklab, vous y trouverez toutes les infos n√©cessaires pour impl√©menter les conversions entre sRGB et Oklab :    Comparez les d√©grad√©s dans les diff√©rents espaces de couleur : lequel pr√©f√©rez vous ? Essayez des d√©grad√©s avec d'autres couleurs : est-ce que Oklab est toujours mieux que sRGB ? Que se passe-t-il si on fait le m√©lange dans d'autres espaces de couleur, comme Linear RGB ou HSL ?  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê(‚≠ê) Fractale de Mandelbrot‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-fractale-de-mandelbrot","content":"   La fractale de Mandelbrot s'obtient ainsi : pour chaque nombre complexe c (correspondant √† la position d'un pixel), on initialise un autre nombre complexe z √† 0, puis on it√®re z = z * z + c un certain nombre de fois. Si le nombre z commence √† devenir de plus en plus grand, alors c ne fait pas partie de la fractale et on colorie le pixel correspondant en noir. √Ä l'inverse, si z reste de taille mod√©r√©e peu importe le nombre d'it√©rations qu'on fait, alors le pixel fait partie de la fractale et on le colorie en blanc.  Plus pr√©cis√©ment, on peut prouver que d√®s que std::abs(z) &gt; 2 alors le nombre z va forc√©ment finir par grandir de plus en plus. On peut donc s'arr√™ter d'it√©rer d√®s que std::abs(z) &gt; 2. Et pour obtenir une fractale plus jolie, plut√¥t que d'assigner du noir pur on peut assigner un gris plus ou moins sombre en fonction du nombre d'it√©rations qu'il a fallu faire avant que std::abs(z) &gt; 2.  Conseil : si vous mappez directement le pixel (x, y) au nombre complexe x + i * y, vous allez visualiser les nombres complexes entre 0 et 500, et votre fractale va √™tre beaucoup trop petite. Les nombres int√©ressants sont plut√¥t entre -2 et 2. Il va donc falloir appliquer une petite transformation √† votre x et y pour les faire rentrer dans cet intervalle.  Conseil : vous pouvez inclure le header &lt;complex&gt; pour utiliser des nombres complexes. Un nombre complexe se d√©finit comme √ßa :  #include &lt;complex&gt; int main() { std::complex&lt;float&gt; z{3.f, 2.f}; // D√©finis le nombre z = 3 + 2*i }   et s'utilise comme un nombre normal : vous pouvez faire des additions, multiplications etc.  info Vous pouvez cr√©er une image noire avec sil::Image image{500/*width*/, 500/*height*/}; puis it√©rer sur les pixels pour les colorer.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê(‚≠ê) D√©grad√©s dans l'espace de couleur Lab‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-d√©grad√©s-dans-lespace-de-couleur-lab-1","content":" Pour commencer, repartez de l'exo ‚≠ê D√©grad√© et adaptez-le pour faire un d√©grad√© de couleur :    Indice Vous pouvez utiliser la fonction glm::mix pour m√©langer deux couleurs en fonction d'un pourcentage.  Maintenant, on peut remarquer que ce d√©grad√© n'est pas super, et que la couleur au milieu est tr√®s sombre par rapport aux couleurs aux extr√©mit√©s. Le probl√®me c'est que nos couleurs sont exprim√©es dans l'espace de couleur sRGB, qui n'est pas adapt√© pour ce genre d'op√©rations de m√©lange entre couleurs. D'autres espaces de couleur ont √©t√© d√©velopp√©s expr√®s pour √ßa, notamment Lab :      Voici l'article original introduisant Oklab, vous y trouverez toutes les infos n√©cessaires pour impl√©menter les conversions entre sRGB et Oklab. ATTENTION : il donne le code entre Oklab et LINEAR RGB (qu'il appelle par erreur Linear sRGB), nous on est en sRGB donc il faut rajouter les conversions entre Linear RGB et sRGB, que vous pourrez trouver ici : https://entropymine.com/imageworsener/srgbformula/    Comparez les d√©grad√©s dans les diff√©rents espaces de couleur : lequel pr√©f√©rez vous ? Essayez des d√©grad√©s avec d'autres couleurs : est-ce que Oklab est toujours mieux que sRGB ? Que se passe-t-il si on fait le m√©lange dans d'autres espaces de couleur, comme Linear RGB ou HSL ?  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê(‚≠ê) Tramage‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-tramage","content":"   Vous pouvez lire ce super article sur le tramage (a.k.a. dithering en anglais).  Sur l'image ci-dessus j'ai utilis√© de l'ordered dithering avec une matrice de Bayer 4x4 (a.k.a. de niveau 1). Tout est expliqu√© dans l'article ci-dessus ! (Plus pr√©cis√©ment, j'ai repris la matrice et le code depuis cet autre article.)  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê(‚≠ê) Normalisation de l'histogramme‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-normalisation-de-lhistogramme","content":" \tAvant\tApr√®s  L'algorithme consiste √† trouver le pixel le moins lumineux et le pixel le plus lumineux de l'image, puis √† appliquer une transformation √† chaque pixel de sorte √† ce que le pixel le plus sombre devienne un noir pur (0) et le plus lumineux devienne un blanc pur (1). (PS : testez avec l'image &quot;images/photo_faible_contraste.jpg&quot;, vous verrez bien l'int√©r√™t de l'effet.)  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê Vortex‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-vortex","content":"   info Pour appliquer une rotation √† un point point, autour d'un autre point center_of_rotation, d'un angle angle (exprim√© en radians) vous pouvez utiliser #include &lt;glm/gtx/matrix_transform_2d.hpp&gt; glm::vec2 rotated(glm::vec2 point, glm::vec2 center_of_rotation, float angle) { return glm::vec2{glm::rotate(glm::mat3{1.f}, angle) * glm::vec3{point - center_of_rotation, 0.f}} + center_of_rotation; }   info Pour obtenir la distance entre deux points, vous pouvez utiliser glm::distance(p1, p2);  Details IndiceChaque pixel subit une rotation, de plus en plus importante au fur et √† mesure qu'on s'√©loigne du centre.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê Convolutions‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-convolutions","content":"  Box blur  Les convolutions permettent d'impl√©menter plein d'effets (flou, d√©tection de contour, augmentation de la nettet√©, etc.). L'effet va varier en fonction du kernel que vous utilisez lors de votre convolution. Tout est expliqu√© dans cette excellente vid√©o, entre 1m10 et 4m18 :      Conseil : une fois que vous savez que votre algo marche, si vous voulez tester avec des kernels plus gros, √ßa peut √™tre lent, donc vous avez int√©r√™t √† build en release (demandez-moi si vous ne savez pas comment faire).  ","version":"Next","tagName":"h2"},{"title":"‚≠ê Nettet√©, Contours, etc.‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-nettet√©-contours-etc","content":"  Emboss\tOutline\tSharpen  Une fois que vous avez impl√©ment√© l'algo g√©n√©rique de convolution qui prend n'importe quel kernel, vous pourrez trouver sur ce site une liste de kernels pour faire diff√©rents effets.  ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê Filtres s√©parables‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-filtres-s√©parables","content":" Box blur na√Øf, 100x100\tBox blur s√©par√©, 100x100 7.44 secondes\t0.18 secondes  Quand vous voulez faire un gros flou il faut augmenter la taille du kernel, ce qui peut consid√©rablement ralentir l'algorithme. Heureusement, certains kernels ont une propri√©t√© qui nous permet de calculer leur convolution BEAUCOUP plus rapidement. Le box blur et le gaussian blur sont de tels kernels. Voici une vid√©o expliquant tout √ßa :    ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê Diff√©rence de gaussiennes‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-diff√©rence-de-gaussiennes","content":"   Voici une vid√©o expliquant l'algorithme :  NB 1 : Il parle de flou gaussien, mais vous pouvez tout aussi bien r√©utiliser votre box blur, pas la peine d'impl√©menter un flou gaussien.NB 2 : Ne faire que l'algo de base, pr√©sent√© jusqu'√† 4m09. Apr√®s √ßa √ßa devient tr√®s compliqu√© (mais tr√®s styl√© n√©anmoins).    ","version":"Next","tagName":"h3"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-k-means--trouver-les-couleurs-les-plus-pr√©sentes-dans-une-image","content":"  Originale\t2 couleurs\t3 couleurs\t16 couleurs  Trouvez les k couleurs les plus repr√©sentatives de l'image, puis assignez √† chaque pixel la couleur dont il est le plus proche parmi les k.  Voici une bonne vid√©o expliquant l'algorithme :      info Vous pouvez utiliser glm::distance(color1, color2) pour obtenir la distance entre deux couleurs.  info Pour obtenir des nombres al√©atoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple √† utiliser, et utilisent des g√©n√©rateurs al√©atoires de meilleure qualit√©. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la m√™me suite de nombres al√©atoires √† chaque fois que vous relancez votre programme, vous pouvez d√©finir une seed avec set_random_seed(0) au d√©but de votre main() (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Filtre de Kuwahara (effet peinture √† l'huile)‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-filtre-de-kuwahara-effet-peinture-√†-lhuile","content":"   Voici une vid√©o expliquant l'algorithme : (La version simple de l'algo, qui est expliqu√©e entre 3m11 et 3m30, suffit largement. (Mais si vous voulez aller plus loin, vous √™tes les bienvenu.es bien s√ªr üòâ))      info Vous pouvez utiliser glm::distance(color1, color2) pour obtenir la distance entre deux couleurs.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-diamond-square","content":"   Algorithme de g√©n√©ration de height map, qui peut ensuite √™tre utilis√©e pour cr√©er des terrains proc√©duraux dans des jeux vid√©os par exemple.  Voici une bonne vid√©o expliquant l'algorithme :      Conseil : commencez par travailler sur une image toute petite (e.g. 17x17), afin de bien voir les pixels et ce qu'il se passe.  info Vous pouvez cr√©er une image noire avec sil::Image image{17/*width*/, 17/*height*/}; puis it√©rer sur les pixels pour les colorer.  ","version":"Next","tagName":"h2"},{"title":"‚≠ê‚≠ê Colorer la height map‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-colorer-la-height-map","content":"   Appliquez un d√©grad√© de couleur en fonction du niveau de gris de la height map.  info Avec glm::mix(color1, color2, pourcentage); vous pouvez faire un m√©lange entre deux couleurs donn√©es.  Indice Essayez par exemple de faire un d√©grad√© d'un bleu sombre √† un bleu clair quand le niveau de gris est entre 0 et 0.5, et un autre d√©grad√© entre du vert et du marron quand le niveau de gris est entre 0.5 et 1.  ","version":"Next","tagName":"h3"},{"title":"Vous pouvez aussi impl√©menter vos propres effets !‚Äã","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#vous-pouvez-aussi-impl√©menter-vos-propres-effets-","content":"","version":"Next","tagName":"h2"}],"options":{"languages":["fr"],"includeRoutes":["**/Lessons/**","**/TDs/**","**/Annexes/**","**/Workshop/**","**/Subjects/**"],"id":"default"}}
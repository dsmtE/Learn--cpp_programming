{"searchDocs":[{"title":"Algorithmique et Programmation S1","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet","content":"","keywords":"","version":"Next"},{"title":"Aide préliminaire​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#aide-préliminaire","content":" Il faut inclure la bibliothèque iostream pour utiliser std::cout et std::endl qui permettent respectivement d'afficher du texte et de passer à la ligne.Il faut inclure respectivement les bibliothèques string, vector et array pour utiliser std::string, std::vector et std::array.Pour convertir un type en un autre (cast), il faut utiliser la syntaxe suivante:  std::static_cast&lt;type&gt;(variable)   Pour compiler manuellement un programme, il faut utiliser la commande g++ suivie du nom du fichier source et de l'option -o suivie du nom du fichier exécutable à générer (ex: g++ main.cpp -o main). Nous préciserons en plus l'option -Wall pour afficher les warnings (messages d'avertissement) et l'option -std=c++17 pour utiliser la version C++17 du langage.Ligne de compilation (pour un fichier ex02.cpp):  g++ ex02.cpp -o ex02 -Wall -std=c++17   ","version":"Next","tagName":"h2"},{"title":"Exercice 1 (questionnaire) (3Pts: 4 questions de 0.75)​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#exercice-1-questionnaire-3pts-4-questions-de-075","content":" Quelle est la différence entre un tableau statique et un tableau dynamique ?Quelle est la différence entre l'opérateur = et l'opérateur == ?Qu’entendez-vous par passage par copie et passage par référence(&amp;) ?A quoi servent les mots clés const et unsigned ? Quand et pourquoi les utiliser ?  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (maximum) (2Pts)​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#exercice-2-maximum-2pts","content":" Écrire une fonction max qui prend en paramètre (par référence constante) un tableau d'entiers (tu es libre d'utiliser un tableau dynamique (std::vector) ou statique (std::array) ) et retourne la valeur maximale du tableau. Utiliser la fonction max pour afficher la valeur maximale des tableaux suivants: {1, 2, 3, 4, 5, 6, 7, 8, 9}{9, 8, 7, 6, 5, 4, 3, 2, 1}{1, 23, 7, 32, 5, 43}  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (voyelles) (3Pts)​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#exercice-3-voyelles-3pts","content":" Écrire une fonction isVowel qui prend en paramètre un caractère et retourne true si le caractère est une voyelle, false sinon. On considère que le caractère est une voyelle si c'est un des caractères suivants: a, e, i, o, u ou y. Attention, il faut compter les voyelles en majuscules et en minuscules. On peut utiliser la fonction std::tolower (de la bibliothèque cctype) pour convertir un caractère en minuscule. On peut également utiliser la représentation ASCII.  Quelques codes ASCII utiles:  A →\\rightarrow→ Z\t0 →\\rightarrow→ 9\ta →\\rightarrow→ z65 →\\rightarrow→ 90\t48 →\\rightarrow→ 57\t97 →\\rightarrow→ 122  Écrire une fonction countVowels qui prend en paramètre une chaîne de caractères (std::string) et retourne le nombre de voyelles dans la chaîne.Afficher le nombre de voyelles dans les chaînes suivantes: Hello World!Ceci est un testJe suis une phrase avec des voyelles  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Géométrie) (2,5Pts + 1Pts bonus)​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#exercice-4-géométrie-25pts--1pts-bonus","content":" On dispose de la structure Point suivante:  struct Point { float x; float y; };   Écrire une fonction distance qui prend en paramètre deux points et retourne la distance entre les deux points.  On utilisera la signature suivante:  float distance(Point const&amp; p1, Point const&amp; p2);   Pour rappel, la distance entre deux points p1 et p2 est égale à la racine carrée de la somme des carrés des différences des coordonnées des points. distance=(p1.x−p2.x)2+(p1.y−p2.y)2\\text{distance} = \\sqrt{(p1.x - p2.x)^2 + (p1.y - p2.y)^2}distance=(p1.x−p2.x)2+(p1.y−p2.y)2​  Vous pouvez utiliser les fonctions sqrt et pow de la bibliothèque cmath pour calculer la racine carrée et la puissance d'un nombre.  #include &lt;cmath&gt; float sqrt_test { std::sqrt(4) }; // racine carrée de 4 = 2 float pow_test { std::pow(2, 3) }; // 2^3 = 8   On considérera que la fonction précédente fonctionne pour la suite de l'exercice si ce n'est pas le cas.  Écrire une fonction isInCircle qui prend en paramètre un point (p), le centre d'un cercle (center) et son rayon (radius) et retourne true si le point p est dans le cercle, false sinon.  On utilisera la signature suivante:  bool isInCircle(Point const&amp; p, Point const&amp; center, float radius);   Utiliser la fonction isInCircle pour afficher si les points suivants sont dans le cercle de centre (0, 1) et de rayon 2.4f: (0, 0)(1, 1)(3, 4) (BONUS) Écrire une fonction isCirclesIntersect qui prend en paramètre deux cercles (sous la forme de deux points et deux rayons) et retourne true si les deux cercles s'intersectent, false sinon.  Deux cercles s'intersectent si leurs centres sont à une distance inférieure à la somme de leur rayon.  (BONUS) Définir un structure Circle qui contiendra les attributs suivants: center : centre du cercle (utiliser la structure Point)radius : rayon du cercle Réécrire les deux fonctions précédentes (surcharge) en utilisant la structure Circle à la place des paramètres Point et float. (BONUS) Utiliser la fonction isCirclesIntersect pour afficher si les deux cercles suivants s'intersectent: Cercle 1: centre (0, 0), rayon 1Cercle 2: centre (2, 0), rayon 1  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Robot) (7.5Pts (10 questions de 0.75) + 1Pts bonus)​","type":1,"pageTitle":"Algorithmique et Programmation S1","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet#exercice-6-robot-75pts-10-questions-de-075--1pts-bonus","content":" Pour cet exercice, je vous fourni un dossier dédié à l'exercice.  Ce dossier contient un sous-dossier src avec les fichiers sources ainsi qu'un fichier CMakeLists.txt pour compiler le programme.  la structure du dossier ressemble à ça:  robot/ L src/ | L main.cpp | L direction.cpp | L direction.hpp | L point.cpp | L point.hpp | L robot.cpp | L robot.hpp L CMakeLists.txt   Compilation manuelle avec cmake​ Ouvrir un terminal dans le dossier robot contenant le fichier CMakeLists.txt et exécuter les commandes suivantes: mkdir build : créer un dossier build (qui va servir à stocker les fichiers de compilation)cd build : se déplacer dans le dossier buildcmake .. : générer les fichiers de compilation dans le dossier build à partir du fichier CMakeLists.txt du dossier parentmake : compiler le programme (générer l'exécutable à partir des fichiers de compilation Makefile)./main : exécuter le programme (remplacer main par le nom de l'exécutable généré) (dans notre cas le cmake est configuré pour générer un exécutable robot dans le dossier bin on peut donc exécuter le programme depuis le dossier build avec la commande ../bin/robot) &quot;..&quot; signifie le dossier parent. &quot;.&quot; signifie le dossier courant.  Le fichier direction.hpp contient un enum Direction avec les valeurs suivantes : north (Nord)south (Sud)east (Est)west (Ouest) Créer le prototype d'une fonction to_string dans le fichier direction.hpp qui prends en paramètre une direction et retourne une chaîne de caractères (std::string) représentant cette Direction (ex: Direction::north →\\rightarrow→ &quot;north&quot;). Créer la définition de la fonction to_string dans le fichier direction.cpp. Définir une structure Point dans le fichier point.hpp. Elle contiendra les attributs suivants : x : position en x (utiliser le type int)y : position en y (utiliser le type int) La structure devra contenir les méthodes suivantes : void display() : affiche les coordonnées du point sous la forme (x, y).void move(Direction const d, unsigned int const n) : déplace le point de n cases dans la direction d. Implémenter les méthodes de la structure Point dans le fichier point.cpp.  On considère que la direction north correspond à une augmentation de la coordonnée y (south une diminution de y) et que la direction east correspond à une augmentation de la coordonnée x (west une diminution de x). y↑→x\\begin{aligned} y &amp; \\\\ \\uparrow &amp; \\\\ &amp; \\rightarrow x \\\\ \\end{aligned}y↑​→x​  Créer une structure Robot dans le fichier robot.hpp qui contiendra les attributs suivants : name : nom du robot (std::string)position : position du robot (utiliser la structure Point)direction : direction du robot (utiliser l'enum Direction) La structure devra contenir les méthodes suivantes : void display() : affiche les informations du robot sous la forme name((x, y), direction).void turnLeft() : tourne le robot de 90° vers la gauche. (ex: north devient west)void turnRight() : tourne le robot de 90° vers la droite.void move(unsigned int const n) : déplace le robot de n cases dans la direction du robot. Implémenter les méthodes de la structure Robot dans le fichier robot.cpp. Ajouter le prototype d'une fonction createRobotName dans le fichier robot.hpp, elle retournera un nom de robot généré aléatoirement sous la forme d'une chaîne de caractère avec un format contenant 2 lettres majuscules suivies de 3 chiffres aléatoires. (ex: AB123). Écrire la définition de la fonction createRobotName dans le fichier robot.cpp.  Pour générer un nombre aléatoire, on peut utiliser la fonction std::rand (elle retourne un nombre aléatoire entre 0 et RAND_MAX).  On utilisera la fonction std::srand pour initialiser le générateur de nombres aléatoires avec la fonction std::time pour que les nombres générés soient différents à chaque exécution du programme.  Pour générer une lettre aléatoire, on peut utiliser la fonction rand et l'opérateur modulo (%) pour générer un nombre aléatoire entre 0 et 25:  #include &lt;cstdlib&gt; // pour utiliser la fonction std::rand #include &lt;ctime&gt; // pour utiliser la fonction std::time int main() { // initialiser le générateur de nombres aléatoires // A utiliser une seule fois dans le programme (dans le main par exemple) std::srand(std::time(nullptr)); // générer un nombre aléatoire entre 0 et 25 (+1 pour inclure 25) int random_number { std::rand() % (25+1) }; return 0; }   On peut se servir de ce nombre pour générer une lettre majuscule (en utilisant la représentation ASCII des lettres majuscules). Quelques codes ASCII utiles sont indiqués à l'exercice 3.  Ajouter le prototype d'une fonction createRobot dans le fichier robot.hpp, elle prendra en paramètre un point et une direction et retournera un robot avec les paramètres passés en argument. le nom du robot sera généré aléatoirement avec la fonction createRobotName. Compléter la fonction main du fichier main.cpp pour effectuer les actions suivantes:  Créer un robot avec la fonction createRobot à la position (0, 0) et la direction initiale north.Afficher le robot avec la méthode display.Effectuer les actions suivantes et afficher la valeur du robot avec la méthode displayune fois les actions effectuées: Tourner le robot à gaucheDéplacer le robot de 3 casesTourner le robot à droiteDéplacer le robot de 5 casesDéplacer le robot de 2 casesTourner deux fois le robot à gaucheDéplacer le robot de 1 caseTourner le robot à droiteDéplacer le robot de 2 cases  Utiliser les méthodes de la structure Robot pour effectuer les actions.  (Bonus) Utiliser un tableau pour stocker les actions à effectuer et les exécuter dans une boucle.  Vous pouvez utiliser des caractères (avec une std::string (qui est un tableau de caractères) ou un std::vector) pour symboliser les actions à effectuer: L : tourner à gaucheR : tourner à droite3 : déplacer le robot de 3 cases (de même pour tout les autres chiffres)Seulement les chiffres 1 à 9 sont à considérés, ainsi &quot;12&quot; correspond à un déplacement de 1 case puis un autre de 2 cases. ","version":"Next","tagName":"h2"},{"title":"Retours Généraux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks","content":"","keywords":"","version":"Next"},{"title":"Caractères et ASCII​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#caractères-et-ascii","content":" Pour comparer un caractère on peut en effet utiliser les codes ASCII mais on peut aussi utiliser le caractère directement.  c == 97 // est équivalent à c == 'a'   un caractère est en fait un entier(compris entre 0 et 255), donc on peut faire des opérations dessus.  char c = 'a'; c = c + 1; // c vaut maintenant 'b'   C'est un nombre qui à une représentation particulière(lorsqu'on l'affiche) mais c'est un nombre comme un autre.  Pour des comparaisons de caractères, il est préférable d'utiliser la notation avec les caractères directement car c'est plus lisible et plus simple à écrire.  c == 'a' // est plus lisible que c == 97   Par exemple si l'on souhaite savoir si un caractère est un lettre minuscule, on peut faire (en sachant que les lettres minuscules sont les caractères entre a et z et qu'ils sont consécutifs dans la table ASCII):  bool isLower(char c) { return c &gt;= 'a' &amp;&amp; c &lt;= 'z'; }   ","version":"Next","tagName":"h2"},{"title":"Condition​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#condition","content":" Pour retourner le résultat d'une condition, il n'est pas nécessaire de faire un if suivi d'un else avec un return dans chaque bloc.  #include &lt;cctype&gt; bool isVoyelle(char c) { c = std::tolower(c); if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') { return true; } else { return false; } }   En effet la condition c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' est déjà un booléen en soit, donc on peut directement le retourner.  C'est équivalent à faire:  if(true) { return true; } else { return false; }   Ca fonctionne mais c'est pas nécessaire et ça fait plus de code à écrire et à lire.  il faut donc plutôt retourner directement le résultat de la condition.  bool isVoyelle(char c) { c = std::tolower(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; }   ","version":"Next","tagName":"h2"},{"title":"Puissance​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#puissance","content":" Attention,  la syntaxe x**2 n'est pas valide en C++. Il faut utiliser la fonction pow de la bibliothèque cmath.  #include &lt;cmath&gt; int x = 2; int y = pow(x, 2); // y vaut 4   ou alors pour faire simplement un carré une multiplication suffit.  int x = 2; int y = x*x; // y vaut 4   ","version":"Next","tagName":"h2"},{"title":"Référence constante​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#référence-constante","content":" Lorsque l'on souhaite juste lire une variable en paramètre d'une fonction, on peut utiliser une référence constante. Particulièrement si cette variable est un &quot;gros&quot; objet comme une chaines de caractères, un tableau ou une structure.  Par exemple pour la fonction countVowels on peut utiliser une référence constante pour le paramètre s qui est un std::string ça permet de ne pas faire de copie de la chaîne de caractère.  int countVowels(std::string const&amp; s) { // ... }   ","version":"Next","tagName":"h2"},{"title":"Initialisation d'un générateur de nombre aléatoire​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#initialisation-dun-générateur-de-nombre-aléatoire","content":" std::srand(seed); permet d'initialiser le générateur de nombre aléatoire avec une valeur qui change à chaque fois que l'on exécute le programme.  On doit l'appeler une seule fois au début du programme et pas dans une fonction qui retourne un nombre aléatoire. Car sinon on réinitialise le générateur à chaque utilisation de la fonction et on obtient toujours le même nombre aléatoire. (sauf si le paramètre seed lui même change à chaque fois mais ça reste pas une bonne solution).  ","version":"Next","tagName":"h2"},{"title":"Include​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#include","content":" Pour pouvoir utiliser les définitions ou fonction écrit dans un fichier depuis un autre il faut utiliser la directive #include.  Par example, pour pouvoir utiliser l'énumération Direction dans le fichier Point.cpp (on en a besoin pour définit la fonction move), il faut inclure le fichier Direction.hpp dans le fichier Point.cpp.  ","version":"Next","tagName":"h2"},{"title":"Séparation des responsabilités​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#séparation-des-responsabilités","content":" Dans l'idéal, il faut que chaque fonction ait une seule responsabilité. C'est à dire qu'elle ne doit faire qu'une seule chose. Cela permet de mieux réutiliser le code et permet d'être plus flexible dans l'utilisation de la fonction.  Par exemple, si on veut trouver la valeur maximale d'un tableau, on peut créer une fonction max et ensuite afficher le résultat.  int max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; for (size_t i {1}; i &lt; vec.size(); ++i) { if (vec[i] &gt; max) { max = vec[i]; } } return max; } int main() { std::vector&lt;int&gt; vec {1, 2, 3, 4, 5}; std::cout &lt;&lt; &quot;la valeur maximale est: &quot; &lt;&lt; max(vec) &lt;&lt; std::endl; }   Plutôt que de faire:   void max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; // ... std::cout &lt;&lt; &quot;la valeur maximale est: &quot; &lt;&lt; max &lt;&lt; std::endl; } int main() { std::vector&lt;int&gt; vec {1, 2, 3, 4, 5}; max(vec); }   Car imaginons que l'on veuille utiliser la fonction max pour autre chose (un algorithme de tri par exemple), on ne peut pas car la fonction max affiche le résultat et ne le retourne pas. Ou si elle l'affiche et le retourne, cela va tout de même &quot;polluer&quot; l'affichage sans que l'on puisse le contrôler.  ","version":"Next","tagName":"h2"},{"title":"Concaténation de chaînes de caractères​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#concaténation-de-chaînes-de-caractères","content":" Pour construire une chaîne de caractères, on peut utiliser l'opérateur + pour concaténer des chaînes de caractères.  Mais il faut faire attention à bien utiliser des chaînes de caractères et pas des caractères.  Les caractères étant des nombres, l'opérateur + va faire une addition et non une concaténation.   std::string hello {&quot;Hello&quot;}; std::string world {&quot;World&quot;}; std::string helloWorld {hello + world}; //fonctionne std::string he {'H' + 'e'}; // ne fonctionne pas // Erreur de compilation : &quot;error: narrowing conversion of ‘173’ from ‘int’ to ‘char’ [-Wnarrowing]&quot;   On ne peux pas non plus faire :   std::string helloWorld {&quot;Hello&quot; + &quot;World&quot;}; // ne fonctionne pas // Erreur de compilation : &quot;error: invalid operands of types ‘const char [6]’ and ‘const char [6]’ to binary ‘operator+’&quot;   Car &quot;Hello&quot; et &quot;World&quot; ne sont pas encore à ce stade des std::string du C++ mais des tableaux de caractères du C. On ne peut pas utilise l'opérateur + sur des tableaux de caractères.  Si l'on souhaites construire une chaîne de caractères à partir de caractères, il faut utiliser la méthode std::string::push_back qui permet d'ajouter un caractère à la fin d'une chaîne de caractères.   std::string hello; helloWorld.push_back('H'); helloWorld.push_back('e'); helloWorld.push_back('l'); helloWorld.push_back('l'); helloWorld.push_back('o');   Ou alors utiliser l'opérateur + ou la méthode std::string::append qui permet d'ajouter une chaîne de caractères à la fin d'une autre chaîne de caractères.   std::string helloWorld {&quot;Hello&quot;}; helloWorld.append(&quot; World&quot;); helloWorld += &quot; !&quot;;   ","version":"Next","tagName":"h2"},{"title":"Unsigned int et std::cin​","type":1,"pageTitle":"Retours Généraux","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks#unsigned-int-et-stdcin","content":" Lorsque l'on utilise std::cin pour lire un nombre entier, si l'on souhaite stocker ce nombre dans un unsigned int il faut faire attention à ce que l'utilisateur ne rentre pas un nombre négatif. Car dans ce cas std::cin ne va pas signaler d'erreur mais va tenter de stocker la valeur négative dans un unsigned int et va donc stocker une valeur qui n'est pas celle que l'utilisateur a rentré. Cela peut provoquer des bugs dans le programme.  Exemple:  #include &lt;iostream&gt; int main() { unsigned int age; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; if (std::cin.fail()) { std::cout &lt;&lt; &quot;Invalid input.&quot; &lt;&lt; std::endl; return 1; } std::cout &lt;&lt; &quot;You are &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }   Avec des lettres il y a bien une erreur:  Enter your age: test Invalid input.   Avec un nombre négatif, il n'y a pas d'erreur mais le résultat n'est pas celui attendu:  Enter your age: -5 You are 4294967291 years old.   Ici la valeur s'explique par le fait qu'il y a un dépassement (un unsigned int ne peut pas stocker de nombre négatif) et il y a donc une conversion implicite (cast) de -5 en unsigned int qui donne 4294967291.  Un unsigned int qui est codé sur 32 bits. Donc la valeur maximale que l'on peut stocker est 2^32 - 1 = 4294967295 et la valeur minimale est 0. Donc si l'on rentre -5 on obtient 2^32 - 5 = 4294967291.  Malheureusement, il n'y a pas de solution simple pour éviter ce problème. Il faut soit utiliser un int temporaire pour stocker la valeur et vérifier que la valeur est positive avant de la stocker dans l'unsigned int mais ce n'est pas idéal car on ne peut pas bénéficier des avantages de l'unsigned int à savoir stocker des nombres plus grands (car on passe par un int temporaire qui est plus limité pour les nombres positifs).  Il faut sinon lire la chaîne de caractère et la convertir ensuite par des fonctions (généralement du C) comme atoi ou strtol qui permettent de convertir une chaîne de caractère en nombre entier avec une gestion des erreurs au cas où la chaîne de caractère ne représente pas le nombre attendu. ","version":"Next","tagName":"h2"},{"title":"Git","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Git","content":"Git","keywords":"","version":"Next"},{"title":"IMAC TOWER DEFENSE","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#introduction","content":" Il est temps de mettre en pratique les connaissances acquises en programmation et en synthèse d'images.  Dans ce projet, vous allez créer un jeu de type tower defense en utilisant OpenGL. Le Tower Defense est une catégorie de jeu vidéo qui consiste à protéger un lieu, un objet ou une personne à l’aide de tours qui vont attaquer des vagues d’ennemies. Vous trouverez quelques clés pour comprendre cette catégorie de jeu dans cette vidéo Youtube.    Exemple de Tower Defense; source: pinterest    ","version":"Next","tagName":"h2"},{"title":"Cahier des charges​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#cahier-des-charges","content":" Voici les indications que vous devez respecter pour ce projet. Il s’agit des consignes du client. Néanmoins, si vous souhaitez modifier certains points, vous devez au préalable nous demander et nous convaincre des changements. Certains points seront explicités dans les parties suivantes.  ","version":"Next","tagName":"h2"},{"title":"Fonctions/Gameplay​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#fonctionsgameplay","content":" Carte: Le jeu affiche une carte ou l’on peut identifier clairement le ou les départ.s des ennemies, leur destination (votre élément à protéger) et plusieurs chemins qu’ils peuvent emprunter. Tours: L’utilisateur peut poser des tours en dehors des éléments cités au-dessus. Ces tours vont agir lorsqu’un ennemie passe à proximité, par défaut, il va attaquer pour l’empêcher d’atteindre l’objectif, mais vous pouvez imaginer d’autres comportements. Vague Ennemies: L’utilisateur peut déclencher les vagues d’attaques des ennemies. Un certain nombre d’ennemies vont se succéder pour atteindre l’objectif. Ils apparaissent dans les différents départs et avancent en utilisant les chemins les plus pertinents. Fin: Lorsque l’utilisateur réussit à repousser les vagues d’attaques ou si un certain nombres d’ennemis atteint leur destination, le jeu affiche un écran de fin (victoire ou défaite)  ","version":"Next","tagName":"h3"},{"title":"Projet​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#projet","content":" Structure du projet : Vous devez organiser votre code en fichiers et dossiers séparés. Nous recommandons l'utilisation d'un système de compilation CMake pour la compilation. Initialisation de la carte : Vous devez être capable de charger une carte à partir d'un fichier image et un fichier (texte) de configuration. Algorithmique : Vous devez mettre en place un graphe pour représenter les chemins de la carte. Vous devez également implémenter un algorithme de plus court chemin pour que les ennemies puissent trouver leur chemin vers la sortie. Synthèse d'image : Vous devez afficher les éléments du jeu (carte, tours, ennemies) en utilisant des sprites (textures) et la bibliothèque OpenGL. Gestion de Projet: Vous devez utiliser Git pour stocker/partager votre code et nous le rendre. Compilation: Un système de compilation Cmake devra être intégré à votre projet, d'autant que vous aurez à utiliser des bibliothèques (opengl, lecture d'images, ...). votre projet devra contenir tout ce qui permet de le compiler et fonctionner sur Linux ou Windows (plateforme de développement à préciser dans le rapport). Si développement sur macOS, pensez à tester votre programme sur une autre machine afin que l'on puisse le compiler sur Linux ou Windows afin de le tester.  Le projet est à faire par binôme ou trinômes. Les trinômes devront obligatoirement réaliser deux fonctionnalités supplémentaires par rapport aux binômes. Si vous choisissez une amélioration qui n'est pas dans la liste des améliorations suggérées, vous devrez nous en faire part pour validation.  ","version":"Next","tagName":"h3"},{"title":"Rapport​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#rapport","content":" Il contiendra une description des fonctionnalités implémentées de l'application (règles du jeu, etc), un guide succinct d'utilisation, et des captures d'écran.  Éventuellement, si vous souhaitez mettre en avant Un bout de code pour sa performance ou parce qu’il s’agit d’une idée intéressante, vous pouvez l'intégrer dans le rapport.  Post mortem: analyser le travail fourni, qu’est ce qui a bien fonctionné, quels ont été les problèmes rencontrés, comment vous les avez surmontés, auriez vous fait différemment ? Avec plus de temps, qu’est ce que vous pourriez ajouter ?  Ne nous faites pas des romans, vous pouvez faire court, par exemple 2 à 4 pages sans les illustrations.  ","version":"Next","tagName":"h3"},{"title":"Notation​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#notation","content":" Ce projet est commun aux matières : Programmation et algorithmique C++ et Synthèse d'images I. Le projet en lui-même possède deux aspects : une partie algorithmique et une partie infographie. Il y aura une base commune puis une note distinctive pour chaque matière.  Exemple: note commune: 8, note algo: 6, note SI: 5 = note finale algo 14, note finale SI 13    ","version":"Next","tagName":"h2"},{"title":"Structure de votre programme​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#structure-de-votre-programme","content":" Dans ce projet complexe, il est hors de question de n'utiliser qu'un seul fichier. Il vous faut donc séparer l'application en différents fichiers .cpp et .hpp. La découpe des fichiers est laissée à votre appréciation mais doit être logique. Globalement, le projet étant scindé en deux parties, il serait logique que la partition des fichiers en tienne compte.  Un système de compilation Cmake devra être intégré à votre projet, d'autant que vous aurez à utiliser des bibliothèques (opengl, lecture d'images, ...).  Note importante : Tout rendu de projet sans possibilité de le compiler sur Linux ou windows entraînera un 0 ! (sauf si vous avez une raison valable et que vous avez prévenu vos enseignants).  Votre projet devra être organisé à minima dans un répertoire suivant la structure suivante :  NomDuProjet/ \\-- src/ \\-- lib/ \\-- data/ \\-- images/ \\-- doc/ \\-- CMakeLists.txt   Le répertoire src contient les fichiers sources .cpp et .hpp (Vous avez la liberté de placer plutôt les fichiers d'entête .hpp dans un répertoire include si vous préférez ce type de structure de projet mais vous devrez alors adapter votre CMakeLists.txt).(Optionnel) Le répertoire lib contiendra les fichiers de vos bibliothèques ainsi que tout le nécessaire pour les compiler ou les inclure dans votre projet (Vous pouvez également utiliser des fetch Cmake pour inclure des librairies).Le répertoire data contient les fichiers .itd des niveaux (expliqués plus loin dans le sujet) et autres fichiers de données utiles pour votre jeu.Le répertoire images contient toutes les images du projet (sprite, niveaux, ...).Le répertoire doc contiendra toute la documentation, dont votre rapport.Enfin, un CMakeLists.txt permettant de compiler le projet.(Optionnel) un répertoire bin dans lequel sera exporté l'exécutable compilé du projet (le fichier exécutable ne doit pas être inclus dans le dépôt git).Tout dossier temporaire build (utilisé par cmake par exemple) ne devra pas être inclus sur git (.gitignore)  ","version":"Next","tagName":"h2"},{"title":"Carte et Fichier de description​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#carte-et-fichier-de-description","content":" Pour ce projet nous allons utiliser une carte à base de cases (tile-based). C'est à dire que la carte est segmentée de cases de même taille. Il y a différents types de cases: chemin, zone d'entrée, zone de sortie et case vide.  ","version":"Next","tagName":"h2"},{"title":"Données de la carte sous forme d'image​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#données-de-la-carte-sous-forme-dimage","content":" Pour représenter la carte, nous utilisons une image en couleur au format .png afin d'indiquer visuellement où sont situés les chemins, la/les zones d'entrées ainsi que la zone de sortie.  Attention il ne s'agit pas là de l'illustration de la carte, cans cette image, chaque pixel représente une case de la carte et la couleur du pixel indique une certaine information (le type entre autre). Ainsi, une image de 10x10 pixels représente une carte de 10x10 cases.  Voilà un exemple d'une carte de 8x8 pixels :    Chaque case devra être d'une couleur précise permettant d'associer à cette case le type de zone. Ici les couleurs utilisées sont :  Chemin : Blanc (255, 255, 255)Zone d'entrée : Bleu (0, 0, 255)Zone de sortie : Rouge (255, 0, 0)  Ces couleurs sont à préciser dans le fichier de description de la carte (voir section suivante) et permettront de déterminer de lire l'image et de déterminer le type de chaque case.  ","version":"Next","tagName":"h3"},{"title":"Chemin sous forme de graphe​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#chemin-sous-forme-de-graphe","content":" Pour permettre aux ennemies de se déplacer sur la carte, nous allons utiliser une représentation des chemins sous forme de graphe. Chaque nœud du graphe représente une intersection, un coude. La zone de sortie et d'entrée seront aussi des nœuds. Les arrêtes du graphe représentent les chemins reliant ces nœuds. Par soucis de facilité, nous allons considérer des lignes purement verticales ou horizontales.    Nous utiliserons ce graphe pour calculer le chemin le plus court entre la zone d'entrée et la zone de sortie pour les ennemies.  ","version":"Next","tagName":"h3"},{"title":"Fichier de description .itd​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#fichier-de-description-itd","content":" Les éléments constitutifs d'une carte sont regroupés dans un fichier texte de configuration simple d'extension .itd.  ℹ️ Les extensions : L'extension ne change pas la nature d'un fichier, il s'agit surtout d'un prefix qui permet au système d'exploitation (grossièrement parlant) de rapidement savoir si un fichier est de tel ou tel type sans regarder le contenu. Ici on choisit un prefix &quot;.itd&quot; (Imac Tower Defense), on aurait pu choisir &quot;.toto&quot;  Ce fichier sera en fait un simple fichier texte. Il indiquera les différents paramètres nécessaires pour charger les données d'un niveau, notamment les informations relatives à la carte.  ITD # ligne de commentaire map fichier.png # Blanc path 255 255 255 # Bleu in 0 0 255 # Rouge out 255 0 0 graph 8 node 0 1 1 1 node 1 6 1 2 node 2 6 3 3 node 3 4 3 4 node 4 4 4 5 node 5 2 4 6 node 6 2 6 7 node 7 6 6   La première ligne est constitué d'un mot clé (pour ce projet, ce sera toujours &quot;ITD&quot;) indiquant qu'il s'agit d'un fichier de description de carte ITD.  Les lignes d'après seront ordonnées selon la position dans le tableau suivant (et donc lu dans un ordre donné) et constituées de deux éléments : un mot clé et une valeur.  Mot clé\tDescription\tType de valeurmap\tNom du fichier image représentant la carte\tchaîne de caractères path\tCouleur représentant les cases de chemin\tTriplet R,V,B (0-255) in\tCouleur représentant la/les zone(s) d'entrée(s)\tTriplet R,V,B (0-255) out\tCouleur représentant la zone de sortie\tTriplet R,V,B (0-255) graph\tNombre de noeuds du graphe\tentier node\tDescription d'un noeud du graphe\tVoir ci-dessous  Les mots clés permettent de se repérer, de vérifier que les lignes sont dans le bon ordre lors de la lecture du fichier et donc d'indiquer si le fichier est mal formaté lors de sa lecture.  De plus, chaque ligne commençant par un &quot;#&quot; sera considéré comme une ligne de commentaire et ignoré pour la lecture du fichier (uniquement là pour des annotations si besoin comme dans l'exemple ci-dessus).  Comme vous pouvez le constater, le fichier contient la description du graphe représentant les chemins de la carte.  Un nœud est décrit par un mot clé node suivi de plusieurs valeurs :  Un entier positif ou nul indiquant l'indice de ce nœud.Deux coordonnées x, y indiquant la position (en cases) de ce nœud dans l'image/carte (1 pixel = 1 case).Enfin, une liste d'indices représentant les nœuds connectés.  Exemple node 1 6 1 2 corresponds au nœud d'indice 1 de position en cases (6, 1) et connecté au nœud d'indice 2.  Ces nœuds sont de natures différentes (Zone d'entrée des ennemies, zone de sortie, chemin) et cette nature est représentée dans l'image de la carte par un pixel d'une couleur particulière. On pourra donc en déduire le type de nœud en fonction de la couleur du pixel central de la case correspondante.  ","version":"Next","tagName":"h3"},{"title":"Validité du fichier​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#validité-du-fichier","content":" Plusieurs conditions doivent être remplies pour qu'une carte soit valide pour le jeu. Votre application devra être capable, lors du chargement, de vérifier si le fichier et donc la carte est valide ou non et d'indiquer à l'utilisateur si ce n'est pas le cas (par un message d'erreur par exemple).  Vous devez vérifier les éléments suivants :  toutes les lignes nécessaires sont présentes et dans le bon ordre.Triplet RGB valide pour les couleurs (comprises entre 0 et 255).Fichier image existant.Les coordonnées des noeuds sont valides (dans l'image).Existence d'au moins une zone d'entrée et de sortie (cette vérification pourra se faire implicitement lors de la recherche du chemin des ennemies).Existence d'au moins un chemin entre la zone d'entrée et de sortie (cette vérification pourra se faire implicitement lors de la recherche du chemin des ennemies).  Vous n'avez pas à vérifier que les arrêtes du graphe passent bien par des cases de chemin, Cela pourrait être une sécurité supplémentaire pour assurer une cohérence visuelle entre la carte et le graphe précisé dans le fichier mais ce n'est pas obligatoire (cf améliorations suggérés). Vous devez par contre faire attention lors de la création de votre fichier pour que cela soit le cas auquel cas vous observerez des comportements inattendus (ennemis ne trouvant pas de chemin par exemple).  ","version":"Next","tagName":"h3"},{"title":"Affichage de la carte​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#affichage-de-la-carte","content":" Pour la partie graphique, vous devez afficher la carte à l'écran.  Mais au lieu de simplement afficher les pixels de l'image, vous devez afficher des cases texturées en fonction du type de case (chemin, zone d'entrée, zone de sortie). Ces textures/images sont généralement appelées des sprites. Vous devez donc charger des sprites pour chaque type de case et les afficher à la place des pixels de l'image.    Exemple de rendu en remplaçant les cases par des sprites  Il faudra tenir compte de la taille de vos sprites pour placer correctement les sprites et afficher la carte correctement.  ","version":"Next","tagName":"h3"},{"title":"Éléments du jeu​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#éléments-du-jeu","content":" ","version":"Next","tagName":"h2"},{"title":"Déroulement d'une partie​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#déroulement-dune-partie","content":" Au début de la partie, le joueur dispose d'une certaine somme d'argent initiale pour construire des tours de défense. Ces tours sont là pour détruire des ennemis, arrivant par vagues, et qui cherchent à atteindre la zone de sortie. Si un ennemi parvient à atteindre la zone de sortie la partie est perdue. Autrement, au bout d'un certain nombre de vagues, si aucun ennemie n'a atteint la zone de sortie, le joueur a gagné.  Chaque ennemie détruit par les tours rapporte de l'argent au joueur. Cet argent permet au joueur de construire des nouvelles tours.  ","version":"Next","tagName":"h3"},{"title":"Les chemins​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#les-chemins","content":" Comme évoqué précédemment, les chemins sont représentés par des pixels d'une certaine couleur dans l'image de la carte mais surtout par un graphe dans le fichier .itd.  Ce graphe est utilisé pour calculer le chemin le plus court entre la zone d'entrée et la zone de sortie pour les ennemies.  Vous devez donc implémenter une structure de graphe pondéré pour représenter les chemins de la carte.  Pondéré car les arrêtes du graphe ont une longueur (en nombre de cases) qui correspond à la distance entre deux nœuds. Le poids d'une arrête est la distance entre les deux nœuds en nombre de cases.  Les ennemies se déplacent en utilisant le plus court chemin entre la zone d'entrée et leur destination. Vous devez implémenter l'algorithme de Dijkstra(recherche de chemin) pour trouver ce chemin.  ","version":"Next","tagName":"h3"},{"title":"Les ennemis​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#les-ennemis","content":" Un ennemi a 3 caractéristiques:  Des points de vie, ils se réduisent lorsqu'il est attaqué et lorsque ces points tombent à 0, l'ennemie meurt et se retire de la carte.Une vitesse indiquant combien de cases il parcourt en un temps donné.Une récompense indiquant combien d'argent le joueur gagne en l’éliminant.  Les ennemis arrivent par vagues. Idéalement, le niveau de difficulté du jeu devrait augmenter au fur et à mesure que le joueur progresse (nombre d'ennemies par vague, points de vie des ennemies, argent gagné, ...).  S'il y a plusieurs zones d'entrée, vous êtes libre de choisir comment les ennemies arrivent sur la carte (aléatoirement, en alternance, ...).  Les ennemis doivent se déplacer le long des chemins de la carte en continu. Par continuité, on entend que les ennemies ne se déplacent pas de case en case mais de manière &quot;fluide&quot;. Vous devez implémenter un algorithme de déplacement pour les ennemis pour faire en sorte qu'ils se déplacent de manière fluide le long du chemin trouvé par l'algorithme de recherche de chemin.  Astuce: Vous pouvez tout simplement utiliser des interpolations linéaires pour faire se déplacer un ennemi d'arrête en arrête.  Graphiquement, vous devez également représenter les ennemies par des sprites.  ","version":"Next","tagName":"h3"},{"title":"Les tours​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#les-tours","content":" Le joueur peut créer des tours de défense qui tireront sur les ennemies. Les tours ont trois caractéristiques :  La puissance indique les dégâts effectués par la tour.La portée indique en cases la distance (discrète) à laquelle la tour peut tirer (Cette distance sera mesurée avec la méthode de Chebyshev).  La distance de Chebyshev correspond à ce que l'on appelle la 8 connexités en traitement d'image. C'est une distance qui tient compte des déplacements en diagonale.  La cadence indique en nombre de dixième de secondes l'intervalle entre deux tirs.  Les différents paramètres de ces différentes tours (puissance, portée, cadence) sont laissés à votre appréciation. Chaque tour a également un coût d'achat pour pouvoir être placée dans la carte.  Voilà des exemples de types de tours :  Des tours avec une bonne portée, une cadence de tir élevée mais une puissance de tir faible.Des tours avec une puissance de tir élevée mais une cadence très lente et une distance de tir moyenne.Des tours avec une portée très courte mais avec une cadence de tir élevée et une puissance moyenne....  Les tours sont également représentées graphiquement par des sprites.  Les tours ne peuvent pas être placées sur un chemin, ni sur une autre tour. Il faut donc vérifier que le placement de la tour est valide en regardant le type de case et son contenu.  ","version":"Next","tagName":"h3"},{"title":"Interface graphique (IHM)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#interface-graphique-ihm","content":" Votre application contiendra au minimum une fenêtre d'affichage contenant la carte et une fenêtre contenant au moins un bouton permettant de quitter l'application.  Lors du lancement de l'application, une fois le fichier .itd chargé, le jeu peut commencer après une action de l'utilisateur (bouton, touche, ...).  Le jeu fonctionne en &quot;continu&quot; c'est-à-dire que c'est le temps qui rythme la succession des événements (tirs des tours, déplacement des ennemies, ...).  L'utilisateur peut par contre construire une tour quand il le souhaite. L'application doit indiquer visuellement si la case peut recevoir une tour.  Le joueur doit pouvoir mettre en pause l'application ou quitter le jeu à tout moment (via un bouton ou une touche).  Votre interface devra permettre de visualiser les éléments suivants :  la carte, les ennemies et les toursIndiquer l'argent restant disponibleIndiquer le prix des toursSélectionner une tour à construire (cela peut se faire par des boutons, des raccourcis clavier, ...)Placer cette tour dans la carte  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#résumé","content":" Pour résumer, voici les éléments que vous devez implémenter dans votre jeu :  ITD : Chargement d'un fichier (texte) de description de carte.Sprites : Des images pour représenter les éléments du jeu (carte, tours, ennemies).Graphes : Un graphe pondéré pour représenter les chemins de la carte.Ennemis : Des ennemis qui se déplacent le long des chemins de la carte pour atteindre la zone de sortie. Minimum 2 types.Déplacement des ennemies : Un algorithme pour faire se déplacer les ennemies de manière &quot;fluide&quot;.Dijkstra : Un algorithme de recherche de chemin pour les ennemies.Tours : Des tours de défense qui tirent sur les ennemies. Minimum 2 types.Tirs des tours : Les tours tirent sur les ennemies à intervalle régulier (la cadence de tir). Les tours tirent sur l'ennemi le plus proche d'elle.Placement des tours : Un système pour placer des tours sur une case valide.Argent : Un système d'argent pour acheter des tours. Les ennemies tués rapportent de l'argent.Fin : Un écran de fin indiquant une défaite ou une victoire.IHM : Une interface graphique pour visualiser les éléments du jeu (argent, points de vie, ...). Le joueur doit pouvoir mettre en pause le jeu ou quitter à tout moment.  ","version":"Next","tagName":"h2"},{"title":"Bonus et améliorations suggérés​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#bonus-et-améliorations-suggérés","content":" Tout outils, spécifications ou fonctionnalités supplémentaires seront récompensés. Nous vous suggérons les améliorations suivantes qui nous semblent intéressantes pour ce projet.  ","version":"Next","tagName":"h2"},{"title":"Zones constructibles pour les tours (algorithmique)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#zones-constructibles-pour-les-tours-algorithmique","content":" Mettons en place des zones constructibles pour les tours. Ces zones sont des cases de la carte où les tours peuvent être placées. Les zones constructibles sont représentées par des pixels d'une certaine couleur dans l'image de la carte.  Dans le fichier .itd, vous devrez ajouter une nouvelle ligne pour indiquer la couleur des zones constructibles.  Vous devrez également vérifier que le placement de la tour est valide en regardant si la case sous la tour est bien constructible lors de la construction de la tour.  ","version":"Next","tagName":"h3"},{"title":"A* pour la recherche de chemin (algorithmique)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#a-pour-la-recherche-de-chemin-algorithmique","content":" Vous pouvez remplacer l'algorithme de Dijkstra par l'algorithme A* pour la recherche de chemin. L'algorithme A* est un algorithme de recherche de chemin plus efficace que Dijkstra qui utilise une heuristique pour guider la recherche.  ","version":"Next","tagName":"h3"},{"title":"Placement intelligent des sprites de chemin (algorithmique et synthèse d'image)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#placement-intelligent-des-sprites-de-chemin-algorithmique-et-synthèse-dimage","content":" Pour l'affichage de la carte, vous devez utiliser des sprites pour représenter les éléments de la carte. Vous pouvez améliorer l'affichage en utilisant des auto-tiles. L'idée est d'afficher des sprites différents en fonction des cases adjacentes pour représenter les chemins de manière plus esthétique (au lieu de répéter la même sprite pour chaque case de chemin).    Exemple de rendu avec des auto-tiles  On peut remarquer qu'il a 4 adjacences (cas simple sans tenir compte des diagonales) pour une case (haut, bas, gauche, droite) et donc 16 possibilités de sprites différents pour une case de chemin.  Vous pouvez utiliser ce qu'on appel un masque binaire (bitmask) pour représenter les adjacences et donc les différentes possibilités de sprites et choisir le bon sprite à afficher en fonction de ce bitmask (dans un tableau de sprites, dans un tileset, ...).  Un bitmask est un nombre dont chaque bit représente une information. Par exemple, pour les auto-tiles, on peut utiliser un bitmask de 4 bits pour représenter les 4 adjacences d'une case de chemin. le premier bit représente l'adjacence du haut, le deuxième bit l'adjacence de gauche, le troisième bit l'adjacence du droite et le quatrième bit l'adjacence du bas.    Exemple de tileset utilisé pour générer l'exemple précédent  Plus d'explications sur cet article: https://code.tutsplus.com/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts--cms-25673t    Il est même possible d'aller plus loin en utilisant des algorithmes d'auto-tiling plus complexes qui tiennent compte des diagonales ou d'ajouter d'autres règles pour afficher des sprites supplémentaires en fonction de valeurs aléatoires ou de conditions particulières.  Cela peut se faire à l'aide de règles de placement de tiles successives (au lieu d'utiliser la technique du bitmask). Le bitmak est une technique simple et efficace pour commencer mais pourrait se remplacer par une succession de 16 règles de placement de tiles (si voisin haut et gauche alors sprite 1, si voisin haut et droite alors sprite 2, ...).  un exemple avec l'ajout d'herbes et arbres sur les cases qui ne sont pas des chemins de manière aléatoire :    ","version":"Next","tagName":"h3"},{"title":"Sprite animé (synthèse d'image)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#sprite-animé-synthèse-dimage","content":" Pour les ennemies, vous pouvez ajouter une animation pour les ennemies. Par exemple, vous pouvez faire en sorte que les ennemies aient une animation de marche lorsqu'ils se déplacent.  Cela peut se faire en utilisant plusieurs sprites pour représenter les différentes étapes de l'animation. Ces sprites sont affichés les uns après les autres pour donner l'illusion du mouvement.  Les différentes sprites sont généralement regroupées dans une seule image appelée sprite sheet.  Exemple de sprite sheet pour un effet de feu :    ","version":"Next","tagName":"h3"},{"title":"Generation du graphe à partir de l'image (algorithmique)​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#generation-du-graphe-à-partir-de-limage-algorithmique","content":" On peut se rendre compte que détailler le graphe dans un fichier texte peut être fastidieux et source d'erreur. Cela fait donc sens de générer ce graphe à partir de l'image de la carte. Cela rendrait la création de niveaux plus simple et plus rapide et éviterait les erreurs de saisie.  L'image étant relativement simple, il est possible de parcourir l'image pixel par pixel (et donc case par par case) pour trouver les noeuds et les arrêtes du graphe.  L'idée est de parcourir l'image et de trouver dans un premier temps un noeud évident (zone d'entrée, zone de sortie) puis à partir de ce noeud itérer dans les 4 directions pour trouver les autres noeuds et les arrêtes du graphe (chemins) de proche en proche. Cela peut se faire de manière récursive ou itérative c'est à vous de voir.  Si vous décidiez d'implémenter cette amélioration, vous pourrez donc omettre la partie graph et node du fichier .itd. Il faudra le gérer dans votre code (détecter l'absence de ces lignes et générer le graphe à partir de l'image ou introduire un nouveau mot clé dans le fichier .itd pour indiquer que le graphe doit être généré à partir de l'image).  Si vous avez des questions sur cette amélioration, n'hésitez pas à demander à vos enseignants d'algorithmie pour plus de détails.  ","version":"Next","tagName":"h3"},{"title":"Autres améliorations possibles​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#autres-améliorations-possibles","content":" On peut penser notamment à :  Différents types de ennemies avec des caractéristiques différentes.Différents types de tours avec des caractéristiques différentes.Déplacement stochastique des ennemies : déplacement aléatoire à chaque noeud rencontré.Différents types de terrain pour les chemins ralentissant ou accélérant les ennemies.Visualisation des tirs des tours sur les ennemies.Sélection des ennemies et affichage de leurs propriétés.Dans le cas de différents types de tours, avoir une résistance propre à chacun des types de tours pour les ennemies.Créer une zone de sortie ayant des points de vie, encaissant les dégâts des ennemies avant de perdre la partie.Stratégies différentes pour les tours (priorité sur les ennemies les plus proches, les plus faibles, les plus forts, ...).Fonctionnalité de sauvegarde et de chargement de partie....  Néanmoins, si une nouvelle fonctionnalité modifiait même de manière légère les spécifications, notamment le format des fichiers .itd, présentes dans cette description de projet alors cette nouvelle fonctionnalité devra être validée par vos enseignants. Elle devra aussi être indiquée clairement dans le rapport.  ","version":"Next","tagName":"h3"},{"title":"Conseils et remarques​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#conseils-et-remarques","content":" Ce sujet de projet constitue un cahier des charges de l'application. Tout changement à propos des spécifications du projet doit être validée par vos enseignants. Le temps qui vous est imparti n'est pas de trop pour réaliser ce projet. N'attendez pas le dernier mois pour commencer à coder. Il est très important que vous réfléchissiez avant de commencer à coder aux principaux modules, algorithmes et aux principales structures de données que vous utiliserez pour votre application. Il faut également que vous vous répartissiez le travail et que vous déterminiez les tâches à réaliser en priorité. Ne rédigez pas le rapport à la dernière minute sinon il sera bâclé. Il est impératif que chacun d'entre vous travaille sur une partie et non pas tous &quot;en même temps&quot; (plusieurs qui regardent un travailler). Sinon, vous n'aurez pas le temps de tout faire. C'est encore plus vrai pour les trinômes. Rappel: Les trinômes devront obligatoirement réaliser des fonctionnalités supplémentaires (expliquées dans la section projet) par rapport aux binômes. Utilisez la bibliothèque standard C++ pour les structures du type listes (std::vector), piles (std::stack), files (std::queue). N'oubliez pas de tester votre application à chaque spécification implémentée. Il est impensable de tout coder puis de tout vérifier après. Pour les tests, confectionnez-vous tout d'abord de petites cartes (taille 5 par 5 par exemple) avec un chemin extrêmement simple. Si cela marche, vous pouvez passer à plus gros ou plus complexe. Vos chargés de TD et CM sont là pour vous aider. Si vous ne comprenez pas un algorithme ou avez des difficultés sur un point (problème technique, compréhension du sujet, etc), n'attendez pas la soutenance pour nous en parler ! Vous ne devez utiliser que des assets libres de droit pour votre projet. Vous devez citer les sources des assets utilisés dans votre rapport. Vous pouvez bien sûr créer vos propres assets.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"IMAC TOWER DEFENSE","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/sujet#sources","content":" Assets utilisés pour les illustrations :  kenney: pixel-shmupbrullov: fire-animation  Logiciel utilisé pour créer les images :  Ldtk ","version":"Next","tagName":"h2"},{"title":"Correction","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annals/IMAC2026/S1/correction","content":"Correction Exercice 1 Quelle est la différence entre un tableau statique et un tableau dynamique ? Un tableau statique est un tableau dont la taille est connue à la compilation, c'est à dire que la taille du tableau est fixe et ne peut pas être modifiée pendant l'exécution du programme (std::array en C++). Un tableau dynamique est un tableau dont la taille peut varier pendant l'exécution du programme (std::vector en C++). Pour cela, il faut utiliser de l’allocation dynamique de mémoire. Quelle est la différence entre l'opérateur = et l'opérateur == ? L'opérateur = permet d'affecter une valeur à une variable. int a {1}; int b {2}; a = b; // a vaut maintenant 2 L'opérateur == permet de comparer deux valeurs et retourne un booléen. int a {1}; int b {2}; bool c {a == b}; // c vaut false Qu’entendez-vous par passage par copie et passage par référence(&amp;) ? Le passage par copie consiste à passer une copie de la variable en paramètre de la fonction. C'est à dire que la variable en paramètre de la fonction est une copie de la variable passée en paramètre lors de l'appel de la fonction. void addOne(int x) { // Ici x est une variable locale à la fonction addOne // x est une copie de la variable passée en paramètre lors de l'appel de la fonction x += 1; } int main() { int a {1}; addOne(a); // a vaut toujours 1 } Le passage par référence consiste à passer une référence de la variable en paramètre de la fonction. C'est à dire que la variable en paramètre de la fonction utilise le même espace mémoire que la variable passée en paramètre lors de l'appel de la fonction. Cela permet de modifier et manipuler directement la variable passée en paramètre lors de l'appel de la fonction. void addOne(int&amp; x) { // Ici x est un référence à la variable passée en paramètre lors de l'appel de la fonction x += 1; } int main() { int a {1}; addOne(a); // a vaut maintenant 2 } A quoi servent les mots clés const et unsigned ? Quand et pourquoi les utiliser ? Le mot clé const permet de déclarer une variable constante. C'est à dire que la variable ne peut pas être modifiée après son initialisation. int main() { const int a {1}; a = 2; // Erreur: a est une variable constante } Cela permet de s'assurer que la variable ne sera pas modifiée par erreur et rajoute de la sécurité au programme. On peut également préciser qu'une méthode ne modifie pas l'objet sur lequel elle est appelée en utilisant le mot clé const après la déclaration de la méthode. struct Point { // ... void display() const; }; Cela permet de pouvoir utiliser la méthode sur un objet constant (sinon ce n'est pas possible). int main() { Point const p {1, 2}; p.display(); // OK } Le mot clé unsigned permet de déclarer une variable non signée. C'est à dire que la variable ne peut pas prendre de valeur négative. Cela permet de s'assurer que la variable ne sera pas négative lors de son utilisation. Cela a aussi l’avantage de doubler la valeur maximale que peut prendre la variable (comme il n'y a plus de valeur négative à stocker). En C++, size_t est un alias pour unsigned long long int (un entier non signée) et est souvent utilisé dans les boucles ou pour représenter la taille d'un tableau ou d'un conteneur (c'est la taille maximale que peut prendre un tableau ou un conteneur). Exercice 2 #include &lt;iostream&gt; #include &lt;vector&gt; // Par référence constante pour éviter de faire une copie du vecteur et pour pouvoir utiliser la fonction sur un vecteur constant int max(std::vector&lt;int&gt; const&amp; vec) { int max {vec[0]}; // Ici je commence à l'index 1 car j'ai déjà initialisé max avec la première valeur du tableau for (size_t i {1}; i &lt; vec.size(); ++i) { if (vec[i] &gt; max) { max = vec[i]; } } return max; } // Version alternative avec un &quot;Range-based for loop&quot; // int max(std::vector&lt;int&gt; const&amp; vec) { // int max = vec[0]; // for (int value: vec) // { // if (value &gt; max) // { // max = value; // } // } // return max; // } int main() { std::vector&lt;int&gt; v1 {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::cout &lt;&lt; max(v1) &lt;&lt; std::endl; std::vector&lt;int&gt; const v2 {9, 8, 7, 6, 5, 4, 3, 2, 1}; std::cout &lt;&lt; max(v2) &lt;&lt; std::endl; // Aussi par valeur comme on a bien une référence constante std::cout &lt;&lt; max({9, 8, 7, 6, 5, 4, 3, 2, 1}) &lt;&lt; std::endl; } Détail du &quot;Range-based for loop&quot; ici Exercice 3 #include &lt;iostream&gt; #include &lt;cctype&gt; bool isVowel(char c) { c = std::tolower(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; } // version alternative avec un tableau (chaîne de caractères) contenant les voyelles // bool isVowel(char c) { // c = std::tolower(c); // std::string const vowels {&quot;aeiouy&quot;}; // for (char vowel: vowels) // { // if (c == vowel) // { // return true; // } // } // return false; // } // Il existe aussi d'autres façon de faire comme avec la méthode find de la classe std::string size_t countVowels(std::string const&amp; str) { size_t count {0}; for(char c: str) { if(isVowel(c)) { count += 1; } } return count; } int main() { std::string helloWorldStr {&quot;Hello World!&quot;}; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; helloWorldStr &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;: &quot; &lt;&lt; countVowels(helloWorldStr) &lt;&lt; std::endl; std::string testStr {&quot;Ceci est un test&quot;}; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; testStr &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;: &quot; &lt;&lt; countVowels(testStr) &lt;&lt; std::endl; // Aussi possible par valeur comme on a bien une référence constante std::cout &lt;&lt; &quot;\\&quot;Je suis une phrase avec des voyelles\\&quot; : &quot; &lt;&lt; countVowels(&quot;Je suis une phrase avec des voyelles&quot;) &lt;&lt; std::endl; } Exercice 4 #include &lt;iostream&gt; #include &lt;cmath&gt; struct Point { float x {0f}; float y {0f}; }; float distance(Point const&amp; p1, Point const&amp; p2) { return std::sqrt(std::pow(p1.x - p2.x, 2) + std::pow(p1.y - p2.y, 2)); } // sans utiliser la fonction pow // float distance(Point const&amp; p1, Point const&amp; p2) { // float diff_x {p1.x - p2.x}; // float diff_y {p1.y - p2.y}; // return std::sqrt(diff_x*diff_x + diff_y*diff_y); // } bool isInCircle(Point const&amp; p, Point const&amp; center, float radius) { return distance(p, center) &lt; radius; } bool isCirclesIntersect(Point const&amp; c1, float r1, Point const&amp; c2, float r2) { return distance(c1, c2) &lt; (r1 + r2); } // BONUS struct Circle { Point center; float radius; }; bool isInCircle(Point const&amp; p, Circle const&amp; circle) { return distance(p, circle.center) &lt; circle.radius; } bool isCirclesIntersect(Circle const&amp; c1, Circle const&amp; c2) { return distance(c1.center, c2.center) &lt; (c1.radius + c2.radius); } int main() { Point circle_center {0, 1}; float circle_radius {2.4f}; // Optionnel: Permet d'afficher les booléens sous forme de true/false (et pas 0/1) std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;(0, 0) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({0, 0}, circle_center, circle_radius) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(1, 1) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({1, 1}, circle_center, circle_radius) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(3, 4) isInCircle ((0, 1), 2.4f): &quot; &lt;&lt; isInCircle({3, 4}, circle_center, circle_radius) &lt;&lt; std::endl; // BONUS Circle c1 { p1, 1.2f}; Circle c2 { p2, 1.f}; std::cout &lt;&lt; &quot;c1 intersect c2 :&quot; &lt;&lt; isCirclesIntersect(c1, c2) &lt;&lt; std::endl; return 0; } Robot src/direction.hpp #pragma once #include &lt;string&gt; enum class Direction { north, east, south, west }; std::string to_string(Direction direction); src/direction.cpp #include &quot;direction.hpp&quot; std::string to_string(Direction direction) { switch (direction) { case Direction::north: return &quot;north&quot;; // break pas nécessaire ici car on utilise le mot clé return qui permet de sortir immédiatement de la fonction case Direction::east: return &quot;east&quot;; case Direction::south: return &quot;south&quot;; case Direction::west: return &quot;west&quot;; } } src/point.hpp #pragma once // J'ai besoin de la déclaration de Direction pour pouvoir déclarer la méthode move #include &quot;direction.hpp&quot; struct Point { int x {0}; int y {0}; // BONUS: Ici la méthode peut être déclarée comme const car elle ne modifie pas la structure void display() const; void move(Direction const d, unsigned int const n); }; src/point.cpp #include &quot;point.hpp&quot; #include &lt;iostream&gt; // Ici je n'ai pas afficher de retour à la ligne afin de pouvoir réutiliser la méthode ensuite dans robot.cpp void Point::display() const { std::cout &lt;&lt; '(' &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; ')'; } void Point::move(Direction const d, unsigned int const n) { switch (d) { case Direction::north: y += n; break; case Direction::east: x += n; break; case Direction::south: y -= n; break; case Direction::west: x -= n; break; } } src/robot.hpp #pragma once #include &lt;string&gt; #include &quot;direction.hpp&quot; #include &quot;point.hpp&quot; struct Robot { std::string name; Point position; Direction direction; void display() const; void turnLeft(); void turnRight(); void move(unsigned int const n); }; std::string createRobotName(); Robot createRobot(Point position, Direction direction); src/robot.cpp #include &quot;robot.hpp&quot; #include &lt;cstdlib&gt; #include &lt;iostream&gt; void Robot::display() const { std::cout &lt;&lt; name &lt;&lt; '('; position.display(); std::cout &lt;&lt; &quot;, &quot; &lt;&lt; to_string(direction) &lt;&lt; ')'; } void Robot::turnLeft() { switch (direction) { case Direction::north: direction = Direction::west; break; case Direction::east: direction = Direction::north; break; case Direction::south: direction = Direction::east; break; case Direction::west: direction = Direction::south; break; } } void Robot::turnRight() { switch (direction) { case Direction::north: direction = Direction::east; break; case Direction::east: direction = Direction::south; break; case Direction::south: direction = Direction::west; break; case Direction::west: direction = Direction::north; break; } } void Robot::move(unsigned int const n) { position.move(direction, n); } std::string createRobotName() { std::string name {&quot;&quot;}; for(size_t i {0}; i &lt; 2; ++i) { name += 'A' + (std::rand() % (25+1)); } for(size_t i {0}; i &lt; 3; ++i) { name += '0' + (std::rand() % (9+1)); } return name; } Robot createRobot(Point position, Direction direction) { return Robot { createRobotName(), position, direction }; } src/main.cpp #include &lt;iostream&gt; #include &lt;ctime&gt; #include &quot;direction.hpp&quot; #include &quot;point.hpp&quot; #include &quot;robot.hpp&quot; int main() { // Initialisation du générateur de nombre aléatoire std::srand(std::time(nullptr)); // Test direction Direction direction_test {Direction::north}; std::cout &lt;&lt; to_string(direction_test) &lt;&lt; std::endl; // Test point Point p1 {1, 2}; p1.display(); std::cout &lt;&lt; std::endl; p1.move(Direction::east, 3); p1.display(); std::cout &lt;&lt; std::endl; Robot robot {createRobot(Point{0, 0}, Direction::north)}; std::count &lt;&lt; &quot;Robot start value: &quot;; robot.display(); std::cout &lt;&lt; std::endl; robot.turnLeft(); robot.move(3); robot.turnRight(); robot.move(5); robot.move(2); robot.turnLeft(); robot.move(1); robot.turnRight(); robot.move(2); std::count &lt;&lt; &quot;Robot end value: &quot;; robot.display(); std::cout &lt;&lt; std::endl; // Version alternative avec boucle sur une chaîne de caractère pour indiquer les actions à effectuer robot = createRobot(Point{0, 0}, Direction::north); for (char action : &quot;L3R52L1R2&quot;) { // number test if (action &gt;= 48 &amp;&amp; action &lt;= 57) { robot.move(static_cast&lt;int&gt;(action - '0')); } else if (action == 'R') { robot.turnRight(); } else if(action == 'L') { robot.turnLeft(); } else { if (action != '\\0') { std::cout &lt;&lt; &quot;unknown action :&quot; &lt;&lt; action; } } robot.display(); std::cout &lt;&lt; std::endl; } } CMakeLists.txt # la version de cmake à utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # On souhaite placer l'exécutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Le nom du projet project(Robot) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources # message(STATUS &quot;Found source files:&quot;) # foreach(SRC_FILE ${SRC_FILES}) # message(STATUS &quot; - ${SRC_FILE}&quot;) # endforeach() # On indique que l'on souhaite faire un exécutable avec nos fichiers sources add_executable(robot ${SRC_FILES}) # le dossier contenant les fichiers d'en-tête pour notre executable target_include_directories(robot PUBLIC &quot;src/&quot;) ","keywords":"","version":"Next"},{"title":"Utiliser des bibliothèques en C++","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Libraries","content":"","keywords":"","version":"Next"},{"title":"Fonctionnement d'une bibliothèque​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#fonctionnement-dune-bibliothèque","content":" La plupart des bibliothèques sont constituées de la même façon : elles contiennent un ensemble de fichiers d'en-tête (extension .h ou .hpp) et des fichiers contenant le code machine de la bibliothèque. Les premiers contiennent les déclarations et sont utile pour l'étape de compilation, les seconds contiennent les définitions et sont utiles pour l'étape de linkage.  ","version":"Next","tagName":"h2"},{"title":"Statique ou dynamique​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#statique-ou-dynamique","content":" Les fichiers en question peuvent être de deux types : statiques ou dynamiques.  Lorsque l'on compile un programme qui utilise une bibliothèque statique, le compilateur va inclure les définitions de la bibliothèque (à l'aide des fichiers objets statiques) dans le fichier exécutable au moment de l'étape de linkage. Cela signifie que le fichier exécutable sera plus gros, mais il n'aura pas besoin d'autres fichiers pour s'exécuter. Avec une bibliothèque dynamique, la bibliothèque n'est pas inclus dans le fichier exécutable. Au lieu de cela, le fichier exécutable contient des références aux fonctions et aux classes de la bibliothèque. Le contenu de la bibliothèque est stocké dans un fichier de bibliothèque (extension .lib ou .dll sur Windows, .so sur Linux et .dylib sur Mac). Lorsque l'on exécute le programme, le système d'exploitation charge le fichier de bibliothèque en mémoire et fait les correspondances entre les références et les définitions. Cela signifie que le fichier exécutable sera plus petit, mais il aura besoin de la bibliothèque pour s'exécuter. L'avantage est que plusieurs programmes peuvent utiliser le même fichier de bibliothèque en mémoire. l’inconvenant et qu'il faut que la bibliothèque soit présente sur le système d'exploitation ou il faut fournir le fichier de bibliothèque avec le programme (généralement dans le même dossier que l'exécutable).  ","version":"Next","tagName":"h3"},{"title":"Header only​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#header-only","content":" Certaines bibliothèques ne contiennent que des fichiers d'en-tête. Cela signifie que les déclarations et les définitions sont dans les mêmes fichiers (cela ne pose pas de problème en utilisant certains concepts avancés du langage C++). Ces bibliothèques sont appelées header only. Elles sont très faciles à utiliser, car il suffit de les inclure dans le programme pour pouvoir les utiliser.  ","version":"Next","tagName":"h3"},{"title":"Debug ou release​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#debug-ou-release","content":" Une bibliothèque peut être compilée en mode debug ou en mode release. En mode debug, la bibliothèque contient des informations supplémentaires qui permettent de déboguer le programme (cela s’accompagne parfois d'un fichier supplémentaire avec les informations de débogage). En mode release, la bibliothèque est optimisée pour la performance ou la taille du fichier exécutable.  ","version":"Next","tagName":"h3"},{"title":"Inclusion d'une bibliothèque​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#inclusion-dune-bibliothèque","content":" Il existe plusieurs façons d'inclure une bibliothèque dans un programme et nous allons découvrir les différentes méthodes et les mettre en pratique avec Cmake.  ","version":"Next","tagName":"h2"},{"title":"CMake FetchContent​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#cmake-fetchcontent","content":" Cmake inclut une fonctionnalité qui permet de télécharger une bibliothèque et de l'inclure dans le projet. Cela s'appel FetchContent et nous allons l'utiliser ensuite dans des exemples.  L'avantage est que cela fonctionne sur tous les systèmes d'exploitation et de ne pas avoir à gérer les fichiers de la bibliothèque manuellement.  ","version":"Next","tagName":"h3"},{"title":"Inclusion manuelle​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#inclusion-manuelle","content":" Il est toujours possible d'inclure une bibliothèque manuellement. Il faut d'abord télécharger la bibliothèque et décompresser les fichiers si nécessaire. Ensuite, il faut indiquer au compilateur (via CMake) où se trouve la bibliothèque et où se trouvent les fichiers d'en-tête. Cela va permet de compiler la bibliothèque et d'inclure les fichiers d'en-tête dans le programme.  Parfois certaines bibliothèques utilisent également CMake pour faciliter l'inclusion de la bibliothèque dans un projet. Dans ce cas on peut simplement indiquer le dossier de la bibliothèque à cmake et il se chargera de tout.  ","version":"Next","tagName":"h3"},{"title":"Gestionnaire de dépendances​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#gestionnaire-de-dépendances","content":" Enfin, il des outils nommés gestionnaires de dépendances qui permettent de télécharger et installer/compiler des bibliothèques automatiquement sur le système d'exploitation. Une fois installées, il suffit d'indiquer au compilateur que l'on souhaite utiliser la bibliothèque et elle va être incluse automatiquement et trouver les fichiers d'en-tête et les fichiers de la bibliothèques sur le système d'exploitation. C'est une des raisons pour lesquelles certains développeurs préfèrent utiliser Linux plutôt que Windows. Il existe des alternatives pour Windows, comme vcpkg ou conan mais ce n'est pas aussi simple que sur Linux.  ","version":"Next","tagName":"h3"},{"title":"Glm​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#glm","content":" Glm est une bibliothèque qui contient des classes et des fonctions pour faire des calculs mathématiques. Elle est très utile pour faire des calculs en 2D et en 3D, comme par exemple des rotations, des translations, des projections, etc.  Glm est une bibliothèque header only. Cela signifie que les déclarations et les définitions sont dans les mêmes fichiers. Il suffit donc de les inclure dans le programme pour pouvoir utiliser la bibliothèque.  ","version":"Next","tagName":"h2"},{"title":"FetchContent et Cmake​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#fetchcontent-et-cmake","content":" Pour télécharger et inclure glm dans un projet CMake nous allons utiliser la fonctionnalité FetchContent.  Premièrement il faut indiquer à CMake que l'on souhaite utiliser la fonctionnalité FetchContent. C'est une fonction qui est incluse dans CMake à partir de la version 3.11, mais qui n'est pas activée par défaut. Pour l'activer, il faut ajouter la ligne suivante avant de l'utiliser dans CMakeLists.txt :  include(FetchContent)   FetchContent permet de télécharger une bibliothèque depuis un url ou un dépôt git. Nous allons utiliser la fonction FetchContent_Declare pour indiquer à cmake que l'on souhaite télécharger la bibliothèque glm depuis un dépôt git.  Il suffit d'ajouter les lignes suivantes dans le fichier CMakeLists.txt :  FetchContent_Declare( glm GIT_REPOSITORY https://github.com/g-truc/glm GIT_TAG efec5db081e3aad807d0731e172ac597f6a39447 )   La fonction FetchContent_Declare prend plusieurs paramètres :  Le nom de la bibliothèque (ici glm)L'url du dépôt git (ici https://github.com/g-truc/glm)Le tag git qui fait référence au commit que l'on souhaite télécharger (ici efec5db081e3aad807d0731e172ac597f6a39447)  Une fois que l'on a déclaré où trouver la bibliothèque, il faut indiquer à CMake que l'on souhaite la télécharger et la rendre disponible dans le projet. Pour cela, on utilise la fonction FetchContent_MakeAvailable :  FetchContent_MakeAvailable(glm)   Une fois disponible, on peut préciser que l'on souhaite utiliser la bibliothèque glm dans une target CMake avec la fonction target_link_libraries :  target_link_libraries(&lt;target&gt; PUBLIC glm)   Une fois tout assemblé, Voilà un exemple de fichier CMakeLists.txt qui utilise glm :  cmake_minimum_required(VERSION 3.20) project(test) // Permet de changer le dossier de sortie des fichiers exécutables (pour qu'ils soient dans un dossier bin au lieu d'être mélangé avec les autres fichiers temporaires dans le dossier build) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) // Ajoute des options de compilation pour le compilateur pour avoir des messages d'erreurs supplémentaires if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # ---Source files--- file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # ---Executable--- add_executable(test ${SRC_FILES}) target_compile_features(test PUBLIC cxx_std_17) target_include_directories(test PUBLIC &quot;src/&quot;) # ---Libraries--- include(FetchContent) # ---glm--- FetchContent_Declare( glm GIT_REPOSITORY https://github.com/g-truc/glm GIT_TAG efec5db081e3aad807d0731e172ac597f6a39447 ) FetchContent_MakeAvailable(glm) // On lie la bibliothèque glm à notre exécutable (target) test target_link_libraries(test PUBLIC glm)   ","version":"Next","tagName":"h3"},{"title":"Magic enum​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#magic-enum","content":" Pour illustrer l'ajout manuel d'une bibliothèque, nous allons utiliser la bibliothèque magic enum. Par la même occasion on découvre une bibliothèque très utile pour manipuler des énumérations qui comble une lacune du langage C++ et simplifie grandement l'utilisation des énumérations.  POur cette approche, l'idée est de manuellement télécharger le fichier de la bibliothèque (qui est un header only) et de l'inclure dans le projet.  Premièrement, il faut télécharger les fichiers de la bibliothèque. Pour cela, il faut se rendre sur la page github de la bibliothèque : https://github.com/Neargye/magic_enum/tree/master/include/magic_enum et télécharger les fichiers dans le dossier include (en cliquant sur le bouton Code puis Download ZIP par exemple ou en clonant le dépôt git).  Ensuite, il faut créer un dossier lib dans le dossier du projet et y placer les fichiers de la bibliothèque (dans un sous dossier magic_enum par exemple).  Enfin, il faut indiquer à cmake où se trouve les fichiers et que l'on souhaite utiliser la bibliothèque magic enum dans le programme. Pour cela, on utilise la fonction target_include_directories :  target_include_directories(&lt;target&gt; PUBLIC &quot;lib/&quot;)   Ainsi il va être possible d'inclure les fichiers dans le programme afin d'utiliser la bibliothèque:  #include &lt;magic_enum/magic_enum.hpp&gt;   remarque C'est évidement plus simple d'utiliser FetchContent pour inclure une bibliothèque, mais il est important de comprendre que cela fonctionne de la même façon et que simplement inclure la bibliothèque et utiliser target_include_directories (dans le cas plus simple d'une bibliothèque header only) permet de l'utiliser dans le programme.  ","version":"Next","tagName":"h2"},{"title":"Find Package et Cmake​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#find-package-et-cmake","content":" Il est également possible d'utiliser la fonctionnalité Find Package de cmake pour inclure une bibliothèque. Cela permet de simplifier l'inclusion d'une bibliothèque et de ne pas avoir à indiquer où se trouve les fichiers de la bibliothèque. Cela repose sur le fait que la bibliothèque est installée sur le système d'exploitation et/ou que l'on utilise un gestionnaire de dépendances. C'est très pratique sur Linux, mais cela peut être plus compliqué sur Windows. Et c'est la raison pour laquelle nous n'allons pas l'utiliser dans ce cours (car trop dépendant du système d'exploitation).  Mais sachez que cela existe et vous ne serez pas surpris si vous tombez dessus.  Voilà un exemple de fichier CMakeLists.txt (non testé) qui utilise Find Package :  cmake_minimum_required(VERSION 3.20) project(test) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # ---Source files--- file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # ---Executable--- add_executable(test ${SRC_FILES}) target_compile_features(test PUBLIC cxx_std_17) target_include_directories(test PUBLIC &quot;src/&quot;) # ---glm--- # set(glm_DIR &lt;installation prefix&gt;/lib/cmake/glm) # if necessary find_package(glm REQUIRED) # On lie la bibliothèque glm à notre exécutable (target) test target_link_libraries(test PUBLIC glm::glm)   info Enfin, avec de nouvelle version de Cmake il est même possible de configurer le fonctionnement de FetchContent_MakeAvailable pour qu'il utilise Find Package pour inclure la bibliothèque si c'est possible et qu'il utilise FetchContent sinon. Cela peut être pratique dans certains cas, et permet d'éviter de télécharger la bibliothèque si elle est déjà installée sur le système d'exploitation, mais cela dépasse le cadre de ce cours.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin: créer sa propre bibliothèque​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#pour-aller-plus-loin-créer-sa-propre-bibliothèque","content":" Il est également possible de créer sa propre bibliothèque. Cela peut être utile pour réutiliser du code dans plusieurs projets ou pour partager du code avec d'autres développeurs.  Pour créer une bibliothèque, il faut créer un nouveau projet cmake et ajouter un dossier lib dans lequel on va placer les fichiers de la bibliothèque. Ensuite, il faut créer un fichier CMakeLists.txt dans le dossier lib et indiquer à cmake que l'on souhaite créer une bibliothèque avec la fonction add_library :  add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)   Je ne vais pas rentrer dans les détails dans ce cours mais voilà un exemple de bibliothèque ici si c'est quelque chose qui vous intéresse : Simple-Image-Lib.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Utiliser des bibliothèques en C++","url":"/Learn--cpp_programming/Annexes/Libraries#résumé","content":" Une bibliothèque est un ensemble de fonctions et de classes qui permettent de réaliser des tâches spécifiques.Une bibliothèque peut être statique ou dynamique.Il existe plusieurs façons d'inclure une bibliothèque dans un programme : CMake FetchContentInclusion manuelleGestionnaire de dépendances En pratique, il est préférable d'utiliser CMake FetchContent pour inclure une bibliothèque (compatible avec tous les systèmes d'exploitation).Il est également possible d'utiliser Find Package pour inclure une bibliothèque (mais cela dépend du système d'exploitation). ","version":"Next","tagName":"h2"},{"title":"Retours","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks","content":"","keywords":"","version":"Next"},{"title":"Rendu Projet​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#rendu-projet","content":" Envoyer uniquement le minimum nécessaire pour compiler et lancer l'executable:  code source du projet S’il y a du code mort (qui n’est utilisé nulle part) ou des lignes de codes commentées, nettoyer avant le rendu. les utilitaires de compilation (Makefile, CMakelist, librairies ou autre)ressources/assets du projet (textures, son, polices ...)  Ne pas envoyer:  les executables et les dossiers compilés (.o et autres fichiers générés par cmake)Si vous pouvez, éviter les fichiers lourds (son/video pas compressé.e, ...)  git Il est important de ne pas inclure les fichiers compilés dans le dépôt git car ils sont propres à chaque machine et configuration (compilateur, structure de dossier personnelle, etc). Il est préférable de les ajouter dans le fichier .gitignore pour ne pas les inclure dans le dépôt git. De plus ces fichier sont générés automatiquement à partir des fichiers sources, il n'est donc pas nécessaire de les inclure dans le dépôt git et cela permet de garder le dépôt git propre.  ","version":"Next","tagName":"h2"},{"title":"Soutenance​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#soutenance","content":" Préparer le déroulé de la soutenance Si démo, faire en sorte que votre scénario de démo mette en valeur les fonctionnalités qui fonctionnent le mieux Ne montrer pas de code (ou très peu) Si vous voulez montrer l’architecture ou des algos, soyez schématique Si vous voulez décrire des fonctionnalités, utiliser surtout la démo pour les montrerVous pouvez parler des difficultés rencontrés mais il ne faut pas ça pèse sur le reste de la soutenance. Vous êtes là pour montrez le meilleur de vous même et le travail accompli.  ","version":"Next","tagName":"h2"},{"title":"Gestion de Projet​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#gestion-de-projet","content":" ","version":"Next","tagName":"h2"},{"title":"Étapes​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#étapes","content":" Commencer par vous approprier les “specs”/le cahier des charges Reprendre avec vos mots et assurez vous d’avoir compris ce qui est attenduFaire une veille et voir l’état de l’art selon le projet. Si c’est un jeu de type Tower Defense, voir ce qui existe comme jeu de ce type.Découper le projet en petite tache, Exemple: Faire l’affichage d’une carte diviser en plusieurs tiles.Lire un fichier ITD et en tirer des informations utilisables.Faire bouger un Ennemie d’un bout à l’autre de la carte.… Réfléchir à la DA, le level design, l’expérience utilisateur, … Cette étape est moins importante dans le cadre d’un projet informatique, étant donné le temps qui vous est imparti, ne passez pas trop de temps dessus Évaluer la temporalité de ces tâches. Il vous est compliqué pour l’instant d’évaluer le temps que va prendre une tache mais déterminer au moins quelle tache doit être fait avant quelle autre et s’il y a des taches parallélisable. En gestion de projet, il s’agit de faire un diagramme de Gant (vous n’êtes pas obligé d’aller aussi loin) Tout au long du projet, réfléchir, à côté, à ce qui peut être intéressant à garder/documenter pour la soutenance/le rapportRéfléchir collectivement à l’organisation du code et à la base de celui ci. Faire un schéma ou une mind map pour clarifier vos idées. Attribuer les tâches à chacun selon les envies et les expertises. ⚠️ Pour un projet dans le cadre d’un cours informatique, il faut que chacun soit impliqué dans le code, il s’agit avant tout d’une évaluation de vos compétences. Développer Concevoir des tests itératif qui valide la fonctionnalité que vous développez.Développer sans GUI lorsque la fonctionnalité n’est pas directement lié à celle ci. Exemple: Déplacement d’un ennemie selon un graphe, afficher la position dans la console et vérifier que la position est raccord avec le graphVous pouvez bien sûr vous aider de la GUI pour vous rendre compte de la fonctionnalité dans son état final mais elle ne doit pas vous bloquer Expliquer succinctement votre code à vos collaborateursRaccorder votre code au reste du projet Faire les assets et le level design Selon la DA choisi, trouver ou créer les assets (textures, sons, police…) dont votre jeu/programme a besoin.  ","version":"Next","tagName":"h3"},{"title":"Outils Kanban​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#outils-kanban","content":" Pour organiser vos tâches, vous pouvez utiliser des outils comme:  TrelloNotionGitHub / GitlabMeistertask  ","version":"Next","tagName":"h3"},{"title":"Architecture logiciel​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#architecture-logiciel","content":" ","version":"Next","tagName":"h2"},{"title":"Variables Globales​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#variables-globales","content":" Éviter les variables globales, déjà pour une question de suivi et de lecture de code, pour savoir d'où vient une variable et où est elle initialisée.  Par ailleurs si on multiplie les variables globales, on risque mélanger des variables locales avec celles-là.  Si j'ai une variable mur globale et que je veux nommer une variable locale mur, soit le compilateur va m'envoyer chier soit le programme va avoir des comportements inattendu parce que les variables se confondent.  Et une autre raison qui vous empêche tout simplement de le faire, le compilateur, lorsqu'il atteint la compilation des fichiers intermédiaires, il peut être amené à vous afficher une erreur de variable multiple multiple declaration of machin.  Solution💡: Faire une structure ou une classe qui va contenir les données dont vous avez besoin dans beaucoup d'endroit et qui sont uniques à une execution du programme. Vous pouvez ensuite passer cette structure (par référence) dans vos fonctions pou accéder à l'état de votre jeu et des variables partagés. struct Game { BallsList balls; Wall walls[10]; int walls_count; std::string background_color; } Une autre solution est de créer une classe et de lui ajouter une fonction (statique) qui va créer une instance unique et la renvoyer à chaque fois, c'est ce qu'on appelle un singleton. attention Attention, les singletons gardent les même travers que les variables globales en terme de suivi de données. il faut donc les utiliser avec parcimonie.  class Game { private: // Constructeur privé pour rendre la classe impossible à instancier manuellement sans passer par la méthode get_instance Game() {} // Un singleton est une instance unique de la classe donc on ne peut pas la copier Game(Game const&amp;) = delete; void operator=(Game const&amp;) = delete; public: // Méthode publique pour récupérer l'instance unique de la classe (et la créer si elle n'existe pas) static Game&amp; get_instance() { static Game instance; return instance; } // ... }   quelques liens pour approfondir le sujet:  Singleton Design PatternMeyers SingletonSingleton Pattern  ","version":"Next","tagName":"h3"},{"title":"Dirty pattern​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#dirty-pattern","content":" J'ai vu plusieurs d'entre vous utiliser un pattern très utilisé dans les moteurs de jeux, que je vais appeler le &quot;dirty pattern&quot;. C'est une technique qui consiste à marquer un élément (structure, classe) comme &quot;dirty&quot; pour savoir si il faut mettre à jour certaines données qui lui sont associées. C'est une technique très utilisée dans les moteurs de jeux pour savoir si il faut recalculer certaines données (comme le chemin d'un ennemi par exemple). Cela permet d'éviter de recalculer des données qui n'ont pas changé. Par exemple, si vous avez un monstre qui se déplace sur une carte, vous pouvez marquer le monstre comme &quot;dirty&quot; si il a changé de position. Ainsi, vous savez que vous devez recalculer le chemin du monstre pour le déplacer à sa nouvelle position. Si le monstre n'a pas bougé, vous n'avez pas besoin de recalculer le chemin. C'est une technique très efficace pour éviter de recalculer des données inutilement.  ","version":"Next","tagName":"h3"},{"title":"Orienté objet​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#orienté-objet","content":" C'est bien d'avoir pensé à l'orienté objet, mais attention à ne pas tombé dans le piège de l'orienté objet pour l'orienté objet. C'est une notion que vous découvrez plus l'année prochaine mais il est possible de définir la visibilité des attributs et méthodes d'une structure ou classe (public, protected, private). Cela permet de protéger les attributs et de ne pas permettre de les modifier directement (pour l'utilisateur de la classe). C'est une bonne pratique de les mettre en private et de créer des méthodes pour les modifier (setter) et les récupérer (getter). Cela permet de contrôler l'accès aux attributs et de garantir l'intégrité des données.  mais il ne faut pas tomber dans l'excès, si c'est pour juste retourner et récupérer la value d'un attribut (autant qu'il soit public dans ce cas).  #include &lt;string&gt; class Monster { public: float get_max_health(); float get_health_points(); std::string get_name(); // ... void set_max_health(float const max_health); void set_health_points(float const health_points); void set_name(std::string const&amp; name); // ... private: float max_health; float health_points; std::string name; // ... }; float Monster::get_max_health() { return this-&gt;max_health; } float Monster::get_health_points() { return this-&gt;health_points; } std::string Monster::get_name() { return this-&gt;name; } // ... void Monster::set_max_health(float const max_health) { this-&gt;max_health = max_health; } void Monster::set_health_points(float const health_points) { this-&gt;health_points = health_points; } void Monster::set_name(std::string const&amp; name) { this-&gt;name = name; } // ...   Ici, il serait préférable de mettre certains attributs en public (si ils sont juste des valeurs modifiable sans contrôle par l'utilisateur) et d'autres en private (si ils sont des données interne à la classe). Par exemple, le maximum de vie d'un monstre ne devrait pas être modifié directement par l'utilisateur mais set une seule fois à la création du monstre (à l'aide d'un constructeur par exemple). En revanche, la vie actuelle du monstre peut être modifiée par l'utilisateur (lorsqu'il est attaqué par exemple). L'intérêt de faire un setter pour la vie actuelle est de pouvoir vérifier que la vie ne dépasse pas le maximum de vie du monstre par exemple.  Dans l'exemple ci-dessous on vérifie donc que la vie actuelle est bien comprise entre 0 et le maximum de vie. Le nom du monstre peut être modifié par l'utilisateur(pas de vérification particulière), je laisse l'attribut en public pour éviter d'avoir à créer un getter et un setter pas très utile pour cet attribut.  #include &lt;string&gt; class Monster { public: // Constructeur Monster(float const max_health, std::string const&amp; name); // ... void set_health_points(float health_points); void get_health_points(); // ... // Attributs publics std::string name; // ... private: // Attributs privés float max_health; float health_points; }; Monster::Monster(float max_health, std::string const&amp; name) { this-&gt;max_health = max_health; // On initialise la vie actuelle du monstre à son maximum this-&gt;health_points = max_health; this-&gt;name = name; } void Monster::set_health_points(float health_points) { if (health_points &gt; this-&gt;max_health) { this-&gt;health_points = this-&gt;max_health; } else if (health_points &lt; 0) { this-&gt;health_points = 0; } else { this-&gt;health_points = health_points; } } float Monster::get_health_points() { return this-&gt;health_points; }   ","version":"Next","tagName":"h3"},{"title":"Propreté du code​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#propreté-du-code","content":" C'est quoi déjà la propreté du code ? il faudrait peut être plus parler de rangement du code. Comme pour un classeur ou un bureau, mieux c'est rangé, mieux on s'y retrouve (même si certains s'y retrouve mieux dans le chaos). On peut ranger le code sur certains aspect pour mieux s'y retrouver et le lire plus facilement.  ","version":"Next","tagName":"h2"},{"title":"Convention de casses​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#convention-de-casses","content":" Je fais une petite parenthèse pour parler de casses, c’est à dire du fait d’avoir des majuscules ou des minuscules et des undescores ou non. Je vous renvoie sur ce site pour un petit résumé des différentes type de casses.  Most Common Programming Case Types  Dans ce document vous allez me voir écrire en snake_case pour les variables et fonctions, c’est ma déformation professionnelle venant de mes habitudes python et rust. En C++, le consensus se tourne vers le camelCase, pareil pour le C# (Unity notamment) mais on retrouve du PascalCase pour les fonctions. Mais êtes libre à niveau là, mais je vous conseille de suivre la convention du langage car vous serez souvent amenés à utiliser des librairies, des packages, des frameworks… et par soucis d’uniformité, il vaut mieux faire comme les standards.  L'important c'est de choisir une convention et de s'y tenir pour garder une cohérence dans le code.  ","version":"Next","tagName":"h3"},{"title":"Nommage des variables et fonctions​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#nommage-des-variables-et-fonctions","content":" plus vos noms sont explicites plus votre code est &quot;straightforward&quot;, ont comprend le comportement du code rien qu'en le lisant.  bool shape_is_closed(Shape* shape) { int sum_of_angles {0}; const int points_count { shapes-&gt;points.size() }; for (int i {0}; i&lt;points_count-2; i++) { const Vector current_vector = make_vector_from_points(shapes-&gt;points[i], shapes-&gt;points[i+1]); const Vector next_vector = make_vector_from_points(shapes-&gt;points[i+1], shapes-&gt;points[i+2]); angle = process_angle_from_vectors(current_vector, next_vector); sum_of_angles += angle; } const Vector last_vector = make_vector_from_points(shapes-&gt;points[points_count-1], shapes-&gt;points[0]); const Vector first_vector = make_vector_from_points(shapes-&gt;points[0], shapes-&gt;points[1]); last_angle = process_angle_from_vectors(last_vector, first_vector); sum_of_angles += last_angle; if (sum_of_angles % 360 == 0) return true; else return false; }   Le code est plus long mais il est plus verbeux et on comprend ce que fais le code en lisant les variables et fonctions.  la fonction s'appelle shape_is_closed, il va sûrement déterminer si une forme est fermée. La première ligne définie la variable sum_of_angles qu'on retrouve à la fin avant le return, ok ça fait la somme des angles pour déterminer si c'est fermé.  Il y a un for dans lequel on calcul un angle à partir d'un segment et celui qui le suit, après ça on recalcule un angle entre le dernier segment et le premier.  Dans ce code, j'exagère la verbosité pour avoir une lecture très littérale, on peut trouver un juste milieu.  ","version":"Next","tagName":"h3"},{"title":"Faites des fonctions​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#faites-des-fonctions","content":" Avoir des fonctions ne permet pas seulement de capitaliser sur un ensemble d’instruction, on peut les utiliser pour structurer le code, notamment en rassemblant des instructions répondant à un besoin particulier sous un même bloc “nommé”. par exemple si vous calculer des collisions, faites une fonction check_collisions , on saura que le bout de code à l’intérieur vise à calculer une collision et quand vous appelez cette fonction dans votre programme on sait que vous souhaitez faire un calcul de collision à cette endroit.  Posez vous la question de la longueur de vos fonctions, si elles sont trop longues, divisez les en sous fonctions. Les plus stricts développeurs diront qu’une bonne fonction ne doit pas dépasser 10 lignes, je trouve personnellement ça trop contraignant, mais cette règle me sert au moins de base pour ma réflexion. A chaque dizaines de lignes que je dépasse, je dois me poser la question “est ce que je peux bouger des instructions dans une fonction dédiée ?”  Je vois par exemple un main qui fait une centaine de lignes et qui contient ça   Wall walls[MAX]; Vector2 position; bool horizontal; for (int i = 0; i&lt;walls_count;i++) { position.x = 150 + rand() % (SCREEN_WIDTH-150); position.y = 150 + rand() % (SCREEN_HEIGHT-150); int taille = 150 + rand() % 200; if (randomNumber(1, 2) == 1) { horizontal = true; } else { horizontal = false; } walls[i].initialize(horizontal, taille, position); }   Je pourrais faire une fonction initialize_walls ou une méthode initialize_random dans la structure/classe Wall.  ","version":"Next","tagName":"h3"},{"title":"L’indentation et les espaces​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#lindentation-et-les-espaces","content":" L’indentation vous permet de bien situer les blocs (les if/else, for/while, switch, structures…).  dans ce code  for(int i {0}; i &lt; codes; i++) { for(int j {0}; j &lt; lines; j++) { if(forme) my_code = is_good + is_better; else my_code = is_good; a_result = call_a_function(); make_it_better(a_result) while(something_call) { if(someone_here()) { answer() } else{ answer_everyone(); take_a_moment(); person = find_someone(); } } } while(yolo) { make(toto) } while(doing_wrong) { error = watch_code(codes); call_a_formater(codes, errors); } }   Il est plus compliqué de terminer la limite de chaque bloc comparé à ce code là  for(int i {0}; i &lt; codes; i++) { for(int j {0}; j &lt; lines; j++) { if(forme) my_code = is_good + is_better; else my_code = is_good; a_result = call_a_function(); make_it_better(a_result) while(something_call) { if(someone_here()) { answer() } else{ answer_everyone(); take_a_moment(); person = find_someone(); } } } while(yolo) { make(toto) } while(doing_wrong) { error = watch_code(codes); call_a_formater(codes, errors); } }   En plus de l’indentation, veillez à espacer votre code pour souligner la proximité de certaines instructions  void main() { Window* window = new Window(); SoundSystem* sound_system = new SoundSystem(); ResourcesManager resources = new ResourcesManager(); window.resize(720, 1080); window.set_title(&quot;Ma fenetre&quot;); window.add_button(&quot;Mon Bouton&quot;); sound_system.register_sound(&quot;le_message_de_paix.mp3&quot;); sound_system.register_sound(&quot;le_code.mp3&quot;); sound_system.play_loop(&quot;le_message_de_paix.mp3&quot;); resources.register_image(&quot;yolo.png&quot;) resources.register_image(&quot;toto.png&quot;) window.open(); }   Vous écrivez un code avant tout pour vous et pour les autres et pas pour la machine. La machine se fiche de savoir si vous avez mis un espace avant ou après un opérateur, si vous avez mis une ligne vide entre deux blocs de code. Mais pour vous et pour les autres, c’est plus facile de lire un code bien espacé et indenté.  Dans d'autres languages comme le python, l'indentation est obligatoire pour définir les blocs de code, en C++ l'indentation est une convention mais en pratique tout le monde se force à l'appliquer pour rendre le code plus lisible.  ","version":"Next","tagName":"h3"},{"title":"La longueur des lignes​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#la-longueur-des-lignes","content":" Éviter les lignes trop longue. La convention actuelle conseille de ne pas dépasser 80 caractères dans une même ligne. Ceci dans l’optique de pouvoir diviser sa fenêtre en 2 pour pouvoir comparer du code, voir des signatures de fonctions,… ou bien de pouvoir mettre son écran à la vertical.  Je trouve personnellement que 80 caractères est assez contraignant. Je me permet des écarts à 90 voire 100 grand maximum.  Pour éviter les lignes trop longues, il suffit tout simplement de diviser les instructions longues en plusieurs ligne. Il y a certaines conventions pour faire ça, en général votre IDE vous aide à le faire.  Dans l’exemple précédent j’ai des lignes dépassant les 80 caractères, reformatons ça  bool shape_is_closed(Shape* shape) { int sum_of_angles {0}; const int points_count { shapes-&gt;points.size() }; for (int i {0}; i&lt;points_count-2; i++) { const Vector current_vector = make_vector_from_points( shapes-&gt;points[i], shapes-&gt;points[i+1] ); const Vector next_vector = make_vector_from_points( shapes-&gt;points[i+1], shapes-&gt;points[i+2] ); angle = process_angle_from_vectors(current_vector, next_vector); sum_of_angles += angle; } const Vector last_vector = make_vector_from_points( shapes-&gt;points[points_count-1], shapes-&gt;points[0] ); const Vector first_vector = make_vector_from_points( shapes-&gt;points[0], shapes-&gt;points[1] ); last_angle = process_angle_from_vectors(last_vector, first_vector); sum_of_angles += last_angle; if (sum_of_angles % 360 == 0) return true; else return false; }   Le code est plus long en vertical mais on s’assure que ce soit lisible en toute circonstance. Si vous ne suivez pas la convention, assurez vous au moins d’avoir des lignes qui se lisent sur votre IDE sans avoir à scroller horizontalement.  ","version":"Next","tagName":"h3"},{"title":"Organisation des fichiers​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#organisation-des-fichiers","content":" Éviter au maximum d’avoir un main.cpp qui dépasse 100 lignes. Le main.cpp et la fonction main() doivent être là que pour faire l’initialisation des variables et lancer la fonction principale (dans un projet, en TP ça peut contenir le corps du programme).  Cependant ne mettez pas tout le code que aviez prévu dans le main.cpp dans un seul autre fichier, essayez le plus possible de disperser le code dans différents fichiers. Le plus souvent on fait un couple header/source par structure. Dans le cas du projet on pourrait avoir ball.h/ball.cpp , wall.h/wall.cpp et game.h/game.cpp. On peut aussi avoir des “utilitaires” tant que vous définissez bien la nature de chaque utilitaire, par exemple ici physics.h/physics.cpp et drawing.h/drawing.cpp.  Pour des projets à plus large echelles, je vous invite à faire des dossiers pour regrouper vos fichiers, la hiérarchie de fichiers dépendra de la logique utilisés. Pour un jeu on pourra par exemple avoir des dossiers principaux core, render_engine, the_game  ","version":"Next","tagName":"h2"},{"title":"Attributs ou Variable ?​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#attributs-ou-variable-","content":" class App { // ... GLuint texture_path; std::unordered_map&lt;std::string, GLuint&gt; tile_texture_mapping; // ... } // init this-&gt;texture_path = loadTexture(path); this-&gt;tile_texture_mapping.insert({&quot;path&quot;, this-&gt;texture_path}); // draw draw_quad_with_texture(tile_texture_mapping[&quot;path&quot;], w, h, taille);   Si vous déclarez un attribut (ici _texturepath) mais qu’il n’est utilisé qu’une seule fois, il n’est peut être pas nécessaire d’avoir un attribut et évaluez si une variable n’est pas suffisante  class App { // ... std::unordered_map&lt;std::string, GLuint&gt; tile_texture_mapping; // ... } // init GLuint texture_path{loadTexture(path)}; this-&gt;tile_texture_mapping.insert({&quot;path&quot;, texture_path}); // draw draw_quad_with_texture(tile_texture_mapping[&quot;path&quot;], w, h, taille);   ","version":"Next","tagName":"h3"},{"title":"Variables en dur​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#variables-en-dur","content":" Attention aux données en dur dans le code. Par exemple, dans le code ci-dessous, il y a des conditions sur les coordonnées x et y qui sont en dur dans le code.  if (x &gt; 11) { return; } else if (y == 1 &amp;&amp; (x &lt; 5 || (x &gt; 6 &amp;&amp; x &lt; 11))) { return; } else if (y == 2 &amp;&amp; (x == 4 || x == 7 || x == 10)) { return; } else if (y == 3 &amp;&amp; ((x &gt;3 &amp;&amp; x&lt;8) || x == 10)) { return; } else if (y == 4 &amp;&amp; x==10 ) { return; } else if (y == 5 &amp;&amp; ((x &gt;0 &amp;&amp; x&lt;5) || (x &gt;7 &amp;&amp; x&lt;11))) { return; } else if (y == 6 &amp;&amp; (x == 1 || x == 4 || x == 8)) { return; } else if (y == 7 &amp;&amp; (x == 1 || x == 4 || (x &gt;7 &amp;&amp; x&lt;11)) ) { return; } else if (y == 8 &amp;&amp; (x == 4 || x == 10 || x&lt;2 ) ) { return; } else if (y == 9 &amp;&amp; (x == 4 || x == 10 )) { return; } else if (y == 10 &amp;&amp; (x &gt;3 &amp;&amp; x&lt;11)) { return; } // ...   C'est une mauvaise pratique car si vous voulez changer la façon dont vos coordonnées sont gérées, vous devrez changer ce code et cela peut être fastidieux. Il est préférable de stocker ces données dans un fichier de configuration par exemple pour pouvoir les modifier facilement. Ou alors de les stocker dans une structure de données (comme une map ou un tableau par exemple) pour pouvoir les modifier plus facilement. L'idéal est de ne pas avoir de données en dur mais de les déduire d'autres données (comme une image par exemple) pour faciliter la maintenance et l'évolutivité du code.  Ici, cela ressemble des conditions de validité pour des cases d'une grille 2D (placement des tours sur une carte). Il serait donc préférable de déduire ces conditions de la carte elle-même (par exemple, si la case est une herbe, on peut placer une tour dessus, ect).  ","version":"Next","tagName":"h3"},{"title":"Erreurs propre aux C++​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#erreurs-propre-aux-c","content":" ","version":"Next","tagName":"h2"},{"title":"Opération Booléenne​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#opération-booléenne","content":" Vous mettez parfois dans le code des testes pour définir une variable booléenne ou pour retourner une valeur booléenne.  Par exemple  bool bidule(int const x) { if (x &gt; 10) { return true; } return false; }   N’oubliez pas que vous ce que vous mettez dans le if est une opération booléenne qui va calculer soit Vrai soit Faux. Et ce résultat peut donc être directement utilisé comme valeur de retour.  bool bidule(int const x) { return x &gt; 10; }   astuce Si vous devez inverser le résultat, vous pouvez utiliser l’opérateur ! qui va inverser le résultat d’une opération booléenne.  ","version":"Next","tagName":"h3"},{"title":"Pragma once vs ifndef​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#pragma-once-vs-ifndef","content":" #pragma once #ifndef PATH_HPP #define PATH_HPP   Les deux façon de protéger des inclusions de header sont redondantes, il faut choisir l'une ou l'autre (préférence pour #pragma once en C++ moderne). Petit rappel ici  Si vous ne devez retenir qu'une chose, c'est ajouter un #pragma once en haut de vos fichiers headers.  ","version":"Next","tagName":"h3"},{"title":"Pointeurs​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#pointeurs","content":" Globalement un pointeur fait référence à un objet dans mémoire. Mais il peut faire référence à deux types d’objets:  un objet prévu dans la mémoire initiale (dans la Pile)un nouvel objet alloué pendant l’exécution (dans le Tas)  !https://media.geeksforgeeks.org/wp-content/uploads/20201210222125/Untitled4-660x361.png  https://media.geeksforgeeks.org/wp-content/uploads/20201210222125/Untitled4-660x361.png  Je vais apporter une petite subtilité, il y a deux types de pointeurs (ou d’usage plutôt)  “Il y a le bon et le mauvais pointeur ?”  “Non, silence…”  Celui qui détient l’adresse original d’un objetCelui qui fait référence à un objet initialisé ailleurs  Et pour bien comprendre cette distinction, voyons un bout de code qui ne la fait pas  Ellipse* current = new Ellipse; current = liste.first; while (current != nullptr) { // ... }   La première ligne de cette fonction va créer un objet, il va l’allouer dans la mémoire grâce à new. On parle ici d’instanciation, nous y reviendrons.  La deuxième quant à elle va faire pointer current vers un objet existant ailleurs (dans liste.first).  L’erreur vient surement d’une confusion sur l’initialisation d’un pointeur:  info 💡 new permet de créer un nouvel objet dans la mémoire et pas de créer un pointeur.  un pointeur est créé à partir du moment où vous déclarer une variable avec * et vous devez distinguer le “pointeur” de l”instance”.  “Ah mais qu’est ce que c’est donc qu’une instance ?”  “Merci personne aléatoire que je n’ai pas payé pour poser cette question”  ","version":"Next","tagName":"h3"},{"title":"Instance​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#instance","content":" J’ai parlé ci-dessus d’”objet”, on pourrait aussi parler d’”instance” (désolé il n’y a pas de mot bien définis pour ce dont je vais parler).  En programmation (on va parler de C++ ici), il y a des “types” de données. On peut retrouver des types natives (ou fondamentaux) qui viennent directement avec le langage (int, bool, float, string…) et des types qu’on peut créer et qui va contenir un ensemble de données (des structures ou des classes mais aussi des enum).  Ces types décrivent comment une donnée (en binaire) va prendre forme. Et quand je déclare une variable d’un certain type, je veux créer une donnée qui doit prendre cette forme. On dit qu’on crée une instance de ce type. L’instance est un élément unique là où le type décrit une donnée générique.  Quand je déclare des variables  int a; string nom_etudiant1; Human steeve;   a est une instance de int, nom_etudiant1 est une instance de string et steeve est une instance d’une structure Human.  Bon où je veux en venir avec tout ça ? (non c’est une vrai question, qu’est ce que je voulais faire ?)  Bon c’est pas grave, faisant une parenthèse pour ceux qui n’ont pas encore appréhendé les structures, voyons ce code:  Parenthèse:  struct Human { string first_name; string last_name; } void display_human_name(Human human) { cout &lt;&lt; ?; }   Ici je veux afficher le nom d’un humain, et d’un humain spécifique, pas de l’entité “humain” (pas de l’humanité). Je vais donc manipuler human et pas Human. On manipule l’instance, pas le type.  Je pourrais reformater le code:  void display_human_name(Human a_specific_human) { cout &lt;&lt; a_specific_human.first_name; }   Je ferme la parenthèse, dite moi si c’est pas claire ou à l’inverse si c’est trop obvious.  Oui donc les instances au final pour les pointeurs. Reprenons l’erreur que j’avais souligné.  void parcours_liste(List* list) { Ellipse* current = new Ellipse; current = list-&gt;first; while (current != nullptr) { // ... current = current-&gt;next; } } int main() { List l; Ellipse ellipse1; Ellipse ellipse2; l.first = &amp;ellipse1; ellipse1.next = &amp;ellipse2; parcours_liste(l); }   new Ellipse va créer une nouvelle instance du type Ellipse. Or il existe déjà des instances d’ellipses, celles qu’on veut parcourir. Ces instances sont celles créés dans le main. Le pointeur current ne va servir qu’à parcourir ces instances d’ellipses et en aucun cas les recréer. C’est ce qu’on appelle un “itérateur”, c’est un pointeur qui permet de se balader dans une structure de données.  Modifions un peu le code  int main() { List l; l.first = new Ellipse; l.first-&gt;next = new Ellipse; parcours_liste(l); }   Le code fait exactement la même chose, sauf que le j’alloue de la mémoire “à la volet” pour créer les ellipses de la liste. Je les instancie d’une autre manière. Les instances se crée dans le Tas et pas dans la pile.  💡 En java, C#, javascript, python… toutes les instances/tous les objets sont instancié.e.s “à la volet”  ","version":"Next","tagName":"h3"},{"title":"Optimisation​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#optimisation","content":" ","version":"Next","tagName":"h2"},{"title":"chaines de caractères VS entiers (énumération)​","type":1,"pageTitle":"Retours","url":"/Learn--cpp_programming/Annals/IMAC2026/S2/Feedbacks#chaines-de-caractères-vs-entiers-énumération","content":" Comparer des chaines de caractères nécessite plus de calcul que comparer des entiers. En effet, une chaîne de caractère est une suite de caractères qui nécessite d’être parcouru (entièrement ou partiellement) pour être comparé. Alors qu’un entier est une valeur numérique qui peut être comparé directement.  Dans le cas où vous avez des chaines de caractères qui représentent des modes, des états, des types ... que l'on connaît à l'avance, il est préférable de les comparer en utilisant des entiers plutôt que de passer par des chaines de caractères.  void move_player(Player &amp; player, string const&amp; direction) { if (direction == &quot;left&quot;) { // ... } else if (direction == &quot;right&quot;) { // ... } else if (direction == &quot;up&quot;) { // ... } else if (direction == &quot;down&quot;) { // ... } else { // ... ? } }   Mais on peut utiliser une énumération pour définir les différent cas et les comparer directement (chaque valeur de l’énumération est représenté par un entier).  enum class Direction { Left, Right, Up, Down, } void move_player(Player &amp; player, Direction const direction) { if (direction == Direction::Left) { // ... } else if (direction == Direction::Right) { // ... } else if (direction == Direction::Up) { } else // if (direction == Direction::Down) { // ... } // Ou encore mieux avec un switch case switch (direction) { case Direction::Left: // ... break; case Direction::Right: // ... break; case Direction::Up: // ... break; case Direction::Down: // ... break; } }   Cela permet de réduire le temps de calcul et de rendre le code plus lisible. Mais cela permet aussi de limiter la gestion des erreurs. Si vous avez une chaîne de caractère qui n’est égale à aucun des cas il faudra gérer le cas ou il pourrait y avoir un comportement inattendu. Avec un enum, vous êtes sûr que la valeur est l’une de celles que vous avez défini. De plus l'utilisation du switch case n'est pas possible avec des chaines de caractères.  info Comparer des chaines de quelques caractères ne représente rien pour un processeur de nos jours mais si la vitesse d'exécution du programme est un critère important C'est tout de même quelques chose à prendre ne compte. ","version":"Next","tagName":"h3"},{"title":"Markdown","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/Markdown","content":"","keywords":"","version":"Next"},{"title":"Extensions​","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#extensions","content":" Vous aurez besoin de ces extensions pour facilement écrire du markdown dans VS Code :  markdown-preview-enhanced Pour voir le rendu final de votre texte. markdown-all-in-one Pour que VSCode comprenne la syntaxe Markdown. code-spell-checker-french Un correcteur d'orthographe. ATTENTION il est par défaut en anglais, et pour activer le français il faut faire ces manips : Faites F1 puis cherchez et cliquez sur Show Spell Checker Configuration InfoSélectionnez l'onglet &quot;User&quot;Activez le langage français en plus de l'anglais (quand il demande Choose Destination, sélectionnez User et pas Workspace).  ","version":"Next","tagName":"h2"},{"title":"Syntaxe​","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#syntaxe","content":" Voici une cheatsheet où vous retrouvez tout la syntaxe.  En résumé :  SyntaxeRésultat *Italique* **Gras** [lien](https://github.com/dsmtE/Learn--cpp_programming) ![image](./output/pouet.png) #### Titre (plus ou moins gros en fonction du nombre de #) - Listes - avec - plusieurs items ```cpp // Bloc de code C++ int x{0}; std::cout &lt;&lt; &quot;x vaut &quot; &lt;&lt; x &lt;&lt; '\\n'; '`` Bout de code `int x0;` au milieu d'une phrase. Équations de math avec LaTeX : $$ \\int_{-\\infty{}}^{+\\infty{}} x^2 dx $$ Notes de bas de page [^1] [^1]: Je suis une note de bas de page ! &gt; Citation | Tableaux | :grin: | :sparkles: | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Séparateur : ---  Et vous pouvez également utiliser n'importe quelle balise html à tout moment, si la syntaxe Markdown ne fournit pas de quoi faire ce que vous voulez. Par exemple :  &lt;kbd&gt;F2&lt;/kbd&gt; pour faire des touches : F2&lt;summary&gt;&lt;/summary&gt; et &lt;details&gt;&lt;/details&gt; pour faire des sections collapsables :  &lt;details&gt; &lt;summary&gt;Ouvre-moi !&lt;/summary&gt; Salut, ceci est un secret ! &lt;/details&gt;   Details Ouvre-moi !Salut, ceci est un secret !  ","version":"Next","tagName":"h2"},{"title":"Générer une table des matières​","type":1,"pageTitle":"Markdown","url":"/Learn--cpp_programming/Annexes/Markdown#générer-une-table-des-matières","content":" VS Code peut générer automatiquement une table des matières pour votre document, qui va lister toutes les différentes sections que vous aurez délimitées avec des titres (#, ##, ###, etc.). Pour cela, mettez votre curseur là où vous voulez la générer (typiquement au début de votre document), puis faites F1 et cherchez et sélectionnez Markdown All In One: Create Table of Contents (ou juste toc pour faire court).    Footnotes​ Je suis une note de bas de page ! ↩ ","version":"Next","tagName":"h2"},{"title":"Comprendre le mot clé this","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/this","content":"","keywords":"","version":"Next"},{"title":"Pourquoi this ?​","type":1,"pageTitle":"Comprendre le mot clé this","url":"/Learn--cpp_programming/Annexes/this#pourquoi-this-","content":" Le mot clé this est un pointeur qui pointe vers l'objet courant. Il est utilisé principalement pour accéder aux membres de la structure/classe à partir d'une méthode (pour éviter les ambiguïtés avec les paramètres par exemple).  ","version":"Next","tagName":"h2"},{"title":"Utilisation de this pour accéder aux membres de la structure à partir d'une méthode​","type":1,"pageTitle":"Comprendre le mot clé this","url":"/Learn--cpp_programming/Annexes/this#utilisation-de-this-pour-accéder-aux-membres-de-la-structure-à-partir-dune-méthode","content":" Voici un exemple pour illustrer son utilisation :  struct Point { int x {0}; int y {0}; void set_x(int const x) { this-&gt;x = x; } };   Comme vous pouvez le voir, this est utilisé pour accéder au membre x de la structure Point à partir de la méthode set_x pour éviter les ambiguïtés avec le paramètre x de la méthode.  J'en profite pour rappeler deux mécanismes des pointeurs:  * devant un pointeur permet de déréférencer une pointeur et obtenir une sorte de référence vers l'objet pointé par le pointeur.-&gt; permet de déréférencer un pointeur et d'accéder à un membre de l'objet pointé par le pointeur. Donc this-&gt;x est équivalent à (*this).x.  On aurait donc pu écrire également :  void set_x(int const x) { Point* myself_ptr {this}; // myself_ptr-&gt;x = x; (*myself_ptr).x = x; }   ou bien encore:  void set_x(int const x) { Point* myself_ptr {this}; Point&amp; myself_ref {*myself_ptr}; myself_ref.x = x; }   Dans l'idéal pour ce cas de figure, il est préférable d'éviter de nommer les paramètres de méthodes avec le même nom que les membres de la structure pour éviter les ambiguïtés. Dans ce cas this n'est même pas nécessaire car il n'y a pas d'ambiguïté et on peut simplement utiliser le nom du membre de la structure pour y accéder:  void set_x(int const new_x) { x = new_x; }   Je t'invite à relire cette section également : structure et this.  ","version":"Next","tagName":"h2"},{"title":"Utilisation de this pour chaîner les appels de méthodes​","type":1,"pageTitle":"Comprendre le mot clé this","url":"/Learn--cpp_programming/Annexes/this#utilisation-de-this-pour-chaîner-les-appels-de-méthodes","content":" This permet également de retourner une référence vers l'objet courant pour pouvoir chaîner les appels de méthodes:  struct Point { int x {0}; int y {0}; Point&amp; set_x(int const new_x) { x = new_x; return *this; } Point&amp; set_y(int const new_y) { y = new_y; return *this; } }; int main() { Point p {}; p.set_x(3).set_y(4); }   C'est particulièrement utile pour les opérateurs de flux par exemple qui retournent une référence vers le flux pour pouvoir chaîner les appels de &lt;&lt;.  Un exemple d'opérateur de flux pour la structure Point et son utilisation :  #include &lt;iostream&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { os &lt;&lt; &quot;Point(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return os; } int main() { Point p {1, 2}; std::cout &lt;&lt; p &lt;&lt; std::endl; }   C'est également utilisé dans les opérateurs d'affection pour permettre d'écrire a = b = c par exemple.  En effet, l'opérateur d'affectation retourne une référence vers l'objet courant pour permettre de chaîner les appels de l'opérateur d'affectation.  Voilà un exemple d'opérateur d'affectation pour la structure Point et son utilisation :  struct Point { int x {0}; int y {0}; Point&amp; operator=(Point const&amp; other) { x = other.x; y = other.y; return *this; } };   Lorsque l'on écrit a = b = c, l'opérateur d'affectation est appelé sur b avec c en paramètre et retourne une référence vers b qui est ensuite utilisée pour appeler l'opérateur d'affectation sur a avec b en paramètre.  ainsi a = b = c est équivalent à a.operator=(b.operator=(c)).  Si l'opérateur d'affectation ne retournait pas une référence vers l'objet courant, on ne pourrait pas écrire a = b = c et on devrait écrire a = c; b = c;. C'est à mon sens tout à fait valable également mais ce n'est pas la convention en C++ et cela pourrait être bloquant pour pouvoir utiliser des classes de la librairie standard qui utilisent cette convention.  Il faut par contre éviter de retourner une copie de l'objet plutôt qu'une référence (Point operator=(Point const&amp; other)). Cela permettrait toujours de chaîner les appels de méthodes mais cela serait moins efficace car cela impliquerait de faire des copies et des destructions d'objets inutiles.  ","version":"Next","tagName":"h2"},{"title":"Appeler une fonction par référence à partir d'une méthode​","type":1,"pageTitle":"Comprendre le mot clé this","url":"/Learn--cpp_programming/Annexes/this#appeler-une-fonction-par-référence-à-partir-dune-méthode","content":" le mot clé this permet également de passer une référence vers l'objet courant à une fonction (depuis une méthode).  Prenons par exemple la structure Point et une méthode turn_point qui prend une référence vers un point en paramètre :  struct Point { int x {0}; int y {0}; }; void turn_point(Point&amp; p) { int temp {x}; x = p.y; p.y = -temp; }   Si l'on souhaite appeler la fonction turn_point depuis une méthode de la structure Point, on peut utiliser this pour passer une référence vers l'objet courant à la fonction turn_point :  struct Point { // ... void turn() { turn_point(*this); } };   J'espère que cette section t'a permis de mieux comprendre le mot clé this en C++. ","version":"Next","tagName":"h2"},{"title":"L'IDE VSCode","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Annexes/VSCode","content":"","keywords":"","version":"Next"},{"title":"Les raccourcis et actions rapides​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#les-raccourcis-et-actions-rapides","content":" Je vais présenter ci-dessous quelques unes des choses les plus importantes pour lesquelles un IDE peut vous aider. Je vais les illustrer à l'aide de VSCode mais la majorité de ces fonctionnalités sont également présentes dans d'autres IDE.  ","version":"Next","tagName":"h2"},{"title":"Recherche dans le fichier courant​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#recherche-dans-le-fichier-courant","content":" Vous pouvez utiliser tout simplement la recherche dans le fichier courant en utilisant le raccourci : CTRL+F. Une popup va s'ouvrir et vous laisser naviguer avec les flèches entre les occurrences. Vous pouvez également faire du remplacement via la popup.    ","version":"Next","tagName":"h3"},{"title":"Recherche dans un projet​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#recherche-dans-un-projet","content":" Avec le raccourci CTRL+SHIFT+F il est possible de rechercher dans un projet entier. Cela peut être très utile si vous savez comment une variable s'appelle mais que vous ne retrouvez plus dans quel fichier elle se trouve par exemple.  La barre de recherche de VSCode est géniale, vous pouvez même renommer les choses (pour corriger une typo) par lot ou limiter la recherche à un dossier spécifique. Cette option est disponible en cliquant sur les trois points à droite.    ","version":"Next","tagName":"h3"},{"title":"Renommer par symbole​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#renommer-par-symbole","content":" Faites un clic droit et sélectionnez &quot;rename symbol&quot; ou même directement avec le raccourci F2 sur ta sélection.    C'est mieux que de faire une simple recherche (avec CTRL+F) car ce renommage arrive à prendre en compte le contexte (les symboles) et permet de remplacer par exemple une variable nommée &quot;Box&quot; sans affecter une autre qui pourrait par exemple s'appeler &quot;boundingBox&quot;.  Etape 1Etape 2Etape 3  ","version":"Next","tagName":"h3"},{"title":"Aller à la définition​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-à-la-définition","content":" Cela vous mènera directement à la définition de la variable / fonction / classe. C'est une fonctionnalité super utile pour se déplacer dans un projet.    Et si vous voulez rester concentré sur la portion de code que vous êtes en train d'éditer, vous pouvez aussi regarder la définition et cela ouvrira une petite fenêtre dans votre fichier actuel.    ","version":"Next","tagName":"h3"},{"title":"Aller à un symbole​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-à-un-symbole","content":" Avec le raccourci CTRL+SHIFT+O vous pouvez accéder à la liste des symboles. C'est en somme la liste des méthodes et fonctions du fichier courant. Vous pouvez ensuite taper ce que vous recherchez pour affiner la liste.    ","version":"Next","tagName":"h3"},{"title":"Aller à un fichier​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-à-un-fichier","content":" De la même manière, il est possible d'aller à un fichier sans passer par l'explorateur en utilisant le raccourci : CTRL+P. C'est beaucoup plus rapide si vous connaissez le nom du fichier que vous cherchez.    ","version":"Next","tagName":"h3"},{"title":"Passer d'un fichier .hpp à un .cpp et inversement​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#passer-dun-fichier-hpp-à-un-cpp-et-inversement","content":" Vous pouvez utiliser ALT+O pour passer rapidement du fichier d'en-tête au fichier d'implémentation. Très utile lorsque vous écrivez du code pour une classe ou structure.  attention Cette action ne fonctionne que dans le contexte d'un projet C++ et nécessite l'extension suivante cpptools-extension-pack .    ","version":"Next","tagName":"h3"},{"title":"Aller plus loin​","type":1,"pageTitle":"L'IDE VSCode","url":"/Learn--cpp_programming/Annexes/VSCode#aller-plus-loin","content":" Si besoin, voici les liens vers les pdf de référence des raccourcis par plateforme de VSCode:  WindowsmacOSLinux ","version":"Next","tagName":"h3"},{"title":"Déboguer son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors","content":"","keywords":"","version":"Next"},{"title":"Qu'est-ce qu'un débogueur ?​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#quest-ce-quun-débogueur-","content":" Un débogueur est un outil qui permet d'arrêter l'exécution d'un programme à un point précis, appelé point d'arrêt (ou breakpoint en anglais), ou juste avant qu'un crash se produise.  Une fois atteint, vous êtes en mesure d'inspecter la valeur de toutes les variables (et de toute la mémoire du programme). Vous pouvez également voir quelles fonctions ont été appelées jusqu'à ce point grâce à la pile d'appel (callstack).  Enfin, vous serez en mesure d'avancer pas à pas dans l'exécution.  Nous allons voir comment cela se passe dans VSCode en C++.  ","version":"Next","tagName":"h2"},{"title":"Configurer le débogueur​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#configurer-le-débogueur","content":" Pour commencer, il faut configurer le débogueur.  Si vous avez suivi le cours sur CMake, vous n'avez rien à faire, tout est déjà configuré.  Configuration manuelle Sinon, sachez qu'il est possible de configurer le débogueur manuellement à l'aide d'un fichier launch.json. Si vous voulez le configurer vous-même, vous pouvez vous rendre dans le panneau &quot;Run and Debug&quot; et cliquer sur le bouton &quot;Run and Debug&quot;. Vous devez ensuite sélectionner le débogueur que vous voulez utiliser (ici C++ (GDB/LLDB)) et cliquer sur Add Configuration. Cela créera un fichier launch.json dans un dossier /.vscode à la racine du projet. Si vous voulez plus de détails sur la configuration manuelle, vous pouvez vous rendre ici. S'il y a une seule chose à vérifier, c'est que le champ &quot;program&quot; pointe bien vers votre exécutable. En général, avec la configuration de CMake, il sera sous &quot;${workspaceFolder}/build/bin/Debug/YOURPROGRAM.exe&quot;  ","version":"Next","tagName":"h2"},{"title":"Utiliser le débogueur​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#utiliser-le-débogueur","content":" Il suffit d'appuyer sur CTRL + F5, ou sur l'icône de debug 🐛 dans la barre inférieure :    Ça y est ! VSCode a lancé le programme en mode débogage. On va pouvoir commencer à l'utiliser.  ","version":"Next","tagName":"h2"},{"title":"Ajouter des points d'arrêt​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#ajouter-des-points-darrêt","content":" Comme vous pouvez le voir sur la capture ci-dessous, le programme est arrêté avec une ligne surlignée.    C'est grâce à un point d'arrêt que j'ai ajouté à la ligne 171717.  Vous pouvez ajouter des points d'arrêt en cliquant à gauche de la ligne sur laquelle vous voulez vous arrêter, juste avant le numéro de ligne, ou en appuyant sur F9 après avoir sélectionné une ligne.  Comme son nom l'indique, il permet d'arrêter le programme à un endroit précis pour inspecter celui-ci.  Points d'arrêt conditionnels​  Il est possible de rendre un point d'arrêt conditionnel, c'est-à-dire qu'il ne sera déclenché que si une certaine condition est remplie.  Pour cela, il suffit de faire un clic droit sur le point d'arrêt et de sélectionner Edit Breakpoint.  Vous pouvez ensuite ajouter une expression qui sera évaluée à chaque fois que le programme passera par ce point d'arrêt pour déterminer s'il doit s'arrêter ou non.  Cela peut être très utile pour ne pas s'arrêter à chaque itération d'une boucle ou d'une fonction, mais seulement lorsqu'une certaine condition est remplie par exemple.  ","version":"Next","tagName":"h3"},{"title":"Inspecter les variables​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#inspecter-les-variables","content":" Dans la section Variables, vous pouvez voir toutes les variables du programme à l'instant où il est arrêté.    Par exemple, ici x vaut 10 !  Vous pouvez également laisser votre curseur sur une variable (hover) qui vous intéresse et un petit encadré va s'afficher pour vous montrer sa valeur.  C'est super utile et évite de devoir ajouter des std::cout (ou print/log en fonction des langages) pour afficher les valeurs actuelles de certaines variables.  Il est également possible de regarder spécifiquement certaines variables via la section Watch. (Cela peut être utile dans des cas plus complexes avec beaucoup de variables locales qui gênent la visibilité de la section Variables par exemple).    Vous pouvez aussi ajouter des expressions à évaluer dans cette section.  Par exemple, si on veut savoir si x est supérieur à 3:    Cela peut être très utile pour vérifier des conditions ou des valeurs intermédiaires ou inspecter des variables qui ne sont pas directement accessibles (comme des membres de structures ou des éléments de tableaux).  ","version":"Next","tagName":"h3"},{"title":"Pile d'appel​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#pile-dappel","content":" La pile d'appel liste les différents appels que le programme a parcouru (fonctions/méthodes) pour arriver au point où le programme est arrêté actuellement.    Vous pouvez voir que le programme est arrêté dans la fonction fib (qui est récursive). Il est possible de naviguer dans la pile d'appel en cliquant sur les différentes lignes.  ","version":"Next","tagName":"h3"},{"title":"Navigation en mode debug​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#navigation-en-mode-debug","content":" Une fois que le programme est en mode débogage, un ensemble de boutons apparaît en haut de ton écran.    Ces boutons contrôlent l'exécution du programme :  Le bouton Continue permet de lancer l'exécution du programme et de la poursuivre jusqu'à ce qu'un nouveau point d'arrêt soit atteint.  remarque Celui-ci se transforme en un bouton pause lorsque le programme n'est pas actuellement arrêté. Cela peut s'avérer utile quand vous avez l'impression que votre programme est bloqué (boucle infinie, appel asynchrone, etc).  Step Over et Step Into se déplacent d'une instruction à la fois et gèrent la façon dont les appels de fonctions sont traités.Step Over sautera les appels de fonctions (ou de méthodes), tandis que Step Into suivra ces appels (pour rentrer dans la fonction qui va être appelée). La quatrième option est Step Out. Elle exécute toutes les commandes de la fonction en cours et s'interrompt lorsqu'elle revient à la fonction appelante. Les deux dernières options sont Restart et Stop, qui permettent de continuer l'exécution du programme ou de l'arrêter.  ","version":"Next","tagName":"h3"},{"title":"Arrêt automatique sur les erreurs​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#arrêt-automatique-sur-les-erreurs","content":" Il est possible de configurer le débogueur pour qu'il s'arrête automatiquement lorsqu'une erreur se produit.  Une fois le programme lancé en mode débogage, vous pouvez allez dans la section Breakpoints et cocher la case All C++ Exceptions. Cela permettra de s'arrêter automatiquement lorsqu'une exception non gérée se produit.  Cela permet de voir où l'erreur se produit et de remonter la pile d'appel pour comprendre pourquoi et surtout où précisément l'erreur se produit.  info généralement, le débogueur s'arrête à un point où l'exception est lancée mais au sein de la bibliothèque standard, donc il faut remonter un peu dans la pile d'appel pour trouver où l'erreur a été déclenchée depuis votre code.  ","version":"Next","tagName":"h3"},{"title":"Raccourcis clavier​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#raccourcis-clavier","content":" Si vous utilisez le débogueur pour la première fois vous allez sûrement utiliser les boutons pour vous déplacer.  Mais il est possible d'utiliser des raccourcis clavier pour aller plus vite. Une fois maîtrisés, ils vous permettront de gagner un temps considérable lors du débogage de vos programmes.  Continue\tStep Over\tStep Into\tStep Out\tRestart\tStopF5\tF10\tF11\tSHIFT + F11\tCTRL + SHIFT + F5\tSHIFT + F5  ","version":"Next","tagName":"h3"},{"title":"Erreurs courantes​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreurs-courantes","content":" Vous avez sûrement déjà rencontré des erreurs lors de la compilation ou de l'exécution de vos programmes.  C'est normal, tout le monde en fait, même les plus expérimentés.  Une erreur peut survenir à la compilation ou à l'exécution de votre programme, ll est important d'apprendre à les lire pour pouvoir les corriger et les comprendre.  Les erreurs de compilation sont les plus courantes. Elles se produisent lorsque le compilateur ne peut pas générer le fichier exécutable à partir de votre code.  Voici quelques exemples d'erreurs de compilation courantes.  ","version":"Next","tagName":"h2"},{"title":"Erreur de segmentation​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-segmentation","content":" L'erreur de segmentation est une erreur très courante en C++. Elle se produit lorsque vous essayez d'accéder à une zone de mémoire à laquelle vous n'avez pas le droit d'accéder. Cela peut être dû à plusieurs raisons :  Accès à un tableau en dehors de ses limitesAccès à un pointeur non initialisé ou libéré (dangling pointer) (nous verrons cela plus tard)  Elle se manifeste par un message d'erreur du type :  Segmentation fault (core dumped)   ","version":"Next","tagName":"h3"},{"title":"Erreur de syntaxe​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-syntaxe","content":" Les erreurs de syntaxe sont les plus simples à trouver. Elles se produisent lorsque vous avez mal écrit quelque chose dans votre code.  Par exemple, si vous oubliez un point-virgule à la fin d'une ligne, ou si vous oubliez une accolade, le compilateur vous le signalera.  int x {10}   error: expected ';' after expression   parfois le message d'erreur peut être un peu cryptique, mais en général, il vous indique la ligne et la colonne où il a trouvé l'erreur. Il suffit de regarder à cet endroit (et un peu avant) pour trouver l'erreur.  ","version":"Next","tagName":"h3"},{"title":"Erreur de type​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-type","content":" Les erreurs de type se produisent lorsque vous essayez d'assigner un type à un autre incompatible.  Par exemple, si vous essayez d'assigner un tableau (std::vector) à une variable de type int :  int x { std::vector&lt;int&gt;{1, 2, 3} };   error: conversion from 'std::vector&lt;int&gt;' to non-scalar type 'int' requested   Les explications peuvent être un peu plus complexes, mais en général, le message d'erreur vous indique clairement ce qui ne va pas.  ","version":"Next","tagName":"h3"},{"title":"Erreur de définition multiple​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-définition-multiple","content":" Les erreurs de définition se produisent lorsque vous déclarez une variable ou une fonction plusieurs fois.  Par exemple, si vous déclarez une variable dans un fichier d'en-tête et que vous l'incluez dans plusieurs fichiers source :  // file1.hpp #pragma once int x;   // file1.cpp #include &quot;file1.hpp&quot; int x {10};   error: redefinition of 'int x'   danger C'est pour cela qu'il est très fortement déconseillé de déclarer des variables dans des fichiers d'en-tête ou des variables globales de manière générale.  ","version":"Next","tagName":"h3"},{"title":"Erreur de référence non définie​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-référence-non-définie","content":" Les erreurs de référence non définie (Undefined reference) se produisent lorsque vous déclarez une fonction mais que vous ne l'implémentez pas.  Par exemple, si vous déclarez une fonction dans un fichier d'en-tête et que vous ne l'implémentez pas dans un fichier source :  // file1.hpp #pragma once void foo();   // file1.cpp #include &quot;file1.hpp&quot; int main() { foo(); return 0; }   error: undefined reference to `foo()'   Le compilateur ne peut pas trouver la définition de la fonction foo et vous signale une erreur.  ","version":"Next","tagName":"h3"},{"title":"Erreur de lien​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-lien","content":" Les erreurs de lien (linker error) se produisent lorsque le compilateur ne peut pas trouver une bibliothèque ou un fichier objet nécessaire à la compilation.  Elles sont souvent plus difficiles à comprendre, mais en général, elles vous indiquent le nom du fichier ou de la bibliothèque manquante.  ","version":"Next","tagName":"h3"},{"title":"Erreur de logique​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#erreur-de-logique","content":" Les erreurs de logique (ou d'implémentation) sont les plus difficiles à trouver. Elles se produisent lorsque votre programme ne fait pas ce que vous attendez de lui, mais qu'il compile et s'exécute sans erreur.  Pour les trouver, il faut souvent déboguer des points d'arrêt et inspecter les variables pour comprendre ce qui ne va pas.  Quelques exemples d'erreurs de logique typiques :  Une boucle infinie :  int i {0}; while (i &lt; 10) { // Oubli d'incrémenter i }   Une condition mal écrite :  int x {10}; if (x = 0) { // Ne sera jamais exécuté }   Un tableau ou un pointeur mal utilisé :  int tab[10] {}; for (int i = 0; i &lt;= 10; i++) { // Accès en dehors des limites du tableau }   Cela peut parfois ne pas générer d'erreur de segmentation, mais le comportement du programme sera incorrect.  Une utilisation de valeur non signée incorrecte :  unsigned int x {0}; int y {-1}; if (x &gt; y) { // Ne sera jamais exécuté }   ou encore  unsigned int x {10}; while (x &gt;= 0) { // Boucle infinie x -= 1; // x est toujours positif et donc lorsqu'il est décrémenté mais qu'il est déjà à 0, //il repasse à la valeur maximale d'un unsigned int }   Une division par zéro :  float division(float const x, float const y) { return x / y; } float x {10}; float y {0}; float z {division(x, y)};   Floating point exception (core dumped)   Passage par copie au lieu de passage par référence :  void increment(int x) { x++; } int x {10}; increment(x); std::cout &lt;&lt; x &lt;&lt; std::endl; // Affiche 10   Ici la fonction increment prend x par copie et non par référence, donc la variable x n'est pas modifiée. C'est une copie locale à la fonction increment qui est modifiée.  ","version":"Next","tagName":"h3"},{"title":"Exceptions​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#exceptions","content":" Dans le cas de la division par zéro par exemple on pourrait utiliser un if pour vérifier si y est différent de 0 avant de faire la division. Mais dans le cas où y est égal à 0 on aimerait pouvoir le signaler à l'utilisateur de la fonction pour afficher un message d'erreur ou alors effectuer une autre action spécifique (redemander une valeur à l'utilisateur par exemple).  C'est là qu'interviennent les exceptions. Les exceptions sont des objets qui permettent de signaler une erreur ou un comportement anormal dans un programme.  En C++ on utilise le mot clé throw pour lancer une exception.  #include &lt;stdexcept&gt; float division(float const x, float const y) { if (y == 0) { throw std::runtime_error(&quot;Division by zero&quot;); } return x / y; }   De même par exemple lors de l'utilisation d'un std::vector si on essaye d'accéder au dernier élément grâce à la méthode back() alors que le vecteur est vide, une exception de type std::out_of_range sera lancée.    Ces exceptions peuvent être &quot;attrapées&quot; et traitées dans un bloc try catch:  try { float z {division(x, y)}; std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; z &lt;&lt; std::endl; } catch (std::exception&amp; const e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }   Il y aurait beaucoup à dire sur les exceptions (utilisation, avantage et inconvénient, etc) mais ce n'est pas le sujet de ce cours. Je voulais juste vous montrer qu'elles existent et introduire le mot clé throw pour que vous puissiez l'identifier si vous le voyez dans du code.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Déboguer son code","url":"/Learn--cpp_programming/Lessons/S1/DebuggerAndErrors#résumé","content":" Le débogueur est un outil puissant pour comprendre le comportement de votre programme. Il permet d'arrêter l'exécution à un point précis appelé point d'arrêt (ou breakpoint). Vous pouvez inspecter les variables, la pile d'appel (callstack) et avancer pas à pas dans l'exécution. Il est possible de configurer le débogueur pour qu'il s'arrête automatiquement lorsqu'une erreur se produit. Les erreurs courantes sont : Erreur de segmentation (segmentation fault) : accès à une zone de mémoire interditeErreur de syntaxe : oubli de point-virgule, d'accolade, etcErreur de type : assignation ou conversion de type incorrecteErreur de logique : boucle infinie, condition mal écrite, etcErreur de compilation : undefined reference, multiple definition, linker error, etc Il est possible de lancer des exceptions avec le mot clé throw et de les gérez avec un bloc try catch. ","version":"Next","tagName":"h2"},{"title":"Des tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Tableaux​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#tableaux","content":" Les tableaux sont là pour résoudre ce problème et nous permettre de stocker plusieurs éléments.  Ils font partie de ce qu'on appelle les structures de données, des structures permettant d'organiser de façon particulière des données, on les nomme aussi des conteneurs.  En ce qui concerne les tableaux il en existe principalement deux types:  std::array qui permet de stocker un nombre fixé à l'avance d'élémentsstd::vector qui permet de stocker un nombre variable ou dynamique d'éléments  A retenir que les tableaux permettent seulement de stocker des variables de même type.  remarque Il existe bien d'autres structures de données qui stockent de façon différente (avec des avantages et des inconvénients) mais nous n'allons pas rentrer dans ce détail pour l'instant.  ","version":"Next","tagName":"h2"},{"title":"std::vector​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdvector","content":" Comme vous le remarquez, j'ai ajouté std:: devant vector ce qui nous indique que c'est une fonctionnalité déjà codée pour nous dans la bibliothèque standard. Pour pouvoir s'en servir on va donc inclure le fichier contenant cette fonctionnalité en faisant #include &lt;vector&gt;  std::vector est un tableau dynamique qui s'agrandit et se rétrécit en fonction du nombre d'éléments que l'on souhaite stocker à l'intérieur.  On l'initialise entre accolades en précisant entre chevrons (&lt; et &gt;) le type de variable que l'on souhaite stocker:  std::vector&lt;/* type des éléments du tableau */&gt; nom {};   des exemples #include &lt;vector&gt; int main() { // initialisation d'un tableau à remplir plus tard std::vector&lt;int&gt; vector01 {}; // il est aussi possible de le préremplir à sa création std::vector&lt;int&gt; vector02 { 12, 18, 8, 4, 9 }; // on peut rendre constant afin d'éviter de future modifications si c'est ce que l'on souhaite std::vector&lt;float&gt; const vector03 { 3.1415f, 5.2365f }; // il est aussi possible de l'initialiser en copiant les valeurs d'un autre tableau de cette manière std::vector&lt;float&gt; vector04 { vector03 }; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Manipuler notre tableau​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#manipuler-notre-tableau","content":" ","version":"Next","tagName":"h2"},{"title":"Accéder aux éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#accéder-aux-éléments","content":" Pour accéder aux éléments on utilise les crochets ([ et ]) après le nom de notre tableau, avec la position de l’élément à récupérer.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; &quot;the second élément is &quot; &lt;&lt; vector[1] &lt;&lt; std::endl; return 0; }   attention ⚠️ généralement en informatique (c'est le cas en C++), les éléments sont indexés à partir de 0 et non 1. c'est pour ça que 0 correspond au premier élément et 1 au deuxième dans notre exemple.  danger Et si j’accède à l’élément d'index 6 (donc le 7ème élément) alors que mon tableau n'en contient que 6, que se passe-t-il ? C'est un comportement indéterminé. Le programme peut continuer sans rien dire, ou alors s'arrêter brusquement avec des erreurs nommées généralement &quot;out of range&quot; (dépassement de capacité) ou &quot;segmentation fault&quot; (erreur de segmentation). Il ne faut pas utiliser d’indice inférieur à 0 ou supérieur ou égal à la taille de notre tableau.  ","version":"Next","tagName":"h3"},{"title":"Taille du tableau​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#taille-du-tableau","content":" Pour connaître la taille du tableau on va utiliser la fonction propre (appelée méthode) size() qui renvoie le nombre d'éléments.  remarque Une fonction est un regroupement d'instructions que permet de réutiliser du code à plusieurs endroits d'un programme. Une méthode est une fonction propre à un objet (ici notre std::vector) et qui peut le manipuler ou retourner des informations à son sujet. Nous en reparlerons plus en détail dans un prochain chapitre, mais nous pouvons dès maintenant en utiliser.  Le type de retour de cette méthode est un type nouveau, que nous n’avons pas rencontré jusque-là et qui s’appelle std::size_t. C’est un type entier non signé capable de stocker l'index d'un élément ou la taille de n’importe quel tableau, aussi grand soit-il. C'est, pour faire simple, un très grand entier positif équivalent à écrire unsigned long int.  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; std::size_t const size { vector.size() }; std::cout &lt;&lt; &quot;Mon tableau contient &quot; &lt;&lt; size &lt;&lt; &quot; éléments.&quot; &lt;&lt; std::endl; return 0; }   remarque Il existe aussi une fonction std::size(...) qui prends en paramètre le tableau et retourne sa taille. std::size_t const size { std::size(vector) }; Dans la pratique, j'utilise plutôt la méthode, plus lisible selon moi mais c'est un avis personnel et vous êtes libres de choisir ce qu’il vous plaît.  ","version":"Next","tagName":"h3"},{"title":"Premier et dernier élément​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#premier-et-dernier-élément","content":" On pourrait utiliser la taille pour accéder au dernier élément du tableau mais on peut aussi utiliser deux autres méthodes (front() et back()) pour accéder au premier et au dernier élément du tableau:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; // Façon de faire hérité du c en utilisant la taille du tableau (attention au -1 les index commencent à 0) std::cout &lt;&lt; &quot;Le dernier élément est &quot; &lt;&lt; vector[vector.size() - 1] &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le premier élément est &quot; &lt;&lt; vector.front() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le dernier élément est &quot; &lt;&lt; vector.back() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Vérifier si un tableau est vide​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#vérifier-si-un-tableau-est-vide","content":" Pour savoir si le tableau est vide on peut utiliser une condition sur la taille du tableau. Il y a aussi la méthode empty() qui fait ce test pour nous et permet d'écrire quelque chose de plus lisible:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector01 { }; std::vector&lt;int&gt; const vector02 { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.size() == 0 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.empty() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector02 est vide : &quot; &lt;&lt; vector02.empty() &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Afficher les éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#afficher-les-éléments","content":" Pour afficher les éléments du tableau on peut simplement utiliser sa taille et une boucle for pour itérer sur les différentes valeurs:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; for (std::size_t i {0}; i &lt; vector.size(); i++) { std::cout &lt;&lt; vector[i] &lt;&lt; std::endl; } return 0; }   Range-based for loop​  Depuis le C++ moderne (à partir de C++11) il existe une nouvelle façon de parcourir des conteneurs (qui se généralise sur d'autres structures de données):  for (/* type d'un élément du tableau */ nom : /* structure de données à parcourir */) { }   remarque On appelle cela un foreach dans d'autres languages.  Plus besoin de récupérer la taille et cela va rendre notre code plus lisible:  Petit exemple avec std::vector #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; const vector { 12.f, 18.f, 8.f, 4.f, 9.f }; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   ","version":"Next","tagName":"h3"},{"title":"Ajouter, supprimer et modifier des éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#ajouter-supprimer-et-modifier-des-éléments","content":" Comme expliqué, le std::vector est dynamique dans le sens où il est possible d'ajouter ou de supprimer des éléments. C'est avec la méthode push_back que l'on ajoute un élément:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;float&gt; vector { 42.f }; // On ajoute des éléments vector.push_back(23.f); vector.push_back(5.f); for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   attention On ne pourra pas ajouter un élément de type différent dans notre tableau, un tableau ne peut contenir qu'un seul type de variable.    Pour supprimer un élément on utilisera les méthodes pop_back ou clear.  clear comme son nom l'indique permet de vider entièrement le tableau et pop_back permet de retirer le dernier élément.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;float&gt; vector { 42.f, 12.f }; std::cout &lt;&lt; &quot;Taille avant clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.clear(); std::cout &lt;&lt; &quot;Taille après clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.push_back(23.f); vector.push_back(42.f); vector.push_back(25.f); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; vector.pop_back(); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; if(!std::empty(vector)) { float last_value {vector.back()}; vector.pop_back(); std::cout &lt;&lt; &quot;La derniere valeur du tableau etait : &quot; &lt;&lt; last_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (float const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; } return 0; }   danger Appeler pop_back sur un tableau vide est aussi un comportement indéterminé. Une très bonne pratique est donc de s'assurer que le tableau n'est pas vide.    Enfin, pour pouvoir modifier une valeur il suffit d'accéder à l'élément (à condition que le tableau ou la variable ne soit pas constante évidemment) d'utiliser le symbole égal =.  #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 24, 12, 6 }; // On change la valeur du premier élément vector[0] = 15; return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::array​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdarray","content":" std::array est un tableau statique, c’est-à-dire que sa taille doit être connue à la compilation et ne peut pas varier. En contre-partie, cette structure de données est plus performant et plus rapide qu’un std::vector puisqu’il n’y a pas d’opération d’ajout ou de retrait d’éléments.  Pour l’utiliser, il faut inclure le ficher qui contient cette fonctionnalité (#include &lt;array&gt;).  On l'initialise en précisant entre chevrons le type de variable que l'on souhaite stocker et sa taille:  std::array&lt;/* type des éléments du tableau */, /* taille du tableau */&gt; nom {};   Contrairement à std::vector, un tableau statique doit contenir autant d'éléments que la taille précisée. Ainsi, si l'on ne précise donc rien ou pas la totalité des éléments à son initialisation, le tableau va être rempli avec des valeurs par défaut.  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array_of_integer { 24, 12, 6, 32, 8 }; // On change la valeur du deuxième élément array_of_integer[1] = 42; std::cout &lt;&lt; &quot;Le tableau d'entier contient: &quot;; for (int const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // les 4 autres valeurs non précisées seront donc égale à 0.0f std::array&lt;float, 6&gt; array_of_float { 45.3f, 142.857f }; std::cout &lt;&lt; &quot;Le tableau de flottant contient: &quot;; for (float const value : array_of_float) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // Ce tableau sera rempli de 4 valeurs par défaut égales à 0.0 std::array&lt;double, 4&gt; array_of_double { }; return 0; }   Il existe la méthode fill spécifique au std::array qui permet de le remplir avec une valeur donnée:  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array { 1, 2, 3, 4, 5}; array.fill(3); std::cout &lt;&lt; &quot;Le tableau contient: &quot;; for (int const value : array) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; return 0; }   Le reste des fonctionnalités reste identique avec le std::vector (hors les ajouts et suppressions car le tableau ne change pas de taille ici).  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#pour-aller-plus-loin","content":" std::vector et std::array sont des structures qui disposent d'une multitude de méthodes très utiles, je vous laisse chercher par vous même dans la documentation ou revenir vers moi si vous avez des questions à ce sujet.  ","version":"Next","tagName":"h2"},{"title":"std::string: un tableau caché​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdstring-un-tableau-caché","content":" Nous avions découvert le type un peu particulier std::string dans le chapitre sur les variables.  Ce &quot;type&quot; est lui même une structure de données qui permet de stocker du texte, une suite de caractères (de type char donc).  Le type std::string n’est donc rien d’autre qu'un tableau dynamique de char, conçu et optimisé spécialement pour le stockage de texte.  On peut donc faire toutes les opérations que nous venons de voir, accéder à sa taille, accéder aux caractères, les modifier, en ajouter ou supprimer et enfin boucler sur les caractères.  des exemples #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string phrase { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; &quot;Premier caractère : &quot; &lt;&lt; phrase.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dernier caractère : &quot; &lt;&lt; phrase.back() &lt;&lt; std::endl; phrase.pop_back(); phrase.push_back('.'); std::cout &lt;&lt; phrase &lt;&lt; std::endl; phrase[9] = ' '; std::cout &lt;&lt; phrase &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Cette phrase contient &quot; &lt;&lt; phrase.size() &lt;&lt; &quot; caractères.&quot; &lt;&lt; std::endl; // Il existe aussi &quot;phrase.length()&quot; qui fait exactement la même chose for (char lettre : phrase) { std::cout &lt;&lt; lettre &lt;&lt; ','; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Est ce que la phrase est vide ? &quot; &lt;&lt; std::empty(phrase) &lt;&lt; std::endl; return 0; }   std::string dispose de nombreuses autres méthodes permettant de faire d'autres choses spécifiques à la gestion de texte. Nous aurons l’occasion de le revoir, retenez simplement ici que std::string peut être manipulé comme un tableau.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#résumé","content":" Il existe plusieurs types de tableaux, statique quand la taille est fixe et dynamique quand elle peut varier.  std::vector est un tableau dynamique.std::array est un tableau statique.std::string est un tableau dynamique spécialement conçu pour la gestion du texte. ","version":"Next","tagName":"h2"},{"title":"Compilation et Headers: Séparer en plusieurs fichiers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Headers","content":"","keywords":"","version":"Next"},{"title":"Mécanisme de compilation (en simple)​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#mécanisme-de-compilation-en-simple","content":" Revenons à la compilation quelques instants pour mieux comprendre.  Quand j'ai parlé de compilation j'ai fait un abus de langage et j'ai englobé plusieurs étapes. Pour faire simple, il y a en réalité trois grandes étapes lors de la compilation en C++:  Le préprocesseurLa compilationLe linkage  ","version":"Next","tagName":"h2"},{"title":"Le préprocesseur​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-préprocesseur","content":" La toute première étape est celle du préprocesseur. C'est le moment où toutes les directives préprocesseur sont traitées (toutes les lignes commençant par #).  Par exemple, nous avons déjà la directive préprocesseur #include qui permet d'inclure des fonctionnalités.  Cette directive fait simplement un copié-collé du contenu du fichier à inclure dans le fichier où la directive est utilisée.  Je ne vais pas en parler ici mais sachez qu'il existe d'autres directives permettant de faire des conditions en fonction des plateformes par exemple.  ","version":"Next","tagName":"h3"},{"title":"La compilation​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#la-compilation","content":" Ensuite nous avons la compilation à proprement parler.  Chaque fichier .cpp, obtenu après les modifications du préprocesseur, appelé unité de compilation, va être traité individuellement. Le but de cette étape est de transformer le code C++ (sous format texte) en langage compréhensible pour l'ordinateur.  C’est à cette étape que des vérifications du code ont lieu. Par exemple, dans le cas où le compilateur ne trouve pas la déclaration d’une fonction que vous appelez. Dans notre exemple précédent dans le fichier main.cpp, la compilation va s'arrêter avec un message d'erreur indiquant ce qui n’a pas fonctionné.  Cette étape va produire des fichiers objets.  Un fichier objet, reconnaissable à son extension en .o ou .obj, n’est rien d’autre que du langage machine mais seul, sans aucun lien avec le reste des autres fichiers. Tel quel, il n’est pas exécutable, car il lui manque des informations.  Il est possible de préciser aux compilateurs que l'on souhaite s'arrêter à ce stade en ajoutant des flags de compilation:  WindowsLinux et MacOS Avec MSVC le flag est /c: cl /c helloImac.cpp   Cela indique au compilateur que l'on souhaite produire des fichiers objets et pas directement lier les fichiers pour en faire un exécutable.  Les fichiers d'objets peuvent faire référence à des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore entièrement définis. C'est le cas lorsque l'on utilise une fonction déclarée et que l'on n'a pas encore écrit le corps de celle-ci, nous allons le voir juste après. Le compilateur ne s'en préoccupe pas et produit le fichier objet demandé si le reste du code est correct.  remarque L'avantage est qu'il n'est pas nécessaire de tout recompiler si vous ne modifiez qu'un seul fichier. Si aucune modification n’est détectée depuis la dernière compilation, alors le compilateur réutilise le fichier objet précédemment créé lors d'une prochaine compilation ce qui accélère la compilation d’un projet. Cmake gère les fichiers objets lui même automatiquement dans le fameux dossier build.  ","version":"Next","tagName":"h3"},{"title":"Le linkage​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-linkage","content":" Nos fichiers objets ne sont pas utilisables en l'état et c'est la dernière étape de linkage qui va les lier entre eux pour produire un exécutable.  C'est ce qui va permettre de lier la déclaration d'une fonction dans un fichier et le corps de la fonction dans un autre fichier par exemple.  Il est aussi possible de faire cette opération en ligne de commande à partir des fichiers objets mais ce n'est pas très utile en pratique car des outils comme CMake se charge de cette étape pour nous.  ","version":"Next","tagName":"h3"},{"title":"En pratique​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#en-pratique","content":" Revenons à notre exemple avec les fichiers maths.cpp et main.cpp:  Premièrement, il manque la déclaration de la fonction sum (son prototype) dans le fichier main.cpp pour pouvoir produire un fichier objet valide:  main.cpp #include &lt;iostream&gt; int sum (int const a, int const b); int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   Ce fichier ne permet toujours pas de créer un exécutable à lui seul (car il manque le corps de la fonction sum) mais il est maintenant possible d'en faire un fichier objet.  ","version":"Next","tagName":"h2"},{"title":"Fichier d'en-tête​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#fichier-den-tête","content":" Pour une seule fonction dans mon exemple c'est simple de recopier le prototype de la fonction. Imaginons que notre fichier maths.cpp soit composé de dizaines de fonctions et que l'on souhaite les utiliser dans le fichier main.cpp mais aussi dans un autre fichier du même projet. Cela commence à être fastidieux de tout recopier.  On va donc regrouper les déclarations des fonctions dans un autre fichier d'extension .hpp que l'on appelle fichier d'en-tête (header en anglais).  Ainsi grâce à la directive préprocesseur #include on va pouvoir inclure (recopier) toutes les déclarations des fonctions facilement.  Dans notre exemple le fichier d'en-tête serait simplement:  maths.hpp int sum (int const a, int const b);   et le main.cpp devient:  main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   guillemets ou chevrons On peut noter une petite différence, j'utilise ici des guillemets &quot;&quot; pour l'inclusion et pas des chevrons &lt; &gt;. On pourrait très bien utiliser des guillemets tout le temps et faire: #include &quot;iostream&quot;. Cette différence est une question de convention et on réserve les chevrons &lt; &gt; pour les fichiers de qui viennent de bibliothèques comme la bibliothèque standard (iostream, string, vector, etc) et les guillemets &quot;&quot; pour le reste.  On va également inclure ce fichier d'en-tête dans notre fichier maths.cpp pour s'assurer que l'on implémente les bonnes fonctions listées dans le fichier d'en-tête.  maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   cpp ou hpp Les fichiers d’en-tête peuvent aussi utiliser l’extension .h. La différence n’est qu’une histoire de goût. Je préfère utiliser .hpp plutôt que .h pour mieux faire la distinction entre C et C++ par analogie aux fichiers sources, qui se terminent par .cpp en C++ mais .c en C.  ","version":"Next","tagName":"h3"},{"title":"Pragma once: éviter les doublons​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#pragma-once-éviter-les-doublons","content":" Mais se pose alors la question des doublons si l'on inclut de nombreux fichiers, les uns dépendants des autres.  Dans le cas des fonctions ce n'est pas bien grave car déclarer plusieurs fois une fonction (je parle du prototype pas du corps qui lui doit être unique) est autorisé bien que ce soit inutile.  Par contre ce n'est pas toujours le cas. Par exemple avec les Enums il n'est pas possible de les déclarer deux fois et on obtient une erreur de compilation si on le fait.  Un exemple Admettons que l'on a un autre fichier utils.cpp qui inclut maths.cpp pour fonctionner. utils.hpp contient les déclarations des fonctions propres au fichier utils.cpp. Le fichier maths.hpp définit un enum. Si maintenant on souhaite utiliser des fonctions des deux fichiers dans notre fichier principal main.cpp, on va se retrouver à inclure les deux: main.cpp #include &quot;utils.hpp&quot; #include &quot;maths.hpp&quot; int main() { // ... return 0; } Cela va provoquer une erreur lors de la compilation du fichier objet main car l'enum est déclaré deux fois. Une fois provenant de l'inclusion de utils.hpp (qui inclut lui-même maths.hpp) et une seconde fois en incluant directement le fichier maths.hpp.  #pragma once est une directive du préprocesseur là pour répondre à notre besoin.  Elle est utilisée pour empêcher que le contenu des fichiers d'en-tête soient inclus plusieurs fois. La directive #pragma once, présente dans un fichier d'en-tête, garantit que le contenu du fichier sera inclus une seule fois dans une compilation.  Le fichier maths.hpp dans notre exemple devient donc:  maths.hpp #pragma once int sum (int const a, int const b);   Un fichier d'en-tête doit toujours contenir cette directive au début du fichier.  Structures​  Bien que ce soit possible de mettre la déclaration d'une structure dans un fichier .cpp généralement on a besoin de s'en resservir dans plusieurs fichiers et la déclaration se trouve donc dans un fichier d'en-tête (.hpp).  Cependant, comme pour les enums, une structure ne peut être déclarée qu'une fois et il ne faut donc surtout pas oublier la directive préprocesseur #pragma once pour éviter un doublon lors d'inclusions.  On utilisera dans ce cas la déclaration de la structure avec les prototypes des fonctions qui lui sont associées dans notre fichier d'en-tête.  ","version":"Next","tagName":"h3"},{"title":"Utiliser Cmake​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#utiliser-cmake","content":" Pour résumer nous avons donc maintenant les fichiers suivants:  maths.hpp #pragma once int sum (int const a, int const b);   main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   Nous allons les placer dans un dossier de projet puis dans un sous dossier /src (pour sources). Pour certains projets on peut avoir plusieurs sous dossiers comme /src, /include (pour séparer les fichiers d'en-tête). C'est une question d'organisation et de préférence.  Dans ce dossier de projet nous allons créer notre fichier CMakeLists.txt pour nous aider à compiler le projet.  Nous allons reprendre et modifier notre premier fichier Cmake.  Dans le fichier CMakeLists.txt il va falloir indiquer les répertoires où se trouvent les fichiers d'en-tête par target_include_directories().  On va également régler une variable Cmake CMAKE_RUNTIME_OUTPUT_DIRECTORY qui va permettre d'indiquer que l'on souhaite placer l'exécutable compilé dans un sous dossier bin.  CMakeLists.txt # la version de cmake à utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On souhaite placer l'exécutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # On indique que l'on souhaite faire un exécutable avec nos deux fichiers .cpp add_executable(helloImac &quot;src/main.cpp&quot; &quot;src/maths.cpp&quot;) # le dossier contenant les fichiers d'en-tête pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   CMAKE_SOURCE_DIR est une variable cmake qui indique le dossier dans lequel se trouve le fichier CMakeLists.txt (documentation ici).  attention Il faut s'assurer qu'il y a exactement une fonction d'entrée main() dans les fichiers sources listés pour un exécutable.  Petit résumé de notre dossier:  projet_folder/ ├── src/ │ ├── main.cpp │ ├── maths.cpp │ └── maths.hpp └── CMakeLists.txt   Vous pouvez maintenant ouvrir le dossier de projet dans VSCode et compiler votre projet.  ","version":"Next","tagName":"h2"},{"title":"Quelques améliorations​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#quelques-améliorations","content":" Je vous ai parlé de &quot;warnings&quot; de compilation à plusieurs reprises. Il est possible d'ajouter des options pour activer des warnings et avoir des informations supplémentaires lors de la compilation.  Je vous propose d'ajouter ces lignes dans votre fichier CMakeLists.txt:  if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif()   Cela va se complexifier avec un nombre plus important de fichiers sources. Avec Cmake il est possible de faire une recherche de fichier afin de ne pas avoir à lister tous les fichiers sources manuellement:  file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;)   Notre fichier CMakeLists.txt devient:  # la version de cmake à utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # Réglage du compilateur pour les warnings if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # On souhaite placer l'exécutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources message(STATUS &quot;Found source files:&quot;) foreach(SRC_FILE ${SRC_FILES}) message(STATUS &quot; - ${SRC_FILE}&quot;) endforeach() # On indique que l'on souhaite faire un exécutable avec nos fichiers sources add_executable(helloImac ${SRC_FILES}) # le dossier contenant les fichiers d'en-tête pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#résumé","content":" Les fichiers d'en-tête ou headers (d'extension .hpp) sont là pour lister les différentes déclarations des fonctions (et d'autres choses comme les enums) afin de pouvoir les utiliser dans plusieurs fichiers. Les fichiers objets sont des fichiers générés pendant la compilation. Ils peuvent faire référence à des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore entièrement définis mais seulement déclarés (et inclus à l'aide des fichiers d'en-tête). Ils permettent aussi d'accélérer la compilation pour réutiliser des parties de code inchangées. La directive préprocesseur #include fait simplement un copier-coller du fichier cible dans le fichier actuel. La directive préprocesseur #pragma once permet d'éviter de copier deux fois des déclarations lors d'inclusions. C'est très utile pour les fichiers d'en-tête contenant des enums ou des structures. Il faut toujours l'utiliser dans les fichiers d'en-tête. il y a 3 étapes dans la compilation: Le préprocesseur qui transforme les directives préprocesseur comme #include ou #pragma once.La compilation qui génère des fichiers objets pour chaque unité de compilation (fichiers .cpp après traitement du préprocesseur).Le linkage qui permet de lier tous les fichiers objets ensemble pour obtenir un exécutable. Cmake permet de gérer ces étapes de compilation simplement. ","version":"Next","tagName":"h2"},{"title":"Un peu d'histoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/introduction","content":"","keywords":"","version":"Next"},{"title":"Pourquoi apprendre C++ ?​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#pourquoi-apprendre-c-","content":" Sa popularité : le C++ est un langage qui est utilisé dans de nombreux projets importants de développement logiciel. Il est également beaucoup utilisé dans l'industrie du jeu vidéo. Il est enseigné dans de nombreuses formations en informatique. Il possède une communauté très importante, beaucoup de documentation et d’aide en ligne ainsi qu'une bibliothèques préexistantes très riche. Sa rapidité : C’est cette caractéristique qui fait de lui un des langages de choix pour les gros logiciels, les calculs scientifiques et le domaine du jeu vidéo. Son ancienneté : C++ est un langage ancien d’un point de vue informatique, il a fait l'objet de plusieurs mises à jour ce qui donne une certaine garantie de maturité, de stabilité et de pérennité (il ne disparaîtra pas dans quelques années). Sa modernisation : depuis sa version de 2011, C++ est beaucoup plus facile à apprendre. La version C++11 le rend plus facile à utiliser et plus puissant dans les fonctionnalités qu’il propose.  ","version":"Next","tagName":"h2"},{"title":"Langage difficile ?​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#langage-difficile-","content":" Tout n’est tout de même pas parfait et le C++ a aussi ses défauts.  Son héritage du C : C++ est un descendant du langage C, inventé dans les années 1970. Certains choix de conception, sûrement pertinents pour l’époque, sont plus problématiques aujourd’hui, et C++ les traine avec lui.  Sa complexité : La liberté et les performances qu'il offre viennent avec leur lot de complexités. Avoir une certaine maîtrise du C++ est &quot;long&quot; et demandera des années d’expérience, notamment parce que certaines des fonctionnalités les plus puissantes demandent de bien connaître les bases.  Mais je vous rassure, nous allons commencer par les bases pour aborder pas à pas ce langage, que vous ayez déjà programmé ou non. Nous allons découvrir les notions petit à petit pour que ce soit le plus compréhensible possible (certaines notions plus complexes ne seront d'ailleurs vu qu'en deuxième année).  ","version":"Next","tagName":"h2"},{"title":"La documentation​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#la-documentation","content":" En programmation, un bon réflexe à adopter est d'aller consulter la documentation de l’outil concerné, et ce avant de demander de l’aide sur un forum par exemple.  Voici un lien vers une excellente documentation C++. Elle est en anglais, mais je suis également là pour vous aider. Je vous donnerai des liens, vous expliquerai comment comprendre et exploiter les informations fournies pour que, par la suite, vous puissiez le faire vous-même.  Enfin, sachez qu’il existe une référence ultime appelée la norme, produit par un organisme de validation international, l'ISO, qui explique tous les détails et les règles du C++ mais qui est un document (trop) complexe, même pour des professionels, et est donc largement hors de portée nous concernant. Je le mentionne simplement pour que vous soyez au courant de son existence, sans être surpris si, lors de vos recherches sur Internet, des réponses mentionnent ou citent la norme.  ","version":"Next","tagName":"h2"},{"title":"Compilé vs interprété​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#compilé-vs-interprété","content":" Il existe deux grands types de langages informatiques, les langages interprétés et compilés.  Dans un langage interprété, le même code source pourra marcher directement sur tout ordinateur disposant de l'interpréteur nécessaire, c'est le cas du Python par exemple.  remarque L'interpréteur est un programme en lui même qui interprète le code pour le convertir en instructions compréhensibles pour la machine.  Avec un langage compilé, il faut compiler son programme (entièrement ou recompiler partiellement) à chaque fois pour pouvoir obtenir un exécutable utilisable sur la machine sur laquelle on veut lancer celui-ci.  Cela nécessite donc une étape supplémentaire (plus ou moins rapide): la compilation. Mais cela apporte également l'avantage de pouvoir optimiser et adapter l'exécutable pour une ou des machines spécifiques.  Dans la majorité des cas, l'exécutable compilé sera plus performant et plus rapide qu'un équivalent dans un langage interprété.  Dans votre cas, vous allez coder en C++ qui est un langage compilé et ce sera donc la première étape de ce cours.  Nous allons voir ensemble comment installer tous les outils nécessaires à tout développeur C++ sur votre machine afin d'exécuter votre premier programme C++. ","version":"Next","tagName":"h2"},{"title":"Des conditions et des boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops","content":"","keywords":"","version":"Next"},{"title":"Conditions​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#conditions","content":" ","version":"Next","tagName":"h2"},{"title":"Les valeurs booléennes​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#les-valeurs-booléennes","content":" J'ai omis un type lors du précédent chapitre, il s'agit du type booléen, il s'utilise avec le mot clé bool.  Ce type peut prendre deux valeurs: soit true, signifiant vrai, soit false qui veut dire faux. C'est donc idéal pour stocker le résultat d'une condition.  Voici un petit exemple int main() { bool const condition { true }; return 0; }   Cela va devenir intéressant grâce à ce que l'on appelle les opérateurs de comparaison.  Opérateur\tSignification==\tÉgalité, compare si deux variables sont égales !=\tInégalité, compare si deux variables sont différentes &lt;\tStrictement inférieur, compare si la variable de gauche est strictement inférieure à celle de droite &lt;=\tInférieur ou égal, compare si la variable de gauche est inférieure ou égale à celle de droite &gt;\tStrictement supérieur, compare si la variable de gauche est strictement supérieure à celle de droite &gt;=\tSupérieur ou égal, compare si la variable de gauche est supérieure ou égale à celle de droite  Ces opérateurs vont nous permettre de créer des conditions (des valeurs booléennes) à partir de nos autres variables.  #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; != &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a != b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt; &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt; b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt;= &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt;= b) &lt;&lt; std::endl; // On peut aussi stocker le résultat de la condition dans une variable booléenne float const price { 24.5f }; bool const is_too_expensive { price &gt;= 100.f }; return 0; }   remarque Par défaut, std::cout affiche 1 pour une condition vraie (true) et 0 pour une condition fausse (false). Il est possible de changer ce comportement en ajoutant un &quot;modificateur&quot; sur le stream std::cout: #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"La logique booléenne​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#la-logique-booléenne","content":" Maintenant que nous disposons d'un moyen d'obtenir une valeur booléenne (via les opérateurs de comparaison) nous allons pouvoir manipuler ces valeurs avec ce que l'on nomme des opérateurs logiques.  Ces opérateurs vont permettre de combiner et modifier des valeurs booléennes afin d'en obtenir d'autres et faire ce que l'on appelle plus généralement de l’algèbre booléenne. Mais ne vous inquiétez pas, derrière ce nom très mathématique se cache des choses très simples.  NOT: La négation​  L'opérateur ! (placé devant une valeur booléenne) permet d'exprimer la négation d'une condition.  remarque C'est ici un opérateur dit unaire (qui s'applique sur une seule valeur) et donne en retour la condition inverse.  Voici ce qu’on appelle la table de vérité de l’opérateur NOT, qui formalise les entrées et les sorties de cet opérateur.  A\tRésultattrue\tfalse false\ttrue  float price { 114.2f }; bool isExpensive { price &gt;= 100.f }; bool isCheap { !isExpensive };   AND​  L'opérateur &amp;&amp; (placé entre deux valeurs booléennes) permet d'exprimer la validité de deux conditions en même temps. On peut l'interpréter en français par : &quot;ma condition1 est vraie ET ma condition2 est aussi vraie&quot;.  A\tB\tRésultattrue\ttrue\ttrue true\tfalse\tfalse false\ttrue\tfalse false\tfalse\tfalse  OR​  L'opérateur || (placé entre deux valeurs booléennes) permet d'exprimer si au moins une des deux conditions est vraie. On peut l'interpréter en français par : &quot;ma condition1 est vraie OU ma condition2 est vraie&quot;.  A\tB\tRésultattrue\ttrue\ttrue true\tfalse\ttrue false\ttrue\ttrue false\tfalse\tfalse    remarque Il est également possible d'utiliser les mots-clés and, or et not pour remplacer respectivement les opérateurs &amp;&amp;, || et !. C'est possible mais très peu répandu en C++ c'est pourquoi je ne l'utiliserai pas personnellement mais sachez que ça existe également. Avec de vielles versions de Visual Studio il est possible que cette syntaxe ne fonctionne pas et dans ce cas il faut inclure le fichier &lt;ciso646&gt;.  danger Pour l'opérateur AND (&amp;&amp;) on note qu'il y a bien deux fois le symbole &amp;. C'est très important car il existe un autre opérateur (avec un seul &amp;) qui fait tout autre chose. Je ne détaillerai pas dans ce chapitre son utilité mais il est important de le souligner car c'est une erreur qui arrive fréquemment. De même pour l'opérateur OR (||) différent de |.  ","version":"Next","tagName":"h3"},{"title":"Des structures de contrôle​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#des-structures-de-contrôle","content":" C'est bien beau toutes ces valeurs booléennes mais comment on peut s'en servir pour exécuter une partie d'un code ou un autre en fonction d'une condition ?  Si​  Notre première structure de contrôle va s'utiliser avec le mot clé if. De l'anglais, ce mot clé signifiant &quot;si&quot;, exécute des instructions si et seulement si la condition donnée est vraie.  Un petit schéma d'explications:    Voilà comment l'utiliser. Toutes les instructions entre accolades seront exécutées si la condition est vraie.  if( /* condtion */ ) { // ... }   Un petit exemple #include &lt;iostream&gt; int main() { float price { 114.2f }; if ( price &gt;= 100.f ) { // appliquer une réduction si l'on dépasse un certain prix price *= 0.9f; } std::cout &lt;&lt; &quot;Le prix final est de &quot; &lt;&lt; price &lt;&lt; &quot;€&quot; &lt;&lt; std::endl; return 0; }   attention Il est possible de créer des variables à l'intérieur même des accolades de la structure de contrôle mais celles-ci sont restreintes à cette portée. C'est ce qu'on appelle la portée des variables (scope en anglais). Plus généralement, cette règle du C++ s'applique à n'importe quel bloc entre accolades.Une variable n’est utilisable que dans la portée, ou le bloc d’accolades où elle a été déclarée. Nous en reparlerons plus en détail dans d'autres chapitres.  attention Il n'est pas très utile de tester par une égalité le résultat d'une condition : float const price { 114.2f }; bool const isExpensive { price &gt;= 100.f }; if ( isExpensive == true ) { // ... } isExpensive ici étant déjà une valeur booléenne ajouter une égalité supplémentaire avec la valeur true ne va rien faire d'autre que de créer une nouvelle valeur booléenne qui a la même valeur. Il est donc plus clair et concis d'écrire directement: bool const isExpensive { price &gt;= 100.f }; if ( isExpensive ) { // ... }   Sinon​  C'est très bien de pouvoir effectuer quelque chose si une condition est vérifée mais comment faire si l'on veut effectuer une action A si la condition est vérifée et une autre action B si ce n'est pas le cas ?  On pourrait très bien enchaîner deux if avec la condition opposée:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } if ( temperature &lt; 35.f ) { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Mais c'est là que le mot-clé else (de l'anglais &quot;sinon&quot;) nous permet d'exécuter des instructions si la condition du if est fausse de manière plus compréhensible:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Ici le else n'a pas de parenthèse et indique donc &quot;tout le reste&quot; (ce qui ne vérifie pas la condition).  remarque L'opérateur logique de négation ! est parfois très utile dans le cas où l'on avait stocké une valeur mais l'on souhaite faire une suite d'instructions uniquement dans le bloc else du if. Au lieu de faire : #include &lt;iostream&gt; int main() { bool condition { false }; if ( condition ) { // ... ne rien faire } else { // effectuer nos instructions } return 0; } Il est préférable de faire: #include &lt;iostream&gt; int main() { bool condition { false }; if ( !condition ) { // effectuer nos instructions } return 0; }   Mais comment tester une succession de conditions différentes avant de faire &quot;tout le reste&quot; ?  Sinon si​  On pourrait très bien chaîner plusieurs if et else imbriqués de cette manière:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( /* condition1 */ ) { // ... } else { if ( /* condition2 */ ) { // ... } else { if ( /* condition3 */ ) { //... } else { //... } } } return 0; }   Mais vous êtes sûrement d'accord pour dire que ça commence à être difficile à suivre et écrire à cause des imbrications. Le C++ est bien fait et nous permet de d'utiliser la combinaison else if pour ce cas de figure.  else if s’utilise entre un if et un else et signifie &quot;ou alors si cette condition est vraie&quot;.  #include &lt;iostream&gt; int main() { if ( /* condition1 */ ) { // ... } else if ( /* condition2 */ ) { // ... } else if ( /* condition3 */ ) { //... } else { //... } return 0; }   remarque Enfin, il existe une dernière syntaxe (le switch pour les curieux) qui permet de faire quelque chose de similaire au else if mais il nous manque quelques notions et je vous le présenterai juste après les boucles.  ","version":"Next","tagName":"h3"},{"title":"Faux-ami​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#faux-ami","content":" danger Attention le test d'égalité == est différent de l'opérateur d'affectation =.  int number { 20 }; if ( number = 10 ) { // ... }   En C++, l'assignation retourne la valeur de la variable assignée. Ici, la condition sera vraie car number vaut 10 après l'assignation et 10 est considéré comme vrai.  Les valeurs numériques non nulles sont considérées comme vraies et la valeur 0 est considérée comme fausse.  ","version":"Next","tagName":"h3"},{"title":"Combinaison d'expressions​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#combinaison-dexpressions","content":" Avec tous les opérateurs logiques vu précédemment il est même possible de tester plusieurs conditions dans un même if.  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; bool const isRaining { false }; bool const wantToGoOut { true }; bool const ownsAnUmbrella { false }; if ( wantToGoOut &amp;&amp; (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella) ) ) { // ... } else { //... } return 0; }   danger Les opérateurs logiques sont comme les opérateurs mathématiques que nous avons vus dans les chapitres précédents: ils ont une priorité. Le plus prioritaire est la négation !Ensuite c'est le ET &amp;&amp;Enfin, le OU || est le moins prioritaire Par exemple avec le code a &amp;&amp; b || c &amp;&amp; d, dans l’ordre, on évalue a &amp;&amp; b, c &amp;&amp; d et enfin (a &amp;&amp; b) || (c &amp;&amp; d). Pour des raisons de lisibilité je vous recommande très fortement d'ajouter des parenthèses (comme dans mon exemple ci-dessus) pour expliciter quelles opérations vous voulez prioriser dans ce genre de cas plus &quot;complexe&quot;.  Pour aller plus loin: Algèbre de Boole​  Enfin, pour aller encore plus loin il est possible de manipuler les opérateurs &amp;&amp;, || et ! et trouver des expressions donnant le même résultat. Cela permet parfois de simplifier le code ou alors d'exprimer la condition sous une forme plus lisible ou compréhensible.  Dans mon exemple précédent la condition (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella)) est équivalente à écrire (!isRaining || ownsAnUmbrella).  En effet, si il ne pleut pas(!isRaining) , peu importe si j'ai un parapluie ou non, je peux sortir, Si cependant la première condition est fausse (il pleut) alors inutile de vérifier de nouveau si il pleut (!isRaining || (isRaining &amp;&amp;...) c'est impliqué par la première condition et donc il suffit de vérifier si j'ai un parapluie.  Il existe aussi le théorème de De Morgan qui permet d'exprimer la négation d'un ET avec un OU et inversement.  Il est possible d'exprimer mon exemple précédent sous cette forme:  (!isRaining || ownsAnUmbrella) équivalent à !(isRaining &amp;&amp; !ownsAnUmbrella)  On peut s'en convaincre en essayant de traduire ces conditions en phrases:  (!isRaining || ownsAnUmbrella): c'est le cas où il ne pleut pas ou alors j'ai un parapluie.!(isRaining &amp;&amp; !ownsAnUmbrella) ce n'est pas le cas où il pleut et je n'ai pas de parapluie.  Vous trouverez des exemples de propriétés et simplifications possibles sur la page Wikipédia suivante:Algèbre de Boole  ","version":"Next","tagName":"h3"},{"title":"Switch​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#switch","content":" Maintenant que nous avons toutes les cartes en main revenons brièvement au switch dont je vous parlais précédemment.  Très souvent on veut seulement tester la valeur d'une variable et effectuer telle ou telle action en fonction. On pourrait très bien écrire cela avec des else if:  #include &lt;iostream&gt; int main() { int value { 42 }; if ( value == 12 ) { // ... } else if ( value == 33 ) { // ... } else if ( value == 52) { //... } else { //... } return 0; }   C'est avec le mot clé switch que l'on va pouvoir faire cela de façon plus lisible:  #include &lt;iostream&gt; int main() { int value { 42 }; switch (value) { case 12: // ... break; // permet de quitter le bloc switch case 33: // ... break; case 52: // ... break; default: // ... break; } return 0; }   Lorsque l'expression testée est égale à une des valeurs listées avec les mots-clés case la totalité des instructions qui suivent sont exécutées. Le mot clé break indique la sortie de la structure de contrôle. Le mot clé default indique quelles instructions exécuter si l'expression n'est jamais égale à une des valeurs.  danger De manière générale, n'oubliez pas d'insérer des instructions break entre chaque test, ce genre d'oubli est difficile à détecter car aucune erreur n'est signalée... En effet la totalité des instructions suivant le case sont exécutées et donc on pourrait se retrouver à exécuter des instructions de manière involontaire. #include &lt;iostream&gt; int main() { int value { 33 }; switch (value) { case 12: std::cout &lt;&lt; &quot;value est égale à 12&quot; &lt;&lt; std::endl; case 33: std::cout &lt;&lt; &quot;value est égale à 33&quot; &lt;&lt; std::endl; default: std::cout &lt;&lt; &quot;value est différent de 12 ou 33&quot; &lt;&lt; std::endl; } return 0; } qui nous donne: value est égale à 33 value est différent de 12 ou 33 Cela peut être parfois voulu mais ici on se rend bien compte qu'il y a un problème et il ne faut donc pas oublier le mot clé break. Voici un exemple où cela peut être utile: #include &lt;iostream&gt; int main() { char letter { 'e' }; switch(letter) { case 'a': case 'e': case 'i': case 'o': case 'u': case 'y': std::cout &lt;&lt; &quot;You entered a vowel.&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;You entered a consonant.&quot; &lt;&lt; std::endl; break; } return 0; } Certains warnings de compilateur permette d'indiquer ce genre de cas mais c'est mieux d'y faire attention.  Switch et chaînes de caractères Il est important de noter que le mot clé switch ne peut pas être utilisé avec des chaînes de caractères. Il ne peut être utilisé qu'avec des types entiers (int, char, short, long, etc...) ou encore les énumérations. il est possible de faire cela avec des if et else if mais généralement lors de l'utilisation de switch on connaît à l'avance les valeurs possibles et donc on utilisera de préférence des énumérations ou des constantes.  ","version":"Next","tagName":"h3"},{"title":"Boucles​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#boucles","content":" Nous avons maintenant la capacité d'exécuter des codes différents en fonction de conditions. Cependant, notre programme reste essentiellement linéaire, car nous exécutons les instructions de haut en bas, l'un à la suite des autres.  Nous allons maintenant explorer de nouvelles structures de contrôle: les boucles. Elles vont nous permettre de répéter plusieurs fois une série d'instructions, selon nos besoins.  ","version":"Next","tagName":"h2"},{"title":"While - \"Tant que ...\"​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#while---tant-que-","content":" La première est la boucle while, de l'anglais qui signifie &quot;tant que&quot;. Elle exécute une série d’instructions tant qu'une condition est vraie. Une fois que la condition devient fausse la boucle s’arrête et passe à la suite.    Un petit exemple #include &lt;iostream&gt; int main() { int count { 0 }; // initialisation (d'un compteur ou autre chose lié à la boucle) while ( count &lt; 10 /* condition */) { std::cout &lt;&lt; count &lt;&lt; std::endl; // Instructions count++; // Itération (mise à jour du compteur généralement) } return 0; }   Le code évalue la condition avant d'effectuer quoi que ce soit. Dans notre cas si le compte est inférieur à 10 alors on va afficher le nombre et l'incrémenter. Quand finalement count vaut 10, la condition devient fausse, on passe à la suite du code. (on ne va donc pas afficher la valeur 10)  attention Attention aux boucles infinies ! Lorsque vous créez une boucle, assurez-vous qu'elle puisse s'arrêter à un moment ! Si la condition est toujours vraie, votre programme ne s'arrêtera jamais !  ","version":"Next","tagName":"h3"},{"title":"Do while​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#do-while","content":" De manière très similaire il existe la boucle Do... while, qui signifie &quot;fait .. tant que...&quot;  Ce type de boucle est moins utilisé. La seule chose qui change par rapport à une boucle while, c'est la position de la condition : au lieu d'être au début de la boucle, la condition est à la fin.  remarque La boucle while peut très bien ne jamais être exécutée si la condition est fausse dès le départ. Dans mon exemple précédent, si on avait initialisé le count à 20, la condition aurait été fausse dès le début, et on ne serait jamais rentré dans la boucle.  Pour la boucle Do... while, on rentre au moins une fois à l'intérieur. Le test se fait à la fin.  Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.  #include &lt;iostream&gt; int main() { int sum {0}; int number; do { std::cout &lt;&lt; &quot;Entre un nombre: &quot;; std::cin &gt;&gt; number; sum += number; } while (number != 0); std::cout &lt;&lt; &quot;La somme vaut &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   attention Il y a une petite spécificité supplémentaire ici, il faut ajouter un &quot;;&quot; à la fin de la ligne contenant la condition while.  ","version":"Next","tagName":"h3"},{"title":"For​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#for","content":" Un des cas les plus fréquents avec les boucles est d'avoir un compteur et un nombre d'itérations prédéfini.  On pourrait très bien le faire avec la boucle while:  int count { 0 }; // initialisation (d'un compteur ou autre chose lié à la boucle) while ( count &lt; 10 /* condition */) { // Instructions count++; // Itération (mise à jour du compteur généralement) }   Mais il existe une boucle dédiée à cela qui permet de séparer le reste de notre code de ce qui est lié à la boucle. Cela rend le code plus clair et plus compréhensible surtout dans le cas ou l'on connait à l'avance le nombre d'itérations.  C'est la boucle for (&quot;pour&quot; en anglais) et elle s'utilise selon le schéma suivant:  for (int count {0} /*initialisation*/ ; count &lt; 10 /*condition*/ ; count++/*Itération*/) { // Instructions }   Voilà le même exemple qu'avec la boucle while mais ici avec la boucle for :  #include &lt;iostream&gt; int main() { for (int count { 0 }; count &lt; 10 ; count++) { std::cout &lt;&lt; count &lt;&lt; std::endl; } return 0; }   L'avantage ici est que le détail de ce que fait la boucle est concentré sur une même ligne.  info Un autre gros avantage est que la portée de la variable (scope) est limitée à la boucle et donc rend notre code plus sûr et propre. #include &lt;iostream&gt; int main() { for (int count { 10 }; count &gt; 0 ; count--) { std::cout &lt;&lt; count &lt;&lt; std::endl; } std::cout &lt;&lt; count &lt;&lt; std::endl; return 0; } La variable count ici est uniquement nécessaire pour la boucle en question et n'a donc pas lieu d'être partagée ensuite avec le reste du code pour éviter des erreurs. Si on essaye de le faire le compilateur nous donne l'erreur suivante: Compilation failed due to following error(s) main.cpp: In function ‘int main()’: main.cpp:17:18: error: ‘count’ was not declared in this scope 17 | std::cout &lt;&lt; count &lt;&lt; std::endl; | ^~~~~   Mais alors quand choisir une boucle while ou une boucle for ?  C'est une question légitime et il n'y a pas de bonne réponse, vous êtes libre. En général on utilise une boucle for dans le cas où l'on connaît le nombre d'itérations à l'avance (un compteur, un nombre de niveaux ou de joueurs dans un jeu, etc...). La boucle while, quant à elle, est généralement utilisée pour effectuer des actions sans savoir à l'avance le nombre d'itérations que l'on va effectuer (par exemple la gestion de l'entrée utilisateur ou dans un jeu faire bouger un ennemi tant qu'il n'a pas atteint sa cible)  astuce Plus simplement, essayez de dire ce que vous voulez faire et si votre phrase contient &quot;pour&quot; ou &quot;pour chaque ... faire ...&quot; il est préférable d'utiliser une boucle for. Et si vous vous dîtes &quot;Tant que ... faire ...&quot; alors vous devriez utiliser une boucle while.  ","version":"Next","tagName":"h3"},{"title":"Contrôler l'exécution​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#contrôler-lexécution","content":" Les boucles sont très utiles, mais parfois on aimerait pouvoir contrôler plus finement les instructions à l’intérieur des accolades et pouvoir s'arrêter plus tôt ou ne pas exécuter les instructions pour un cas particulier.  Il existe en C++ deux mots-clés: break et continue  Break​  Break (de anglais &quot;casser&quot;/&quot;interrompre&quot;) permet d'interrompre une boucle et mettre fin à l’exécution de celle-ci peu importe où on en est.  Voyons un exemple plus &quot;complexe&quot; ensemble:  for (int i { 0 }; i &lt; 5; ++i) { std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; for (int j { 0 }; j &lt; i; ++j) { if (j == 2) { std::cout &lt;&lt; &quot;break j == 2&quot; &lt;&lt; std::endl; break; } std::cout &lt;&lt; &quot;j : &quot; &lt;&lt; j &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl; }   qui nous donne le résultat suivant:  i: 0 i: 1 j: 0 i: 2 j: 0 j: 1 i: 3 j: 0 j: 1 break j == 2 i: 4 j: 0 j: 1 break j == 2   Ici il y a plusieurs choses qui se passent:  il y a déjà deux boucles imbriquées, et oui rien ne nous empêche de faire cela en C++la deuxième boucle (sur la variable j) dépend de la variable i de la première (c'est parfois utile de le faire et je vous montre donc un petit exemple)ici le mot clé break permet d'interrompre la boucle de la variable j si la valeur de j est égale à 2.  Une petite analyse des itérations s'impose:  la première fois i est égal à 0 et donc la condition j &lt; i est directement fausse vu que j aussi est égal à 0. ensuiteensuite i est égal à 1 et donc on passe une fois seulement dans la boucle du j car à la seconde itération j devient égal à i et invalide la condition j &lt; i.la troisième fois c'est le break qui entre en jeu et permet d'interrompre la boucle quand j est égal à 2 (à noter que la condition de la boucle aurait aussi invalidé la condition j &lt; i)enfin ici le break prend tout son sens car s'il n'était pas là, on aurait encore continué un tour car j étant égal à 3, la condition (j &lt; i) serait valide car i est égal à 4 et que 3 &lt; 4.  attention Comme nous venons de le voir, dans le cas de boucles imbriquées cela arrête seulement la boucle du niveau au dessus et pas toutes les boucles.  Continue​  L’autre mot-clé, continue, permet de sauter l’itération courante.  Toutes les instructions restantes du bloc sont ignorées et la boucle continue au tour suivant.  for (int i { 0 }; i &lt; 5; ++i) { if( i == 3) { continue; } std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; }   Ce qui nous donne:  i : 0 i : 1 i : 2 i : 4   danger Comme cela interrompt la totalité des instructions suivantes de la boucle cela peut être dangereux dans le cas d'une boucle while: #include &lt;iostream&gt; int main() { int count { 10 }; while (count &gt; 0) { std::cout &lt;&lt; count &lt;&lt; std::endl; if (count == 5) { continue; } count--; } return 0; } Ici, l'instruction de count--; ne sera donc jamais appelée une fois que count devient égal à 5.count restera donc égal à 5 indéfiniment: C'est une boucle infinie.  ","version":"Next","tagName":"h3"},{"title":"En résumé​","type":1,"pageTitle":"Des conditions et des boucles","url":"/Learn--cpp_programming/Lessons/S1/ConditionsAndLoops#en-résumé","content":" Une valeur booléenne est du type bool et peut prendre comme valeur true ou false. On obtient une valeur booléenne avec une condition sur nos variables (avec les opérateurs de comparaison ==, !=, &lt;, &lt;=, &gt; ou &gt;=) Les opérateurs &amp;&amp;, || et ! permettent de modifier et combiner les valeurs booléennes. On utilise les structures de contrôle if, else, else if pour exécuter des instructions différentes en fonction des conditions.    Il existe trois types de boucle: la boucle while qui permet d'exécuter des instructions tant qu'une condition est vérifiée.la boucle Do while qui permet de faire la même chose que la boucle while mais en faisant le test seulement à la fin et permettant d'exécuter les instructions au moins une fois.la boucle for plus utile en pratique quand l'on connait à l'avance le nombre d'itérations à effectuer. Elle permet aussi de mieux &quot;scoper&quot; les variables et limiter leur portée. Il existe deux mots-clés break et continue qui permettent de contrôler plus finement les boucles. La structure de contrôle switch est une alternative au else if compatible seulement avec des types entiers et les énumérations. ","version":"Next","tagName":"h2"},{"title":"Mise en place des outils","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/","content":"Mise en place des outils Comme expliqué précédemment le C++ est un langage compilé et il va donc falloir installer un compilateur. Mais ce n'est pas tout, il est aussi préférable d'utiliser un éditeur ou IDE (Integrated Development Environment) adapté pour coder et je vous propose d'utiliser Visual Studio Code. De plus, nous installerons également un petit outil supplémentaire pour simplifier grandement l'étape de compilation (et particulièrement plus tard pour un projet composé de plusieurs fichiers).","keywords":"","version":"Next"},{"title":"Fonctions : Découper son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Structure d'une fonction​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#structure-dune-fonction","content":" Une fonction est un ensemble d'instructions délimité par des accolades { et } ce qui défini sa portée (scope).  Elle a un nom et peut ou non prendre des informations en entrée et peut ou non fournir une information en sortie.  type_de_retour nom(paramètres) { instructions }   Un exemple bien connu Dès notre premier programme nous avions rencontré une fonction, la fonction main. Celle-ci est le point d’entrée de tous les programmes que nous codons en C++. int main() { // Instructions diverses return 0; } Ici, main est le nom de la fonction. Le int situé juste avant indique son type de retour. Dans ce cas, la fonction renvoie une valeur entière (via le return 0;) qui indique que tout s’est bien passé. Après, le nom, il y a des parenthèses vides (), ce qui signifie que la fonction n’attend aucune information en entrée. Enfin, entre les accolades , nous avons les instructions qui la composent.  ","version":"Next","tagName":"h2"},{"title":"Choisir un nom​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#choisir-un-nom","content":" Les règles de nommage des fonctions sont les mêmes que pour nommer nos variables, vous pouvez aller les relire ici si nécessaire.  De même que pour les variables, il est important de donner un nom explicite aux fonctions afin de définir clairement ce qu’elles font.  ","version":"Next","tagName":"h3"},{"title":"Type de retour​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#type-de-retour","content":" Une fonction peut ou non renvoyer une valeur de retour, comme nous l’avons vu avec la fonction main. Il faut simplement préciser le type de la valeur à retourner comme vu précédemment.  Pour renvoyer une valeur, on utilise le mot-clé return, exactement comme dans la fonction main.  info Il peut y avoir plusieurs return dans une fonction. Un si un if est vrai, l’autre s’il est faux par exemple. Mais dès que l'instruction return est exécutée, on sort de la fonction en cours et tout le code restant n’est pas exécuté. Cela coupe le flot d’exécution de la fonction comme avec les mots-clés break et continue avec les boucles.  Si votre fonction ne doit rien renvoyer, alors on utilise le mot-clé void, qui signifie &quot;vide&quot; et qui, dans ce contexte, indique que la fonction ne retourne pas d'information (dans ce cas il n'est pas nécessaire d'utiliser l'instruction return mais peut tout de même être utilisée pour couper le flot d’exécution).  ","version":"Next","tagName":"h3"},{"title":"Des paramètres​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#des-paramètres","content":" Maintenant, parlons des paramètres. C'est via des paramètres que la fonction décrit ce qu'elle attend pour travailler.  On les déclare entre les parenthèses (()). Il faut que chaque paramètre ait un type et un nom. S’il y en a plusieurs, ils seront séparés par des virgules.  Des exemples #include &lt;iostream&gt; int sum (int a, int b) { return a + b; } int pgcd(int a, int b) { int r { a % b }; while (r != 0) { a = b; b = r; r = a % b; } // On peut tout à fait renvoyer la valeur d'un paramètre return b; } int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le PGCD de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; pgcd(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   attention Une fonction doit être déclarée avant son utilisation. Il faut donc la déclarer avant la fonction main afin d'être en mesure de l'utiliser dans la fonction main par exemple.  Le nom donné aux paramètres d'une fonction est spécifique à cette fonction et n'est pas partagé par le reste du code. Il est possible de donner en argument à une fonction une variable qui porte le même nom qu’un des paramètres.  Inversement, il n’est pas possible d’utiliser un paramètre de fonction en dehors de celle-ci. Le code suivant produit donc une erreur.  int function(int parameter) { parameter += 5; return parameter; } int main() { int const a { function(37) }; int const b { function(a) }; // La variable parameter n'existe pas ici parameter = 410; return 0; }   Argument vs paramètre Attention, il faut bien faire la distinction entre paramètre et argument. Un paramètre, c’est ce qu’attend une fonction pour travailler et qui est inscrit dans sa déclaration, le nom du paramètre est propre à la fonction et utilisable uniquement dans celle-ci. Un argument, c’est la valeur transmise à la fonction quand on l’utilise. Dans notre exemple précédent parameter est le paramètre de la fonction. 37 est l'argument de la fonction pour l'assignation de la variable a. Ensuite a devient lui même argument de la fonction pour l'assignation de b. En pratique, il y a souvent un abus de langage et les deux termes s'utilisent de façon interchangeable et je ne vous en voudrais si vous faites de même mais je tenais à vous expliquer la différence.  ","version":"Next","tagName":"h3"},{"title":"Petit point vocabulaire: les méthodes​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#petit-point-vocabulaire-les-méthodes","content":" Dans le précédent chapitre sur les tableaux nous avons vu des fonctions propres ou méthodes.  On parle de méthode quand une fonction est associée à un objet. C'est le cas par exemple de la fonction size() sur l'objet std::vector. Elle s'utilise avec un point . après le nom de la variable en question. On dit que size() est une méthode de std::vector. Une méthode a donc &quot;connaissance&quot; de l'objet en question pour le modifier, lire des informations, etc.  std::vector&lt;int&gt; const array { 12, 18, 8, 4, 9 }; std::size_t const size { array.size() };   Nous y reviendrons plus tard, pour l'instant gardez simplement à l'esprit que c'est réservé à des type &quot;particuliers&quot; comme le std::vector ou std::string et que l'on appelle ça des méthodes.  ","version":"Next","tagName":"h3"},{"title":"Une portée limitée​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#une-portée-limitée","content":" J'avais déjà évoqué la notion de portée (ou scope) lors de l'introduction des stuctures de contrôle. Cette notion est aussi vraie avec les fonctions. Les instructions d'une fonction sont contenues entre des accolades et donc restreignent la portée des variables à l'intérieur de ce bloc.  C’est une bonne pratique de déclarer ses variables dans la plus petite portée possible.  Cela permet premièrement de limiter son utilisation à cette portée et éviter un usage malencontreux plus tard. Déclarer une variable proche de son utilisation évite de devoir chercher et parcourir un code parfois long et complexe pour comprendre pourquoi cette variable est utilisée à cet endroit précis. Cela aide donc à la lecture et la compréhension du code.  Enfin, lorsqu’on atteint la fin d'un bloc (accolade }), le programme libère dans la mémoire les emplacements qu’il avait réservés pour les variables du bloc en question. C'est donc plus propre et plus performant (niveau mémoire) de déclarer les variables à l’intérieur d'un bloc (fonction, condition, etc) si elles ne sont pas destinées à être utilisées ailleurs.  ","version":"Next","tagName":"h2"},{"title":"Paramètre par copie​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#paramètre-par-copie","content":" J’ai expliqué précédemment que les paramètres d’une fonction étaient dans une portée différente concernant le nommage.  La portée différente implique une copie. Pour chaque utilisation de la fonction, le compilateur va réserver un nouvel espace mémoire et copier l'argument (la variable) qu’on lui passe en paramètre. Une variable dans la fonction est donc totalement différente. C’est ce qu'on appelle un passage par copie.  On peut donc nommer nos paramètres avec le même nom qu'une de nos variables.  Un exemple #include &lt;iostream&gt; void addOne(int a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   On pourrait penser que cela va afficher 9 mais en réalité a est toujours égal à 8. la fonction addOne a reçu une copie de la variable a (nommée a elle aussi) mais elle ne peut pas modifier la variable a originale.  Dans le cas d’un entier ou d’un caractère par exemple ce n'est pas très grave, mais dans le cas d’un tableau de plusieurs d’éléments, on perd du temps inutilement à copier toutes les valeurs du tableau (même si on ne veut en lire que quelques unes dans la fonction).  ","version":"Next","tagName":"h2"},{"title":"Référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#référence","content":" Mais, en C++, il existe un moyen de créer un alias, une référence vers une variable. Cette référence devient manipulable comme si nous avions la variable originale entre les mains.  On indique qu'une variable est une référence vers une autre en ajoutant une esperluette (&amp;) après le type de notre variable.  #include &lt;iostream&gt; int main() { int a { 8 }; // refA est une référence vers la variable a int &amp; refA { a }; // ici je modifie donc la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   danger On ne peut pas créer de référence qui ne cible rien, ni changer la cible d’une référence une fois qu’on l’a créée. Une référence est un alias vers une autre variable, si on essaye de l'assigner de nouveau cela revient à modifier la variable originale et pas à réatribuer la référence. #include &lt;iostream&gt; int main() { int a { 8 }; int b { 42 }; int &amp; refA { a }; refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; // ici refA reste une référence vers la variable a qui prend la valeur de b // refA ne devient PAS une référence vers la variable b refA = b; // Je modifie ici toujours la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#passage-par-référence","content":" Cela devient intéressant dans nos fonctions où il va aussi être possible de déclarer un paramètre en tant que référence et non pas comme une copie de la variable originale.  Pour indiquer que l'on souhaite recevoir une référence il faut ajouter une esperluette (&amp;) après le type de notre paramètre.  remarque Bien entendu on ne pourra passer en argument qu'une variable du même type que le type de la référence attendue par la fonction.  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Référence constante​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#référence-constante","content":" Je vous avais dit que les variables constantes allaient prendre tout leur importance et bien c'est ici ! :partying_face:  En effet, si on manipule une référence, on peut très bien modifier la variable originale comme vu précédemment. Mais parfois on aimerait utiliser une référence (pour éviter une copie d'un tableau par exemple) mais protéger la variable originale et interdire les modifications de celle-ci, un mode lecture seule.  On peut donc rajouter le mot clé const dans notre paramètre comme cela:  #include &lt;iostream&gt; #include &lt;vector&gt; float sum(std::vector&lt;float&gt; const&amp; list) { float sum {0}; for(float const value: list) { sum += value; } return sum; } int main() { std::vector&lt;float&gt; list { 8.f, 4.2f, 3.1415f, 43.8f }; float sum { sum(list) }; std::cout &lt;&lt; &quot;La somme des valeurs de mon tableau est de &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   Si vous essayez de modifier un paramètre constant vous allez obtenir une erreur (et c'est tant mieux !).  #include &lt;iostream&gt; void addOne(int const&amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   main.cpp: In function ‘void addOne(const int&amp;)’: main.cpp:4:7: error: assignment of read-only reference ‘a’ 4 | a += 1; | ~~^~~~   Le compilateur nous indique qu'il y a une tentative de modification d'un paramètre déclaré comme constant.  C'est donc une sécurité importante pour éviter des erreurs et je vous recommande d'utiliser des variables ou paramètres constants dès que possible.  remarque Une référence constante ne peut évidemment pas redevenir modifiable et le code ci-dessous va aussi produire une erreur de compilation. #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } void readyOnlyFunction(int const &amp; a) { addOne(a); } int main() { int a { 8 }; readyOnlyFunction(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Le cas des littéraux​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#le-cas-des-littéraux","content":" Avec les litéraux il se passe un autre mécanisme.  Le code ci-dessous ne va pas compiler, à cause de la ligne 15.  #include &lt;iostream&gt; void display(int &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { display(42); displayConst(42); return 0; }   En effet, nous passons un litéral à notre fonction qui attend une référence, un alias, sur une variable modifiable. Un litéral n'est pas à proprement parlé une variable, il est invariable et n’existe nulle part en mémoire, il n'est pas modifiable.  Par contre, supprimez-la et le code compilera, la fonction displayConst ne pose pas de problème de compilation. La seule différence entre les deux fonctions, c’est la présence du mot-clé const.  Ici, le compilateur va créer une variable constante temporaire, qui n’existera que le temps que la fonction, et va lui assigner le litéral comme valeur. Cela revient à faire cela par exemple:  #include &lt;iostream&gt; void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { { int const temporaryVariable { 42 }; displayConst(temporaryVariable); // A la sortie de ce scope (délimité entre accolades) la variable temporaire va être détruite } return 0; }   C'est donc préférable d'utiliser des paramètres constants car cela permet également de rendre compatible nos fonctions avec les littéraux.  ","version":"Next","tagName":"h3"},{"title":"Retour par référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#retour-par-référence","content":" Les références ont une contrainte particulière : elles doivent toujours être valides.  Dans le cas d’un paramètre de fonction il n'y a pas de problème car l’argument transmis à la fonction existera toujours quand celle-ci se terminera:  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; // la variable a est passée en argument addOne(a); // Ici la variable a existe toujours return 0; }   Mais, dans le cas où l’on souhaite qu’une fonction retourne une référence, cela peut être dangereux et on peut renvoyer une référence sur une variable qui n’existera plus à la fin de la fonction !  #include &lt;iostream&gt; int&amp; test() { int a { 33 }; return a; // A la fin du scope de la fonction la variable 'a' va être détruite } int main() { int &amp; reference { test() }; // ici notre référence est invalide ! return 0; }   C'est un comportement indéterminé. Il ne produira pas d'erreur de compilation mais l'utilisation de la référence est invalide.  danger Il ne faut jamais renvoyer une référence vers une variable locale à une fonction.  ","version":"Next","tagName":"h3"},{"title":"Références et types standard​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#références-et-types-standard","content":" Utiliser des références pour std::vector ou std::string d’accord, mais qu’en est-il des types standard comme int, char et double ? Y a-t-il un intérêt à utiliser des références ? Doit-on bannir toutes les copies de notre code ?  Les types standard sont petits (en mémoire) et le coût de la création d’une référence sur des types aussi simples est souvent plus élevé ou équivalent que celui d’une &quot;bête&quot; copie. En effet, le compilateur arrive très souvent à optimiser les copies et les rendre extrêmement rapides, bien plus qu’avec les références.  Donc ne tombez pas dans le piège de l’optimisation prématurée. Pensez au références lorsqu'il s'agit d'objets &quot;gros&quot;. Vouloir mettre des références partout n'est pas une erreur (et je ne vous en tiendrai pas compte au contraire cela veux dire que vous pensez aux références). Mais, garder à l'esprit que cela a aussi un coût de créer une référence et que laisser juste un int const parameter permet au compilateur de mieux optimiser le code.  ","version":"Next","tagName":"h2"},{"title":"Signature et fonctions surchargées​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#signature-et-fonctions-surchargées","content":" Ce qui différencie deux fonctions, ça n’est pas seulement leur nom mais également leurs paramètres. C’est ce qu’on appelle la signature d’une fonction.  On peut donc très bien avoir deux fonctions qui ont le même nom mais pas les mêmes paramètres:  #include &lt;iostream&gt; void testDisplay(int const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void testDisplay(float const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { testDisplay(42); testDisplay(63.5f); return 0; }   Ici, le compilateur voit deux signatures différentes testDisplay(int const a) et testDisplay(float const a) il n'y a donc pas de problème.  On appelle cela la surcharge, de l’anglais &quot;overloading&quot;. Cela rend le code plus simple et le compilateur appelle la bonne surcharge de la fonction pour les arguments précisés (si elle existe évidemment).  Par contre, le type de retour n'est pas une forme de surcharge. Deux fonctions avec le même nom, les mêmes paramètres et des types de retour différents ne compileront pas. Et c’est logique, car comment savoir quelle fonction utiliser et quoi retourner sans ambiguïté sinon ?  ","version":"Next","tagName":"h2"},{"title":"Prototype: déclaration des fonctions​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-déclaration-des-fonctions","content":" J'ai expliqué précédemment qu'une fonction a besoin d'être déclarée avant son utilisation. C'est vrai mais incomplet.  Cette déclaration peut se faire à l'aide de ce qu'on appelle le prototype de la fonction.  Le prototype est très similaire à la signature et est composé du nom, des paramètres(et leur type) ET du type de retour de la fonction.  Voilà un petit exemple de fonction et son prototype:  // la déclaration de la fonction sum avec son prototype int sum (int a, int b); // Le corps de la fonction qui contient les instructions de la fonction int sum (int a, int b) { return a + b; }   Il est possible d'utiliser une fonction dès lors qu'elle est déclarée avec son prototype seulement.  #include &lt;iostream&gt; int sum (int const a, int const b); int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; } int sum (int const a, int const b) { return a + b; }   Je complète donc:  Une fonction doit être déclarée avant son utilisation. Cela peut se faire avec le prototype de la fonction ou le corps lui même. Une fonction peut être utilisée même si le corps de la fonction est écrit plus tard du moment que son prototype est écrit avant toute utilisation de la fonction.  Le prototype est là pour déclarer/signaler au compilateur que le corps de la fonction qu'on appelle sera bien défini plus tard dans le programme.  remarque Évidemment le programme ne va pas compiler si le corps de la fonction déclarée n'existe pas et va nous l'indiquer (undefined reference): in function `main': main.cpp: undefined reference to `sum(int, int)'   remarque C'est une notion qui va être utile quand on verra la séparation du code en plusieurs fichiers.  ","version":"Next","tagName":"h2"},{"title":"Prototype vs signature​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-vs-signature","content":" Il y a souvent un abus de langage et les termes de prototype et signature sont souvent interchangés. Je ne vous en voudrais donc pas si vous utilisez le terme de signature ou de prototype.  Si on veut être pointilleux le prototype désigne le nom, les paramètres et le type de retour d'une fonction alors que la signature indique seulement son nom et ses paramètres (permettant de faire de la surcharge de fonction).  ","version":"Next","tagName":"h3"},{"title":"Récursivité​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#récursivité","content":" Enfin, il est possible d'utiliser une fonction dans elle même, on parle alors de récursivité.  Cela peut être utile quand le problème que l'on souhaite résoudre est de nature récursive, se répète sur lui même.  ","version":"Next","tagName":"h2"},{"title":"Un petit exemple​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#un-petit-exemple","content":" Par exemple si l'on souhaite calculer le produit de tous les entiers de 1 à une valeur n.  Pn=1×2×⋯×n−1×nP_n = 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\Pn​=1×2×⋯×n−1×n  On pourrait voir ce problème de manière récursive en exprimant cette somme en fonction de la somme à l'étape d'avant (n-1):  Pn=1×2×⋯×n−1×nPn=(1×2×⋯×n−1)×nPn=Pn−1×n\\begin{aligned} P_n &amp;= 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\ P_n &amp;= (1 \\times 2 \\times \\dots \\times n-1) \\times n \\\\ P_n &amp;= P_{n-1} \\times n \\end{aligned}Pn​Pn​Pn​​=1×2×⋯×n−1×n=(1×2×⋯×n−1)×n=Pn−1​×n​  On a finalement exprimé le produit des entiers de 1 à n comme étant n fois le produit des entiers de 1 à n-1.  remarque On nomme ce résulat la factorielle de n en Mathématiques.  Sous forme de fonction récursive cela nous donnerait:  int fact(int n) { return fact(n-1) * n; }   On oublie cependant un ingrédient très important des fonctions récursives: la condition d'arrêt.  En effet, dans notre problème on a bien précisé que c'était de 1 à n. On fait donc attention de s'arrêter quand n &lt;= 1. La factorielle de 1 étant égale à 1 je retourne donc 1.  int fact(int n) { if( n &lt;= 1 ) { return 1; } return fact(n-1) * n; }   Il faut faire attention à ne pas oublier cette condition d'arrêt et bien s'assurer qu'il est possible de la vérifier pour s'arrêter sinon notre fonction ne va jamais se terminer et notre programme va sûrement planter.    Dans la plupart des cas, il existe une version alternative non récursive (avec des boucles par exemple).  int fact(int n) { int P { 1 }; // Ici si n est négatif alors la condition i &lt;= n est directement invalide et on ne passe pas dans la boucle if et on retourne 1 for(int i {2}; i &lt;= n; i++) { P *= i; } return P; }   Il est préférable d'utiliser des fonctions non récursives quand c'est possible car elle sont généralement plus performantes et moins propices à l'erreur (condition d'arrêt jamais valide, etc).  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#résumé","content":" Une fonction est un ensemble d'instructions délimité par des accolades ().Elle peut retourner une valeur en précisant le type de retour avant le nom ou le mot-clé void dans le cas où l'on souhaite ne rien retourner.Elle peut avoir des paramètres.Les arguments passés en paramètre sont par défaut copiés.Il est possible de manipuler la variable d'origine à l'aide de référence (en ajoutant une esperluette (&amp;) après le type de notre variable).Il est possible de surcharger un fonction, c'est à dire avoir le même nom mais des paramètres différents, on parle de signatures différentes.Il est recommandé d'utiliser des paramètres constants (avec le mot-clé const) pour éviter des erreurs, éviter des copies et protéger nos variables. ","version":"Next","tagName":"h2"},{"title":"Cmake","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/CMake","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Cmake","url":"/Learn--cpp_programming/Lessons/S1/Setup/CMake#installation","content":" WindowsLinuxMacOS Si vous êtes passé par l'installation avec Winlibs, vous avez normalement déjà CMake d'installé.  Vous pouvez ensuite vérifier que c'est bien installé en exécutant la commande suivante dans un terminal :  cmake --version   Si vous obtenez un message d'erreur, c'est que CMake n'est pas installé correctement.  Dans ce cas, vous pouvez aussi télécharger l'installeur sur le site officiel de CMake. Vous pouvez vous rendre ici et sélectionner l'installeur qui correspond à votre OS. ","version":"Next","tagName":"h2"},{"title":"Installation d'un compilateur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler","content":"","keywords":"","version":"Next"},{"title":"Vérifier que le compilateur est installé​","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#vérifier-que-le-compilateur-est-installé","content":" Dans un premier temps, vous allez pouvoir vérifier que le compilateur GCC est bien installé avec la commande suivante :  g++ --version   WindowsLinuxMacOS MSVC Avec MSVC c'est un peu particulier et la commande du compilateur ne sera accessible qu'à travers un terminal particulier. Vous pouvez le trouver en cherchant &quot;developer powershell&quot; ou &quot;developer Command Prompt&quot; dans le Menu Windows. Vous pouvez ouvrir un terminal développeur et essayer d'exécuter la commande suivante! cl Vous devriez voir un retour comme celui là : C:\\Program Files\\Microsoft Visual Studio\\2022\\Community&gt; cl Microsoft (R) C/C++ Optimizing Compiler Version 19.31.31105 for x86 Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option... ] filename... [ /link linkoption... ]   Cela peut ne pas fonctionner si le répertoire contenant le compilateur n'est pas &quot;accessible&quot;. Dans ce cas, il faut ajouter le chemin du compilateur aux variables d'environnement.  ","version":"Next","tagName":"h2"},{"title":"Variables d'environnement​","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#variables-denvironnement","content":" Les commandes sont elles-mêmes des exécutables sous forme de fichiers situés quelque part sur votre ordinateur.  Depuis un terminal, l'ordinateur a une liste de tous les endroits dans lesquels il va essayer de chercher les dits fichiers (commandes) à exécuter. Ces endroits (sous forme de chemins de dossier) sont listés dans ce qu'on appelle des variables d'environnement et particulièrement la variable d'environnement PATH.  Pour pouvoir avoir accès à la commande du compilateur depuis n'importe où dans votre ordinateur il va donc falloir ajouter le chemin où est installé l'exécutable (les outils de compilation dans notre cas) à cette variable PATH.  WindowsLinuxMacOS Vous pouvez y accéder en allant dans le Panneau de configuration et en cliquant sur le lien Paramètres système avancés puis sur Variables d'environnement. Ou plus simplement en cherchant &quot;path&quot; ou &quot;variable&quot; dans le Menu démarrer. Dans la section Variables système recherchez la variable d'environnement PATH et sélectionnez-la. Cliquez sur Modifier. Dans la fenêtre qui vient de s'ouvrir, ajoutez une valeur avec le chemin vers le dossier contenant la commande. (Pour MSVC par exemple c'est quelque chose comme : &quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\19.09.26726\\bin\\HostX86\\x64&quot;)Cliquez sur OK.Fermez toutes les fenêtres restantes en cliquant sur OK. C'est également expliqué ici avec des illustrations si nécessaire.  ::: ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#installation","content":" Tout d'abord il s'agit d'installer l'IDE.  Rendez-vous .css-q8raqo{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-q8raqo.Mui-disabled{opacity:0.38;pointer-events:none;}.css-q8raqo .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-q8raqo .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-q8raqo .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-q8raqo .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-q8raqo .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-q8raqo .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-q8raqo .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-q8raqo .MuiChip-deleteIcon:hover,.css-q8raqo .MuiChip-deleteIcon:active{color:#fff;}.css-q8raqo:hover{background-color:rgba(0, 0, 0, 0.12);}.css-q8raqo.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-q8raqo:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-q8raqo:hover,.css-q8raqo.Mui-focusVisible{background-color:#1565c0;} .css-1giu1bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1giu1bt::-moz-focus-inner{border-style:none;}.css-1giu1bt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1giu1bt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1giu1bt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1giu1bt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1giu1bt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1giu1bt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1giu1bt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1giu1bt .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-1giu1bt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-1giu1bt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1giu1bt .MuiChip-deleteIcon:hover,.css-1giu1bt .MuiChip-deleteIcon:active{color:#fff;}.css-1giu1bt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1giu1bt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1giu1bt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1giu1bt:hover,.css-1giu1bt.Mui-focusVisible{background-color:#1565c0;} ici et sélectionnez l'installeur adapté à votre système d'exploitation.   ","version":"Next","tagName":"h2"},{"title":"Les extensions​","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#les-extensions","content":" Les extensions sont, comme le nom l'indique, des modules qui permettent d'étendre les fonctionnalités de l'IDE.  Elles sont listées ici et vous pouvez également les parcourir pour les installer à l'intérieur de l'IDE via le raccourci CTRL+SHIFT+X ou en cliquant sur cet onglet :    N'hésitez pas à consulter les extensions recommandées par langage ou découvrir ce que d'autres personnes utilisent.  Concernant le C++, nous avons besoin au minimum d'installer ces extensions :  cpptools-extension-packcmakeBuildOutputColorizer  Ces extensions vont nous permettre de lancer notre programme C++ sans difficulté.  Si vous voulez aller plus loin et connaître un peu mieux VSCode, je vous invite à aller regarder la page suivante. ","version":"Next","tagName":"h2"},{"title":"Compiler votre premier programme","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac","content":"","keywords":"","version":"Next"},{"title":"Utiliser CMake et VSCode​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#utiliser-cmake-et-vscode","content":" C'est donc possible de le faire uniquement avec des lignes de commandes mais par simplicité nous allons dès maintenant utiliser CMake dont j'ai parlé précédemment qui s'intègre facilement avec VSCode.  Pour utiliser CMake il faut tout d'abord créer un fichier nommé CMakeLists.txtVoici le premier qu'on va utiliser (quelques explications en commentaire &quot;#&quot; du fichier) :  CMakeLists.txt # Nous voulons un cmake &quot;récent&quot; pour utiliser les dernières fonctionnalités cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On indique que l'on veut créer un exécutable &quot;helloImac&quot; compilé à partir du fichier helloImac.cpp add_executable(helloImac helloImac.cpp)   Ce fichier CMakeLists.txt va être bien pratique car il est reconnu par divers IDE et en ce qui nous concerne on va l'utiliser avec VSCode.  Il suffit d'avoir au préalable installé l'extension dont je vous ai parlé .css-173r67b{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-173r67b.Mui-disabled{opacity:0.38;pointer-events:none;}.css-173r67b .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-173r67b .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-173r67b .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-173r67b .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-173r67b .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-173r67b .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-173r67b .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-173r67b:hover{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-173r67b:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-173r67b.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b .MuiChip-avatar{margin-left:4px;}.css-173r67b .MuiChip-avatarSmall{margin-left:2px;}.css-173r67b .MuiChip-icon{margin-left:4px;}.css-173r67b .MuiChip-iconSmall{margin-left:2px;}.css-173r67b .MuiChip-deleteIcon{margin-right:5px;}.css-173r67b .MuiChip-deleteIconSmall{margin-right:3px;} .css-1aq2sw4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-1aq2sw4::-moz-focus-inner{border-style:none;}.css-1aq2sw4.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1aq2sw4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1aq2sw4.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1aq2sw4 .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1aq2sw4 .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1aq2sw4 .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1aq2sw4 .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-1aq2sw4 .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-1aq2sw4 .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1aq2sw4:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1aq2sw4:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1aq2sw4.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4 .MuiChip-avatar{margin-left:4px;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-icon{margin-left:4px;}.css-1aq2sw4 .MuiChip-iconSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-deleteIcon{margin-right:5px;}.css-1aq2sw4 .MuiChip-deleteIconSmall{margin-right:3px;} cmake et d'ouvrir le dossier contenant le fichier CMakeLists.txt dans VSCode (il est recommandé de créer un dossier dédié au &quot;projet&quot; contenant les fichiers sources et le fichier CMakeLists.txt ). L'extension devrait normalement reconnaître automatiquement qu'il y a un fichier cmake et vous proposer d'initialiser celui-ci automatiquement.     Si c'est la première fois que vous l'ouvrez ce qui est sûrement le cas il devrait vous demander de choisir un kit de compilation et il faudra donc sélectionner GCC (ou MSVC si c'est ce que vous avez décidé d'installer).    astuce Si ce n'est pas le cas vous pouvez toujours utiliser le raccourci Ctrl+Shift+P puis taper et sélectionner &quot;CMake: select a kit&quot;  Une fois tout initialisé, vous devriez voir des logs dans un terminal ressemblant à cela (dans mon cas sous Linux avec le compilateur GCC ici) :  [variant] Loaded new set of variants [kit] Successfully loaded 1 kits from /home/user/.local/share/CMakeTools/cmake-tools-kits.json [proc] Executing command: /usr/bin/cmake --version [proc] Executing command: /usr/bin/gcc -v [proc] The command: ninja --version failed with error: Error: spawn ninja ENOENT [proc] The command: ninja-build --version failed with error: Error: spawn ninja-build ENOENT [proc] Executing command: /usr/bin/cmake &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [main] Configuring project: helloImac [proc] Executing command: /usr/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/gcc -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/g++ &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [cmake] Not searching for unused variables given on the command line. [cmake] -- Configuring done [cmake] -- Generating done [cmake] -- Build files have been written to: /home/user/DATA/Cours IMAC1/helloImac/build   Vous pouvez maintenant cliquer sur le bouton &quot;play&quot; dans la barre en bas pour exécuter le programme. 🥳    remarque En cliquant sur ce bouton, l'IDE compile automatiquement si nécessaire puis exécute l'exécutable.  remarque Cmake devrait normalement créer un dossier build, c'est normal. CMake est un outil de compilation mais ne compile pas directement, il permet de générer des fichiers permettant ensuite de compiler un projet. Vous n'avez pas besoin d'aller voir ce qui s'y trouve, CMake gère automatiquement ce dossier build pour vous.  attention Pour qu'un projet CMake soit fonctionnel, il faut que le dossier ouvert dans votre IDE contienne un fichier CMakeLists.txt à la racine du dossier. Sinon, l'extension CMake ne détectera pas le dossier ouvert comme un projet CMake et il ne va pas s'initialiser automatiquement. Les fonctionnalités de l'extension ne seront donc pas disponibles.  ","version":"Next","tagName":"h2"},{"title":"Quelques explications sur le programme​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#quelques-explications-sur-le-programme","content":" ","version":"Next","tagName":"h2"},{"title":"include ?​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#include-","content":" #include &lt;iostream&gt;   Le but de notre programme est d’afficher un message. Des développeurs experts ont déjà créé un outil qui permet de le faire facilement. Il se trouve dans un fichier nommé iostream, acronyme de &quot;Input Output Stream&quot;, soit &quot;Flux d’Entrées Sorties&quot;. Ce fichier fait partie de la bibliothèque standard C++ STD (pour &quot;C++ STandarD library&quot;), un ensemble de fonctionnalités déjà pré-codées et disponibles partout avec n'importe quel compilateur C++.  Pour utiliser les fonctionnalités offertes par ce fichier, notamment écrire un message avec std::cout, on doit l’importer dans notre programme. On dit qu’on l’inclut, d’où l’anglais &quot;include&quot;. Nous utiliserons beaucoup cette fonctionnalité en C++.  Essayez donc de supprimer la ligne, puis compilez de nouveau votre programme et voyez ce qu'il se passe !    Le compilateur ne peut pas compiler notre programme, et il nous fournit donc une erreur de compilation. Il est très important d'apprendre à lire et comprendre ces erreurs car elles vous apportent beaucoup d'informations pour vous aider à corriger votre programme ! En l'occurrence elle nous indique que le symbole std::cout est introuvable, et nous donne même une piste pour corriger le problème : rajouter #include &lt;iostream&gt; !  Il nous indique même où l'erreur s'est produite :cela signifie que c'est dans le fichier helloImac.cpp, à la ligne 4, et au 8ème caractère de cette ligne. Vous pouvez aussi CTRL+click dessus pour que VSCode vous emmène directement au bon endroit !  info #include s'appelle une directive préprocesseur. Le préprocesseur est un programme exécuté lors de la première phase de la compilation qui effectue des modifications textuelles sur le fichier source à partir de directives. Ces directives commencent par le caractère # et doivent se terminer par un saut de ligne. Retenez simplement que #include nous permet d’importer des fichiers pour les inclure dans le programme que l'on est en train d'écrire, et je le détaillerai plus tard dans le semestre.  ","version":"Next","tagName":"h3"},{"title":"La fonction main​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#la-fonction-main","content":" int main() { // ... return 0; }   Lorsqu’on lance le programme, celui-ci doit savoir par où commencer. On parle de point d’entrée. Ce point d'entrée doit être une fonction nommée main et renvoyer une valeur avec le mot clé return.  Nous reviendrons sur les fonctions dans un autre chapitre mais retenez que c'est un ensemble d'instructions délimité par des accolades { et }, et auquel on donne un nom (main dans ce cas).  remarque La fonction main est un peu spéciale et sa valeur de retour (de type int) sert à indiquer si le programme s’est terminé sans erreur. Si tout se passe bien, il faut retourner 0. N’importe quelle autre valeur indique une erreur.  ","version":"Next","tagName":"h3"},{"title":"Hello and welcome to IMAC !​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#hello-and-welcome-to-imac-","content":" L’instruction ci-dessous permet d’afficher le texte (qu'on appelle &quot;chaîne de caractères&quot;, ou &quot;string&quot;, en programmation) &quot;Hello and welcome to IMAC !&quot; sur la sortie standard du programme.  std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl;   Premièrement &quot;std&quot; fait référence à la bibliothèque standard C++ dont je parlais précédemment.  std:: permet d'indiquer que l'on veut utiliser une fonctionnalité particulière de cette bibliothèque, ici cout :  Il s’agit de l'objet (on parle de stream dans le jargon C++) permettant de renvoyer des caractères, généralement pour les afficher dans le terminal. Le 'c' fait référence à caractère et ‘out’ indique ‘sortie’.  Enfin, std::endl indique ici &quot;end-line&quot; soit la 'fin de ligne'.  ","version":"Next","tagName":"h3"},{"title":"Dernier point (virgule)​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#dernier-point-virgule","content":" Chaque instruction doit être identifiable afin de que compilateur puisse faire son travail et produire un programme exécutable.  C'est le rôle du point-virgule ; de délimiter chaque instruction et il est donc important de ne pas l'oublier.  On le retrouve par exemple dans notre programme à la fin du return 0;.  attention Ce n'est pas le cas pour les directives préprocesseur comme #include vu précédemment qui, elles, doivent avoir leur propre ligne et ne doivent pas se terminer par un point-virgule ; mais un saut de ligne.  Les sauts de lignes et espacements sont là pour améliorer la lisibilité mais pas pour le bon fonctionnement du compilateur en lui même et on pourrait très bien écrire :  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl; return 0; }   Je vous recommande tout de même d'utiliser des espacements et sauts de ligne pour mieux s'y retrouver et c'est ce que je vais faire tout au long de ce cours.    Et voilà ! Vous avez exécuté votre premier programme C++ à l'aide de VSCode ! 🎉 ","version":"Next","tagName":"h3"},{"title":"Allouer et manipuler la mémoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Mode d'allocation​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#mode-dallocation","content":" Il existe trois principaux modes d’allocation de la mémoire:  l’allocation statiquel’allocation sur la Stackl’allocation sur la Heap  ","version":"Next","tagName":"h2"},{"title":"Allocation statique​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-statique","content":" Lorsque le programme s’initialise, il demande une quantité de mémoire spécifiée dans le code source du programme, laquelle ne pourra pas changer par la suite.  Nous n'avons pas rencontré ce type d'allocation pour l'instant mais sachez que ça existe.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Stack​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-stack","content":" Jusqu'a présent, nous avons principalement rencontré des allocations de mémoire sur la Stack. C'est le cas de toutes nos variables locales (dans des fonctions, y compris dans la fonction main).  La Stack (ou pile en français) est une zone mémoire qui sert d’espace de stockage aux variables déclarées par les fonctions et permet aussi de garder une trace des appels de fonctions.  Elle tient son nom de son mode de fonctionnement, semblable à une pile de dossiers. Il s’agit d’une structure de données fondée sur le principe “dernier posé sur le dessus de la pile, premier à sortir”. Cet ordonnancement s’appelle LIFO (Last In, First Out). La Stack possède donc deux actions principales : push, pour ajouter un élément, et pop pour retirer et récupérer cet élément. Cela rend très simple le suivi de la pile pour libérer ou demander de la mémoire.  Comme les accès à la Stack sont contiguës et que les mêmes adresses mémoire tendent à être réutilisées, les lectures et écritures dans la Stack sont très performantes. Cependant cela manque de souplesse car son allocation doit être &quot;prévue&quot; lors de l’écriture du programme (Pour des variables de taille déjà connue à la compilation).  info La Stack a une taille fixée (qui dépend des machines et systèmes d'exploitation(OS)). Pour garder une trace de l’emplacement mémoire actuel, il existe un pointeur appelé Stack Pointer. Chaque fois que quelque chose doit être écrit ou retiré dans la Stack, on déplace simplement ce pointeur. Le pointeur ne peut pas aller au delà des limites de la Stack, cela risque de provoquer un crash du programme appelé Stack overflow. Cela peut se produire avec une fonction récursive avec de nombreux appels récursifs ou sans condition d'arrêt par exemple.  La syntaxe pour allouer de la mémoire sur la Stack est la suivante:  int x {};   Vous connaissez déjà cette syntaxe, c'est simplement la déclaration d'une variable locale.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Heap​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-heap","content":" L’allocation sur la Heap se fait de manière dynamique pendant l’exécution d’un programme (on parle de runtime). L’espace nécessaire n’a pas besoin d'être défini en amont dans le code. Le programme effectue la demande d’allocation d’espace à l’OS au cours de son exécution.  remarque Il y a généralement un abus de langage et ce que l'on qualifie d'allocation dynamique désigne ce type d'allocation sur la Heap. L'allocation sur la Stack est également dynamique dans le sens où elle se produit pendant l'exécution du programme en fonction des variables déclarées.  La Heap permet donc le contrôle complètement arbitraire de l’allocation et de la libération. Lorsque le processus nécessite plus de mémoire, il en fait simplement la demande à l’OS (dans la limite où il est en mesure de fournir un tel emplacement mémoire). C'est donc aussi ce type d'allocation que l'on privilégie dans le cas de gros volumes de données.  Cependant, cela demande de maintenir des pointeurs pour chacune des valeurs stockées, afin de savoir où se trouve la mémoire demandée pour pouvoir la manipuler mais aussi la libérer. Cette gestion de la mémoire étant plus &quot;complexe&quot;, les performances n’en sont généralement pas aussi bonnes, mais parfois on n'a tout simplement pas le choix.  La syntaxe pour allouer de la mémoire sur la Heap est la suivante:  int* x { new int };   Je vous expliquerai plus en détail ce que cela signifie dans la suite de ce chapitre.  ","version":"Next","tagName":"h3"},{"title":"Adresse et pointeurs​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#adresse-et-pointeurs","content":" J'ai évoqué le terme de pointeur mais qu'est ce que c'est ?  Une variable est localisée quelque part dans notre mémoire. On peut voir la mémoire de notre ordinateur comme une grande étagère à livres dans laquelle chaque emplacement est numéroté. Chaque variable a une adresse (un numéro) qui permet de savoir où elle se trouve en mémoire.  Cette adresse est simplement un nombre (généralement représenté sous forme hexadécimale).  On peut récupérer l'adresse d'une variable en ajoutant le symbole &quot;esperluette&quot; &amp; devant le nom de la variable en question.  Essayons: #include &lt;iostream&gt; int main() { int integer {4}; std::cout &lt;&lt; &amp;integer &lt;&lt; std::endl; return 0; }   qui nous donne un truc qui ressemble à ça:  0x7ffe08bf5854   Ce nombre indique où est stockée la valeur de notre variable en mémoire (que ce soit la heap ou la stack).  Maintenant que nous savons où se trouve notre variable on va pouvoir stocker cette adresse.  C'est justement le rôle du pointeur de stocker l'adresse d'une variable.  On indique que l'on souhaite manipuler un pointeur en ajoutant le symbole * après le type de la variable. Cela indique donc que l'on stocke une adresse vers une variable du type indiqué et non une valeur.  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Déréférencement​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#déréférencement","content":" Avec ce pointeur, il est possible de faire ce qu'on appelle un déréférencement et aller voir le contenu de l'emplacement situé à l'adresse stockée. C'est-à-dire, la valeur de la variable pointée.  Pour faire un déréférencement on utilise également le symbole * devant le nom de notre pointeur comme cela:  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; *integer_pointer &lt;&lt; std::endl; // On peut même modifier la valeur de notre variable par ce biais *integer_pointer = 18; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Null pointer​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#null-pointer","content":" Il est possible d'indiquer qu'un pointeur ne pointe actuellement sur rien en lui attribuant une valeur nulle avec le mot-clé nullptr:  Il s'agit alors d'un pointeur nul (ou null pointer en anglais). Le déréférencement d'un pointeur nul provoque une erreur:  #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { float* float_pointer {nullptr}; displayPointer(float_pointer); // null return 0; }   info Il existe également le mot-clé NULL qui vient du C pour indiquer un pointeur nul. Il a cependant des inconvénients et je vous demande d'utiliser nullptr en C++ qui est plus sûr.  ","version":"Next","tagName":"h3"},{"title":"Allocation dynamique en pratique: New & delete​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-dynamique-en-pratique-new--delete","content":" Comme je l'ai évoqué précédemment avec l’allocation dynamique dans la Heap on va donc demander un emplacement mémoire et le libérer plus tard. Cela se fait avec les mots-clés new et delete. Cette demande de mémoire va retourner un pointeur.  #include &lt;iostream&gt; int main() { // je demande un emplacement mémoire pour un entier int* integer_ptr {new int}; // je peux aussi demander et initialiser un entier int* number_ptr {new int{5}}; std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; // Une fois que l'on en a plus besoin, on libère les zones mémoire demandées delete number_ptr; delete integer_ptr; return 0; }   qui nous donne: 0x557590f93eb0 5   danger Le pointeur est toujours &quot;existant&quot; après avoir été libéré. Le pointeur n'est rien d'autre qu'un nombre représentant l'adresse mémoire. Cela ne veut pas dire que nous avons le droit de manipuler cette mémoire. Si l'espace mémoire pointé par le pointeur est libéré, il ne faut pas l'utiliser car cet emplacement mémoire ne nous appartient plus. #include &lt;iostream&gt; int main() { int* number_ptr {new int{2}}; delete number_ptr; // Ici l'adresse étant un nombre, elle est toujours valide std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; // Mais la valeur contenue à cette adresse peut prendre n'importe quelle valeur en fonction de l'usage nouveau de cet emplacement mémoire std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; return 0; } Il est donc recommandé d'assigner au pointeur la valeur nullptr une fois libéré pour éviter tout problème. int* number_ptr {new int{2}}; delete number_ptr; number_ptr = nullptr; // ...   ","version":"Next","tagName":"h2"},{"title":"Tableaux​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#tableaux","content":" Il est également possible de demander plusieurs emplacements mémoire contiguës (autrement dit un tableau) d'un coup en précisant entre crochets la taille du tableau [ ] . Le pointeur va contenir alors l'adresse du premier élément du tableau.  L'adresse stockée par le pointeur étant un nombre (représenté en hexadécimal) il est possible de faire des opérations dessus comme l'addition ou la soustraction. Cela permet de se positionner sur un emplacement mémoire précis du tableau.  Pour libérer un tableau alloué dynamiquement, il faut utiliser le mot-clé delete suivi de crochets [ ] .  int main() { // attention ici les valeurs ne sont pas initialisées int* array_ptr {new int[5]}; // Je me positionne sur le 3ème élément du tableau et j'utilise le déréférencement pour modifier sa valeur *(array_ptr + 2) = 42; // On peut aussi utiliser la notation avec les crochets qui est équivalente array_ptr[2] = 42; // Je libère l'espace mémoire alloué delete[] array_ptr; return 0; }   remarque Si la taille est connue à l'avance (à la compilation), il est aussi possible de déclarer un tableau sur la Stack avec la taille entre crochets [ ]. int main() { int array[5]; // Je peux accéder aux valeurs du tableau avec les crochets array[0] = 42; return 0; }   danger Il est important de noter que le pointeur ne contient pas la taille du tableau. Il est donc important de la conserver quelque part pour ne pas dépasser la taille du tableau. Si vous dépassez, vous risquez de modifier des valeurs qui ne vous appartiennent pas et donc de causer des erreurs. int main() { int* array_ptr {new int[5]}; // Ici je dépasse la taille du tableau et j'essaie de modifier une valeur qui ne m'appartient pas array_ptr[5] = 42; return 0; } Il s'agit d'une erreur très courante appelée &quot;erreur de segmentation&quot;. Elle se produit lorsque votre programme essaie de lire ou d'écrire dans une zone mémoire qui ne lui a pas été attribuée (ou ne l'est plus).  C'est la façon de gérer les tableaux en C. Cependant, en C++ il existe des structures de données plus adaptées pour gérer les tableaux comme std::array ou std::vector que nous avons vu précédemment.  ","version":"Next","tagName":"h2"},{"title":"std::vector: explications​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdvector-explications","content":" Justement, parlons un peu de std::vector. Comme dit précédemment, l'allocation dynamique (sur la Heap) est particulièrement intéressante lorsque l’on ne sait pas à l’avance la taille dont on va avoir besoin. C'est exactement le cas d'utilisation du std::vector.  En effet, std::vector n'est rien d'autre qu'une structure de donnée qui gère en interne un pointeur vers une zone mémoire contiguë. Lorsque celui-ci est trop petit et que l'on souhaite tout de même ajouter une valeur, la structure demande un nouvel espace mémoire plus grand, copie les données dans ce nouvel espace mémoire et enfin libère l'ancien espace mémoire qui n'est donc plus utilisé.  Ce changement (allocation, copie, libération de mémoire) a un coût c'est pourquoi std::vector prévoit un espace plus grand que nécessaire lors d'une allocation pour anticiper de futurs ajouts dans le tableau dynamique.  Il est possible de connaître la taille de l'espace de stockage alloué pour le std::vector avec sa méthode capacity() qui retourne cette taille exprimée en nombre d'éléments. C'est différent de la taille actuellement utilisée qui s'obtient avec la méthode size().   Une implémentation simplifiée struct IntegerVector { size_t size {0}; size_t capacity {0}; int* pointer {nullptr}; void reserve(size_t const newCapacity) { if (newCapacity &lt;= capacity) { return; } // Je demande un nouvel espace mémoire int* newPointer {new int[newCapacity]}; // Si j'avais déjà un espace mémoire if (pointer != nullptr) { // Je copie les données de l'ancien espace mémoire vers le nouveau std::copy(pointer, pointer + size, newPointer); // Je libère l'ancien espace mémoire delete [ ] pointer; } // Je met à jour les informations de la structure capacity = newCapacity; pointer = newPointer; } void push_back(int const value) { // Si je n'ai plus de place dans mon tableau, j'en demande plus if( size == capacity ) { reserve( 2 * capacity + 1 ); } // J'ajoute la valeur à la fin du tableau objects[size] = value; size++; } void pop_back() { if (size &gt; 0) { size--; } } int &amp; at(size_t const index) { // Si l'index est en dehors du tableau, je lève une exception (erreur) // Nous n'avons pas encore vu les exceptions, mais c'est un mécanisme qui permet de gérer les erreurs if (index &gt;= size) { throw std::out_of_range(&quot;Index out of range&quot;); } // Je retourne la valeur à l'index demandé return pointer[index]; } //... }; std::vector est bien sûr plus complexe que cela et a été fait par des experts du C++ mais cela permet de comprendre le principe qui se cache derrière cette structure de donnée.  ","version":"Next","tagName":"h2"},{"title":"Structure et This​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#structure-et-this","content":" Vous vous souvenez de l'utilisation du mot-clé this dans les méthodes de nos structures ?  this est en fait un pointeur vers la structure elle même !  On peut donc faire un déréférencement et avoir accès à la structure pour la modifier.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { (*this).price = price; // this-&gt;price = price; } };   C'est ce qui permet ici de faire la différence entre price qui est un paramètre de la méthode et this-&gt;price qui est le membre de la structure.  info La syntaxe -&gt; est en réalité un raccourci de syntaxe qui permet de faire un déréférencement puis d'accéder à un membre ou une méthode de la structure: Ces deux écritures sont donc équivalentes: this-&gt;member (*this).member.  ","version":"Next","tagName":"h2"},{"title":"Les références dans tout ça​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#les-références-dans-tout-ça","content":" Vous avez remarqué des ressemblances entre les pointeurs et les références ? C'est normal c'est le même mécanisme sous-jacent. La référence utilise l'adresse mémoire de la variable ciblée.  attention Cependant, une référence ne peut pas être nulle comme avec nullptr pour les pointeurs. Une référence est forcément associée à une variable.  Une référence peut être considérée comme un pointeur avec déréférencement automatique, c'est-à-dire que le compilateur applique en quelque sorte l'opérateur * pour vous.  comparaison #include &lt;iostream&gt; void addOneUsingPtr(int * a) { *a += 1; } void addOneUsingRef(int &amp; a) { a += 1; } void constDisplayUsingRef(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void constDisplayUsingPtr(int const * a) { std::cout &lt;&lt; *a &lt;&lt; std::endl; }   La référence a donc l'avantage d'être plus lisible et simple à utiliser.  remarque Utiliser les pointeurs directement est plutôt réservé à des cas spécifiques. Comme par exemple dans le cas où on souhaite une &quot;référence&quot; optionnelle (qui peut être nulle) ou alors réassigner la référence à une autre variable. #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { int a {42}; int b {24}; int&amp; ref {a}; ref = b; // a = b int* ptr {&amp;a}; *ptr = 12; // a = 12 ptr = &amp;b; // ptr pointe sur b *ptr = 36; // b = 36 displayPointer(ptr); // 36 ptr = nullptr; displayPointer(ptr); // null return 0; }   ","version":"Next","tagName":"h2"},{"title":"Pointeurs intelligents​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#pointeurs-intelligents","content":" Pendant l’exécution d'un programme, le système ne peut pas écraser ce que les développeurs ont demandé. C’est à nous, humains, de le gérer avec le mot-clé delete sinon cela provoque une fuite de mémoire.  Une fuite de mémoire est la mémoire qui a été demandée par l’utilisateur et qui n’a jamais été libérée, lorsque le programme s’est terminé ou que des pointeurs vers son emplacement ont été perdus. Pour éviter cela, chaque fois que nous n’avons plus besoin d’un élément de la Heap alloué, nous devons absolument le libérer.  L'accumulation de fuites de mémoire risque de provoquer un crash du programme ou de ralentir le système d'exploitation ou même dans le pire des cas faire planter l'ordinateur.    Pour éviter ce problème, et nous aider à gérer la mémoire le C++11 a introduit des pointeurs dits intelligents (smart pointer en anglais) dans la bibliothèque standard.  Lorsque le pointeur est détruit, la mémoire allouée précédemment est également libérée. Il n'est donc pas nécessaire de libérer la mémoire explicitement avec delete, c'est le pointeur intelligent qui s'en charge.  Un pointeur intelligent est en quelque sorte une structure enveloppant un pointeur et permettant de s'assurer que la mémoire est libérée une fois que le pointeur n'est plus utilisé.  ","version":"Next","tagName":"h2"},{"title":"unique_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#unique_ptr","content":" std::unique_ptr est un pointeur intelligent qui gère une zone mémoire allouée dynamiquement. Il est, comme son l'indique, l'unique responsable de cette zone mémoire. Elle sera détruite dès que le pointeur est détruit.  Il ne peut pas être copié, c'est à dire que l'on ne peut pas avoir deux std::unique_ptr pointant vers le même objet. Sinon, lors de la destruction des deux pointeurs, l'objet serait détruit deux fois.  #include &lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; ptr {new int{42}}; // On ne peut pas copier un unique_ptr // std::unique_ptr&lt;int&gt; ptr2 {ptr}; // A la fin du bloc (de la fonction main ici), ptr est détruit et l'espace mémoire est libéré }   ","version":"Next","tagName":"h3"},{"title":"shared_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#shared_ptr","content":" std::shared_ptr est un pointeur intelligent qui gère une zone mémoire allouée dynamiquement. La responsabilité de cette zone mémoire peut-être partagée entre plusieurs std::shared_ptr, et elle ne sera détruite que quand tous les std::shared_ptr responsables auront été détruits. Il est possible de copier un std::shared_ptr pour partager la responsabilité de la zone mémoire. Il utilise un compteur interne pour savoir combien de std::shared_ptr pointent vers la zone mémoire. Lorsque ce compteur tombe à zéro, la zone mémoire est libérée.  #include &lt;memory&gt; int main() { std::shared_ptr&lt;int&gt; ptr1 {new int{42}}; { // On peut copier un shared_ptr std::shared_ptr&lt;int&gt; ptr2 {ptr1}; // Changer la valeur de ptr1 *ptr1 = 24; // ptr1 et ptr2 pointent vers la même zone mémoire std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 24 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 24 *ptr2 = 12; std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 12 // Ici ptr2 est détruit mais la zone mémoire n'est pas libérée car ptr1 pointe toujours vers cette zone mémoire } std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 // A la fin du bloc (de la fonction main ici), ptr1 est détruit et l'espace mémoire est libéré return 0; }   C'est utile lorsque l'on souhaite partager un objet entre plusieurs parties du code.  ","version":"Next","tagName":"h3"},{"title":"std::weak_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdweak_ptr","content":" Il existe également un pointeur intelligent std::weak_ptr qui est un pointeur qui permet de pointer vers un objet gérer par un std::shared_ptr sans augmenter le compteur de références. C'est utile pour éviter des références circulaires et mieux gérer le cycle de vie des objets mais nous n'irons pas plus loin dans ce cours.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#résumé","content":" Il existe plusieurs types d'allocation de mémoire: L'allocation de mémoire statique est effectuée à la compilation. Elle est donc très rapide mais ne permet pas de modifier la taille de la mémoire allouée.L'allocation de mémoire sur la stack est effectuée à l'exécution. Elle est utilisée pour allouer nos variables locales et est à privilégier car elle est rapide.L'allocation de mémoire dynamique sur la heap est effectuée à l'exécution. Elle est utilisée si on ne connaît pas la taille de la mémoire à allouer à la compilation ou si on veut modifier la taille de la mémoire allouée. Cela permet de gérer plus finement la mémoire mais est plus lente que l'allocation de mémoire sur la stack. Un pointeur est une variable qui contient une adresse mémoire (un nombre représenté en hexadécimal). C'est un type de variable à part entière qu'on différencie avec le symbole * après le type de la variable. On utilise les mots-clés new et delete pour allouer et désallouer de la mémoire sur la heap. Le déréférencement d'un pointeur permet d'accéder à la valeur de la variable pointée. Cela s'effectue avec l'opérateur * devant le nom du pointeur. Il est possible d'attribuer à un pointeur la valeur nullptr qui représente un pointeur nul. Cela permet d'indiquer qu'un pointeur ne pointe sur rien. On l'utilise pour vérifier qu'un pointeur est valide avant de l'utiliser. std::vector est un conteneur qui permet de gérer les allocations dynamiques de tableaux à notre place. le mot-clé this est un pointeur vers la structure elle même. Cela permet de faire la différence entre un paramètre de méthode et un membre de la structure. Il existe des pointeurs intelligents (smart pointer) qui permettent de gérer la mémoire à notre place. Ils sont très pratiques car ils permettent d'éviter les fuites mémoires et les erreurs de désallocation de mémoire. ","version":"Next","tagName":"h2"},{"title":"Déduction de type et bibliothèque standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"Itérateurs​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#itérateurs","content":" Les itérateurs sont des objets propres à la STL qui permettent de parcourir les conteneurs et structures de données sans se soucier de la manière dont ils sont implémentés. Cela permet d'abstraire le conteneur utilisé et de pouvoir utiliser des algorithmes de manière générique.  Les itérateurs sont des objets qui se comportent un peu comme des pointeurs. Ils permettent de cibler un élément dans un conteneur, de le manipuler et permettent de passer d'un élément à l'autre.  Pour un tableau (comme std::array ou std::vector) le passage d'un élément à l'autre se fait généralement en incrémentant un compteur mais pour d'autres conteneurs, le passage d'un élément à l'autre est plus complexe. Grâce aux itérateurs, nous n'avons pas à nous soucier de la manière dont le conteneur est implémenté.  info Il existe plusieurs types d'itérateurs qui permettent de parcourir les conteneurs de différentes manières (parcours en lecture seule, parcours en lecture et écriture, parcours seulement dans un sens, ...). Nous n'allons pas rentrer dans les détails des différents types d'itérateurs mais sachez qu'il existe plusieurs types d'itérateurs qui permettent de parcourir les conteneurs de différentes manières.  Les itérateurs ont des opérateurs et méthodes qui permettent de les manipuler comme avec l'opérateur * pour déréférencer et accéder à la valeur pointée par l'itérateur et l'opérateur ++ pour passer à l'élément suivant.  ","version":"Next","tagName":"h2"},{"title":"Begin et end​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#begin-et-end","content":" Il existe principalement deux méthodes sur les conteneurs qui permettent de récupérer un itérateur sur le premier élément du conteneur et un itérateur permettant d'indiquer la fin du conteneur.  Voici un exemple avec un vecteur (std::vector) :  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur sur le vecteur v std::vector&lt;int&gt;::iterator begin_iterator { v.begin() }; // Déclaration d'un itérateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() };   remarque Ici, nous utilisons l'itérateur std::vector&lt;int&gt;::iterator qui permet de parcourir un vecteur. Il existe aussi l'itérateur std::vector&lt;int&gt;::const_iterator qui permet de parcourir un vecteur en lecture seule (const) (on peut obtenir des itérateurs constants avec les méthodes cbegin et cend).  attention L'itérateur end ne pointe pas sur le dernier élément du conteneur mais vers un élément invalide qui indique la fin du conteneur (généralement un élément après le dernier élément du conteneur comme c'est le cas pour std::vector par exemple). Il ne faut donc pas déréférencer l'itérateur end car cela provoquerait une erreur. Il sert uniquement à indiquer la fin du conteneur.  ","version":"Next","tagName":"h3"},{"title":"Utilisation des itérateurs​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#utilisation-des-itérateurs","content":" Pour illustrer le fonctionnement des itérateurs, reprenons l'exemple précédent avec un vecteur pour utiliser l'itérateur pour parcourir le vecteur.  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() }; // Parcours du vecteur avec l'itérateur for (std::vector&lt;int&gt;::iterator it { v.begin() }; it != end_iterator; ++it) { std::cout &lt;&lt; *it &lt;&lt; std::endl; }   Quelques explications sur ce code : Nous déclarons un itérateur sur le premier élément du vecteur v et un itérateur sur le dernier élément du vecteur v. Ensuite, nous parcourons le vecteur avec une boucle for en incrémentant l'itérateur (pour passer à l'élément suivant). Nous utilisons l'opérateur != pour comparer l'itérateur actuel avec l'itérateur qui indique la fin du vecteur afin de savoir quand nous avons parcouru tout le vecteur. L'opérateur * permet de récupérer la valeur pointée par l'itérateur (à l'instar du déréférencement d'un pointeur).  for range based loop Il existe une syntaxe plus simple pour parcourir un conteneur avec un itérateur. Il s'agit de la boucle for avec la syntaxe for (element : container). Nous avons déjà vu cette syntaxe avec les tableaux. Cette syntaxe est aussi valable pour les autres conteneurs de la STL et utilise en fait les itérateurs. Voilà le même exemple que précédemment avec la boucle for et la syntaxe for (element : container) : std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Parcours du vecteur avec l'itérateur for (int const element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } C'est cette syntaxe que nous privilégierons en pratique pour parcourir les conteneurs.  ","version":"Next","tagName":"h3"},{"title":"Déduction de type​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#déduction-de-type","content":" Jusqu'à présent, nous avons toujours déclaré nos variables en précisant leur type. Cependant, il existe une syntaxe qui permet de déduire le type d'une variable à partir de son initialisation. Nous avons vu avec les itérateurs que le type de l'itérateur dépend du conteneur sur lequel il est utilisé (par exemple std::vector&lt;int&gt;::iterator pour un vecteur de int et std::vector&lt;float&gt;::iterator pour un vecteur de float)  Il est donc impossible de déclarer un itérateur sans connaître le type du conteneur. De plus, le type de l'itérateur est généralement très long et compliqué à écrire.  Dans ce cas, nous pouvons utiliser la déduction de type pour déclarer notre itérateur. Cela se fait avec le mot clé auto à la place du type de la variable.  std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur sur le vecteur v auto it { v.begin() };   Pourquoi ne pas utiliser la déduction de type pour toutes les variables ? C'est une question de lisibilité du code. Il est plus facile de comprendre le code si les types sont précisés. De plus, la déduction de type ne fonctionne que si la variable est initialisée et que le type peut être déduit. Cela peut être problématique dans certains cas où le type ne peut pas être déduit ou conduit à des erreurs (par exemple avec {1, 2, 3, 4, 5} qui peut être un std::vector ou un std::array).  Finalement, la déduction de type est une fonctionnalité très utile mais qui doit être utilisée avec parcimonie quand cela est pertinent. Il est préférable de préciser le type des variables pour rendre le code plus lisible quand cela est possible.  On préférera donc écrire float plutôt que auto pour déclarer une variable de type float. Mais on préférera utiliser la déduction de type pour déclarer un itérateur sur un conteneur.  remarque C'est généralement considéré comme une mauvaise pratique de ne pas préciser le type des variables (comme c'est le cas en Python ou en JavaScript). Il existe pour ces langages des surcouches qui permettent de vérifier le type des variables (comme TypeScript pour JavaScript et le module typing pour Python). Le C++ est un langage fortement typé et nous impose de préciser le type des variables mais c'est pour une bonne raison et la déduction de type (auto) est une fonctionnalité qui permet de simplifier le code dans certains cas et n'a pas pour but de remplacer la déclaration de type.  ","version":"Next","tagName":"h2"},{"title":"Exemples et algorithmes​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#exemples-et-algorithmes","content":" L'intérêt de l'itérateur pour boucler sur un conteneur est limité. En effet, il est plus simple d'utiliser la boucle for avec la syntaxe for (element : container) pour parcourir un conteneur.  L'intérêt des itérateurs est de pouvoir utiliser des algorithmes de la STL qui permettent de manipuler les conteneurs de manière générique.  Toutes ces fonctions sont définies dans le fichier d'en-tête algorithm de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-tête sur le site cppreference.com (attention, la documentation est en anglais).  Nous allons voir quelques exemples d'algorithmes les plus courants de la STL.  ","version":"Next","tagName":"h2"},{"title":"Find​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#find","content":" L'algorithme std::find permet de rechercher un élément dans un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur, un itérateur sur le dernier élément du conteneur et la valeur à rechercher.  L'algorithme std::find renvoie un itérateur sur l'élément trouvé ou l'itérateur end si l'élément n'est pas trouvé.  Voici un exemple avec un vecteur (std::vector) :  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Recherche de l'élément 3 dans le vecteur v auto it { std::find(v.begin(), v.end(), 3) }; // On compare l'itérateur avec l'itérateur sur le dernier élément du vecteur if (it != v.end()) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Sort​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#sort","content":" L'algorithme std::sort permet de trier un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur et un itérateur sur le dernier élément du conteneur.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {5, 2, 3, 1, 4}; // Tri du vecteur v std::sort(v.begin(), v.end()); // Parcours du vecteur avec l'itérateur for (int element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Remove et Erase​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#remove-et-erase","content":" Pour le std::vector, il existe une méthode std::erase qui permet de supprimer des éléments du vecteur. Cependant, cette méthode n'existe pas pour tous les conteneurs.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {14, 25, 36, 42, 53}; // Suppression de tous les éléments du vecteur v qui sont égaux à 36 std::erase(v, 36); }   Cette fonction propre au std::vector ne permet pas de supprimer un élément d'un conteneur générique.  Pour cela, il existe l'algorithme std::remove qui permet de supprimer un élément d'un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur, un itérateur sur la fin du conteneur et la valeur à supprimer. C'est ce qu'utilise la méthode std::erase pour supprimer un élément du std::vector.  attention std::remove ne supprime pas réellement les éléments du conteneur. Il déplace les éléments à supprimer à la fin du conteneur et renvoie un itérateur sur le premier élément à supprimer pour définir la nouvelle fin du conteneur. Il faut ensuite utiliser la méthode erase pour supprimer les éléments à supprimer du conteneur. v.erase(std::remove(v.begin(), v.end(), 5), v.end());   C'est ce qu'on appelle l'idiome remove-erase.  A partir du C++20, il existe de nouvelles fonctions qui permettent de supprimer des éléments d'un conteneur de manière générique: std::erase et std::erase_if. Ces fonctions prennent en paramètre des itérateurs et fonctionnent donc avec tous les conteneurs.  Vous trouverez une explication ici.  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Les fonctions lambda​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#les-fonctions-lambda","content":" Details Il existe de nombreux autres algorithmes dans la STL. Il est impossible de tous les présenter dans ce cours. Je vous invite à consulter la documentation de la STL sur le site cppreference.com pour découvrir les autres algorithmes. Certains utilisent des fonctions lambda pour permettre de personnaliser le comportement de l'algorithme. C'est le cas de l'algorithme std::transform qui permet d'appliquer une fonction à tous les éléments d'un conteneur. Je ne vais pas rentrer dans les détails des fonctions lambda mais sachez que c'est une syntaxe qui permet de définir une fonction anonyme (généralement petite) et permet de passer une fonction en paramètre d'une autre fonction. C'est quelque chose de très utilisé avec la STL. Cela reste une notion avancée et je ne vais pas rentrer dans les détails des fonctions lambda dans ce cours. Vous pouvez seulement retenir deux choses : La syntaxe est la suivante : [] (paramètres) { instructions }.Si l'on souhaite accéder aux variables définies en dehors de la fonction lambda (sans que ce soit un paramètre), il faut ajouter le symbole &amp; entre les crochets et les paramètres de la fonction lambda ([&amp;] (paramètres) { instructions }) (c'est ce que l'on appelle une capture). Je vais présenter quelques algorithmes qui utilisent des fonctions lambda pour vous montrer comment cela fonctionne.  ","version":"Next","tagName":"h3"},{"title":"Transform​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#transform","content":" Details L'algorithme std::transform permet d'appliquer une fonction à tous les éléments d'un conteneur. Il prend en paramètre un itérateur sur le premier et le dernier élément du conteneur, un itérateur sur le premier élément du conteneur de destination et la fonction à appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {0, 0, 0, 0, 0}; // Application de la fonction lambda à tous les éléments du vecteur v std::transform(v.begin(), v.end(), v2.begin(), [](int element) { return element * 2; }); // Parcours du vecteur avec l'itérateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } } attention Il faut faire attention à la taille du conteneur de destination. Si le conteneur de destination est trop petit, il y aura un dépassement et soit le programme plantera soit il y aura des résultats inattendus (le vecteur de destination ne sera pas rempli, etc...). Avec des conteneurs pour lesquels on peut ajouter des éléments à la fin (comme std::vector), il est possible d'utiliser la fonction std::back_inserter pour ajouter des éléments à la fin du conteneur de destination. Cela permet de ne pas avoir à se soucier de la taille du conteneur de destination. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {}; // Application de la fonction lambda à tous les éléments du vecteur v std::transform(v.begin(), v.end(), std::back_inserter(v2), [](int element) { return element * 2; }); // Parcours du vecteur avec l'itérateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Accumulate et reduce​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#accumulate-et-reduce","content":" Details Lorsque l'on souhaite agréger les éléments d'un conteneur pour en extraire une valeur, il existe deux algorithmes qui permettent de faire cela : std::accumulate et std::reduce. Il sont inclus dans le fichier d'en-tête numeric de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-tête sur le site cppreference.com. L'algorithme std::accumulate permet d’accumuler les éléments d'un conteneur selon une opération. Pour en faire la somme par exemple. Il prend en paramètre un itérateur sur le premier et le dernier élément du conteneur, la valeur initiale et l'opération à appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des éléments du vecteur v int sum { std::accumulate(v.begin(), v.end(), 0, [](int acc, int current_element) { return acc + current_element; }) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; } A chaque itération, l'opération est appliquée entre la valeur accumulée et l'élément courant du conteneur. La valeur accumulée est initialisée avec la valeur initiale. Les valeurs sont parcourues dans l'ordre du conteneur. L'algorithme std::reduce fonctionne de la même manière que std::accumulate mais il n'y a pas de valeur initiale. Les valeurs sont parcourues dans n'importe quel ordre. C'est utile quand l'opération est commutative (l'ordre des opérandes n'a pas d'importance). Somme #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des éléments du vecteur v int sum { std::reduce(v.begin(), v.end(), [](int a, int b) { return a + b; }) }; // Ou en utilisant std::plus pour faire la somme (une fonction somme déjà implémentée dans la STL dans l'entête &lt;functional&gt;) // int sum { std::reduce(v.begin(), v.end(), std::plus&lt;int&gt;()) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; }   ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#résumé","content":" La STL fournit des algorithmes et des fonctions qui permettent de simplifier la manipulation des conteneurs.La STL fournit des itérateurs qui permettent de parcourir les conteneurs de manière générique.Un itérateur est un objet qui se comporte un peu comme un pointeur et permet de cibler un élément dans un conteneur, de le manipuler et permet de passer d'un élément à l'autre.Il existe deux méthodes sur les conteneurs qui permettent de récupérer un itérateur sur le premier élément du conteneur et un itérateur sur le dernier élément du conteneur : begin et end.La syntaxe for (element : container) utilise les itérateurs pour parcourir un conteneur.La déduction de type permet de déduire le type d'une variable à partir de son initialisation. Cela se fait avec le mot clé auto à la place du type de la variable.La déduction de type est une fonctionnalité très utile mais qui doit être utilisée avec parcimonie quand cela est pertinent. Il est préférable de préciser le type des variables pour rendre le code plus lisible quand cela est possible.L'algorithme std::find permet de rechercher un élément dans un conteneur.L'algorithme std::sort permet de trier un conteneur.L'algorithme std::erase permet de supprimer un élément d'un std::vector.Les fonctions lambda permettent de définir une fonction anonyme (généralement petite) pour personnaliser le comportement d'un algorithme.L'algorithme std::transform permet d'appliquer une fonction à tous les éléments d'un conteneur.Les algorithmes std::accumulate et std::reduce permettent d'agréger les éléments d'un conteneur pour en extraire une valeur. ","version":"Next","tagName":"h2"},{"title":"Un monde de variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Les littéraux​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-littéraux","content":" Un littéral est une valeur donnée explicitement dans le code. Il y a plusieurs types de littéraux en C++.  ","version":"Next","tagName":"h2"},{"title":"Les caractères​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-caractères","content":" En effet, la phrase &quot;Hello and welcome to IMAC !&quot; précédemment rencontrée représente simplement du texte. C'est ce qu'on appelle une chaîne de caractères.  Qui dit chaîne de caractères dit caractères et il est également possible de représenter un unique caractère avec des guillemets simples '.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'a' &lt;&lt; std::endl; std::cout &lt;&lt; '7' &lt;&lt; std::endl; std::cout &lt;&lt; '?' &lt;&lt; std::endl; return 0; }   #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'H' &lt;&lt; 'e' &lt;&lt; 'l' &lt;&lt; 'l' &lt;&lt; 'o' &lt;&lt; ' ' &lt;&lt; 'I' &lt;&lt; 'M' &lt;&lt; 'A' &lt;&lt; 'C' &lt;&lt; '!' &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Les chaînes de caractères​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-chaînes-de-caractères","content":" On pourrait simplement se contenter de caractères me direz vous mais c'est un peu fastidieux et les chaînes de caractères sont donc là pour nous simplifier la vie.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello IMAC!&quot; &lt;&lt; std::endl; return 0; }   remarque On différencie les caractères simples (utilisant des ') des chaines de caractères par les guillemets &quot;.  Les caractères spéciaux​  Avez vous une idée de comment afficher des guillemets ?  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello &quot;IMAC&quot;!&quot; &lt;&lt; std::endl; return 0; }   Si j'essaie d'utiliser des guillemets cela ne compile pas comme dans l'exemple ci-dessus.  En effet, les guillemets permettent déjà de signaler le début et la fin d'une chaîne de caractères.  C'est également le cas quand on essaye de représenter un chemin de dossier au format Windows, par exemple, avec le chemin de fichier &quot;C:\\Program Files&quot; et on obtient une erreur du type warning: unknown escape sequence: '\\P'.  Il existe en C++ des caractères dits spéciaux, appelés séquences d’échappement. Le symbole \\ permet d'indiquer au compilateur d’afficher et non interpréter ces caractères.  Il faut donc préfixer les guillemets du caractère \\ pour pouvoir les afficher:  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello \\&quot;IMAC\\&quot;!&quot; &lt;&lt; std::endl; return 0; }   Vous pouvez trouver tous les caractères d'échappement ici.  Voilà les plus utiles en pratique:  \\' qui permet d’afficher un guillemet simple '\\&quot; qui permet d’afficher un guillemet double &quot;\\n qui permet d’aller à la ligne, comme std::endl\\t qui permet de faire une tabulation horizontale\\\\ qui permet d’afficher un antislash \\  ","version":"Next","tagName":"h3"},{"title":"Les nombres​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-nombres","content":" On peut également manipuler des nombres.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; -1 &lt;&lt; std::endl; std::cout &lt;&lt; 0 &lt;&lt; std::endl; std::cout &lt;&lt; 42 &lt;&lt; std::endl; return 0; }   On les appelle nombres entiers mais il est aussi possible d'utiliser des nombres à virgule, appelés flottants.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 3.141593 &lt;&lt; std::endl; std::cout &lt;&lt; -1.5 &lt;&lt; std::endl; return 0; }   info On remarque que l'on peut utiliser des nombres négatifs sans aucun problème. On y reviendra un peu plus tard.  Concernant les nombres (entiers ou flottants) les opérateurs arithmétiques usuels sont utilisables:  Opérateur\tDescription+\tAddition -\tSoustraction *\tMultiplication /\tDivision %\tModulo (reste de la division)  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Opérateurs arithmétiques :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Addition: 1 + 2 = &quot; &lt;&lt; 1 + 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Soustraction: 6 - 2 = &quot; &lt;&lt; 6 - 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Multiplication: 3.14 * 2 = &quot; &lt;&lt; 3.14 * 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Division: 42.5 / 3.2 = &quot; &lt;&lt; 42.5 / 3.2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Modulo: 7 % 3 = &quot; &lt;&lt; 7 % 3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; 5 / 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5. / 2 = &quot; &lt;&lt; 5. / 2 &lt;&lt; std::endl; return 0; }   C'est aussi vrai pour les règles de distributivité, associativité, commutativité ou priorité des opérateurs, rien de bien étonnant me direz vous.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Associativité :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 + (3 + 6) = &quot; &lt;&lt; 2 + (3 + 6) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(2 + 3) + 6 = &quot; &lt;&lt; (2 + 3) + 6 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distributivité :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 * (4 + 3) = &quot; &lt;&lt; 2 * (4 + 3) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Priorité des opérateurs :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;42 * 3 + (2 + 8 / 4) = &quot; &lt;&lt; 42 * 3 + (2 + 8 / 4) &lt;&lt; std::endl; return 0; }   attention Ne remarquez vous pas quelque chose d'étonnant ? 5 / 2 et 5. / 2 ne donne pas la même chose ? La raison est que pour le C++, si on fait une opération sur deux nombres entiers, le résultat doit rester un nombre entier. Si l’on veut que le résultat soit un flottant, il faut qu’au moins un des deux nombres soit un flottant. C'est pour cela d'ailleurs que mon exemple 3.14 * 2 fonctionne bien car au moins un des deux nombres est un flottant et le résultat est donc un flottant également.  Pour résumer, toutes ces valeurs écrites dans notre code s'appellent des littéraux.  Les variables  Les littéraux c'est sympa mais comment faire si l'on veut se resservir d'un résultat précédemment calculé ? C'est avec les variables que l'on va pouvoir faire ça !  C’est un concept commun à beaucoup de langages de programmation qui permet de stocker une valeur et de lui associer un nom, afin de pouvoir l'identifier et la manipuler facilement.  Nous ne rentrons pas dans le détail de comment sont stockées ces valeurs dans la mémoire de l'ordinateur car ce n'est pas le propos ici.  ","version":"Next","tagName":"h3"},{"title":"Créer une variable​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#créer-une-variable","content":" Pour déclarer une variable en C++, il faut trois choses:  Préciser d'abord son type, qui indique ce que la variable va stocker (un entier, un flottant, une chaîne de caractères, etc)Un nom qui permet d'identifier la variableEnfin, la valeur à stocker dans notre variable. Ceci se fait en mettant la valeur entre accolades   #include &lt;iostream&gt; #include &lt;string&gt; int main() { int number { 42 }; char letter { 'A' }; float pi { 3.1415927f }; double pi_double { 1415926535897931 }; std::string text { &quot;Hello IMAC!&quot; }; return 0; }   Syntaxe héritée Il existe également une syntaxe alternative, de la forme type nom = valeur;. Essayez, vous verrez que ça marche. #include &lt;iostream&gt; int main() { int number { 42 }; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0; } Cette syntaxe est héritée du C et est toujours valable en C++. Dans ce cours je vous conseille fortement d'utiliser la syntaxe dite moderne utilisant les accolades . De plus la syntaxe avec le symbole = a d'autres subtilités et peut parfois induire en erreur (des conversions implicites non desirées par exemple), c'est pourquoi nous ne l'utiliserons pas dans la majorité des cas. Ne soyez pas surpris si vous rencontrez cette syntaxe, elle est encore très utilisée et je l'ai moi même utilisé pendant très longtemps.  ","version":"Next","tagName":"h2"},{"title":"Les types​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-types","content":" Dans l'exemple précédent j'ai utilisé divers mots-clés qui font chacun référence à un type de variable spécifique:  Pour les nombres entiers c'est le mot-clé int, (abréviation de l’anglais integer signifiant nombre entier). Grâce à ce type, on peut stocker des entiers négatifs ou positifs.Pour les flottants(les nombres à virgule), nous avons le mot-clé &quot;float&quot;, (abréviation de floating point numbers en anglais). Il existe aussi le mot clé &quot;double&quot; pour stocker des nombres à virgule plus précis quand c'est nécessaire.  remarque Il est recommandé de faire la distinction entre float et double en ajoutant le suffixe f à la fin du nombre: #include &lt;iostream&gt; int main() { float pi { 3.141592f }; double price { 4.14 }; return 0; } Pour l'instant ça n'a pas beaucoup d'importance mais essayez de le mettre car c'est une bonne pratique et a son importance avec des concepts plus avancés en C++.  Pour les caractères, nous avons char.Pour les chaînes de caractères nous avons std::string.  Chaîne de caractères Pour les chaînes de caractères c'est légèrement différent, nous avons le type std::string. Ce type est particulier car il n’existe pas nativement en C++. Pour ceux qui sont attentifs à std:: c'est un type issu de la bibliothèque standard dont j'ai déjà parlé. Ce sont des programmeurs experts qui ont codé ce type afin de manipuler aisément des chaînes de caractères. Afin de pouvoir manipuler des std::string, il faut donc inclure le bon fichier, ce que l’on fait grâce à la ligne #include &lt;string&gt;. #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string hello { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; hello &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des préfixes modificateurs​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-préfixes-modificateurs","content":" Il est possible d'utiliser des mot-clés modificateurs sur les entiers (type int) devant le type de la variable pour altérer son fonctionnement (et implicitement la façon dont ils sont stockés en mémoire).  signed: permet d'indiquer que le nombre est signé (+ ou -) unsigned: permet d'indiquer que le nombre n'a pas de signe (une valeur absolue ou une taille) short: le nombre sera stocké sur 16 bits minimum (dans le cas des petits nombres) long: le nombre sera stocké sur 32 bits minimum (dans le cas de plus grands nombres) long long: le nombre sera stocké sur 64 bits minimum  remarque Ces préfixes sont une indication pour le compilateur. Cela donne donc un minimum mais le compilateur est libre de choisir une représentation mémoire s'il estime que c'est mieux ou plus adapté à un ordinateur spécifique. Pour garantir une taille très précise en mémoire il existe depuis le C++11 des entiers de taille fixée (Fixed width integer types en anglais) disponible dans le fichier à inclure &lt; cstdint &gt;. On retrouve donc par exemple int16_t pour un entier sur 16 bits ou uint32_t pour représenter un entier non signé de 32 bits. Une liste exhaustive est disponible ici. C'est vraiment un usage très spécifique et nous allons pas du tout nous en servir.  ","version":"Next","tagName":"h2"},{"title":"Comportement indéterminé​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#comportement-indéterminé","content":" Mais qu'est ce qui se passe si je ne précise rien comme valeur pour ma variable (sans les accolades ) ?  int my_varaible;   C'est ce qu'on appelle un comportement indéterminé, en anglais &quot;undefined behaviour&quot;. La variable se voit attribuée une valeur indéterminée. Cela peut être 0 comme 142857, on ne peut pas le prévoir.  C'est donc quelque chose qu'il faut absolument éviter !  remarque Le compilateur l'autorise pour des questions d'optimisation et d'héritage avec le C. Certains warnings de compilation indique ces erreurs.  Il faut toujours initialiser ses variables.  Valeur par défaut Si on ajoute les accolades mais sans préciser de valeur, notre variable va contenir une valeur par défaut. Ce sera par exemple une chaîne de caractères vide (&quot;&quot;) pour les std::string ou un 0 dans le cas d'un entier. Je vous laisse essayer: #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string default_string { }; std::cout &lt;&lt; default_string &lt;&lt; std::endl; // &quot;&quot; int default_int { }; std::cout &lt;&lt; default_int &lt;&lt; std::endl; // 0 float default_float { }; std::cout &lt;&lt; default_float &lt;&lt; std::endl; // 0.0f return 0; } Pour commencer, nous écrirons toujours les valeurs explicitement pour éviter de mauvaise surprise... Plus tard, avec un peu plus de pratique, vous aurez la liberté d'utiliser l’initialisation par défaut, en connaissance de cause.  ","version":"Next","tagName":"h2"},{"title":"Quelques règles de nommage​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-règles-de-nommage","content":" Les noms des variables sont tout de même soumis à quelques règles de nommage.  Premièrement, de son origine américaine, le C++ n’autorise que les 26 lettres de l’alphabet anglais (plus les chiffres et l’underscore _), on peut donc malheureusement dire adieu à nos jolis accents français. Les espaces et les signes de ponctuation sont aussi interdits (', ?, etc). Il ne peut pas commencer par un chiffre, c’est interdit. L'usage de l'underscore _ au début, bien que possible, est conventionnellement utilisé dans un cadre spécifique et je vous déconseille donc de l'utiliser pour commencer. Enfin, il n'est pas possible d'utiliser un mot-clé du C++ comme nom de variable. Par exemple, il est interdit de déclarer une variable s’appelant int.  Quelques exemples int main() { int variable42 { 42 }; int 42variable { 42 }; // Erreur : ne peut pas commencer par un chiffre. int my_variable { 0 }; int my variable { 0 }; // Erreur : espace interdit. float result { 2.71f }; float return { 2.71f }; // Erreur : mot-clé réservé par le C++ return 0; }   ","version":"Next","tagName":"h2"},{"title":"Un joli petit nom​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#un-joli-petit-nom","content":" Au-delà des règles de nommage, trouver un nom adapté à une variable est un casse tête que même les programmeurs expérimentés rencontrent.  En effet, respecter les règles ne suffit pas à bien nommer une variable. Le nom d'une variable permet de l'identifier, de comprendre ce qu'elle stocke et comment on la manipule.  remarque Le nom d'une variable est destiné à un lecteur humain. On choisit un nom de variable pour qu'il soit compréhensible pour nous et nos futurs lecteurs, amis, collègues, etc Une fois le code compilé, l'ordinateur ne fait aucune différence entre un nom ou un autre.  ","version":"Next","tagName":"h3"},{"title":"Quelques mauvais exemples​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-mauvais-exemples","content":" lpi: Un acronyme ? Que signifie t'il ?value: Que stocke-t-elle ? Dans quel contexte ? Pourquoi existe-t-elle ?multiplication_of_two_by_sqrt_of_pi: Clair mais un peu trop long.dIsTanCe: Court et compréhensible mais les majuscules / minuscules peuvent rendre la lecture moins facile.qsqffqedfqzdjzqoid: Sûrement un chat qui est passé sur mon clavier.  Avec l'expérience et le temps vous arriverez à trouver plus facilement des noms clairs et simples.  Je vous demande dès maintenant de faire quelques efforts pour réfléchir aux noms des variables. Cela peut vous sembler peu important, jusqu'au jour où vous perdrez une semaine de travail à comprendre ce que votre programme ou variable est supposée faire.  ","version":"Next","tagName":"h3"},{"title":"Enum: Un type supplémentaire​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#enum-un-type-supplémentaire","content":" Vous allez sûrement le découvrir en pratiquant mais parfois on souhaite stocker un nombre limité de possibilités.  Par exemple les points cardinaux (Nord, Sud, Est, Ouest), les saisons (été, printemps, automne, hiver), les jours de la semaine, etc  On pourrait bien associer un entier à chaque possibilité (c'est une pratique très répandue en C) mais ce n'est pas la meilleure façon de faire. Un entier peut stocker des valeurs négatives ou alors être supérieur au nombre de possibilités voulues ce qui n'a pas vraiment de sens.  C'est là qu'entre en jeu les enum (de l'anglais Enumeration).  On le déclare en utilisant le préfixe enum class puis le nom de notre énumération suivis des valeurs possibles entre accolades.  Un exemple enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; return 0; }   remarque On utilise ici aussi la syntaxe avec :: pour signifier l'appartenance de la valeur à l'enum (de la même façon qu'avec la bibliothèque standard comme avec std::string).  représentation en mémoire Une enum est stockée en mémoire comme un entier. Chaque valeur de l'enum est associée à un entier, commençant par 0 pour la première valeur, 1 pour la deuxième, etc. Il est possible de changer cette valeur en précisant un entier après le nom de la valeur mais ce n'est pas une pratique recommandée. enum class Season { Spring = 42, Summer, Autumn, Winter, }; Nous verrons un exemple dans la partie conversion de type (cast) pour voir comment récupérer la valeur entière associée à une valeur d'une enum et vice versa.  attention Mais pourquoi le mot clé class ici ? Il est également possible de l'omettre mais cette syntaxe est un autre &quot;type&quot; d'enum hérité du C qui a de nombreux inconvénients: Il n'est pas possible de déclarer deux enums utilisant la même valeur (mais dans un contexte différent).Déclarer une variable ayant le même nom qu'une valeur d'un enum peut avoir des comportements imprévus. #include &lt;iostream&gt; enum PrimaryColor { Red, Yellow, Blue }; enum EyesColor { Brown, Hazel, Blue, // Erreur de compilation ici car la valeur Blue est aussi utilisée dans l'enum PrimaryColor Green, Grey, Amber }; int main() { // Ici Red fait référence à la valeur dans l'enum PrimaryColor std::cout &lt;&lt; Red &lt;&lt; std::endl; int Red { 35 }; // Maintenant, bien que la ligne soit identique, Red fait référence à la variable créée ci-dessus std::cout &lt;&lt; Red &lt;&lt; std::endl; return 0; } On parle de &quot;Scoped enumerations&quot; avec enum class (autrement dit ayant une portée limitée pour éviter les collisions de valeurs). Pour faire simple on écrira systématiquement enum class en C++ moderne pour s'éviter des problèmes.  Enfin, il n’existe pas de moyen simple de convertir une enum en chaîne de caractères. C'est un problème récurrent en C++ et il existe plusieurs solutions plus ou moins élégantes pour le faire. Nous en verrons une plus tard au deuxième semestre (ici).  ","version":"Next","tagName":"h2"},{"title":"Des opérateurs pour manipuler nos variables​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-opérateurs-pour-manipuler-nos-variables","content":" Il n'est pas seulement possible d'afficher nos variables (via std::cout), il est aussi possible de faire des opérations dessus.  Pour cela nous allons utiliser des opérateurs.  Les opérateurs sont des symboles qui permettent de manipuler des variables, c'est-à-dire effectuer des opérations, les évaluer, etc.  Il y a principalement deux catégories d'opérateurs:  Les opérateurs binaires qui utilisent deux valeurs pour en produire une nouvelle (comme a + b par exemple)Les opérateurs unaires qui s'appliquent sur une valeur pour en produire une nouvelle.  Nous avons par exemple vu précédemment les opérateurs arithmétiques (+, -, *, / et %) sur les nombres. Ces opérateurs sont binaires.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'affectation​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#opérateurs-daffectation","content":" Pour attribuer une nouvelle valeur à une variable, on utilise l’opérateur d’affectation =, précédé du nom de la variable et suivi de la valeur à affecter : nom = valeur;.  #include &lt;iostream&gt; int main() { int x { 0 }; std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3; std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }   C++ s'occupe en premier lieu de tout ce qui se trouve à droite du signe =. On peut donc utiliser la valeur d'une variable pour faire un calcul avant de l'assigner à cette même variable.    Dans le cas où l'on veut effectuer une opération sur une variable et assigner le résultat à cette même variable il existe des opérateurs binaires nommés opérateurs d'assignation composés.  On retrouve principalement ces opérateurs composées avec les opérateurs arithmétiques:+=, -=, *=, /= et %=  int integer { 42 }; // équivalent à écrire &quot;integer = integer + 3&quot; integer += 3; integer -= 1; integer *= 4; integer /= 2; integer %= 2;   Il existe d'autres opérateurs d'affectation composés mais nous les découvrirons le moment venu.  ","version":"Next","tagName":"h3"},{"title":"Opérateurs d'incrémentation​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#opérateurs-dincrémentation","content":" Cela va même plus loin, il existe un raccourci supplémentaire lorsque l'on souhaite ajouter ou soustraire 1 à un nombre. On parle d'incrémentation et de décrémentation.  a++ ou ++a pour incrémenter de 1 la valeur de la variable a.a-- ou --a pour décrémenter de 1 la valeur de la variable a.  info Les deux syntaxes sont quasiment équivalentes, il y a une petite différence lorsque l'on souhaite utiliser le résultat de l'incrémentation: On parle de Post-incrémentation avec a++: Cette forme signifie que la variable a est d'abord utilisée, puis elle est incrémentée de 1. Cela signifie que l'effet de l'incrémentation ne sera visible qu'après l'évaluation de l'expression qui contient a++. int a { 5 }; int result { a++ }; // result prend la valeur de a (5) puis a est incrémenté à 6. // Maintenant, a vaut 6 et result vaut 5. On parle de Pré-incrémentation avec ++a: Cette forme signifie que la variable a est d'abord incrémentée, puis cette nouvelle valeur est utilisée. Cela signifie que l'effet de l'incrémentation sera visible immédiatement dans l'expression qui contient ++a. int a { 5 }; int result { ++a }; // a est incrémenté à 6, puis result prend la nouvelle valeur de a (6). // Maintenant, a et result valent tous les deux 6. En résumé, la seule différence entre les deux formes réside dans le moment où l'incrémentation est réalisée (avant ou après l'utilisation de sa valeur actuelle). Lorsque vous voulez récupérer le résultat de l'incrémentation, assurez-vous de choisir celle qui convient le mieux à votre situation pour obtenir le comportement souhaité dans votre programme. Dans la plupart des cas, je vous recommande tout simplement de ne pas l'utiliser! C'est une grosse source d’erreurs. Faites plutôt: int a { 5 }; a++; int result { a }; ou int a { 5 }; int result { a }; a++; Aussi, je recommandes même d’utiliser a += 1 à la place. Comme ça pas de surprise on est certain de ce qu’on fait. int a { 5 }; a += 1; int result { a };   ","version":"Next","tagName":"h3"},{"title":"Quelques exemples​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-exemples","content":" #include &lt;iostream&gt; int main() { int variable { 42 }; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je donne une nouvelle valeur à ma variable variable = 2 + (3 * 9); std::cout &lt;&lt; variable &lt;&lt; std::endl; // J'utilise la valeur de ma variable pour un calcul et réaffecte le résultat à la même variable variable = variable + 7; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je me sers de ma variable pour en créer une nouvelle int other_value { variable * 3 }; std::cout &lt;&lt; other_value &lt;&lt; std::endl; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux utiliser d'autres variables également variable = other_value - 1; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux incrémenter ma variable de deux façons variable += 1; variable++; std::cout &lt;&lt; variable &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Variables constantes​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#variables-constantes","content":" Il existe enfin un dernier mot clé important, le mot clé const. Il va permettre, comme son nom l'indique, de rendre constant une variable et ainsi empêcher toute modification de celle-ci. Si l’on essaye de modifier une constante, on obtient une erreur de compilation.  int main() { float const gravity { 9.80665f }; gravity = 9.0f; // Erreur de compilation return 0; }   Pour l'instant cela ne va pas être très utile. Mais c'est une très (très (très)) bonne pratique et permet de protéger des variables et donner des contraintes fortes à notre code. Je vais l'utiliser régulièrement dans des exemples et on découvrira ensemble plus tard où cela prendra vraiment toute son importance d'utiliser des const dès que possible.  info Vous verrez souvent des codes qui inversent l’ordre de const et écrivent const float variable ;. C'est tout à fait possible car le const respecte la règle suivante : Il s’applique à ce qui est à sa gauche, sauf s’il n’y a rien, auquel cas il s’applique à ce qu’il y a à droite. Je vais le placer à droite dans la suite de ce cours car c'est le fonctionnement voulu initialement du const. C'est une question de préférence et de lisibilité, vous êtes libre de choisir ce que vous préférez.  ","version":"Next","tagName":"h2"},{"title":"Entrée / Sortie​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#entrée--sortie","content":" Jusque là, nous avons régulièrement rencontré std::cout qui nous permet d'afficher des caractères.  Il est également possible de faire l'inverse en manipulant ce qu'on appelle une entrée.  Grâce aux variables, il est possible de demander des informations à l’utilisateur et de stocker cette information afin d'en faire quelque chose.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Entre ton age : &quot; &lt;&lt; std::endl; int age { 0 }; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Tu as &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl; return 0; }   Ici std::cin est très similaire à std::cout et signifie &quot;character input&quot;.  Il faut le préfixer par std::, car lui aussi appartient à la bibliothèque standard. De plus, on utilise ici les chevrons &gt;&gt; dans le sens inverse pour signifier que l'on &quot;insère&quot;&quot; ce qui vient de notre entrée pour le stocker dans notre variable.  attention Dans notre cas le C++ comprend que c'est un nombre et le convertit en entier (int). Mais que se passe t'il si l'on entre des lettres ? Dans ce cas de figure la variable (age ici) n'est pas modifiée. Mais pas seulement, std::cin n'arrive pas à convertir notre entrée, il passe dans un état invalide, mémorise tous les caractères invalides et toutes les utilisations suivantes de std::cin seront érronées. Nous verrons plus tard comment gérer ce cas de figure et détecter si une erreur survient.  ","version":"Next","tagName":"h2"},{"title":"Cast​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast","content":" Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast.  Il existe plusieurs types de cast dont le plus courant est le cast statique (static_cast).  static_cast permet de convertir un type en un autre type. Par exemple, un int en float. C'est un cast sûr car il fait des vérifications. Il est à utiliser par défaut pour les conversions de type.  #include &lt;iostream&gt; int main() { int integer {42}; float floating {3.14f}; float floatingFromInteger {static_cast&lt;float&gt;(integer)}; int integerFromFloating {static_cast&lt;int&gt;(floating)}; std::cout &lt;&lt; &quot;integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // static_cast std::cout &lt;&lt; &quot;static_cast&lt;float&gt;(integer): &quot; &lt;&lt; floatingFromInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;static_cast&lt;int&gt;(floating): &quot; &lt;&lt; integerFromFloating &lt;&lt; std::endl; return 0; }   integer: 42 floating: 3.14 static_cast&lt;float&gt;(integer): 42 static_cast&lt;int&gt;(floating): 3   remarque Il existe également un cast hérité du C qui s'effectue avec des parenthèses ( ( ) ) autour du type vers lequel on veut caster devant la variable à caster. int integer {42}; float floating {3.14f}; float floatingFromInteger {(float)integer}; int integerFromFloating {(int)floating}; Il est à éviter car il est dangereux et fonctionne de différentes manières en fonction des cas sans vérifications et peut donc provoquer des erreurs ou comportements inattendus.  ","version":"Next","tagName":"h2"},{"title":"Cast et enum​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast-et-enum","content":" Il est également possible de caster une valeur d'une enum en entier et vice versa. C'est une pratique courante pour afficher et manipuler une valeur d'une enum.  #include &lt;iostream&gt; enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; int current_season_int { static_cast&lt;int&gt;(current_season) }; std::cout &lt;&lt; current_season_int &lt;&lt; std::endl; int season_int { 2 }; Season season { static_cast&lt;Season&gt;(season_int) }; std::cout &lt;&lt; static_cast&lt;int&gt;(season) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"En résumé​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#en-résumé","content":" Nous venons de découvrir les variables en C++. C'est la base de tout programme informatique, ce qui permet d'échanger et de manipuler des informations.  C++ nous permet de manipuler différents types de données: des caractères simples (char)des chaînes de caractères (via std::string)des nombres entiers (int)des nombres réels (float ou double)Des énumérations (avec enum class) Il est possible d'utiliser toutes les opérations usuelles qui existent sur les nombres. Les variables nous permettent de stocker des valeurs et d'y associer un nom (en tenant compte de certaines règles de nommage). Il est important de choisir un nom de variable qui a du sens et le plus simple possible. Il est possible de spécifier qu'une variable est non modifiable avec le mot-clé const. On utilise des opérateurs pour manipuler nos variables. Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast. Le plus courant est le cast statique (static_cast). Il fait des vérifications et est donc plus sûr. Il est à utiliser par défaut pour les conversions de type. Nous pouvons demander des informations à l’utilisateur grâce à std::cin. ","version":"Next","tagName":"h2"},{"title":"Structure: organiser nos données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Déclaration​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#déclaration","content":" C'est en utilisant le mot-clé struct que l'on va créer une nouvelle structure. La syntaxe de déclaration est la suivante:  struct nom { // liste des membres // type nom; // type nom; };   Cette structure est ensuite utilisable comme n'importe quel autre type de variable.  Un exemple de déclaration:  struct People { std::string name; std::string lastName; unsigned int age; };   ","version":"Next","tagName":"h2"},{"title":"Initialisation​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#initialisation","content":" Pour initialiser une structure, il y a plusieurs façons de faire similaire à la déclaration des variables &quot;classiques&quot;.  // Initialisation avec des valeurs (elles doivent être ordonnées comme les membres de la structure) People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Syntaxe possible utilisant le signe = (comme en C) People people = { &quot;name&quot;, &quot;lastName&quot;, 42 };   remarque Lors de l'initialisation avec des valeurs, elles doivent être ordonnées dans l’ordre dans lequel elles sont définies dans la structure. On ne peut pas donner juste un entier comme première valeur pour l'age dans notre cas.  danger Comme pour les variables, ne pas initialiser une structure est un comportement indéterminé. // Initialisation indéterminée People defaultPeople; Dans ce cas, il faut s'assurer de bien définir les membres de la structure ensuite !  ","version":"Next","tagName":"h2"},{"title":"Valeurs par défaut​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#valeurs-par-défaut","content":" Lors de l'initialisation, si il n'y a pas de valeur fournie entre accolades () pour les membres de la structure, ils seront initialisés avec une valeur par défaut. Pour les types primitifs (comme int, float, double, char, bool, etc.) la valeur par défaut est zéro. Pour les objets (comme std::string, std::vector, etc.) la valeur par défaut est l'objet vide.  Si une valeur est fournie en même temps que la déclaration d'un membre, c'est cette valeur qui sera utilisée lors de l'initialisation par défaut de la structure.  un exemple #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name {&quot;unknown&quot;}; float price {0.f}; unsigned int quantity {1}; }; void Display(Product const&amp; product) { std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; product.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; product.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; product.quantity &lt;&lt; std::endl; } int main() { Product unknownProduct {}; Display(unknownProduct); return 0; }   Name: unknown Price: 0 Quantity: 1   Résumé de toutes les possibilités d'initialisation Si une structure est initialisée avec accolades (ce qu'il fait faire tout le temps comme pour les variables) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur explicite est utilisée.Si une valeur est manquante dans les accolades et qu'il existe une valeur de variable membre par défaut, cette valeur est utilisée. (c'est l'exemple de la structure Product ci-dessus)Si une valeur est manquante dans les accolades et qu'il n'y a pas valeur par défaut dans la structure, l'initialisation par défaut pour le type de la variable est utilisée. Si une structure est initialisée sans accolades (ce qui est à éviter) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur est utilisée.Si une valeur est manquante dans les accolades, la variable membre reste non initialisée. (comportement indéterminé)  Bonne pratique Une bonne pratique est de toujours initialiser les variables membres de la structure avec une valeur par défaut explicite ou à défaut d'utiliser des accolades vide pour éviter le risque de variables non initialisées et de comportement indéterminé. #include &lt;string&gt; struct Product { std::string name {}; float price {}; unsigned int quantity {1}; };   ","version":"Next","tagName":"h3"},{"title":"Utilisation​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#utilisation","content":" Pour manipuler un membre, c’est-à-dire une variable appartenant à la structure, il suffit d’utiliser la syntaxe structure.membre.  #include &lt;iostream&gt; #include &lt;string&gt; struct People { std::string name; std::string lastName; unsigned int age; }; int main() { People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Modification de l'age people.age = 19; // Lecture des membres std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; people.name &lt;&lt; &quot; &quot; &lt;&lt; people.lastName &lt;&lt; &quot; and i'm &quot; &lt;&lt; people.age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par référence​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#passage-par-référence","content":" Une structure étant un agrégat de données (plus ou moins gros) il est intéressant d'utiliser des références pour passer en paramètres nos structures afin d'éviter des copies.  #include &lt;string&gt; #include &lt;iostream&gt; struct Product { std::string name; float price; unsigned int quantity; }; float GetTotalPrice(Product const&amp; product) { return product.price * product.quantity; } int main() { Product product { &quot;Tomatos&quot;, 0.32, 12 }; // Lecture des membres std::cout &lt;&lt; &quot;The total price for &quot; &lt;&lt; product.name &lt;&lt; &quot; is &quot; &lt;&lt; GetTotalPrice(product) &lt;&lt; &quot; €.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des méthodes​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#des-méthodes","content":" Maintenant que nous avons nos propres structures cela va devenir intéressant d'utiliser des méthodes. En effet, dans mon exemple précédent j'ai créé des fonctions GetTotalPrice et Display. Mais j'aurais bien aimé pouvoir faire : product.TotalPrice(). Autrement dit, créer et utiliser une méthode TotalPrice() pour ma structure Product.  Il suffit simplement de déclarer notre fonction au sein même des accolades de notre structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() { return price * quantity; } };   remarque Vous pouvez remarquer qu'ici je peux accéder aux membres de ma struct sans avoir à faire struct.membre. En effet, la méthode a connaissance de la structure elle-même et peut manipuler ses membres directement.  ","version":"Next","tagName":"h2"},{"title":"Prototype de méthodes​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#prototype-de-méthodes","content":" Comme pour les fonctions, il est possible de déclarer seulement le prototype de la méthode et d'implémenter le corps de la méthode plus tard. Il y a juste un petit détail en plus, il faut indiquer à l'aide du nom de la structure et des caractères :: ,l'appartenance de la méthode à la structure (comme avec std::).  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; }   remarque C'est une notion qui va être utile quand on verra la séparation du code en plusieurs fichiers.  ","version":"Next","tagName":"h3"},{"title":"Méthode constante​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#méthode-constante","content":" Ici, il est aussi possible de préciser qu'une méthode ne modifie pas la structure, on parle de méthode constante. Il faut ajouter le mot-clé const à la fin de la déclaration de la méthode, avant le point virgule ;.  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() const; }; float Product::TotalPrice() const { return price * quantity; }   C'est important car si on ne le fait pas on ne pourra pas appeler une méthode non constante d'une variable constante car celle-ci est susceptible de modifier la structure alors que c'est interdit par la variable constante.  #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; } int main() { Product const tomatos { &quot;Tomatos&quot;, 0.32, 12 }; // erreur ici: la variable tomatos est constante mais la méthode 'TotalPrice' ne l'est pas float tomatosPrice { tomatos.TotalPrice() }; return 0; }   Il faut donc indiquer que la méthode est constante:  // le prototype float GetTotalPrice() const; // et la fonction float Product::GetTotalPrice() const { return price * quantity; }   ","version":"Next","tagName":"h3"},{"title":"Conflit de noms​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#conflit-de-noms","content":" Comme pour les fonctions, il est possible de passer des paramètres à notre méthode.  Mais si le paramètre a le même nom qu'un des membres de la structure il y a un conflit de noms.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float price) { price = price; } };   Ici la variable price manipulée dans la fonction n'est plus le membre mais le paramètre, les paramètres ont la priorité sur les membres de la structure.  attention Sur certains compilateurs bien configurés on peut avoir des warnings : Warning généré par clang Explicitly assigning value of variable of type 'float' to itself; did you mean to assign to member 'price'? Mais ce n'est pas toujours le cas. Avec un paramètre constant on aurait généré des erreurs de compilation et pas seulement un warning et c'est donc préférable pour mieux se rendre compte des erreurs. - Cannot assign to variable 'price' with const-qualified type 'const float' - assignment of read-only parameter 'price'   Pour éviter la confusion, il est préférable d'utiliser le mot clé this suivi des caractères -&gt; devant le nom d'un membre de la structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { this-&gt;price = price; } };   Ici, plus de problème, this-&gt;price fait référence à notre membre et price est le paramètre constant de la méthode.  Une autre solution préférable et recommandée est de renommer le nom du paramètre pour éviter cette confusion:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const newPrice) { price = newPrice; // this-&gt;price = newPrice; } };   Vous êtes libre de laisser ou non le this-&gt; pour indiquer plus explicitement l'utilisation du membre de la structure surtout si c'est plus compréhensible pour vous.  Je ne rentre pas dans le détail ici. Je reviendrai sur le fonctionnement du mot-clé this dans un autre chapitre. Retenez simplement ici que cela permet d'indiquer explicitement que l'on souhaite manipuler la structure.  ","version":"Next","tagName":"h3"},{"title":"Aller plus loin: Forward Declaration​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#aller-plus-loin-forward-declaration","content":" Parfois deux structures ont besoin l'une de l'autre, on veut utiliser une struct A dans une struct B et inversement.  Problème, l'une est définie avant l'autre et donc dans la première structure A il y a une erreur, B est encore inconnue.    Pour résoudre ce problème on va faire une déclaration anticipée (Forward Declaration en anglais).  Un peu à la manière d'un prototype on va indiquer que la structure existe, sans en définir précisément encore son contenu.  #include &lt;vector&gt; // Déclaration anticipée de la structure Book struct Book; struct Author { std::string name; // Je peux donc l'utiliser ici std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); };   attention Cela ne permet pas de manipuler la structure vu que l'on ne sait pas encore ce qu'elle contient. De ce fait, les méthodes de la structure Author qui utilisent la structure Book doivent se trouver après la déclaration complète de la structure Book.  Un exemple plus complet #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; struct Book; struct Author { std::string name; std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); }; void Author::Display() { std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Books: &quot; &lt;&lt; std::endl; for (Book const&amp; book : books) { std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; book.title &lt;&lt; std::endl; } } void Author::AddBook(std::string title) { // le &quot;*this&quot; permet de récupérer une référence vers l'objet courant // Ce mécanisme sera détaillé dans un prochain chapitre Book book {title, *this}; // Ici une copie de l'objet book est faite dans le vecteur books.push_back(book); // La variable book va être détruite à la fin de la fonction // mais le vecteur books contient une copie de l'objet book donc pas de problème } void Book::Display() { std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author.name &lt;&lt; std::endl; } int main() { Author author {&quot;Jules Verne&quot;, {}}; author.AddBook(&quot;Vingt mille lieues sous les mers&quot;); author.Display(); return 0; }   ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#résumé","content":" Une structure est un agrégat de données, on la déclare avec le mot-clé struct. Les membres de la structure sont les variables qui la composent. On y accède avec un point . après le nom de la variable. Une structure peut avoir des méthodes qui se déclarent comme pour les fonctions mais au sein même des accolades de la structure. Le corps d'une méthode peut être déclaré plus tard (du moment que le prototype de la méthode est dans la structure). Il faut utiliser le nom de la structure suivi des caractères :: pour indiquer l'appartenance de la méthode à la structure si elle est déclarée en dehors des accolades délimitant la structure. Une méthode peut être constante pour indiquer qu'elle ne va pas modifier la structure. Il faut ajouter le mot-clé const après les paramètres de la fonction et avant le point virgule ;. On peut utiliser le mot-clé this pour expliciter que l'on souhaite manipuler la structure et éviter des conflits de nommages entre les membres et les paramètres d'une méthode. ","version":"Next","tagName":"h2"},{"title":"Arbres binaires","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree","content":"","keywords":"","version":"Next"},{"title":"Profondeur d'un nœud​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#profondeur-dun-nœud","content":" La profondeur d'un nœud est le nombre de nœuds qui le séparent du nœud racine. En considérant que la profondeur du nœud racine est 1.  Dans notre exemple, la profondeur du nœud racine A est 1. La profondeur du nœud B est 2. La profondeur du nœud E est 3. etc..  ","version":"Next","tagName":"h3"},{"title":"Hauteur d'un arbre​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#hauteur-dun-arbre","content":" La hauteur d'un arbre est la profondeur maximale de ses nœuds. C'est à dire la profondeur du nœud le plus profond.  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires","content":" Il existe plusieurs types d'arbres qui ont des propriétés différentes. On peut par exemple se limiter à un nombre maximum de fils par nœud, imposer un ordre sur les fils d'un nœud, ou encore imposer que chaque nœud ait un nombre fixe de fils.  C'est le cas des arbres binaires. Un arbre binaire est un arbre dont chaque nœud a au maximum deux fils. Un fils gauche et un fils droit.  C'est une structure de données très utilisée en informatique et c'est ce que nous allons étudier.  ","version":"Next","tagName":"h2"},{"title":"Représentation d'un arbre binaire​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#représentation-dun-arbre-binaire","content":" ","version":"Next","tagName":"h2"},{"title":"Structure par récursivité​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-récursivité","content":" Pour représenter un arbre binaire une solution qui peut sembler naturelle est d'utiliser une structure récursive. C'est à dire une structure qui contient des éléments de son propre type.  En effet, n'importe quel nœud de l'arbre, peut être vu comme un sous arbre binaire dont la racine est ce nœud. Ce jeu de l'esprit permet de comprendre qu'un nœud pointe vers deux autres nœuds qui sont les fils gauche et droit de ce nœud.  Il peut ne pointer vers aucun nœud, dans ce cas il est une feuille. Sinon, ce nœud représente un embranchement de l'arbre.  Mais on peut se demander comment représenter ce lien (qui peut ne pas exister dans le cas d'une feuille) entre un nœud et ses fils.  C'est là qu'interviennent les pointeurs. On peut représenter ce lien en utilisant des pointeurs vers les nœuds fils.  attention On ne peut pas utiliser des références car elles doivent être une référence vers un objet existant. Or, dans le cas d'une feuille, il n'y a pas de nœud fils.  Le pointeur lui peut être nul, c'est à dire qu'il ne pointe vers aucun objet. C'est cette particularité qui permet de représenter le cas d'une feuille.  Voilà à quoi ressemble la structure que l'on va utiliser pour représenter un arbre binaire:  struct Node { int value; Node* left; Node* right; };   Elle est composée d'un entier qui représente la valeur du nœud (cela peut être n'importe quel type de donnée), et de deux pointeurs vers des nœuds qui représentent les fils gauche et droit.  C'est pratique mais cela s'accompagne des inconvénients des pointeurs. Il faut faire attention à ne pas avoir de fuites mémoires (gérer l'allocation et la désallocation de la mémoire) et il faut faire attention à ne pas utiliser(déréférencer) un pointeur qui ne pointe vers rien (pointeur nul).  Exemple d'utilisation:  Node* root { new Node {1, nullptr, nullptr}}; root-&gt;left = { new Node {2, nullptr, nullptr}}; root-&gt;right = { new Node {3, nullptr, nullptr}}; root-&gt;left-&gt;left = { new Node {4, nullptr, nullptr}}; delete root-&gt;left-&gt;left; delete root-&gt;left; delete root-&gt;right; delete root;   attention ⚠️ Il faut faire attention à désallouer la mémoire dans le bon ordre ! Si on désalloue le nœud racine avant ses fils, on ne pourra plus accéder aux fils pour les désallouer. Cela provoque une fuite de mémoire.  info On pourrait se limiter seulement à cette structure de nœud pour représenter un arbre binaire. Mais cela peut être pratique d'avoir une structure dédiée à l'arbre binaire qui contient un pointeur vers le nœud racine. Cela permet de gérer le cas où l'arbre est vide (qui n'a pas encore de nœud racine). Cela permet aussi de cacher la structure interne de l'arbre. On peut par exemple changer la structure interne Node (la structure de nœud) sans avoir à modifier le code qui l'utilise (la structure de l'arbre). L'utilisateur de l'arbre n'a pas besoin de savoir comment est représenté l'arbre en interne, il n'est pas censé manipuler directement les nœuds. Cette notion de cacher la structure interne d'un objet est appelée encapsulation. C'est une notion importante en programmation orientée objet. Vous découvrirez cela plus en détail l'année prochaine et cela sera encore plus pertinent avec la notion de visibilité. struct BinaryTree { Node* root; };    Pointeurs intelligents Il existe des pointeurs intelligents qui permettent de gérer automatiquement la mémoire. Ils sont définis dans la bibliothèque &lt;memory&gt;. On pourrait se servir dans notre cas du pointeur intelligent std::unique_ptr qui permet de gérer automatiquement la mémoire d'un objet alloué dynamiquement. struct Node { int value; std::unique_ptr&lt;Node&gt; left; std::unique_ptr&lt;Node&gt; right; }; On peut alors utiliser la fonction std::make_unique pour créer un objet alloué dynamiquement et initialiser les pointeurs intelligents. std::unique_ptr&lt;Node&gt; root { std::make_unique&lt;Node&gt;(1, nullptr, nullptr)}; root-&gt;left = std::make_unique&lt;Node&gt;(2, nullptr, nullptr); root-&gt;right = std::make_unique&lt;Node&gt;(3, nullptr, nullptr); Cela permet de ne pas avoir à gérer la désallocation de la mémoire. La structure est automatiquement désallouée lorsque le pointeur intelligent est détruit. Cela va se faire dans le bon ordre naturellement car pour détruire une structure, il faut d'abord détruire ses membres. Ses enfants seront donc détruits avant le nœud parent.  ","version":"Next","tagName":"h3"},{"title":"Structure par tableau​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-tableau","content":" Une autre façon de représenter un arbre binaire est d'utiliser un tableau. Cela peut sembler étrange mais c'est possible.  On peut représenter un arbre binaire en utilisant un tableau en utilisant la relation entre les indices du tableau et les nœuds de l'arbre.  On commence par numéroter le nœud racine avec l'indice 0. Ensuite, on définit une relation entre les indices des nœuds et les indices de leurs fils.  On définit que le fils gauche d'un nœud d'indice i est le nœud d'indice 2*i + 1. Et que le fils droit d'un nœud d'indice i est le nœud d'indice 2*i + 2.  Un exemple avec l'arbre suivant:    On peut représenter cet arbre avec le tableau suivant:  [A, B, C, D, E, F, G]   En effet, le nœud A est à l'indice 0. Son fils gauche est le nœud B qui est à l'indice 2*0 + 1 = 1. Son fils droit est le nœud C qui est à l'indice 2*0 + 2 = 2. Pour le nœud B(d'indice 1) , son fils gauche est le nœud D qui est à l'indice 2*1 + 1 = 3. Son fils droit est le nœud E qui est à l'indice 2*1 + 2 = 4. Etc...  info On peut remarquer qu'il faut un tableau de taille 2n−12^n - 12n−1 pour représenter un arbre binaire complet de hauteur n. C'est à dire un arbre binaire dont tous les niveaux sont remplis sauf éventuellement le dernier niveau qui peut ne pas être rempli.  Dans le cas où l'arbre n'est pas complet (c'est à dire que tous les feuilles ne sont pas sur le même niveau ou que des nœuds de l'arbre n'ont pas forcément deux fils), on peut avoir des trous dans le tableau. C'est à dire des cases du tableau qui ne sont pas utilisées.  Par exemple, pour l'arbre suivant:    On peut représenter cet arbre avec le tableau suivant:  [A, B, C, _, _, D, E, _, _, _, _, H, _, F, _]   Cette représentation est intéressante car elle permet de représenter un arbre binaire sans avoir à utiliser de pointeurs. Mais elle a aussi l'inconvénient de ne pas être très efficace quand l'arbre n'est pas complètement rempli. En effet, on peut avoir beaucoup de trous dans le tableau. Cela peut être problématique si l'arbre a une hauteur importante.  De plus il faut un moyen de représenter les trous dans le tableau. On peut par exemple utiliser une valeur spéciale qui ne peut pas être une valeur valide pour un nœud. Par exemple, on peut utiliser la valeur -1 pour représenter un trou dans le tableau. Ou alors on peut utiliser std::optional pour représenter un nœud qui n'existe pas.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un arbre binaire​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-dun-arbre-binaire","content":" Il existe plusieurs façons de parcourir les différents nœuds d'un arbre binaire. On peut par exemple parcourir l'arbre en largeur ou en profondeur.  Donnons nous l'arbre suivant:    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-largeur","content":" Le parcours en largeur consiste à parcourir l'arbre en commençant par le nœud racine puis en parcourant les nœuds de chaque niveau de profondeur de l'arbre de gauche à droite.  astuce Cela correspond à l'ordre dans lequel sont rangées les données lorsque l'on représente un arbre binaire par un tableau.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-profondeur","content":" Le parcours en profondeur consiste à parcourir l'arbre de la racine vers les feuilles par récursion dans les sous-arbres gauche et droite. On peut parcourir l'arbre en profondeur de différentes façons:  Parcours en profondeur préfixe (ou pré-ordre): on parcourt d'abord le nœud racine, puis le sous-arbre gauche et enfin le sous-arbre droit.Parcours en profondeur infixe (ou symétrique): on parcourt d'abord le sous-arbre gauche, puis le nœud racine et enfin le sous-arbre droit.Parcours en profondeur postfixe (ou post-ordre): on parcourt d'abord le sous-arbre gauche, puis le sous-arbre droit et enfin le nœud racine.  Exemple de parcours Pour l'arbre suivant:    Parcours en largeur: A B C D E F GParcours en profondeur préfixe: A B D E C F GParcours en profondeur infixe: D B E A F C GParcours en profondeur postfixe: D E B F G C A  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires de recherche​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires-de-recherche","content":" Une fois que l'on a vu comment représenter un arbre binaire, on peut se demander à quoi cela peut servir. On peut par exemple se demander comment faire une recherche efficace dans un arbre binaire.  Un arbre binaire de recherche est un arbre binaire qui a la particularité d'être ordonné. On va imposer un ordre sur les valeurs des nœuds de l'arbre.  Dans notre cas on va imposer que pour chaque nœud, toutes les valeurs des nœuds du sous-arbre gauche sont inférieures à la valeur du nœud et toutes les valeurs des nœuds du sous-arbre droit sont supérieures à la valeur du nœud.  Le premier élément inséré dans l'arbre devient la racine. Ensuite, il suffit de mettre à gauche les éléments plus petits et à droite les éléments plus grands. C'est cette particularité qui rend les arbres binaires de recherche intéressants.  Cela permet de faire des recherches efficaces dans l'arbre. Grâce à la relation d'ordre entre les nœuds, on peut savoir dans quel sous-arbre se trouve la valeur recherchée et effectuer une recherche rappelant le fonctionnement de la recherche dichotomique.  Vous pouvez trouver un visuel interactif pour comprendre le fonctionnement d'un arbre binaire de recherche ici.  ","version":"Next","tagName":"h2"},{"title":"Insertion​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#insertion","content":" L'insertion dans un arbre binaire de recherche est assez simple. Il suffit de trouver le bon endroit pour insérer le nouveau nœud en respectant la relation d'ordre entre les nœuds.  On commence par comparer la valeur du nouveau nœud avec la valeur du nœud racine. Si la valeur du nouveau nœud est inférieure à la valeur du nœud racine, on insère le nouveau nœud dans le sous-arbre gauche. Sinon, on insère le nouveau nœud dans le sous-arbre droit.  On répète cette opération jusqu'à trouver un nœud qui n'a pas de fils dans la direction où l'on souhaite insérer le nouveau nœud. On insère alors le nouveau nœud à cet endroit.  ","version":"Next","tagName":"h3"},{"title":"Recherche​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#recherche","content":" La recherche dans un arbre binaire de recherche est similaire à la recherche dichotomique. Pour commencer, on compare la valeur recherchée avec la valeur du nœud racine. Si la valeur recherchée est inférieure à la valeur du nœud racine, on effectue la recherche dans le sous-arbre gauche. Sinon, on effectue la recherche dans le sous-arbre droit.  On répète cette opération jusqu'à trouver la valeur recherchée ou jusqu'à arriver à un nœud qui n'a pas de fils dans la direction où l'on souhaite continuer la recherche. Dans ce cas, on peut conclure que la valeur recherchée n'est pas dans l'arbre.  L'intérêt de la recherche dans un arbre binaire de recherche est que l'on peut exclure une partie de l'arbre à chaque étape de la recherche. Cela permet de réduire le nombre de comparaisons nécessaires pour trouver un élément dans l'arbre. C'est ce qui rend la recherche dans un arbre binaire de recherche efficace. C'est une complexité en O(log(n))O(log(n))O(log(n)).  ","version":"Next","tagName":"h3"},{"title":"Suppression​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#suppression","content":" La suppression dans un arbre binaire de recherche est plus complexe que l'insertion et la recherche. Il faut faire attention à ne pas casser la relation d'ordre entre les nœuds.  Il existe trois cas de figure:  Le nœud à supprimer est une feuille: il suffit de supprimer le nœud.Le nœud à supprimer a un seul fils: il suffit de supprimer le nœud et de le remplacer par son fils.Le nœud à supprimer a deux fils: il faut trouver le nœud qui va remplacer le nœud à supprimer tout en conservant la relation d'ordre entre les nœuds.  Dans le cas 3, il faut faire attention à ne pas casser la relation d'ordre entre les nœuds. Je rappelle que pour chaque nœud, toutes les valeurs des nœuds du sous-arbre gauche sont inférieures à la valeur du nœud et toutes les valeurs des nœuds du sous-arbre droit sont supérieures à la valeur du nœud. Pour conserver cette relation d'ordre, il faut alors que le nœud qui remplace le nœud à supprimer soit plus grand que tous les nœuds du sous-arbre gauche ou plus petit que tous les nœuds du sous-arbre droit.  On va donc par exemple chercher le nœud le plus à gauche du sous-arbre droit. Ce nœud est le plus petit nœud du sous-arbre droit. Il est donc plus grand que tous les nœuds du sous-arbre gauche et plus petit que tous les nœuds du sous-arbre droit. Il peut donc remplacer le nœud à supprimer tout en conservant la relation d'ordre entre les nœuds.  ","version":"Next","tagName":"h3"},{"title":"Une multitude d'arbres binaires​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#une-multitude-darbres-binaires","content":" Il existe une multitude d'arbres binaires différents qui ont des propriétés différentes. Cela permet de s'adapter à différents cas d'utilisation.  Par exemple, dans le cadre d'une recherche, on peut vouloir que l'arbre soit le plus équilibré possible (c'est à dire que la hauteur de l'arbre soit la plus petite possible). Cela permet de réduire le nombre de comparaisons nécessaires pour trouver un élément dans l'arbre. C'est le cas des arbres binaires de recherche AVL. Cela nous force à implémenter des algorithmes d'insertion et de suppression plus complexes pour maintenir l'équilibre de l'arbre.  Dans d'autres cas, on peut vouloir privilégier la rapidité d'insertion et de suppression. C'est le cas des arbres binaires de recherche Rouge-Noir. C'est un autre type d'arbre binaire de recherche qui permet de maintenir un arbre équilibré mais qui ne garantit pas à tout moment que l'arbre soit le plus équilibré possible. Cela permet de simplifier les algorithmes d'insertion et de suppression tout en restant efficace la majorité du temps.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#résumé","content":" Un arbre est une structure de données qui permet de représenter des données hiérarchiques.Un arbre est composé de nœuds. Chaque nœud peut avoir un nombre quelconque de fils. Un nœud qui n'a pas de fils est appelé une feuille.Un arbre est composé d'un nœud racine qui est le nœud de départ de l'arbre. Il est possible d'accéder à tous les autres nœuds de l'arbre à partir du nœud racine.La profondeur d'un nœud est le nombre de nœuds qui le séparent du nœud racine.La hauteur d'un arbre est la profondeur maximale de ses nœuds. C'est à dire la profondeur du nœud le plus profond.Un arbre binaire est un arbre dont chaque nœud a au maximum deux fils. Un fils gauche et un fils droit.Un arbre binaire peut être représenté par une structure récursive (C'est à dire une structure qui contient des éléments de son propre type) ou par un tableau.Un arbre binaire de recherche est un arbre binaire qui a la particularité d'être ordonné. On va imposer un ordre sur les valeurs des nœuds de l'arbre. Cela va permettre de faire des recherches efficaces dans l'arbre.Il existe une multitude d'arbres binaires différents qui ont des propriétés différentes. Cela permet de s'adapter à différents cas d'utilisation (pour optimiser la recherche, l'insertion, la suppression, etc...) ","version":"Next","tagName":"h2"},{"title":"Structures de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Piles et files (LIFO, FIFO)​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#piles-et-files-lifo-fifo","content":" Une pile est une structure de données qui permet de stocker des éléments de façon à ce que le dernier élément ajouté soit le premier à être retiré. On parle de structure de données LIFO (Last In First Out).  Une file est une structure de données qui permet de stocker des éléments de façon à ce que le premier élément ajouté soit le premier à être retiré. On parle de structure de données FIFO (First In First Out).  ","version":"Next","tagName":"h2"},{"title":"std::stack — Une pile​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdstack--une-pile","content":" La classe std::stack permet de représenter une pile. Elle est définie dans la bibliothèque &lt;stack&gt;.  On utilise la méthode push pour ajouter un élément au sommet de la pile et la méthode pop pour retirer l'élément au sommet de la pile.  Elle s'utilise de la même façon que d'autres conteneurs de la bibliothèque standard.  #include &lt;stack&gt; #include &lt;iostream&gt; int main() { std::stack&lt;int&gt; stack; stack.push(1); stack.push(2); stack.push(3); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 3 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 2 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 1 stack.pop(); }   ","version":"Next","tagName":"h3"},{"title":"std::queue — Une file​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdqueue--une-file","content":" La classe std::queue permet de représenter une file. Elle est définie dans la bibliothèque &lt;queue&gt;.  On utilise la méthode push pour ajouter un élément à la fin de la file et la méthode pop pour retirer l'élément au début de la file.  #include &lt;queue&gt; #include &lt;iostream&gt; int main() { std::queue&lt;int&gt; queue; queue.push(1); queue.push(2); queue.push(3); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 1 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 2 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 3 queue.pop(); }   ","version":"Next","tagName":"h3"},{"title":"std::pair — Un conteneur de paires d'éléments​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdpair--un-conteneur-de-paires-déléments","content":" La classe std::pair (définie dans la bibliothèque &lt;utility&gt;) permet de représenter une paire d'éléments de types différents.  On peut accéder aux éléments de la paire avec les attributs first et second.  ","version":"Next","tagName":"h2"},{"title":"Définition d'une paire​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#définition-dune-paire","content":" Pour définir une paire, on peut utiliser la fonction std::make_pair ou assigner les valeurs directement aux attributs first et second.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 = std::make_pair(3, 4); std::pair&lt;int, int&gt; p3 {}; p3.first = 5; p3.second = 6; std::cout &lt;&lt; p1.first &lt;&lt; &quot; &quot; &lt;&lt; p1.second &lt;&lt; std::endl; // Affiche 1 2 std::cout &lt;&lt; p2.first &lt;&lt; &quot; &quot; &lt;&lt; p2.second &lt;&lt; std::endl; // Affiche 3 4 std::cout &lt;&lt; p3.first &lt;&lt; &quot; &quot; &lt;&lt; p3.second &lt;&lt; std::endl; // Affiche 5 6 }   Si rien n'est spécifié, les attributs first et second sont initialisés avec des valeurs par défaut.  info La fonction std::make_pair permet d'expliciter le type de la paire. C'est utile dans certains cas où le type de la paire ne peut pas être déduit automatiquement.  ","version":"Next","tagName":"h3"},{"title":"Comparaison de paires​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#comparaison-de-paires","content":" La paire intègre également un opérateur de comparaison qui compare les éléments de la paire dans l'ordre lexicographique.  Ordre lexicographique L'ordre lexicographique est comparable à l'ordre alphabétique. Si l'on se limite aux mots et lettres c'est l'ordre utilisé pour comparer les mots dans un dictionnaire. On compare les premières lettres des mots. Si les premières lettres sont égales, on compare les secondes lettres, etc. Cela peut être étendu à des éléments plus complexes comme des nombres. On compare les premiers éléments. Si les premiers éléments sont égaux, on compare les seconds éléments, etc.  Dans le cas des paires, on compare les premiers éléments. Si les premiers éléments sont égaux, on compare les seconds éléments.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 {1, 3}; std::pair&lt;int, int&gt; p3 {2, 1}; std::pair&lt;int, int&gt; p4 {1, 2}; std::cout &lt;&lt; (p1 &lt; p2) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p3) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p4) &lt;&lt; std::endl; // Affiche 0 }   ","version":"Next","tagName":"h3"},{"title":"Utilisation de std::pair​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#utilisation-de-stdpair","content":" On peut se servir de la classe std::pair et de son ordre lexicographique pour trier des éléments dans un tableau.  #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;std::pair&lt;int, int&gt;&gt; pairs { {1, 2}, {3, 4}, {1, 3}, {2, 1}, {1, 1} }; std::sort(pairs.begin(), pairs.end()); for (auto const&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl; } }   Dans cet exemple, on trie les paires dans l'ordre lexicographique sur les premiers éléments. Si les premiers éléments sont égaux, on trie les paires dans l'ordre lexicographique sur les seconds éléments.  Ce qui donne le résultat suivant :  1 1 1 2 1 3 2 1 3 4     Cela peut aussi être utile pour retourner plusieurs valeurs dans une fonction.  #include &lt;utility&gt; #include &lt;vector&gt; std::pair&lt;float, float&gt; minMax(std::vector&lt;float&gt; const&amp; array) { float min {array[0]}; float max {array[0]}; for (float const&amp; value: array) { if (value &lt; min) { min = value; } if (value &gt; max) { max = value; } } return std::make_pair(min, max); }   info La classe std::pair est également utilisée par d'autres conteneurs de la bibliothèque standard comme std::map que nous verrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"std::tuple — Un conteneur de données hétérogènes​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdtuple--un-conteneur-de-données-hétérogènes","content":" La classe std::tuple (définie dans la bibliothèque &lt;tuple&gt;) permet de représenter un ensemble de données hétérogènes  C'est similaire à std::pair mais on peut stocker plus de deux éléments.  On peut accéder aux éléments de la paire avec la fonction std::get.  Exemple :   #include &lt;tuple&gt; #include &lt;iostream&gt; int main() { std::tuple&lt;int, float, std::string&gt; t {1, 3.14f, &quot;Hello&quot;}; std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl; // Affiche 3.14 std::cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl; // Affiche Hello }   attention On privilégie l'utilisation de structures de données avec des membres explicites plutôt que des tuples ou des pairs quand c'est pertinent. Nommés les membres d'une structure permet de rendre le code plus lisible et plus facile à maintenir. Les tuples et pair sont utiles dans certains cas, mais il faut faire attention à ne pas en abuser.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#pour-aller-plus-loin","content":" std::variant La classe std::variant (définie dans la bibliothèque &lt;variant&gt;) permet de stocker un élément parmi un ensemble d'éléments possibles. Similaires aux aux enums, mais avec la possibilité de stocker des types différents. #include &lt;variant&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::variant&lt;int, float, std::string&gt; v {}; v = 42; // v contient un int v = 3.14f; // v contient un float v = &quot;Hello&quot;; // v contient une std::string if (std::holds_alternative&lt;int&gt;(v)) { std::cout &lt;&lt; &quot;v contient un int dont la valeur est &quot; &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;float&gt;(v)) { std::cout &lt;&lt; &quot;v contient un float dont la valeur est &quot; &lt;&lt; std::get&lt;float&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;std::string&gt;(v)) { std::cout &lt;&lt; &quot;v contient une std::string dont la valeur est &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl; }   std::optional La classe std::optional (définie dans la bibliothèque &lt;optional&gt;) permet de stocker un élément optionnel. C'est-à-dire un élément qui peut être présent ou non. Pour représenter un élément optionnel qui ne contient rien, on peut utiliser la valeur std::nullopt. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::optional&lt;int&gt; o {}; o = 42; // o contient un int if (o.has_value()) { std::cout &lt;&lt; &quot;o contient un int dont la valeur est &quot; &lt;&lt; o.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;o ne contient rien&quot; &lt;&lt; std::endl; } C'est un objet qui peut être utile pour représenter des valeurs optionnelles, comme par exemple le résultat d'une recherche dans un tableau ou un paramètre optionnel d'une fonction. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; // Recherche la valeur dans le tableau et retourne son index si elle est trouvée sous forme d'un std::optional std::optional&lt;size_t&gt; find(std::vector&lt;int&gt; const&amp; array, int value) { for (size_t i {0}; i &lt; array.size(); ++i) { if (array[i] == value) { return i; } } return std::nullopt; } int main() { std::vector&lt;int&gt; array {1, 2, 3, 4, 5}; std::optional&lt;size_t&gt; index {find(array, 3)}; if (index.has_value()) { std::cout &lt;&lt; &quot;3 se trouve à l'index &quot; &lt;&lt; index.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;3 ne se trouve pas dans le tableau&quot; &lt;&lt; std::endl; } } info Cela permet de ne pas avoir à utiliser des valeurs spéciales pour représenter l'absence de valeur comme par exemple -1 pour un index comme on retrouve souvent en C.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#résumé","content":" Les piles et les files sont des structures de données qui permettent de stocker des éléments de façon à ce que le dernier élément ajouté soit le premier à être retiré (LIFO) ou le premier élément ajouté soit le premier à être retiré (FIFO). On utilise les classes std::stack et std::queue pour les représenter dans la bibliothèque standard de C++. La classe std::pair (&lt;utility&gt;) permet de représenter une paire d'éléments de types différents. C'est une classe qui est utilisée par d'autres conteneurs de la bibliothèque standard comme std::map. La classe std::tuple (&lt;tuple&gt;) permet de représenter un ensemble de données hétérogènes. std::optional La classe std::optional (&lt;optional&gt;) permet de stocker un élément optionnel. C'est utile pour éviter d'avoir recours à des valeurs spéciales pour représenter l'absence de valeur. std::variant La classe std::variant (&lt;variant&gt;) permet de stocker un élément parmi un ensemble d'éléments possibles. C'est comparable aux enums, mais permet de stocker des types différents. ","version":"Next","tagName":"h2"},{"title":"Compression et encodage de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression","content":"","keywords":"","version":"Next"},{"title":"Compression de données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression-de-données","content":" La compression de données est une technique qui permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.  C'est un domaine crucial en informatique moderne. Sans la compression de données, il serait impossible de stocker des milliers de photos sur un téléphone portable, ou de regarder des vidéos en streaming sur Internet.  Il existe deux types de compression de données : la compression avec perte et la compression sans perte. La compression avec perte permet de réduire la taille des données, mais on ne garantit pas que les données décompressées seront identiques aux données d'origine. C'est le cas par exemple de la compression d'images au format JPEG où la perte de qualité est relativement maîtrisée pour cela soit le moins perceptible par l'œil humain. La compression sans perte permet de retrouver les données d'origine après les avoir décompressées. C'est le cas par exemple de la compression d'images au format PNG.  note concernant le format JPEG Le format JPEG est un format de compression avec perte.Le processus de compression JPEG est assez complexe et est composé de plusieurs étapes. Certaines de ces étapes sont des étapes de compression avec perte, et d'autres sont des étapes de compression sans perte (dont l'encodage RLE et l'encodage de Huffman que nous allons voir dans ce cours). C'est pour cela que l'on dit que le format JPEG est un format de compression avec perte.  ","version":"Next","tagName":"h2"},{"title":"Prérequis​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#prérequis","content":" Pour ce cours, il est nécessaire de connaître quelques notions de base sur la représentation des données en informatique. Voici un résumé des notions à connaître :  Un bit est la plus petite unité de stockage en informatique. Il ne peut prendre que deux valeurs : 0 ou 1. Un octet est un groupe de 8 bits. Il peut donc prendre 256 valeurs différentes (de 0 à 255). Chaque donnée peut être représentée par une suite de bits. Par exemple, le nombre 42 peut être représenté en binaire par la suite de bits 101010. Avec un octet, on peut représenter au maximum 256 nombres différents. Un caractère est généralement codé sur un octet (cela peut dépendre de l'encodage utilisé). Cela signifie que l'on peut représenter 256 caractères différents. Cela inclut les lettres de l'alphabet, les chiffres, les caractères spéciaux, etc.  ","version":"Next","tagName":"h2"},{"title":"Encodage et représentation des données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#encodage-et-représentation-des-données","content":" Un encodage est une manière de représenter les données. Par exemple, on peut représenter le nombre 42 de la manière suivante : 101010. C'est un encodage binaire. On peut aussi représenter le nombre 42 de la manière suivante : 2A. C'est un encodage hexadécimal.  Encoder des données revient à associer à chaque donnée un code.  Dans la suite de ce cours nous allons nous intéresser à l'encodage binaire. C'est l'encodage utilisé par les ordinateurs et qui permet de représenter les données de manière la plus compacte possible. C'est aussi l'encodage utilisé par les algorithmes de compression.    Dans un fichier texte, chaque lettre est représentée par un caractère. Ce caractère est généralement encodé sur un octet. Cela signifie que l'on peut représenter au maximum 256 caractères différents. Cela inclut les lettres de l'alphabet, les chiffres, les caractères spéciaux, etc.  Mais cela dépend des données du problème. Cet encodage sur un octet est simplement une convention qui permet d'associer à chaque caractère un code unique et d'uniformiser la manière dont les caractères sont représentés (chaque caractère est représenté par un octet). C'est bien pratique et flexible pour communiquer des fichiers texte entre ordinateurs.  ","version":"Next","tagName":"h2"},{"title":"Compression​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression","content":" Mais généralement lorsqu'il s'agit de compresser des données, les données du problème sont plus simples. Par exemple on pourrait se limiter aux lettres de l'alphabet. Dans ce cas, avoir un octet pour représenter chaque lettre est une perte d'espace. En effet, on pourrait se contenter de 5 bits pour représenter les 26 lettres de l'alphabet. Cela permettrait de réduire la taille du texte de 37.5% !  info Plus généralement, si on se limite à n possibilités de données et que l'on souhaite utiliser un encodage avec le même nombre de bits pour chaque donnée, il faut ⌈log⁡2(n)⌉\\lceil \\log_2(n) \\rceil⌈log2​(n)⌉ bits pour représenter chaque donnée. Par exemple, si on se limite aux 26 lettres de l'alphabet, il faut ⌈log⁡2(26)⌉=⌈4.7⌉=5\\lceil \\log_2(26) \\rceil = \\lceil 4.7 \\rceil = 5⌈log2​(26)⌉=⌈4.7⌉=5 bits pour représenter chaque lettre.  De plus pour n'importe quelle façon d'encoder les données, il faut respecter deux règles pour que l'encodage puisse être décodé :  Chaque donnée doit être associée à un code uniqueIl ne doit pas y avoir d'ambiguïté lors du décodage des données. Cela signifie qu'il ne faut pas associer à une donnée le code 01 et à une autre donnée le code 011 sinon impossible de savoir si l'on doit décoder les deux premiers bits 01 ou si cela faisait en fait partie du code 011. Un tel codage sans ambiguïté est appelé préfixe, nous y reviendrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"Codage par plages (Run-Length Encoding)​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-par-plages-run-length-encoding","content":" Le codage par plages est une technique de compression sans perte. Cela signifie que l'on peut retrouver les données d'origine après les avoir décompressées. Elle est très utilisée pour compresser des images, comme par exemple les images au format BMP ou JPEG.  Le principe du codage par plages est de tenir compte de la répétition des données. Admettons que l'on ait un texte de 8 caractères, composé uniquement de la lettre a : aaaaaaaa. Si l'on veut stocker ce texte sur un support de stockage, il faudra donc 8 octets pour le stocker (1 octet par caractère).  Mais si l'on tient compte du fait que le texte est composé uniquement de la lettre a, on peut le représenter de la manière suivante : 8a.  On peut donc stocker ce texte sur un support de stockage en utilisant seulement 2 octets. Cela permet de réduire la taille du texte de 75% !  C'est le principe du codage par plages : on remplace une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère. Par exemple, le texte suivant aaaabbbcddddd peut être représenté par 4a3b1c5d. Pour un gain de 13-8=5 octets, soit 38% de gain.  ⚠️ Quand il y a peu de répétitions cependant le codage par plages peut augmenter la taille des données. Par exemple, si on applique le codage par plage sur le texte suivant abcdefgh on obtient 1a1b1c1d1e1f1g1h. Cela prend plus de place que la chaîne d'origine ! Dans ce cas de figure, pour minimiser cet effet, on choisit plutôt d'ajouter un caractère de contrôle et un nombre n pour indiquer que les n prochains caractères ne sont pas compressés. Par exemple, on pourrait utiliser le caractère * comme caractère de contrôle et la chaîne abcdefgh serait compressée en *8abcdefgh.  ","version":"Next","tagName":"h2"},{"title":"En pratique​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#en-pratique","content":" L'encodage RLE peut être exprimé de multiples façons en pratique pour tenir compte des propriétés des données ainsi que d'algorithmes de compression supplémentaires. Cela permet de compresser les données seulement lorsque cela est nécessaire et de laisser la chaîne telle quelle lorsque la compression induit un gaspillage.  Par exemple on pourrait se donner les règles suivantes :  Lorsque trois éléments ou plus se répètent consécutivement alors la méthode de compression RLE est utilisée. On insère alors le nombre d'éléments répétés, suivi du caractère répété.Sinon un caractère de contrôle (*) est inséré, suivi du nombre d'éléments de la chaîne non compressée puis de cette dernière.  Ainsi la chaîne aaaabccdeeeeefgh serait compressée en 4a*4bccd5e*3fgh et la chaîne abcdefgh serait compressée en *8abcdefgh.  On pourrait aussi plutôt se dire que l'on utilise le caractère de contrôle pour indiquer que la chaîne est compressée. Dans ce cas, la chaîne aaaabccdeeeeefgh serait compressée en *4abccd*5efgh.  Enfin on pourrait aussi se dire que l'on utilise le caractère lui même comme caractère de contrôle. de sorte que chaque fois qu'un caractère apparaît deux fois, il indique une longueur d'exécution. Dans l'exemple précédent, cela donnerait pour la chaîne aaaabccdeeeeefgh l'encodage aa4bcc1dee5fgh.  ","version":"Next","tagName":"h3"},{"title":"Dans les images​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#dans-les-images","content":" Dans les images il est courant de trouver des zones de couleurs uniformes. Par exemple, une image de ciel bleu peut être représentée par une suite de pixels bleus. Dans ce cas, le codage par plages permet de réduire considérablement la taille de l'image.  Il existe donc des variantes pour parcourir les pixels d'une image dans un certain sens pour maximiser les zones de couleurs uniformes (ou de valeurs identiques). Par exemple, on peut parcourir les pixels de gauche à droite, de haut en bas ou même encore en zigzag.  ","version":"Next","tagName":"h3"},{"title":"Codage de Huffman​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-de-huffman","content":" Le codage de Huffman est aussi une technique de compression sans perte. C'est une technique très utilisée pour compresser des fichiers, comme par exemple des fichiers texte. Cette technique est utilisée par de nombreux formats de fichiers, comme par exemple le format JPEG pour les images.  Par exemple, si on se limite aux quatre lettres a, b, c et d (on a donc besoin seulement de 2 bits pour coder chaque lettre ). Voilà un encodage possible :  a est codé sur 00b est codé sur 01c est codé sur 10d est codé sur 11  Le texte abbacada peut donc être représenté par 0001010010001100. C'est déjà mieux que l'encodage ASCII, qui utilise 8 bits pour coder chaque lettre. On se limite à des données particulières, et on utilise un encodage plus compact.  Mais on peut faire mieux !  ","version":"Next","tagName":"h2"},{"title":"Fréquence d'apparition des données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#fréquence-dapparition-des-données","content":" Le principe du codage de Huffman est de tenir compte de la fréquence d'apparition des données.  Pour un texte composé de 100 caractères (toujours avec notre alphabet de 4 lettres) il faudra donc 200 bits pour le représenter.  Dans le cas de notre exemple précédent abbacada, on peut remarquer que la lettre a apparaît 4 fois, la lettre b apparaît 2 fois et les lettres c et d apparaissent 1 fois. On peut donc se demander si l'on ne pourrait pas utiliser un encodage différent pour chaque lettre, en tenant compte de la fréquence d'apparition de chaque lettre. Cela permettrait de réduire la taille du texte.  On pourrait donc utiliser moins d'un octet pour coder les lettres les plus utilisées, et plus d'un octet pour coder les lettres les moins utilisées. Cela permettrait de réduire la taille du texte.  Admettons que l'on code les lettres de la manière suivante :  a est codé sur 0b est codé sur 10c est codé sur 110d est codé sur 111  remarque J'ai fait attention à ce que chaque code soit préfixe. Cela signifie qu'il n'y a pas de code qui est préfixe d'un autre code. Cela permet de décoder les données sans ambiguïté.  Le texte abbacada peut donc être représenté par 01010011001110 (soit 14 bits). C'est mieux que l'encodage précédent, qui utilisait 16 bits.  Mais comment faire pour trouver le meilleur encodage possible ?  ","version":"Next","tagName":"h3"},{"title":"Arbre binaire​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#arbre-binaire","content":" Dans la suite de ce cours, nous allons utiliser un arbre binaire (strict) pour trouver l'encodage de Huffman (en fonction de la fréquence d'apparition des données). Mais j'aimerais d'abord vous expliquer pourquoi on utilise un arbre binaire.  remarque Dans un arbre binaire strict (ou localement complet), chaque nœud a soit 0, soit 2 fils. C'est donc soit un nœud interne (qui a deux fils), soit une feuille (qui n'a pas de fils).  Une propriété intéressante des arbres binaires est que pour chaque feuille il existe un chemin unique de la racine à la feuille. Ce chemin va permettre d'associer un code à chaque donnée. En plus d'être unique, ce chemin est aussi préfixe. Cela signifie que l'on ne peut pas avoir un chemin qui est préfixe d'un autre chemin.  Reprenons notre exemple précédent avec les lettres a, b, c et d. Admettons que les quatre lettres apparaissent avec la même fréquence.    Chaque feuille de l'arbre va permettre de représenter une donnée, ici une lettre.  Dans cet arbre, si l'on parcourt le chemin 0-0 (successivement le fils gauche puis le fils gauche), on arrive à la lettre a. De même pour les autres feuillets. On peut donc associer à chaque lettre un code unique :  a est codé sur 00b est codé sur 01c est codé sur 10d est codé sur 11  On retrouve bien l'encodage que l'on avait utilisé précédemment dans le cas de données équiprobables.  ","version":"Next","tagName":"h3"},{"title":"Algorithme​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#algorithme","content":" Revenons maintenant à notre cas avec des données non équiprobables. Admettons que l'on ait le texte suivant : abbacada. On peut calculer la fréquence d'apparition de chaque lettre :  Lettre\tFréquencea\t4/8=0.54/8 = 0.54/8=0.5 b\t2/8=0.252/8 = 0.252/8=0.25 c\t1/8=0.1251/8 = 0.1251/8=0.125 d\t1/8=0.1251/8 = 0.1251/8=0.125  On peut remarquer qu'en utilisant une représentation en arbre binaire complet, les lettres les moins fréquentes seront codées sur des codes plus gros (chemins les plus longs dans l'arbre) et donc sur les feuilles les plus basses de l'arbre. Les lettres les plus fréquentes seront codées sur des codes plus petits (chemins les plus courts dans l'arbre) et donc sur les feuilles les plus hautes de l'arbre.    C'est donc en suivant cette logique que l'on va construire l'arbre binaire. On va commencer par construire un arbre binaire avec les lettres les moins fréquentes.  On va donc commencer par construire un arbre binaire avec les lettres c et d. On va donc créer un nœud cd qui va avoir deux fils c et d. On va associer à chaque nœud la somme des fréquences de ses fils. On va donc associer à cd la fréquence 0.125 + 0.125 = 0.25.  On va considérer maintenant que cd est un substitut aux lettres c et d et représente donc une seule donnée avec un fréquence de 0.25.  Je vais appeler ce regroupement de données un symbole. Un symbole est donc une donnée qui peut être composée de plusieurs données. Par exemple, le symbole cd est composé des données c et d.  On va donc construire un arbre binaire avec les lettres b et cd (qui sont les deux symboles les moins fréquents parmi a, b et cd). On va donc créer un nœud bcd qui va avoir deux fils b et cd.  En répétant cette opération, on va finir par n'avoir plus que deux symboles : a et bcd. Cela va conduire à créer l'arbre final qui contient tous les lettres initiales.  Cela nous donne finalement l'arbre suivant:    Ce qui peut se traduire par l'encodage suivant :  a: 0b: 10c: 110d: 111  On retrouve bien l'encodage que j'avais proposé précédemment.  Mathématiquement, on peut démontrer que l'encodage de Huffman est optimal. Cela signifie que l'encodage de Huffman permet de compresser les données de manière optimale.  remarque En pratique, pour pouvoir décoder les données, il faut stocker l'arbre binaire quelque part. Cela peut être fait de différentes manières. Par exemple, on peut stocker l'arbre binaire dans le fichier compressé. Cela ajoute un peu de poids au fichier compressé, mais cela permet de décoder les données ce qui est tout de même pratique 😃.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#résumé","content":" La compression de données permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.Il existe deux types de compression de données : la compression avec perte et la compression sans perte.L'encodage est le fait d'associer à chaque donnée un code.Le codage par plages (RLE) est une technique de compression sans perte et consiste à remplacer une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère.Le codage de Huffman est une technique de compression sans perte et consiste à tenir compte de la fréquence d'apparition des données. Chaque donnée est associée à un code unique et préfixe. L'encodage de Huffman est optimal. On peut construire l'encodage de Huffman en utilisant un arbre binaire complet.Un code préfixe est un code dans lequel aucun code n'est préfixe d'un autre code. Cela permet de décoder les données sans ambiguïté.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#sources","content":" Super vidéo sur la théorie de l'information et l'encodage de Huffman : https://www.youtube.com/watch?v=B3y0RsVCyrw ","version":"Next","tagName":"h2"},{"title":"Hash et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Hachage​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#hachage","content":" En informatique, le hachage est une technique qui consiste à associer à une donnée une empreinte numérique, appelée hash qui permet d'identifier rapidement et efficacement cette donnée.  On nomme fonction de hachage une fonction qui prend en entrée une donnée et qui retourne le hash de cette donnée.  La fonction de hachage doit être déterministe, c'est-à-dire que pour une donnée donnée, elle doit toujours retourner le même hash. Idéalement, la fonction de hachage doit être aussi:  Rapide à calculerDonner des résultats différents pour des données différentes (résistance aux collisions)Donner des résultats différents pour des données similaires (résistance aux attaques par force brute)  En pratique, il est compliqué de trouver une fonction de hachage qui vérifie toutes ces propriétés. On essaye donc de trouver une fonction de hachage qui vérifie au mieux ces propriétés et notamment la résistance aux collisions. Cela permet d'éviter que deux données différentes aient le même hash.  Cela dépend aussi de l'application. Par exemple, pour une application qui stocke des mots de passe, il est important que la fonction de hachage soit résistante aux collisions et aux attaques par force brute. Cela permet d'éviter que deux mots de passe différents aient le même hash, ce qui permettrait à un attaquant de trouver un mot de passe valide sans avoir à le deviner par exemple.  Il existe de nombreux algorithmes et fonctions de hachage complexes pour des applications réelles. Vous trouverez par exemple l'algorithme MD5 (considéré comme obsolète) ou la famille de fonctions SHA-2 et notamment SHA-256 qui est réputée pour être résistante aux collisions et aux attaques par force brute et beaucoup utilisée aujourd’hui.  ","version":"Next","tagName":"h2"},{"title":"Table de hachage​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#table-de-hachage","content":" Dans notre exemple, on a associé à chaque nom de jour de la semaine un indice, une valeur numérique entière, qui permet de l'identifier (dans l'idéal de manière unique).  Ensuite on a utilisé cet indice comme indice dans un tableau pour récupérer une information associée à ce nom de jour de la semaine: le numéro de jour de la semaine.  C'est ce que l'on appelle une table de hachage.  Une table de hachage est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant un hash de la clé comme indice dans un tableau.  Une façon de gérer les collisions est d'utiliser une liste pour stocker les valeurs associées aux clés qui ont le même hash. Une fois que l'on a calculé le hash de la clé, on utilise ce hash comme indice dans un tableau pour trouver la liste des valeurs associées. S'il y a plusieurs valeurs associées à la clé, on peut parcourir la liste pour trouver la valeur qui correspond à la clé en comparant les clés.    ","version":"Next","tagName":"h2"},{"title":"Tableau associatif​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#tableau-associatif","content":" La structure de données que l'on vient de décrire est ce que l'on appelle un tableau associatif.  Un tableau associatif est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant la clé.  ","version":"Next","tagName":"h2"},{"title":"std::unordered_map​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdunordered_map","content":" La bibliothèque standard de C++ fournit une implémentation de tableau associatif utilisant une table de hachage: la classe std::unordered_map( définie dans la bibliothèque &lt;unordered_map&gt;).  Implicitement, cette classe utilise la fonction de hachage std::hash pour calculer le hash des clés. Cette fonction de hachage est définie pour les types de base et les types de la bibliothèque standard (comme std::string par exemple).  Elle utilise aussi la fonction std::equal_to pour comparer les clés dans le cas des collisions. Cette fonction est aussi définie pour les types de base et les types de la bibliothèque standard.  On utilise la méthode insert pour ajouter une valeur associée à une clé et la méthode find pour retrouver la valeur associée à une clé. Je vous invite à relire le cours précédent sur les itérateurs pour comprendre comment utiliser ces méthodes.  #include &lt;unordered_map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::unordered_map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5}, {&quot;dimanche&quot;, 6} }; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber { days.find(dayName) }; if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour numéro &quot; &lt;&lt; (*dayNumber).second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info Il est possible de définir une fonction de hachage personnalisée pour la classe std::unordered_map afin de pouvoir utiliser des types personnalisés comme des structures ou des classes comme clés. Mais cela dépasse le cadre de ce cours. Si c'est quelque chose qui vous intéresse, n'hésitez pas à faire des recherches ou à me contacter.  ","version":"Next","tagName":"h3"},{"title":"std::map​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdmap","content":" Il existe une autre implémentation de tableau associatif dans la bibliothèque standard de C++: la classe std::map (définie dans la bibliothèque &lt;map&gt;).  Cette classe utilise un arbre binaire de recherche pour stocker les données. Cela permet de stocker les données dans un ordre défini par une relation d'ordre sur les clés.  Elle utilise une opération de comparaison pour stocker les données. Cette opération de comparaison est définie pour les types de base et les types de la bibliothèque standard (comme std::string par exemple).  Elle s'utilise de la même façon que std::unordered_map.  #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; // On peut ajouter des éléments à une std::map avec l’opérateur [] days[&quot;dimanche&quot;] = 6; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber = days.find(dayName); if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour numéro &quot; &lt;&lt; dayNumber-&gt;second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info La classe std::map utilise un arbre binaire de recherche pour stocker les associations clé-valeur sous la forme de paires (std::pair). On peut donc aussi utiliser la classe std::pair pour ajouter des éléments à une std::map. #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; days.insert(std::make_pair(&quot;dimanche&quot;, 6)); return 0; }   Cas d'utilisation avec les énumérations​  Les énumérations sont des types de données qui permettent de définir un ensemble de valeurs possibles pour une variable.  Mais il n'est pas simplement possible de convertir un élément d'une énumération en une chaîne de caractères.  Mais étant représentées par des entiers en mémoire, il est possible de les utiliser comme clés dans un tableau associatif pour y associer des chaînes de caractères.  C'est un cas d'utilisation très courant des tableaux associatifs et des énumérations.  #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; enum class Season { Spring, Summer, Autumn, Winter }; int main() { std::map&lt;Season, std::string&gt; season_to_string { {Season::Spring, &quot;Printemps&quot;}, {Season::Summer, &quot;Été&quot;}, {Season::Autumn, &quot;Automne&quot;}, {Season::Winter, &quot;Hiver&quot;} }; Season currentSeason {Season::Spring}; std::cout &lt;&lt; &quot;La saison actuelle est &quot; &lt;&lt; season_to_string[currentSeason] &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::set — Un ensemble d'éléments uniques​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdset--un-ensemble-déléments-uniques","content":" Une autre structure de données fournie par la bibliothèque standard de C++ est la classe std::set (définie dans la bibliothèque &lt;set&gt;).  Elle permet de représenter un ensemble d'éléments uniques.  Cette classe est similaire à std::map mais elle ne stocke pas de valeurs associées aux clés. Elle ne stocke que les clés. Cela permet de stocker des ensembles d'éléments uniques.  Elle s'utilise de la même façon que std::map.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#résumé","content":" Une fonction de hachage est une fonction qui prend en entrée une donnée et qui retourne le hash de cette donnée (un nombre entier)Une table de hachage est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant un hash de la clé comme indice dans un tableau.Une table de hachageUn tableau associatif est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant la clé.La bibliothèque standard de C++ fournit deux implémentations de tableau associatif: std::unordered_map qui utilise une table de hachagestd::map qui utilise un arbre binaire de recherche La bibliothèque standard de C++ fournit aussi une implémentation d'ensemble d'éléments uniques: std::set. ","version":"Next","tagName":"h2"},{"title":"Graphes","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/graphs","content":"","keywords":"","version":"Next"},{"title":"Quelques définitions​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#quelques-définitions","content":" Un graphe est un ensemble de sommets reliés par des arêtes. On peut représenter un graphe par un ensemble de points reliés par des traits. Les points sont les sommets et les traits sont les arêtes.    Un graphe est dit orienté si les arêtes ont un sens. Dans ce cas, on parle d'arc. Un graphe est dit non orienté si les arêtes n'ont pas de sens.    Un graphe est dit pondéré si les arêtes ont un poids. Dans ce cas, on parle de poids d'une arête. Un graphe est dit non pondéré si les arêtes n'ont pas de poids.    Un graphe est dit connexe si tous les sommets sont reliés entre eux par une arête ou une suite d'arêtes.    graphe orienté connexe Pour un graphe orienté il y a plusieurs notions plus précises de connexité: Connexité forte: un graphe orienté est dit fortement connexe si pour chaque paire de sommets uuu et vvv, il existe un chemin de uuu à vvv et un chemin de vvv à uuu.Connexité unilatérale: un graphe orienté est dit unilatéralement connexe si pour chaque paire de sommets uuu et vvv, il existe un chemin de uuu à vvv ou un chemin de vvv à uuu.Connexité faible: un graphe orienté est dit faiblement connexe si le graphe sous-jacent non orienté est connexe.  Un graphe est dit cyclique si il contient au moins un cycle. Un cycle est une suite d'arêtes qui permet de revenir au point de départ.    ","version":"Next","tagName":"h2"},{"title":"Les arbres​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#les-arbres","content":" On a précédemment vu les arbres binaires. Un arbre n'est rien d'autre qu'un graphe particulier. Un arbre est un graphe non orienté, non pondéré, connexe et acyclique.  ","version":"Next","tagName":"h3"},{"title":"Représentation d'un graphe​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#représentation-dun-graphe","content":" Il existe plusieurs manières de représenter un graphe en mémoire. Nous allons voir les deux plus courantes.  ","version":"Next","tagName":"h2"},{"title":"Matrice d'adjacence​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#matrice-dadjacence","content":" La première manière de représenter un graphe est d'utiliser une matrice d'adjacence. Une matrice d'adjacence est une matrice carrée dont les lignes et les colonnes représentent les sommets du graphe. Si le sommet iii est relié au sommet jjj, alors la case (i,j)(i,j)(i,j) de la matrice vaut 1. Sinon, elle vaut 0. Si le graphe est pondéré, la case (i,j)(i,j)(i,j) de la matrice vaut le poids de l'arête.  Voici un exemple de matrice d'adjacence pour un graphe non orienté et non pondéré :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t1\t0\t1\t1\t0 C\t1\t1\t0\t0\t1 D\t0\t1\t0\t0\t1 E\t0\t0\t1\t1\t0  Et le graphe correspondant :    Dans le cas d'un graphe orienté, la matrice n'est plus symétrique. Voici un exemple de matrice d'adjacence pour un graphe orienté et non pondéré :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t0\t0\t1\t1\t0 C\t0\t0\t0\t0\t1 D\t0\t0\t0\t0\t1 E\t0\t0\t0\t0\t0  Et le graphe correspondant :    ","version":"Next","tagName":"h3"},{"title":"Liste d'adjacence​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#liste-dadjacence","content":" La deuxième manière de représenter un graphe est d'utiliser une liste d'adjacence. Une liste d'adjacence est une liste de listes. Pour chaque sommet, on a une liste des sommets adjacents. Si le graphe est pondéré, on a une liste des sommets adjacents avec leur poids (avec une paire par exemple).  Voici un exemple de liste d'adjacence pour un graphe non orienté et non pondéré :  Sommet\tAdjacentsA\tB, C B\tA, C, D C\tA, B, E D\tB, E E\tC, D  En pratique, on utilise plutôt la liste d'adjacence pour représenter un graphe car la matrice d'adjacence peut être très coûteuse en mémoire. En effet, une matrice d'adjacence est une matrice carrée. Donc, si on a nnn sommets, on a n2n^2n2 cases. Même si le graphe possède peu d'arêtes, la matrice d'adjacence est quand même de taille n2n^2n2. Cela peut être légèrement optimisé dans le cas des graphes non orientés car la matrice est symétrique. On peut donc ne stocker que la moitié de la matrice. Mais cela reste quand même très coûteux en mémoire.  L'utilité de la matrice d'adjacence est qu'elle permet de savoir si deux sommets sont reliés en temps constant. Dans les cas où c'est acceptable de stocker une matrice d'adjacence, on peut donc utiliser cette propriété pour gagner du temps. Cela a aussi des applications en théorie des graphes pour analyser des graphes.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un graphe​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-dun-graphe","content":" Maintenant que nous avons vu comment représenter un graphe en mémoire, nous allons voir comment parcourir un graphe. Il existe principalement deux manières de parcourir un graphe : en largeur et en profondeur.  Donnons-nous le graphe suivant :    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-largeur","content":" Le parcours en largeur consiste à parcourir le graphe en partant d'un sommet et en visitant tous les sommets adjacents avant de passer aux sommets adjacents de ces sommets adjacents. On visite donc les sommets par niveau.  Pour parcourir un graphe en largeur, on utilise une file. On commence par ajouter le sommet de départ dans la file. Tant que la file n'est pas vide, on retire le premier élément de la file et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file. On recommence jusqu'à ce que la file soit vide.  Voici le déroulement du parcours en largeur au départ du nœud A pour le graphe précédent :  On commence par ajouter le sommet A dans la file.  File\tA  Comme la file n'est pas vide, on retire le premier élément (A) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc B et C dans la file.  File\tC\tB  On retire le premier élément (B) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc D et E dans la file.  File\tE\tD\tC  On retire le premier élément (C) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc F et G dans la file.  File\tG\tF\tE\tD  On retire le premier élément (D) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc rien dans la file.  File\tG\tF\tE  On fait de même pour E, F et G. La file est maintenant vide. On a donc parcouru tous les sommets du graphe.  Cela nous donne donc le parcours suivant : A, B, C, D, E, F, G.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-profondeur","content":" Le parcours en profondeur consiste à parcourir le graphe en partant d'un sommet et en visitant ses sommets adjacents puis les sommets adjacents de ces sommets adjacents, etc. On visite donc les sommets en profondeur. On peut voir le parcours en profondeur comme une descente dans le graphe.  Pour parcourir un graphe en profondeur, on utilise une pile. On commence par ajouter le sommet de départ dans la pile. Tant que la pile n'est pas vide, on retire le premier élément de la pile et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la pile. On recommence jusqu'à ce que la pile soit vide.  Voici le déroulement du parcours en profondeur au départ du nœud A pour le graphe précédent :  On commence par ajouter le sommet A dans la pile.  Pile\tA  Comme la pile n'est pas vide, on retire le premier élément (A) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile (B et C).  Pile\tB\tC  On retire le premier élément (C) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc F et G dans la pile.  Pile\tB\tF\tG  On retire le premier élément (G) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile.  Pile\tB\tF  On retire le premier élément (F) de la pile, il n'a pas de sommets adjacents. On ajoute donc rien dans la pile.  Pile\tB  On recommence avec B. On ajoute D et E dans la pile.  Pile\tD\tE  On fait de même pour E et D. La pile est maintenant vide. On a donc parcouru tous les sommets du graphe.  Ce qui nous donne le parcours suivant : A, C, G, F, B, E, D.  ","version":"Next","tagName":"h3"},{"title":"En pratique​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#en-pratique","content":" Maintenant que nous avons vu ce qu'est un graphe il est légitime de se demander à quoi cela peut bien servir. En effet, on peut se demander si on a déjà rencontré des graphes dans la vie de tous les jours. La réponse est oui. Les graphes sont utilisés dans de nombreux domaines. En voici quelques exemples :  Les réseaux sociaux : les graphes sont utilisés pour modéliser les relations entre les utilisateurs.Les jeux vidéos : les graphes sont utilisés pour modéliser les niveaux, les cartes ou encore pour de la recherche de chemin (intelligence artificielle des ennemis par exemple).Les bases de données : les graphes sont utilisés pour modéliser les relations entre les données.Les problèmes de transport : les graphes sont utilisés pour modéliser les réseaux de transport (routes, métro, etc.) et permettent de résoudre des problèmes d'optimisation (par exemple, trouver le plus court chemin entre deux villes).Des algorithmes de programmation dynamique : les graphes sont beaucoup utilisés dans les algorithmes dis de programmation dynamique où le problème est si complexe qu'il est nécessaire de le décomposer en sous-problèmes, de faire des estimations et d'explorer les solutions possibles à travers un graphe de solutions.  ","version":"Next","tagName":"h2"},{"title":"Dijkstra​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#dijkstra","content":" Je vous propose de voir un exemple d'algorithme de graphe : l'algorithme de Dijkstra. Cet algorithme permet de trouver le plus court chemin entre deux sommets d'un graphe pondéré. Il est très répandu et est utilisé dans de nombreux domaines.  L'algorithme de Dijkstra est simplement une application du parcours en largeur. On part d'un sommet de départ et on visite tous les sommets adjacents. On ajoute ensuite les sommets adjacents de ces sommets adjacents dans la file. On recommence jusqu'à ce qu'on ait trouvé le sommet d'arrivée. On peut alors remonter le chemin en partant du sommet d'arrivée et en remontant les sommets précédents jusqu'au sommet de départ.  Pour l'illustrer on peut prendre une liste de même taille que le nombre de sommets du graphe pour représenter les distances. On initialise toutes les distances à l'infini sauf la distance du sommet de départ qui est à 0. On utilise également une file pour stocker les sommets à visiter et une liste pour stocker les sommets déjà visités. On commence par ajouter le sommet de départ dans la file des sommets à visiter. Tant que la file n'est pas vide, on retire le premier élément de la file et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file s'ils n'ont pas déjà été visités. Pour chaque sommet adjacent, on met à jour sa distance si la distance actuelle est plus grande que la distance du sommet actuel plus le poids de l'arête entre le sommet actuel et le sommet adjacent. On recommence jusqu'à ce que la file soit vide.  astuce Dans la pratique: On utilise une file de priorité std::priority_queue pour stocker les sommets à visiter. Cela permet de retirer le sommet avec la plus petite distance facilement et de manière efficace. On utilise un tableau associatif pour stocker les distances. Cela permet de ne pas avoir à créer une liste de taille fixe de tout les nœuds avec une distance infinie initialement. On peut simplement ajouter les distances au fur et à mesure que l'on parcourt le graphe et cela permet au passage de savoir quels nœuds ont déjà été visités sans avoir de liste de nœuds visités supplémentaire. De plus, généralement, cet algorithme est utilisé pour trouver le plus court chemin entre deux sommets. On peut donc s'arrêter dès qu'on a trouvé le sommet d'arrivée.  attention L'algorithme de Dijkstra ne fonctionne que pour les graphes pondérés positivement. En effet, si le graphe contient des arêtes de poids négatif, l'algorithme peut boucler indéfiniment. Pour éviter ces problèmes,il est aussi possible d'utiliser une variante: l'algorithme de Bellman-Ford qui est plus lent mais qui fonctionne pour les graphes avec des cycles et des arêtes de poids négatif.  Pour illustrer l'algorithme de Dijkstra, donnons-nous le graphe suivant :    L'idée de l'algorithme est de partir d'un sommet de départ que l'on ajoute à un ensemble de sommets à visiter (on va également noter la distance depuis le sommet de départ pour aller jusqu'à ce sommet (ce qui va permettre de prioriser les sommets à visiter)).  On va se servir d'un tableau associatif pour associer à chaque sommet visité la distance la plus courte connue pour aller du sommet de départ à ce sommet et d'où on vient pour atteindre cette distance (ce qui permet de reconstruire le chemin le plus court à la fin). Cela permet au passage de marquer les sommets comme visités sans avoir de liste ou structure de données supplémentaire.  Ensuite on va itérer sur les sommets à visiter en choisissant à chaque fois le sommet le plus proche du sommet de départ. Pour cela, on va se servi d'une file de priorité std::priority_queue qui va nous permettre de choisir le sommet le plus proche à chaque itération.  Si le sommet choisi n'a pas encore été visité, on va le marquer comme visité (mettre à jour le tableau associatif) et on va ajouter à la liste des sommets à visiter tous les sommets voisins de ce sommet.  Si le sommet choisi a déjà été visité, on va regarder si la distance la plus courte connue pour aller à ce sommet (la valeur dans le tableau associatif) est plus grande en passant par le sommet choisi. Si c'est le cas, on va mettre à jour la distance la plus courte et le sommet d'où on vient pour atteindre cette distance et on va de nouveau ajouter le sommet à la liste des sommets à visiter car l'on a trouvé un chemin plus court pour y arriver, on dois propager cette information.  ","version":"Next","tagName":"h2"},{"title":"Illustration de l'algorithme de Dijkstra​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#illustration-de-lalgorithme-de-dijkstra","content":" on considère que le sommet de départ est A et le sommet d'arrivée est E.  On ajoute le sommet A à la liste des sommets à visiter avec une distance de 0 (on est déjà sur le sommet de départ) et d'où on vient (on est déjà sur le sommet de départ).  Distances\tA visiter-\tA(0)  Il reste des éléments dans la liste à visiter on récupère le sommet qui a la plus petite distance (A) et on le retire de la liste à visiter. On parcours la liste des voisins de A (B et C), les deux ne sont pas déjà visités, on les ajoutes à la liste à visiter et au tableau associatif avec la distance en passant par A (0 + poids de l'arête) et d'où on vient (A).  Distances\tA visiterB(1, A), C(2, A)\tB(1), C(2)  Je récupère maintenant B qui est le sommet prioritaire dans la liste à visiter (plus petites distance).  Je parcours la liste des voisins de B (C et D). C est déjà présent dans le tableau associatif ce qui indique qu'il a déjà été visité ou marqué à visiter. Ici le poids actuellement dans le tableau des distances est égale au poids en passant par B (1 + 1) donc on ne fait rien les deux chemins sont aussi cours l'un que l'autre.  pour D on ajoute comme précédemment ce qui donne:  Distances\tA visiterB(1, A), C(2, A), D(6, B)\tC(2), D(6)  Je recommence de nouveau avec C qui est le sommet prioritaire dans la liste à visiter (plus petites distance).D a déjà été visité mais ici le coût en passant par C est plus faible (2+3&lt;62 + 3 &lt; 62+3&lt;6), je mets donc à jour la distance et je rajoute de nouveau D dans la liste à visiter:  Distances\tA visiterB(1, A), C(2, A), D(5, C)\tD(6), D(5)  remarque Ici il y a deux fois D dans la liste, ce n'est pas grave car avec la priorité on va de toute façon choisir le plus petit. Puis au moment de traiter une deuxième fois D on va voir que la distance est plus grande et on ne va rien faire.  Enfin on ajoute aussi E l'autre sommet adjacent à C:  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(8, C)\tD(6), D(5), E(8)  Je continue avec D :  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(7, D)\tD(6), E(8), E(7)  De nouveau avec D car il était en doublon dans la liste mais cela ne va avoir aucun effet car E est listé avec un poids donc plus faible.  Distances\tA visiterB(1, A), C(2, A), D(5, C), E(7, D)\tE(8), E(7)  Enfin on récupère E, il n'a pas d'arrêtes donc on ne fait rien, mais c'est le sommet de destination on a atteins notre destination, on peut s'arrêter et retourner le tableau associatif.  On peut s'amuser à retrouver la succession des arrêtes à parcours grâce au tableau associatif: A →\\rightarrow→ C →\\rightarrow→ D →\\rightarrow→ E.  remarque Vous pouvez trouver une autre façon de représenter l'algorithme avec une liste de distances pour tout les sommets (initialisée à l'infini) et une liste de sommets visités. Néanmoins, cette méthode est plus coûteuse en mémoire et moins proche de l'implémentation de l'algorithme de Dijkstra. C'est pour cela que j'ai choisi de vous présenter cette illustration (avec un tableau associatif (Distances) et une file de priorité (A visiter)).  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin: A*​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#pour-aller-plus-loin-a","content":" L'algorithme de Dijkstra peut être amélioré. En effet, il explore tous les sommets adjacents d'un sommet avant de passer au sommet suivant. Cela peut être très coûteux en temps si le graphe est très grand et / ou si le sommet de départ et le sommet d'arrivée sont très éloignés. L'algorithme de Dijkstra explore alors beaucoup de sommets inutilement.  L'algorithme A* est une amélioration de l'algorithme de Dijkstra. Il utilise une heuristique pour guider la recherche. L'heuristique est une fonction qui permet d'estimer la distance entre un sommet et le sommet d'arrivée. L'algorithme A* explore alors en priorité les sommets qui sont les plus proches(selon cette estimation) du sommet d'arrivée. Cela permet de réduire le nombre de sommets explorés et donc de gagner du temps.  Pour donner un exemple concret, on peut utiliser la distance euclidienne comme heuristique. La distance euclidienne est la distance à vol d'oiseau entre deux points. On peut l'utiliser pour guider la recherche dans un labyrinthe par exemple. On peut alors utiliser la distance euclidienne entre le sommet actuel et le sommet d'arrivée comme heuristique. Cela permet d'explorer en priorité les sommets qui sont les plus proches (à vol d'oiseau) du sommet d'arrivée.  ","version":"Next","tagName":"h3"},{"title":"Simplification 2D​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#simplification-2d","content":" La représentation en liste d'adjacence est très pratique pour représenter un graphe arbitraire. Cependant, dans certains cas, on peut utiliser une représentation plus simple. C'est le cas par exemple quand on cherche le plus court chemin entre deux points dans une grille. Dans ce cas les sommets sont les centres des cases de la grille et les arêtes sont les côtés des cases de la grille. Il n'est alors pas nécessaire de stocker la représentation complète du graphe car celle-ci est connue à l'avance. On peut donc utiliser une représentation plus simple.  Dans le cas où le coup de déplacement d'une case à une autre est le même pour toutes les cases, appliquer Dijkstra sur une grille devient alors très simple. Il suffit de parcourir la grille en largeur en partant du point de départ et en s'arrêtant quand on a trouvé le point d'arrivée. On peut alors remonter le chemin en partant du point d'arrivée et en remontant les points précédents jusqu'au point de départ (parfois aussi nommé Breadth First Search ou BFS).  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#résumé","content":" Un graphe est un ensemble de sommets reliés par des arêtes.Un graphe est dit orienté si les arêtes ont un sens. Dans ce cas, on parle d'arc.Un graphe est dit pondéré si les arêtes ont un poids.Un graphe est dit connexe si tous les sommets sont reliés entre eux par une arête ou une suite d'arêtes.Un arbre est un graphe(Un graphe non orienté, non pondéré, connexe et acyclique)Il existe deux manières de représenter un graphe en mémoire : la matrice d'adjacence et la liste d'adjacence.Il existe deux manières de parcourir un graphe : en largeur et en profondeur.L'algorithme de Dijkstra permet de trouver les distances les plus courtes entre un sommet de départ et tous les autres sommets d'un graphe pondéré positivement.L'algorithme A* est une amélioration de l'algorithme de Dijkstra qui utilise une heuristique pour guider la recherche.Dans le cas d'un graphe non pondéré, Dijkstra n'est rien d'autre qu'un parcours en largeur.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#sources","content":" Voilà quelques sources qui peuvent vous aider à approfondir le sujet et mieux comprendre les graphes et la recherche de chemin :  https://www.redblobgames.com/pathfinding/a-star/introduction.htmlhttps://www.youtube.com/watch?v=GazC3A4OQTEhttps://www.youtube.com/watch?v=i3_V90yUfcAhttps://www.youtube.com/watch?v=-L-WgKMFuhE ","version":"Next","tagName":"h2"},{"title":"TD4 - Tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (min & max)​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-1-min--max","content":" Des nains partent en expédition dans les montagnes. Ils transportent chacun une certaine quantité de provisions (exprimée en calories).  Votre mission est de déterminer la quantité de provisions la plus grande transportée par un nain.  Je vous donne le programme suivant qui génère la liste des calories transportées par chaque nain:  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; int main() { size_t const dwarf_count { 20 }; std::vector&lt;float&gt; calories {}; // std::srand permet de fixer la &quot;seed&quot; du générateur aléatoire (pour avoir des résultats reproductibles) std::srand(42); calories.reserve(dwarf_count); // Pour optimiser, on dit à l'avance au tableau combien d'éléments vont être ajoutés, afin qu'il puisse allouer la mémoire nécessaire en une seule fois. Si on ne fait pas ça, à chaque push_back dans la boucle le tableau va être obligé d'allouer de la mémoire supplémentaire pour contenir le nouvel élément, ce qui est plus lent. for (size_t i { 0 }; i &lt; dwarf_count; ++i) { // Génération d'un nombre aléatoire entre 100 et 24000 float const random_01 { static_cast&lt;float&gt;(rand()) / static_cast&lt;float&gt;(RAND_MAX) }; calories.push_back(100.f + (24000.f-100.f) * random_01); } // affichage optionnel des calories transportées par chaque nain for (float const c : calories) { std::cout &lt;&lt; c &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // TODO: afficher la quantité de provisions la plus grande transportée par un nain return 0; }   Trouver la quantité de provisions la plus grande transportée par un nain. Trouver la quantité de provisions la plus petite transportée par un nain (arrivez vous à le faire sans utiliser de boucle supplémentaire ?). Essayez de faire fonctionner le programme avec plus de nains, par exemple 200, 2000 ou même 20000 nains. (Attention, il ne faut pas afficher les calories transportées par chaque nain dans ce cas). Si vous avez eu besoin de changer autre chose que la variable dwarf_count pour répondre à la question précédente, essayez de trouver une solution qui fonctionne avec n'importe quel nombre de nains sans avoir à modifier le code. Pour aller plus loin: Trouver les trois nains transportant le plus de provisions et afficher la somme des provisions transportées par ces trois nains.  info Exercice inspiré de de l'édition 2022 de l'advent of code: https://adventofcode.com/2022/day/1C'est un évènement annuel qui propose un problème de code par jour sous forme de calendrier de l'avent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Palindrome)​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-2-palindrome","content":" Un palindrome est un mot qui peut être lu de la même manière de gauche à droite et de droite à gauche.  Par exemple, kayak est un palindrome.  Écrire un programme qui demande à l'utilisateur de saisir un mot et qui affiche si ce mot est un palindrome ou non.  astuce Une chaîne de caractères est un tableau de caractères.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Comptage)​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-3-comptage","content":" Écrire un programme qui demande un nombre entier positif (supérieur à 1 000 000) à l'utilisateur et qui remplit un tableau avec les chiffres de ce nombre. Le programme doit ensuite compter le nombre d'occurrences de chiffre et afficher le chiffre qui apparaît le plus souvent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Points d'énergie)​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-4-points-dénergie","content":" Dans un jeu vidéo de type RPG, dès que le joueur termine un niveau, il gagne des points d’énergie.  Les points d'énergie sont calculés en fonction du niveau terminé et du nombre et du niveau de difficulté des ennemis tués.  Le nombre de points d'énergie gagnés est calculé de la manière suivante:  Pour chaque ennemi tué, trouver tous les multiples de son niveau de difficulté inférieurs au niveau terminé par le joueur.Combiner tous les multiples trouvés pour chaque ennemi tué en supprimant les doublons.Additionnez tous les nombres restants pour obtenir le nombre de points d'énergie gagnés.  Voici un exemple:  Le joueur termine le niveau 20.Il tue 2 ennemis de niveau 3, 5.  Les multiples de 3 inférieurs à 20 sont: 3, 6, 9, 12, 15, 18. Les multiples de 5 inférieurs à 20 sont: 5, 10, 15.  En supprimant les doublons, nous obtenons: 3, 5, 6, 9, 10, 12, 15, 18.  En additionnant tous les nombres, nous obtenons 78 points d'énergie.  Vous devez écrire un programme qui demande à l'utilisateur de saisir le niveau terminé et le nombre et le niveau de difficulté des ennemis tués et qui affiche le nombre de points d'énergie gagnés.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Suppression et tassement)​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-5-suppression-et-tassement","content":" Écrire un programme qui demande à l'utilisateur de saisir 10 entiers compris entre 0 et 5 et qui les stocke dans un tableau. (vous pouvez aussi demander à l'utilisateur de saisir un nombre puis le décomposer en chiffres et stocker les chiffres dans un tableau).  Vous devez ensuite supprimer toutes les valeurs valant 3 dans le tableau en décalant tous les éléments vers la gauche et en complétant le tableau avec des 0.  Tableau avant:  [1, 3, 2, 3, 3, 4, 5, 3, 0, 2]   Tableau après:  [1, 2, 4, 5, 0, 2, 0, 0, 0, 0]   ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus​","type":1,"pageTitle":"TD4 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercices-bonus","content":" Algorithmes de Luhn Le numéro de carte bancaire est un nombre de 16 chiffres. Il est composé de 4 groupes de 4 chiffres séparés par un espace. Tous les numéros de carte bancaire ne sont pas valides et il existe des algorithmes pour le vérifier. Cela permet de vérifier rapidement si un numéro de carte bancaire est valide ou non sans avoir à contacter la banque et permet de détecter rapidement certaines erreurs de saisie (comme l'inversion de deux chiffres par exemple). L'algorithme de Luhn est l'un de ces algorithmes. Son principe est de calculer, à partir d'un nombre (ou une suite de chiffres), une clé de contrôle (appelée checksum) qui permet de vérifier que le numéro est correct (car la clé est un nombre qui est dépendant des autres et doit respecter certaines conditions). Dans notre cas, la clé de contrôle est calculée de la manière suivante: On multiplie un chiffre sur deux par 2 (en commençant par le deuxième chiffre).Si le résultat de la multiplication est supérieur à 9, on additionne les chiffres du résultat (par exemple, 8 * 2 = 16, 1 + 6 = 7).On additionne tous les chiffres (y compris ceux qui n'ont pas été multipliés par 2). Si le résultat (la clé de contrôle) est un multiple de 10, alors le numéro est valide. Un exemple Prenons le numéro de carte bancaire suivant: 1234 5678 9002 3456. On multiplie un chiffre sur deux par 2 (en commençant par le dernier chiffre): 1 2 3 4 5 6 7 8 9 0 0 2 3 4 5 6 x2 x2 x2 x2 x2 x2 x2 x2 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 On additionne les chiffres du résultat si le résultat est supérieur à 9: 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 On additionne tous les chiffres: 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 1 + 4 + 3 + 8 + 5 + 3 + 7 + 7 + 9 + 0 + 0 + 4 + 3 + 8 + 5 + 3 = 70 La clé de contrôle est 70. 70 est un multiple de 10, donc le numéro de carte bancaire est valide. Vous devez écrire un programme qui demande à l'utilisateur de saisir un numéro de carte bancaire et qui affiche si ce numéro est valide ou non. Pour la saisie, vous êtes libre de choisir le format ou syntaxe que vous voulez (via une chaîne de caractères, avec ou sans espaces, un nombre ou une boucle sur plusieurs chiffres). astuce Convertissez premièrement la chaîne de caractères en un tableau de chiffres.Pour convertir un caractère en un nombre, vous pouvez utiliser la fonction std::stoi (string to integer) ou la valeur ASCII du caractère. (voir l'Exercice 5 du TD2). ","version":"Next","tagName":"h2"},{"title":"Sémantique et opérateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Operators","content":"","keywords":"","version":"Next"},{"title":"Opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs","content":" Les opérateurs sont des symboles qui permettent de manipuler des données. Par exemple, l'opérateur + permet d'additionner deux nombres entre eux.  En C++, il est possible de définir des opérateurs pour nos structures, c'est ce que l'on appelle la surcharge d'opérateurs. Cela permet ensuite d'utiliser l'opérateur sur nos structures sans devoir passer par une méthode.  Pour définir un opérateur, on utilise le mot clé operator suivi du symbole de l'opérateur. Par exemple, pour définir l'opérateur +, on utilise operator+.  Par exemple, on peut définir un opérateur + pour notre structure Point qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet opérateur sur nos structures comme si elles étaient des nombres.  struct Point { int x; int y; }; Point operator+(Point const&amp; a, Point const&amp; b) { return {a.x + b.x, a.y + b.y}; } int main() { Point a {1, 2}; Point b {3, 4}; Point c {a + b}; // c = {4, 6} }   ","version":"Next","tagName":"h2"},{"title":"Égalité​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#égalité","content":" Ce qui fait généralement sens pour une structure, c'est de pouvoir comparer deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont égaux ou non.  Pour être en mesure de définir l’égalité, on doit respecter les conditions suivantes.  Pour n'importe quel a, a == a doit être vrai, c'est ce qu'on appelle la réflexivité.Pour n'importe quel a et b de même type, si a == b est vrai, alors b == a doit être vrai, c'est ce qu'on appelle la symétrie et la commutativité.Pour n'importe quel a, b et c de même type, si a == b et b == c sont vrais, alors a == c doit être vrai, c'est ce qu'on appelle la transitivité.  Pour définir l'opérateur d'égalité, on utilise operator==. On peut ensuite utiliser cet opérateur sur nos structures de la même façon que pour les types de base.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } int main() { Point a {1, 2}; Point b {1, 2}; if (a==b) { std::cout &lt;&lt; &quot;Les points a et b ont les mêmes coordonnées&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Les points a et b ont des coordonnées différentes&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h2"},{"title":"Fonction ou méthode​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#fonction-ou-méthode","content":" On peut définir l'opérateur d'égalité comme une fonction (en dehors de la définition de la structure) ou comme une méthode (à l'intérieur de la définition de la structure).  La différence est que dans le cas d'une méthode, le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode.  struct Point { int x; int y; bool operator==(Point const&amp; b) const { return x == b.x &amp;&amp; y == b.y; } };   Cela a une influence sur la façon dont on utilise l'opérateur.  remarque Ici la méthode est définie comme const car elle ne modifie pas l'instance sur laquelle on l'appelle. Cela permet d'appeler la méthode sur une instance constante.  Par exemple si l'on souhaite multiplier un point par un nombre, on peut définir l'opérateur comme une méthode.  struct Point { int x; int y; Point operator*(int const a) const { return {x * a, y * a}; } }; int main() { Point a {1, 2}; Point b {a * 2}; // b = {2, 4} }   Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas définir l'opérateur comme une méthode car le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode.  Il faut donc définir l'opérateur comme une fonction libre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} }   Les deux syntaxes sont donc valables, mais il faut garder en tête que la syntaxe avec une méthode implique que le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode. Il y a plusieurs écoles, en général on préfère la syntaxe avec une fonction libre concernant les opérateurs binaires (qui prennent deux paramètres). Cela permet par exemple, dans le cas d'opérateurs binaires commutatifs (dans lequel l'ordre des paramètres n'a pas d'importance), de définir les deux opérateurs en fonction l'un de l'autre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } Point operator*(Point const&amp; b, int const a) { return a * b; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} Point c {a * 3}; // b = {3, 6} }   ","version":"Next","tagName":"h3"},{"title":"Réutilisation des opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#réutilisation-des-opérateurs","content":" Je vous ai déjà parlé de l’intérêt de la réutilisation avec les fonctions. C'est aussi valable pour les opérateurs.  L’habitude que beaucoup prennent est de définir les opérateurs == et &lt;, puis de définir les autres en fonction de ces deux-là.  On va donc définir l'opérateur != en fonction de ==.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } bool operator!=(Point const&amp; a, Point const&amp; b) { return !(a == b); }   Dans notre cas définir les opérateurs de comparaison &lt;, &lt;=, &gt;, &gt;= fait moins sens car on ne peut pas vraiment dire qu'un point est plus grand qu'un autre.   ## default et C++ 20 Il est parfois possible de définir automatiquement certains opérateurs. Dans le cas de structures simples, on peut définir automatiquement les opérateurs `==` et `!=` avec le mot clé `default`. ```cpp struct Point { int x; int y; bool operator==(Point const&amp; p) const = default; bool operator!=(Point const&amp; p) const = default; };   Cela permet de définir automatiquement les opérateurs == et != en fonction des opérateurs == et != de chaque membre de la structure.  Depuis C++20, il est même possible de définir automatiquement l'opérateur d'égalité et les opérateurs de comparaison (&lt;, &lt;=, &gt;, &gt;=) d'un coup avec l'opérateur &lt;=&gt; (appelé three-way comparison operator).  struct Point { int x; int y; auto operator&lt;=&gt;(Point const&amp; p) const = default; };   L'opérateur &lt;=&gt; est un opérateur qui permet de donner un ordre à une structure. Avec le mot clé default, on délègue la définition de l'opérateur &lt;=&gt; à chaque membre de la structure. On défini donc automatiquement l'ordre de la structure en fonction de l'ordre de chaque membre (dans notre cas, on compare d'abord x puis y).  C'est très pratique dans le cas où nos structures sont composées de types de base ou de structures qui ont déjà des opérateurs de comparaison définis.  Dans le cadre de ce cours nous allons définir les opérateurs manuellement pour bien comprendre le principe. Mais dans la pratique, il est préférable d'utiliser default ou default avec &lt;=&gt; si possible.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'assignation composés​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-dassignation-composés","content":" Les opérateurs d'assignation composés permettent de combiner une opération et une assignation. Par exemple, l'opérateur += permet d'additionner une valeur à une variable et de stocker le résultat dans la variable.  Il est aussi possible de définir des opérateurs d'assignation composés pour nos structures. Par exemple, on peut définir l'opérateur += pour notre structure Point qui permet d'additionner un point à un autre point et de stocker le résultat dans le premier point.  Cela fait sens dans ce cas de les définir comme des méthodes.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; p) { x += p.x; y += p.y; return *this; } };   astuce L'expression *this peut sembler étrange. this est un pointeur sur l'instance courante. *this est donc une référence sur l'instance courante. On retourne une référence sur l'instance courante pour pouvoir faire des opérations en chaîne. Par exemple, on peut écrire a += b += c qui est équivalent à a += (b += c). Cela nous permet d’avoir le même comportement pour notre structure que s’il s’agissait d’un type natif comme int.  ","version":"Next","tagName":"h2"},{"title":"Deux en un​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#deux-en-un","content":" Pour chaque opérateur d'assignation composé, il existe un opérateur binaire (prenant deux paramètres) correspondant. Par exemple, l'opérateur += a pour opérateur binaire correspondant +.  Dans un souci de réutilisation, on peut définir l'opérateur binaire en fonction de l'opérateur d'assignation composé.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; b) { x += b.x; y += b.y; return *this; } }; Point operator+(Point a, Point const&amp; b) { a += b; return a; }   Ici le principe de passage par copie (ou par valeur) du paramètre a est important. Puisque qu'il est copié, on peut le modifier avec l’opérateur += sans risque modifier l'instance originale. On obtient donc l'opérateur binaire + en fonction de l'opérateur d'assignation composé +=.  L'avantage est que si l'on doit modifier ou corriger le comportement de l'addition, on n'a pas besoin de modifier l'opérateur binaire + puisqu'il est défini en fonction de l'opérateur d'assignation composé +=.  ","version":"Next","tagName":"h3"},{"title":"Opérateurs de flux​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-de-flux","content":" Les opérateurs de flux permettent de définir comment afficher une structure ou la lire depuis un flux (comme std::cout ou std::cin). Par exemple, on peut définir l'opérateur &lt;&lt; pour notre structure Point qui permet d'afficher un point dans un flux.  struct Point { int x; int y; }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; ')'; }   L'opérateur &lt;&lt; prend en premier paramètre un flux de sortie (std::ostream&amp;) et en deuxième paramètre un point (Point const&amp;). Il retourne le flux de sortie pour pouvoir faire des opérations en chaîne.   Opérateur &gt;&gt; Il existe aussi l'opérateur &gt;&gt; qui permet de lire depuis un flux pour construire une structure. Il se définit ainsi: std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Point&amp; p) { // gestion de la lecture is &gt;&gt; p.x &gt;&gt; p.y; if( /* Erreur, impossible de construire notre structure */ ) { is.setstate(std::ios::failbit); } return is; } Notez que dans ce cas il faut signaler si l’entrée est invalide en mettant le flux dans un état invalide avec std::ios::failbit, ce qui permet à l’utilisateur de faire if (std::cin.fail()).  Ces opérateurs s’écrivent toujours sous la forme libre car leur premier argument est toujours un flux.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'affectation par copie​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-daffectation-par-copie","content":" Parfois, on a besoin de copier une structure. Pas seulement à l'initialisation (dans ce cas là on peut utiliser la syntaxe d'initialisation {}), mais on a besoin d'affecter une nouvelle valeur à une structure déjà existante.  Point const point {3, 4}; Point copie {1, 1}; // ... copie = point;   Pour faire cela il faut définir l'opérateur d'affectation par copie =. Cet opérateur est appelé quand on affecte une valeur à une structure déjà existante.   struct Point { int x; int y; Point&amp; operator=(Point const&amp; b) { x = b.x; y = b.y; return *this; } };   C'est intéressant de le définir s'il a un comportement spécifique à notre structure. Sinon, il est préférable de ne pas le définir car il y a déjà un opérateur d'affectation par copie par défaut qui fait une copie membre à membre. Ce qui correspond souvent à ce que l'on veut (c'est le cas pour notre structure Point).  ","version":"Next","tagName":"h2"},{"title":"Quelques bonnes pratiques​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#quelques-bonnes-pratiques","content":" Il est important de garder en tête que la surcharge d'opérateurs est une facilité et non une nécessité. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Il est aussi important de respecter la sémantique des opérateurs. Par exemple, l'opérateur + doit faire une addition et non une soustraction. Si un opérateur a une sémantique déjà définie pour un domaine, tenez vous-y. Si la signification de l'opérateur n'est pas évidente et indiscutable, il faut éviter de le surcharger. Il est préférable de définir une méthode explicite dans les cas où la sémantique n'est pas évidente. Si pour une raison ou une autre, vous devez surcharger un opérateur qui n'a pas de sémantique évidente, il faut le commenter absolument. Enfin, certains opérateurs sont liés entre eux. Par exemple, si vous surchargez l'opérateur ==, il est conseillé de surcharger l'opérateur != (en fonction de == si possible). De même, si vous surchargez l'opérateur &lt;, les utilisateurs de votre structure s'attendront à ce que les opérateurs &gt;, &lt;= et &gt;= soient définis également.  ","version":"Next","tagName":"h2"},{"title":"D'autres opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#dautres-opérateurs","content":" On peut aussi surcharger les opérateurs [] et () pour définir un accès à un élément de notre structure ou les opérateurs -- et ++ pour définir un incrément ou un décrément.  Il existe de nombreux opérateurs que l'on peut surcharger mais le principe reste le même.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#résumé","content":" On peut définir des opérateurs pour nos structures, c'est ce que l'on appelle la surcharge d'opérateurs.Pour définir un opérateur, on utilise le mot clé operator suivi du symbole de l'opérateur. Par exemple, pour définir l'opérateur +, on utilise operator+.Les opérateurs permettent de donner du sens à nos structures et de les manipuler comme si elles étaient des types de base. Cela donne de la sémantique à nos structures.C'est intéressant de réutiliser les opérateurs entre eux. Par exemple, on peut définir l'opérateur + en fonction de l'opérateur +=.L'expression *this permet de retourner une référence sur l'instance courante pour pouvoir faire des opérations en chaîne.Il est important de garder en tête que la surcharge d'opérateurs est une facilité et non une nécessité. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est préférable de définir une méthode avec un nom explicite.On peut surcharger les opérateurs de flux &lt;&lt; et &gt;&gt; pour définir comment afficher une structure ou la lire depuis un flux.Vous trouverez la page de documentation sur la surcharge d'opérateurs ici. ","version":"Next","tagName":"h2"},{"title":"TD6 - Débogueur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/DebuggerAndErrors","content":"TD6 - Débogueur Ce TD a pour but de vous familiariser avec l'utilisation du débogueur en C++. Il n'y a pas d'exercices à proprement parler, je vous invite à tester les différentes fonctionnalités du débogueur sur des exercices des TDs précédents ou vous aider du débogueur pour corriger et rattraper des exercices des TDs précédents. Quelques suggestions d'exercices à déboguer: Fonction récursives: FibonacciVous pouvez observer le comportement de la fonction récursive de Fibonacci en mettant un point d'arrêt conditionnel sur la valeur de n et inspecter la pile d'appels. Conjecture de SyracuseVous pouvez observer le comportement de la conjecture de Syracuse si le nombre devient trop grand par exemple. Tableaux Vous pouvez vous servir des watch pour observer les valeurs des éléments d'un tableau comme dans l'exercice de comptage ou de suppression et tassement","keywords":"","version":"Next"},{"title":"TD8 - Headers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/headers","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Fraction)​","type":1,"pageTitle":"TD8 - Headers","url":"/Learn--cpp_programming/TDs/S1/headers#exercice-1-fraction","content":" Le but de cet exercice est de créer une structure permettant de représenter une fraction. Cette structure devra contenir deux entiers positifs, un pour le numérateur et un pour le dénominateur.  On va utiliser un fichier d'en-tête pour définir la structure et les fonctions qui vont permettre de manipuler les fractions.  Créer un fichier fraction.hpp qui contiendra la définition de la structure et les prototypes des méthodes. La structure devra s'appeler Fraction et contenir deux entiers positifs nommés numerator et denominator de type unsigned int avec comme valeur par défaut 0/1. La structure devra contenir une méthode display et qui permet d'afficher (std::cout) la fraction sous la forme numerator/denominator. Vous devrez également définir les prototypes des fonctions suivantes : add : prend deux fractions en paramètre et retourne la somme des deux fractions.sub : prend deux fractions en paramètre et retourne la différence des deux fractions.mul : prend deux fractions en paramètre et retourne le produit des deux fractions.div : prend deux fractions en paramètre et retourne le quotient des deux fractions.  info Pour simplifier on va considérer que les fractions sont toujours positives et on ne va pas gérer le cas ou le résultat d'une opération est négatif ou le problème de division par zéro. Vous êtes toute fois libre de gérer ces cas si vous le souhaitez (et donc changer le type des attributs de la structure et utiliser des entiers signés).  astuce Petit rappel sur la définition des prototypes de méthodes pour les structures ici.  Créer un fichier fraction.cpp qui contiendra les définitions des méthodes et fonctions. Implémenter les fonctions dans le fichier fraction.cpp.  attention Les fonctions add, sub, mul et div ne doivent pas modifier les fractions passées en paramètre mais bien retourner une nouvelle fraction qui est le résultat de l'opération.  Créer un fichier utils.hpp qui contiendra les fonctions suivantes : gcd : prend deux entiers positifs en paramètre et retourne le plus grand diviseur commun.simplify : prend une fraction en paramètre et retourne la fraction simplifiée. Créer un fichier utils.cpp et implémenter les fonctions.  astuce Pour simplifier une fraction, il faut diviser le numérateur et le dénominateur par le plus grand diviseur commun. On va donc utiliser la fonction gcd pour calculer le plus grand diviseur commun et ensuite diviser le numérateur et le dénominateur par ce nombre. la fraction 4/6 devient 2/3 car gcd(4, 6) = 2 et 4/2 = 2 et 6/2 = 3. Il faut importer le fichier fraction.hpp dans le fichier utils.hpp pour pouvoir utiliser la structure Fraction dans la fonction simplify.  info Pour trouver le plus grand diviseur commun, on peut utiliser l'algorithme d'Euclide qui consiste à diviser le plus grand nombre par le plus petit et à répéter l'opération avec le reste de la division jusqu'à obtenir un reste nul. Dans ce cas, le plus petit nombre non nul est le plus grand diviseur commun. exemple avec 22 et 8: 22 % 8 = 6 (reste de la division de 22 par 8) 6 est différent de 0 donc on continue8 % 6 = 2 (reste de la division de 8 par 6) 2 est différent de 0 donc on continue6 % 2 = 0 (reste de la division de 6 par 2) 0 est égal à 0 donc on s'arrête et le plus grand diviseur commun est 2.  Modifier vos fonctions add, sub, mul et div pour simplifier le résultat avant de le retourner. Créer un fichier main.cpp qui contiendra le programme principal. Ce programme devra : Créer deux fractions f1 et f2 avec les valeurs de votre choix. (idéalement avec des valeurs aléatoires ou saisies par l'utilisateur)Afficher les deux fractions.Afficher la somme des deux fractions.Afficher la différence des deux fractions.Afficher le produit des deux fractions.Afficher le quotient des deux fractions.  info Vous découvrirez au prochain semestre comment améliorer ce programme en utilisant la surcharge d'opérateurs 🛠. ","version":"Next","tagName":"h2"},{"title":"TD5 - Fonctions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Somme)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-1-somme","content":" Écrire une fonction somme qui retourne la somme de deux entiers.  Utiliser des paramètres par copie et le prototype suivant: int somme(int a, int b); Utiliser des paramètres constants pour les arguments de la fonction. Utiliser des références pour les arguments de la fonction. Vérifier que cela fonctionne aussi bien avec des variables que des littéraux dans le cas des références.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Factorielle)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-2-factorielle","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif.Écrire une fonction récursive qui retourne la factorielle de n. info La factorielle d'un entier n est le produit des nombres entiers strictement positifs inférieurs ou égaux à n :2×3×4×⋯×(n−1)×n2 \\times 3 \\times 4 \\times \\dots \\times (n-1) \\times n2×3×4×⋯×(n−1)×n Afficher le résultat.Gérer les cas d'erreur (nombre négatif, nombre trop grand (limiter arbitrairement la valeur de n à 12 par exemple), etc.).Utiliser une fonction itérative (non récursive).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Fibonacci)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-3-fibonacci","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif.Écrire une fonction récursive qui retourne le terme n de la suite de Fibonacci. info La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le précèdent. Ses premiers termes sont 0 et 1. Afficher les n premiers termes de la suite de Fibonacci à l'aide de la fonction précédente. Par exemple, si l’utilisateur saisit 7, le programme affichera 0, 1, 1, 2, 3, 5, 8.Pour aller plus loin: Essayer de trouver une solution itérative (non récursive).Pour aller plus loin: Essayer de faire une fonction itérative qui au lieu de retourner seulement le n-ième terme, retourne les n premiers termes de la suite de Fibonacci dans un tableau std::vector.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Surcharges)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-4-surcharges","content":" Écrire une fonction qui permet de calculer la moyenne d'un tableau d'entiers.Écrire une fonction surchargée portant le même nom qui permet de calculer la moyenne d'un tableau de flottants.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Pangramme)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-5-pangramme","content":" Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne true si la chaîne est un pangramme, false sinon.  Il faut faire attention à la casse (majuscules/minuscules), un même lettre majuscule et minuscule compte pour la même lettre.  info Un pangramme est une phrase contenant toutes les lettres de l'alphabet au moins une fois.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (String)​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-6-string","content":" Écrire une fonction qui prend en paramètre une chaîne de caractères et qui modifie cette chaîne en remplaçant les lettres minuscules par des lettres majuscules et vice-versa. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne le nombre de voyelles de cette chaîne. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne le nombre de mots de cette chaîne. On considère que les mots sont séparés par un ou plusieurs espaces. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne la même chaîne écrite à l'envers. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne true si la chaîne est un nombre entier. astuce L'idée est de parcourir la chaîne de caractères et de vérifier si chaque caractère est un chiffre ou non. Pour tester si un caractère est un chiffre vous pouvez comparer la valeur ASCII du caractère avec les valeurs ASCII des chiffres (voir l'Exercice 5 du TD2). Il existe aussi la fonction std::isdigit (voir la documentation) qui permet de tester si un caractère est un chiffre ou non.  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus​","type":1,"pageTitle":"TD5 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercices-bonus","content":" Suite Écrire sous forme récursive les fonctions UnU_nUn​ et VnV_nVn​ conformément à la description suivante: U0=1U_0 = 1U0​=1 et Un+1=3Un+2VnU_{n+1} = 3U_n + 2V_nUn+1​=3Un​+2Vn​V0=2V_0 = 2V0​=2 et Vn+1=2Vn+Un+1V_{n+1} = 2V_n + U_n + 1Vn+1​=2Vn​+Un​+1 Afficher les dix premiers termes de chacune des suites. Vous devez obtenir les résultats suivants: U0 = 1 et V0 = 2 U1 = 7 et V1 = 6 U2 = 33 et V2 = 20 U3 = 139 et V3 = 74 U4 = 565 et V4 = 288 U5 = 2271 et V5 = 1142 U6 = 9097 et V6 = 4556 U7 = 36403 et V7 = 18210 U8 = 145629 et V8 = 72824 U9 = 582535 et V9 = 291278  ","version":"Next","tagName":"h2"},{"title":"TD3 - Conditions et boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Positif ou négatif)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-1-positif-ou-négatif","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier et affiche si cet entier est positif ou négatif.  Exemples d’exécution:  Saisir un entier : 42 42 est positif   Saisir un entier : -5 -5 est négatif   Modifier le programme pour utiliser une condition ternaire.  ternaire Un ternaire est une expression conditionnelle qui permet de faire un test comme un if/else et de retourner une valeur en fonction du résultat du test. int a {5}; int b {10}; // condition ? valeur si vrai : valeur si faux int c {(a &gt; b) ? a : b }; // c = 10 C'est réservé aux cas simples qui peuvent s'écrire sur une seule ligne. Il ne faut pas abuser des ternaires car cela peut rendre le code illisible.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Somme d'entiers positifs)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-2-somme-dentiers-positifs","content":" Écrire un programme qui demande à l’utilisateur de saisir des entiers positifs (s’arrête dès que l’utilisateur saisit un entier négatif)  Gérer l'entrée utilisateur (et son arrêt) à l'aide d'une boucle while ou do while.Afficher la somme des entiers positifs saisis par l’utilisateur.Modifier le programme pour qu'il affiche également la moyenne des entiers positifs saisis par l’utilisateur.  info Pour calculer la moyenne, il faut compter le nombre d'entiers positifs saisis par l'utilisateur puis diviser la somme par ce nombre. Vous n'avez pas à stocker les entiers saisis par l'utilisateur (vous découvrirez comment faire cela dans le prochain chapitre) vous pouvez simplement stocker la somme et le nombre d'entiers saisis.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Pair ou impair)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-3-pair-ou-impair","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier et affiche si cet entier est pair tous les nombres positifs pairs inférieurs à cet entier sinon si il est impair tous les nombres positifs impairs inférieurs à cet entier.  astuce Vous pourrez utiliser std::cin pour demander le nombre à l'utilisateur (aucune gestion d'une éventuelle erreur de saisie n'est demandée ici).  astuce Vous pouvez utiliser l'opérateur modulo % qui donne le reste de la division entière.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Majeur ou mineur)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-4-majeur-ou-mineur","content":" Écrire un programme qui demande à l’utilisateur de saisir son âge (un nombre entier) et aﬀiche s’il est majeur ou mineur.  Gérer la saisie d'un âge à stocker dans une variable.Gérer le cas où l’utilisateur saisit un âge négatif et afficher un message d’erreur dans ce cas.Gérer le cas où l’utilisateur saisit un âge avec des lettres et afficher et gérer l’erreur.  info Après avoir utilisé std::cin &gt;&gt; x, il est possible de tester si la saisie a échoué avec std::cin.fail() qui renvoie true si la saisie a échoué et false sinon. Dans notre cas, si l'utilisateur saisit un âge avec des lettres, la saisie échoue et la variable âge n'est pas modifiée. Dans le cas où la saisie a échoué, il faut réinitialiser la saisie de l'utilisateur pour pouvoir saisir à nouveau un âge : std::cin.clear() restaure std::cin à un état fonctionnel, sans erreur.std::cin.ignore() permet d’ignorer un nombre défini de caractères, soit jusqu’à un nombre maximum (exemple 500), soit jusqu’à un caractère précis (exemple '\\n' ou 'a'). Dans notre cas, nous allons utiliser ceci pour réinitialiser la saisie de l'utilisateur si on a rencontré une erreur : std::cin.clear(); // On remet std::cin dans un état fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caractères mémorisés.   ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Le juste prix)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-5-le-juste-prix","content":" Un nombre entier est tiré au hasard entre 1 et 100 (inclus).  Le joueur doit deviner ce nombre en un minimum de tentatives.  À chaque tentative, le programme indique au joueur si le nombre à deviner est plus grand ou plus petit que celui qu’il a proposé.  Le programme s’arrête lorsque le joueur a trouvé le nombre mystère.  info Pour générer un nombre aléatoire, vous pouvez utiliser la fonction rand() de la bibliothèque cstdlib. Elle retourne un nombre entier aléatoire entre 0 et RAND_MAX (une constante définie dans la bibliothèque cstdlib). Pour obtenir un nombre aléatoire entre 1 et 100, on peut utiliser l'opérateur modulo % : std::rand() % 100 + 1 Pour que le générateur de nombres aléatoires ne génère pas toujours la même séquence de nombres, il faut l’initialiser avec une valeur différente à chaque exécution du programme. C'est avec la fonction srand(). On peut utiliser la fonction time() de la bibliothèque ctime pour obtenir l'heure actuelle en secondes et l'utiliser comme valeur d'initialisation du générateur de nombres aléatoires. #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; int main() { // Initialisation du générateur de nombres aléatoires avec la fonction time() std::srand(std::time(nullptr)); int random_variable { std::rand() }; std::cout &lt;&lt; &quot;Random value between 0 and &quot; &lt;&lt; RAND_MAX &lt;&lt; &quot; : &quot; &lt;&lt; random_variable &lt;&lt; std::endl; } NB : Il existe une façon plus moderne de générer des nombres aléatoires à partir de C++11, nous découvrirons cela au prochain semestre.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (ASCII art)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-6-ascii-art","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif et affiche un triangle rectangle de hauteur n comme dans l’exemple ci-dessous.  exemple d'exécution Entrez un entier positif : 5 * ** *** **** *****   Essayer d'afficher un sapin de noël, autrement dit un triangle rectangle isocèle de hauteur n et dont le sommet est composé d'une seule étoile.  exemple d'exécution Entrez un entier positif : 3 * *** *****   Essayer d'afficher les contours d'un carré de côté n comme dans l’exemple ci-dessous.  exemple d'exécution Entrez un entier positif : 5 ***** * * * * * * *****   ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (conjecture de Syracuse)​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercice-7-conjecture-de-syracuse","content":" Écrire un programme qui, à partir d’un entier positif saisi par l’utilisateur, affiche le nombre de termes de la suite de Syracuse nécessaires pour atteindre 1 (on inclut le terme de départ dans le décompte).  La suite de Syracuse est une suite d'entiers dans laquelle chaque terme est obtenu en appliquant une fonction à son terme précédent. Cette fonction est définie comme suit:  si le terme est pair, le terme suivant est égal à la moitié du terme précédent. (x/2)si le terme est impair, le terme suivant est égal à 3 fois le terme précédent plus 1 (3x+1).  Par exemple, si le terme de départ est 7, la suite est :  7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1, ...  Ici, la suite atteint la valeur 1 au bout de 17 termes (incluant le terme de départ).  Vous remarquez qu’à la fin, une fois qu’on est tombé sur 1, la suite finit par répéter indéfiniment le cycle 4, 2, 1.  Il est conjecturé que cette suite atteint toujours la valeur 1 quelque soit le terme de départ. Cela a d'ailleurs déjà été vérifiée numériquement jusqu’à 10^20 (par Tomas Oliveira e Silva).  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus​","type":1,"pageTitle":"TD3 - Conditions et boucles","url":"/Learn--cpp_programming/TDs/S1/ConditionsAndLoops#exercices-bonus","content":" Soldes : Conditions et gestion de l'entrée utilisateur C'est les soldes ! Créer un programme qui demande à l'utilisateur : le type de produit (à stocker dans un enum)le prix du produit (un nombre flottant)s'il a une carte de fidélité (boolean)son age (un nombre entier) En fonction des informations saisies, le programme affiche le prix final après réduction. Vous disposez des informations suivantes: Type d'article\tRéduction\tRéduction avec carte de fidélitéAlimentation\t5%\t8% Vêtements\t10%\t15% Chaussures\t12%\t18% Autre\t0%\t0% S'il à moins de 26 ans, il a 10% de réduction supplémentaire sur tous les articles après réduction. Je vous fourni le code suivant pour l'énumération et la gestion de la saisie de l'utilisateur: enum class Article { Alimentation, Vetements, Chaussures, Autre }; // C'est un mécanisme avancé, vous n'avez pas besoin de comprendre comment ça marche. // On en reparlera au second semestre. // retenez juste que ça permet de convertir une entrée de l'utilisateur en Article. std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } Cela nous permet d'utiliser l'opérateur &gt;&gt; pour lire un enum comme on pourrait le faire avec un int ou un float. Sans cela, on aurait dû utiliser une variable intermédiaire de type string ou int pour stocker la saisie de l'utilisateur et faire la conversion nous-même. Exemple de saisie d'un enum #include &lt;iostream&gt; enum class Article { Alimentation, Vetements, Chaussures, Autre }; std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } int main() { Article article; std::cin &gt;&gt; article; // On vérifie si la saisie a échoué. if (std::cin.fail()) { std::cout &lt;&lt; &quot;Erreur de saisie, il faut saisir un type d'article valide (\\&quot;Alimentation\\&quot;, \\&quot;Vetements\\&quot;, \\&quot;Chaussures\\&quot; ou \\&quot;Autre\\&quot;)&quot; &lt;&lt; std::endl; std::cin.clear(); // On remet std::cin dans un état fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caractères mémorisés. // le programme s'arrête si on a rencontré une erreur de saisie et renvoie 1 pour indiquer une erreur. return 1; } if (article == Article::Alimentation) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Alimentation&quot; &lt;&lt; std::endl; } else if (article == Article::Vetements) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Vetements&quot; &lt;&lt; std::endl; } else if (article == Article::Chaussures) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Chaussures&quot; &lt;&lt; std::endl; } else if (article == Article::Autre) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Autre&quot; &lt;&lt; std::endl; } return 0; } Demander à l'utilisateur de saisir le type d'article, le prix, s'il a une carte de fidélité et son âge. Gérer les cas où l'utilisateur saisit des informations incorrectes (enum incorrect, prix ou âge négatif, etc.) et afficher un message d'erreur dans ce cas. Vous pouvez reprendre mon exemple de saisie d'un enum. Calculer le prix final en fonction des informations saisies et afficher le résultat. L'enseigne offre également un bon d'achat de 10% du montant total du ticket de caisse, à valoir sur un prochain achat. Le bon d'achat ne peut pas être supérieur à 30€. Calculer le montant du bon d'achat et l'afficher en fin de programme. ","version":"Next","tagName":"h2"},{"title":"TD9 - Mémoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Allocation dynamique)​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-1-allocation-dynamique","content":" Écrire un programme qui alloue dynamiquement une variable de type int avec le mot-clé new (sans initialisation).Demander à l'utilisateur de saisir une valeur pour cette variable et modifier la valeur de la variable avec cette saisie.Écrire une fonction qui prend en paramètre un pointeur sur un int et qui affiche la valeur de la variable pointée.Afficher la valeur de la variable avec la fonction précédente.Afficher l'adresse de la variable.Libérer cette variable avec le mot-clé delete.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-2","content":" Écrire un programme qui génère un tableau (std::vector) de 100 entiers aléatoires compris entre 0 et 100. info Vous pouvez utiliser la fonction rand() pour générer un nombre aléatoire. Je vous renvoie à l'Exercice 1 du TD5 pour plus d'informations. Écrire une fonction qui retourne un pointeur sur le plus grand élément du tableau. Écrire une fonction qui prend en paramètre un pointeur sur un emplacement mémoire contiguë d'entiers et sa taille et qui retourne la somme des éléments du tableau. Utiliser les fonctions précédentes pour afficher le plus grand élément du tableau et la somme des éléments du tableau. astuce On peut récupérer un pointeur sur le premier élément d'un std::vector avec la méthode data(). Sinon il est aussi possible d'utiliser l'opérateur &amp; sur le premier élément du std::vector. Completer la fonction sum suivante pour qu'elle retourne un pointeur sur la somme des éléments du tableau passé en paramètre. int* sum(std::vector&lt;int&gt; const&amp; v) { int sum {0}; // boucle for // TODO } Utiliser la fonction sum pour afficher la somme des éléments du tableau. En fonction du résultat obtenu, que pouvez-vous en déduire sur le fonctionnement de la fonction sum ? Si elle ne fonctionne pas, corriger la fonction sum pour qu'elle fonctionne correctement.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Split)​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-3-split","content":" Dans cet exercice, on ne doit pas utiliser de std::vector.  Allouer dynamiquement un tableau de 100 flottants aléatoires compris entre 0 et 100 (utiliser l'allocation dynamique pour des emplacements mémoire contiguës). info Vous pouvez utiliser la fonction rand() pour générer un nombre aléatoire. Pour générer un nombre flottant aléatoire vous pouvez utiliser la fonction rand() et la diviser par RAND_MAX (qui est une constante définie dans la bibliothèque cstdlib) ce qui permet d'obtenir un nombre flottant aléatoire entre 0 et 1. Il ne vous reste plus qu'à multiplier ce nombre par 100 pour obtenir un nombre flottant aléatoire entre 0 et 100. Écrire une fonction qui prend en paramètre un tableau de flottants (sous la forme d'un pointeur sur le premier élément du tableau) et sa taille et qui retourne un pointeur sur le plus grand élément du tableau. On souhaite créer une fonction qui permet de créer un nouveau tableau composé des éléments du tableau passé en paramètre qui sont supérieurs à un certain seuil. Écrire une fonction thresholdFilter qui prend en paramètre un tableau de flottants, sa taille, un seuil et une référence sur un entier qui contiendra la taille du nouveau tableau et qui retourne un pointeur sur le premier élément du nouveau tableau. Voilà la signature de la fonction: float* thresholdFilter(float const* const array, size_t const size, float const threshold, size_t&amp; new_size); info Vous pouvez remarquer que j'ai écrit float const* const array au lieu de float* array. Le premier const signifie que l'on ne peut pas modifier les valeurs pointées par le pointeur array et le deuxième const signifie que l'on ne peut pas modifier l'adresse pointée par le pointeur array. ","version":"Next","tagName":"h2"},{"title":"Algorithmes de tri, complexité et recherche dichotomique","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Sorting","content":"","keywords":"","version":"Next"},{"title":"Tri par comparaison​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-comparaison","content":" Les premiers algorithmes de tri que nous allons voir sont des algorithmes de tri par comparaison (Comparison based strategies).  Ils consistent à comparer deux à deux les éléments du tableau puis de les échanger ou non en fonction du résultat de la comparaison.  ","version":"Next","tagName":"h2"},{"title":"Tri par sélection (selection sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-sélection-selection-sort","content":" L'algorithme de tri par sélection est un algorithme de tri qui consiste à trouver le plus petit élément du tableau, et à le placer en première position (ou le plus grand élément en dernière position). On répète cette opération jusqu'à ce que le tableau soit trié.  Un exemple, avec le tableau suivant [6, 2, 8, 1, 5, 3, 9]:  On, parcourt le tableau pour trouver le plus petit élément qui est 1. Son indice est 3, on l'échange avec l'élément à l'indice 0 (le premier élément du tableau). 1\t2\t8\t6\t5\t3\t9 Le premier élément du tableau est désormais le plus petit élément du tableau. On recommence l'opération, mais en ignorant le premier élément du tableau, car il est déjà trié. info Toute l'astuce de cet algorithme est donc de trier un sous-tableau plus petit à chaque itération jusqu'à ce que le tableau soit trié.  Voilà les itérations suivantes:  Le deuxième plus petit élément est 2, il est déjà à la bonne place, on ne fait rien. 1\t2\t3\t6\t5\t8\t9 1\t2\t3\t5\t6\t8\t9 Il reste trois éléments à trier ([6, 8, 9]), il sont déjà triés, on ne fait rien.  Voilà, le tableau est trié.  Je t'invite à regarder le fonctionnement de cet algorithme sur cette animation ou encore ici (clique sur &quot;SEL&quot; ou &quot;Selection Sort&quot; dans la barre de navigation).  ","version":"Next","tagName":"h3"},{"title":"Tri à bulles (bubble sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-à-bulles-bubble-sort","content":" Le tri à bulles est un autre algorithme de tri très connu. Il consiste à comparer deux à deux les éléments du tableau, et à les échanger si ils ne sont pas dans le bon ordre. On répète cette opération jusqu'à ce que le tableau soit trié.  remarque Cela va avoir pour effet de faire &quot;remonter&quot; les plus grands éléments du tableau vers la fin du tableau, comme des bulles d'air qui remontent à la surface.  Un exemple, avec le même tableau [6, 2, 8, 1, 5, 3, 9]:  On compare les deux premiers éléments du tableau, 6 et 2. Comme 6 est plus grand que 2, on les échange. 2\t6\t8\t1\t5\t3\t9  On recommence l'opération avec les deux éléments suivants, 6 et 8. Comme 6 est plus petit que 8, on ne fait rien. On procède ainsi jusqu'à la fin du tableau.  On obtient après un premier passage sur l'ensemble du tableau:  2\t6\t1\t5\t3\t8\t9  On recommence l'opération, mais en ignorant le dernier élément du tableau, car il est déjà trié.  Voilà les itérations suivantes:  2\t1\t5\t3\t6\t8\t9 1\t2\t3\t5\t6\t8\t9 Dernier passage, aucun échange n'est effectué. Le tableau est trié.  ","version":"Next","tagName":"h3"},{"title":"Parlons un peu de complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#parlons-un-peu-de-complexité","content":" La complexité d'un algorithme est une mesure de la quantité de ressources (temps, mémoire, etc) que celui-ci va utiliser pour s'exécuter.  En général, on s'intéresse à la complexité en fonction de la taille des données en entrée de l'algorithme.  Il existe plusieurs types de complexité, la plus souvent utilisée est la complexité en temps.  Cela revient à se poser la question:  Si je donne à mon programme une entrée de taille n, quel est l'ordre de grandeur (en fonction de n) du nombre d'opérations qu'il va effectuer ?  remarque La complexité permet de quantifier la relation entre les conditions de départ et le temps effectué par l'algorithme.  ","version":"Next","tagName":"h2"},{"title":"Opérations de base​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#opérations-de-base","content":" Pour &quot;compter les opérations&quot;, il faut décider de ce qu'est une opération. Ce choix dépend du problème (et même de l'algorithme) considéré. Il faut en fait choisir soi-même quelques petites opérations que l'algorithme effectue souvent, et que l'on veut utiliser comme opérations de base pour mesurer la complexité. Les opérations qui caractérisent le mieux l'algorithme et représentent le mieux le temps d'exécution de celui-ci. Les opérations de base sont souvent les opérations arithmétiques, les comparaisons, les affectations, etc. Par exemple, pour un algorithme de tri, on va compter le nombre de comparaisons et d'échanges d'éléments du tableau.  En fonction des algorithmes, certaines opérations peuvent être plus significatives que d'autres. Par exemple, la multiplication est plus coûteuse que l'addition, on peut donc ne considérer que les opérations de multiplication pour mesurer la complexité d'un algorithme.  info On ne compte pas les opérations qui ne dépendent pas de la taille des données en entrée (comme l'initialisation de variables, etc). Ces opérations sont considérées comme constantes et pas significatives pour la complexité en fonction de la taille des données en entrée.  ","version":"Next","tagName":"h3"},{"title":"Notation \"grand O\"​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#notation-grand-o","content":" On exprime la complexité en fonction de la taille des données en entrée avec la notation &quot;grand O&quot;. La notation &quot;grand O&quot; est une notion mathématique qui permet d'exprimer un ordre de grandeur.  Par exemple, des algorithmes effectuant environ nnn opérations, 2n+202n+202n+20 opérations ou n/2n/2n/2 opérations ont tous la même complexité : on la note O(n)O(n)O(n) (lire &quot;grand O de nnn&quot;). De même, un algorithme en 3n2+4n+23n^2 + 4n + 23n2+4n+2 opérations aura une complexité de O(n2)O(n^2)O(n2) : on néglige les termes de plus faible degré (ici 4n4n4n et 222) et les coefficients (ici 333). On cherche seulement à savoir comment évolue le nombre d'opérations en fonction de la taille des données en entrée et on considère le terme de plus haut degré qui est celui qui va croître le plus vite en fonction de la taille des données en entrée.  VOilà un graphique récapitulatif des différentes notations &quot;grand O&quot; communes:    ","version":"Next","tagName":"h3"},{"title":"Exemple de calcul de complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#exemple-de-calcul-de-complexité","content":" Prenons l'exemple du tri par sélection.  Pour trier un tableau de taille nnn, premièrement on parcourt le tableau pour trouver le plus petit élément, on va donc effectuer nnn comparaisons.  Ensuite, on va échanger cet élément avec le premier élément du tableau, on va donc effectuer 111 échange.  Ensuite on va recommencer l'opération, mais en ignorant le premier élément du tableau, car il est déjà trié.  On va donc effectuer n−1n-1n−1 comparaisons et 111 échange.  On va faire cela jusqu'à ce que le tableau soit trié, donc jusqu'à ce qu'il ne reste plus qu'un seul élément à trier.  Pour résumer, on va effectuer pour les différentes itérations:  nnn comparaisons et 111 échangen−1n-1n−1 comparaisons et 111 échangen−2n-2n−2 comparaisons et 111 échange...111 comparaison et 111 échange  On peut donc calculer le nombre total de comparaisons et d'échanges effectués par l'algorithme:  =(n+1)+((n−1)+1)+((n−2)+1)+...+(1+1)=(n+(n−1)+⋯+1)+(1+⋯+1)=n(n+1)2+n=n2+3n2\\begin{align*} = &amp; (n+1) + ((n-1)+1) + ((n-2)+1) + ... + (1+1) \\\\ = &amp; (n + (n-1) + \\dots + 1) + (1 + \\dots + 1) \\\\ = &amp; \\frac{n(n+1)}{2} + n \\\\ = &amp; \\frac{n^2 + 3n}{2} \\\\ \\end{align*}====​(n+1)+((n−1)+1)+((n−2)+1)+...+(1+1)(n+(n−1)+⋯+1)+(1+⋯+1)2n(n+1)​+n2n2+3n​​  Ici, j'ai compté de manière exacte le nombre d'opérations effectuées par l'algorithme, mais en général on s'intéresse à la complexité en fonction de la taille des données en entrée.  On va donc garder uniquement le terme de plus haut degré, ici n2n^2n2.  On dit que la complexité du tri par sélection est en O(n2)O(n^2)O(n2).  info On peut aussi évaluer cette complexité sans calcul exact, mais plutôt en estimant le nombre d'opérations effectuées par l'algorithme. On peut voir que l'algorithme doit à chaque itération parcourir le tableau, c'est ce qui va prendre le plus de temps et dépendra de la taille du tableau. Chaque itération va permettre de trier un élément du tableau, donc on va effectuer nnn itérations. On peut donc estimer que la complexité du tri par sélection est en O(n×n)=O(n2)O(n \\times n) = O(n^2)O(n×n)=O(n2).  ","version":"Next","tagName":"h3"},{"title":"Complexité dans le pire des cas​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-dans-le-pire-des-cas","content":" Le nombre d'opérations effectuées par un algorithme peut dépendre de la taille des données en entrée, mais aussi des données elles-mêmes.  Par exemple, dans le cadre d'un tri à bulles, si le tableau est déjà trié, on n'effectuera aucune opération d'échange, et seulement nnn comparaisons.  On peut donc dire que la complexité du tri à bulles est en O(n)O(n)O(n) dans le meilleur des cas.  Mais si le tableau est trié dans l'ordre inverse, on va effectuer nnn comparaisons et nnn échanges à chaque itération, et on va effectuer nnn itérations.  On peut donc dire que la complexité du tri à bulles est en O(n×n)=O(n2)O(n \\times n) = O(n^2)O(n×n)=O(n2) dans le pire des cas.  remarque C'est intéressant de considérer la complexité dans le pire des cas, car elle permet de savoir si l'algorithme est efficace pour toutes les données possibles. En général pour des données quelconques, c'est en général assez proche du comportement dans le pire des cas.  ","version":"Next","tagName":"h3"},{"title":"Complexité en moyenne​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-en-moyenne","content":" On peut aussi s'intéresser à la complexité en moyenne, c'est-à-dire la complexité sur toutes les données possibles.  Par exemple, pour le tri à bulles, la complexité en moyenne est en O(n2)O(n^2)O(n2).  Il existe des algorithmes qui ont une complexité en moyenne bien meilleure que leur complexité dans le pire des cas. Cela dépend du problème considéré et demande une analyse plus fine de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Complexité en mémoire​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-en-mémoire","content":" On peut aussi s'intéresser à la complexité en mémoire d'un algorithme. Autrement dit, combien de mémoire va utiliser l'algorithme en fonction de la taille des données en entrée.  C'est aussi une mesure de la complexité pertinente.  Si par exemple on a besoin de trier un tableau de 1000 éléments, on peut se dire que la complexité en temps n'est pas très importante, car l'algorithme va s'exécuter très rapidement. Mais si l'algorithme utilise beaucoup de mémoire, cela peut poser problème, car il peut ne pas avoir assez de mémoire disponible pour exécuter l'algorithme.  Dans la plupart des cas, la complexité en mémoire est beaucoup plus simple à calculer que la complexité en temps.  Mais dans des problèmes plus compliqués, la complexité en mémoire et la complexité en temps peuvent être liées.  On peut par exemple choisir de sacrifier un peu de rapidité d'exécution pour utiliser moins de mémoire, ou au contraire d'augmenter la vitesse en augmentant la complexité en mémoire de notre algorithme, par exemple en stockant dans un tableau les résultats déjà calculés (c'est le principe de la mise en cache, appelée aussi memoization).  remarque De nos jours, la complexité en mémoire est moins importante qu'avant, car les ordinateurs ont beaucoup de mémoire disponible. Dans la majorité des cas, on va donc plutôt s'intéresser à la complexité en temps. Mais la complexité en mémoire reste importante dans certains cas avancés ou avec des données très volumineuses.  ","version":"Next","tagName":"h3"},{"title":"Limitation de la complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#limitation-de-la-complexité","content":" La complexité d'un algorithme est donc une mesure d'ordre de grandeur en fonction de la taille des données en entrée.  Cependant, il est important de garder à l'esprit que la complexité ne permet pas de savoir si un algorithme est rapide ou lent.  Même si un algorithme à une complexité plus faible qu'un autre, il peut être plus (beaucoup plus) lent à s'exécuter qu'un autre algorithme pour des tailles de données en entrée faibles.  ","version":"Next","tagName":"h3"},{"title":"Tri diviser pour régner (Divide-and-Conquer paradigm)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-diviser-pour-régner-divide-and-conquer-paradigm","content":" Il existe d'autres algorithmes de tri plus efficaces que les algorithmes de tri par comparaison. Ils sont basés sur le principe de diviser pour régner (divide and conquer en anglais). L'idée est de diviser le problème en sous-problèmes plus petits, de résoudre les sous-problèmes, puis de fusionner les solutions des sous-problèmes pour résoudre le problème initial.  ","version":"Next","tagName":"h2"},{"title":"Tri fusion (merge sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-fusion-merge-sort","content":" Le tri fusion est un algorithme de tri qui consiste à diviser le tableau en deux parties égales, trier les deux parties, puis fusionner les deux parties triées.  Il y a donc deux &quot;phases&quot; dans cet algorithme:  la phase de division du tableau en deux parties égalesla phase de fusion des deux parties triées  Phase de division​  Pour la phase de division, on va choisir de diviser et trier le tableau en deux parties égales pour maximiser l'efficacité de l'algorithme (ou presque égales si le tableau a une taille impaire).  Il existe deux façons de procéder pour cibler les deux parties du tableau:  Créer des tableaux intermédiaires pour stocker les deux parties du tableau à trier.Utiliser des indices pour définir les parties du tableau à trier, et trier directement le tableau en place.  La première méthode est plus simple à comprendre, mais utilise plus de mémoire, car il faut créer des tableaux intermédiaires (allocation de mémoire supplémentaire).  En pratique, on privilégie donc la deuxième méthode, et c'est celle que je vais détailler ici.  Pour trier un tableau, on va donc utiliser deux indices, un indice de début et un indice de fin, qui vont définir la partie du tableau à trier.  Par exemple, pour le tableau [6, 2, 8, 1, 5, 3, 9], les indices 0 et 6 vont définir le tableau complet. On va calculer la taille de la partie du tableau à trier, ici 6 (indice de fin) - 0 (indice de début) + 1 (car on compte l'élément à l'indice de fin), soit 7.  On va ensuite diviser cette taille par deux, soit 3 (on peut arrondir à l'entier inférieur).  On va donc trier les deux parties [6, 2, 8, 1] (des indices 0 à 3) et [5, 3, 9] (des indices 4 à 6). Enfin, la fusion des deux parties triées va permettre d'obtenir le tableau trié.  info Cela fonctionne à condition que l'algo de tri que l'on va utiliser pour trier les deux sous-tableaux fonctionne &quot;in-place&quot;, c'est-à-dire qu'il trie directement le tableau en place sans utiliser de tableau intermédiaire.  Phase de fusion​  C'est la phase de fusion qui est la plus intéressante, car c'est elle qui va permettre réellement de trier le tableau.  Dans cette phase de fusion il est plus simple de copier les éléments dans deux sous-tableaux intermédiaires, puis d'écrire les éléments triés dans le tableau final directement.  info Il existe des méthodes pour effectuer cette fusion sans copier les éléments dans des tableaux intermédiaires, mais elles sont bien plus complexes à mettre en oeuvre.  Pour fusionner deux tableaux triés, on va utiliser deux (autres) indices, un indice pour chaque sous-tableau, qui vont permettre de parcourir les deux tableaux et de pointer vers les éléments les plus petits des deux tableaux.  On va comparer les deux éléments les plus petits des deux tableaux, et ajouter le plus petit des deux dans le tableau final.  On va incrémenter l'indice du tableau dont on a ajouté l'élément, et on recommence l'opération jusqu'à ce qu'on ait parcouru les deux tableaux.  attention Il faut faire attention à ne pas dépasser la taille des sous-tableaux avec les indices, sinon on va avoir une erreur en essayant d'accéder à un élément qui n'existe pas. Il faut donc vérifier que les indices sont bien inférieurs à la taille des sous-tableaux. Si l'un des deux indices est égal à la taille du sous-tableau, cela veut dire qu'on a parcouru tout le sous-tableau, et qu'il ne reste plus qu'à ajouter les éléments du deuxième sous-tableau dans le tableau final.  On obtient ainsi un tableau trié.  info La condition d'arrêt de la récursion est quand la taille de la partie du tableau à trier est inférieure ou égale à 1, car un tableau de taille 1 est déjà trié (de même pour un tableau vide).  Récursion​  Dans l'exemple précédent, je n'ai pas détaillé la phase de tri des deux sous-tableaux, on pourrait par exemple utiliser un tri précédemment vu comme le tri par sélection pour trier les deux sous-tableaux.  Cela améliorerait la complexité de l'algorithme mais pas la tendance asymptotique de l'algorithme. En reprenant les calculs précédents (où on avait n2+3n2\\frac{n^2 + 3n}{2}2n2+3n​ comparaisons et d'échanges), cela nous donnerait:  =(n2)2+3(n2)2∗2=n24+3(n2)\\begin{align*} = &amp; \\frac{(\\frac{n}{2})^2 + 3(\\frac{n}{2})}{2} * 2 \\\\ = &amp; \\frac{n^2}{4} + 3(\\frac{n}{2}) \\\\ \\end{align*}==​2(2n​)2+3(2n​)​∗24n2​+3(2n​)​  C'est bien inférieur à la complexité du tri par sélection initial, mais cela reste en O(n2)O(n^2)O(n2).  Mais on pourrait très bien de nouveau utiliser le tri fusion pour trier les sous-tableaux, et ainsi de suite.  L'algorithme de tri fusion est un algorithme récursif, c'est-à-dire qu'il s'appelle lui-même pour trier les sous-tableaux.  Cela reviens à diviser le tableau en deux parties égales, puis chaque partie en deux parties égales, etc, jusqu'à ce qu'on ait des sous-tableaux de taille 1 ou 0 puis fusionner les sous-tableaux 2 à 2 pour obtenir le tableau trié.  C'est un algorithme très efficace, en faisant cela, on va trier le tableau en O(nlog⁡n)O(n \\log n)O(nlogn) opérations, ce qui est beaucoup plus efficace que les algorithmes de tri par comparaison.  info Il est plus efficace cependant les copies effectuées pour l'étape de fusion des tableaux intermédiaires triés peuvent être coûteuses et impacter la complexité (en mémoire) de l'algorithme. On va découvrir un autre algorithme de tri qui à la même complexité en temps que le tri fusion mais qui ne nécessite pas de copies intermédiaires (En TDs, si vous les implémentez tout les deux je vous suggère de comparer les deux algorithmes pour vous rendre compte de la différence de performance).  ","version":"Next","tagName":"h3"},{"title":"Tri rapide (quick sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-rapide-quick-sort","content":" Le tri rapide est un algorithme de tri qui consiste à choisir un élément du tableau, appelé pivot, et à placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.  On répète ensuite l'opération sur les deux sous-tableaux, jusqu'à ce que le tableau soit trié.  De la même manière que pour le tri fusion, c'est un algorithme récursif et on va donc utiliser des indices pour définir les parties du tableau à trier.  Il y a également deux phases dans cet algorithme:  la phase de division du tableau en deux parties en fonction du pivotla phase de tri des deux parties  Phase de division​  Choix du pivot​  Le choix du pivot est très important, car il va déterminer la complexité de l'algorithme.  Si on choisit un pivot qui est toujours le plus petit élément du tableau, on va avoir une complexité en O(n2)O(n^2)O(n2), car on va devoir parcourir tout le tableau à chaque itération (de même si on choisit le plus grand élément du tableau).  Il existe plusieurs méthodes pour choisir le pivot, la plus simple est de choisir le premier ou le dernier élément du tableau. Mais cela peut être problématique si le tableau est déjà trié car on va diviser le tableau en deux parties de tailles très différentes.  info L'idéal est de choisir un pivot qui est proche de la valeur médiane du tableau, c'est-à-dire qui va diviser le tableau en deux parties égales. Il existe plusieurs méthodes pour choisir un pivot proche de la valeur médiane du tableau, mais elles sont plus compliquées à mettre en oeuvre.  Partitionnement​  Une fois le pivot choisi, on va parcourir le tableau et placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.  Il y a plusieurs approches pour gérer le pivot, dans notre cas, on va choisir de premièrement placer le pivot à la fin du tableau. Ou tout simplement choisir le pivot comme étant le dernier élément du tableau.  On va s'aider d'un indice qui va nous indiquer le premier élément plus grand que le pivot et qui va nous permettre de placer le pivot à sa place définitive.  On va ensuite parcourir le tableau pour placer les éléments plus petits que le pivot à gauche du pivot, et les éléments plus grands que le pivot à droite du pivot.  Si l'élément que l'on parcourt est plus petit que le pivot, on va l'échanger avec l'élément à l'indice du premier élément plus grand que le pivot, et on va incrémenter l'indice du premier élément plus grand que le pivot.  Une fois qu'on a parcouru tout le tableau, on va échanger le pivot avec l'élément à l'indice du premier élément plus grand que le pivot pour que le pivot soit à sa place définitive (entre les éléments plus petits et les éléments plus grands).  Enfin, on va renvoyer l'indice du pivot pour pouvoir appeler récursivement l'algorithme sur les deux sous-tableaux.  Récursion​  On obtient ainsi un tableau avec le pivot à sa place définitive, et tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot et on connaît l'indice du pivot.  On va donc pouvoir appeler récursivement l'algorithme sur les deux sous-tableaux, en ignorant la place du pivot.  ","version":"Next","tagName":"h3"},{"title":"Tri par dénombrement (counting sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-dénombrement-counting-sort","content":" IL existe encore d'autres algorithmes de tri, mais ils sont plus spécifiques et ne fonctionnent que dans certains cas. Je vais en présenter un simple ici pour vous donner une idée de ce qui existe.  Le tri par dénombrement (ou counting sort en anglais) est très efficace, car il va permettre de trier un tableau en complexité linéaire, c'est-à-dire en O(n)O(n)O(n). Il ne fonctionne cependant que pour des données entières car il ne se base pas sur des comparaisons mais va compter le nombre d'occurrences de chaque valeur (de plus pour simplifier, on va supposer que les valeurs sont positives).  Le prérequis pour utiliser cet algorithme est donc de connaître la valeur maximale des données à trier. Soit on connaît cette valeur à l'avance, soit on peut la calculer en parcourant le tableau une première fois.  L'algorithme consiste à compter le nombre d'occurrences de chaque valeur dans le tableau, puis à reconstruire le tableau en plaçant les valeurs dans l'ordre.  Par exemple, si on se fixe des valeurs entières entre 0 et 9, on peut trier le tableau suivant [1, 4, 1, 2, 7, 5, 2] en procédant ainsi:  On parcourt le tableau pour compter le nombre d'occurrences de chaque valeur.  valeur\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9nombre d'occurrences\t0\t2\t2\t0\t1\t1\t0\t1\t0\t0  On reconstruit le tableau en parcourant le tableau des occurrences et en ajoutant les valeurs dans l'ordre.  On ajoute 2 fois la valeur 1On ajoute 2 fois la valeur 2...  On obtient ainsi le tableau trié [1, 1, 2, 2, 4, 5, 7].  attention On remarque qu'il faut pouvoir stocker le nombre d'occurrences de chaque valeur, donc un tableau de taille 10 dans notre exemple. Il faut donc un tableau de taille kkk pour trier des données comprises entre 0 et k−1k-1k−1 ce qui augmente la complexité en mémoire de l'algorithme. C'est à prendre en compte si on veut utiliser cet algorithme car il peut être très efficace en temps, mais peut aussi utiliser beaucoup de mémoire si les valeurs sont très grandes. C'est un algorithme à utiliser seulement dans le cas où on connaît la valeur maximale des données à trier et que cette valeur est raisonnable.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin:​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Tri par dénombrement stable​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-dénombrement-stable","content":" Details On peut améliorer le tri par dénombrement en le rendant stable. Cela signifie que si deux éléments ont la même valeur, ils seront dans le même ordre dans le tableau trié que dans le tableau initial. Cela ne semble pas très important à première vue, mais cela permet de trier des données plus complexes en leur associant des valeurs entières sur lesquelles on va effectuer le tri. Pour faire cela il faut modifier légèrement l'algorithme de tri par dénombrement. Une fois qu'on a compté le nombre d'occurrences de chaque valeur, on va calculer la somme partielle des occurrences de chaque valeur. Cela va nous permettre de connaître la position de chaque valeur dans le tableau trié. Par exemple, avec le tableau suivant [1, 4, 1, 2, 7, 5, 2] contenant des valeurs entières entre 0 et 9: On compte le nombre d'occurrences de chaque valeur : [0, 2, 2, 0, 1, 1, 0, 1, 0, 0]On calcule la somme partielle des occurrences de chaque valeur : [0, 2, 4, 4, 5, 6, 6, 7, 7, 7] remarque On peut se resservir du tableau des occurrences pour stocker la somme partielle des occurrences de chaque valeur, ce qui permet de ne pas utiliser de tableau intermédiaire supplémentaire. On va construire un nouveau tableau de même taille que le tableau initial, en parcourant le tableau initial pour ajouter les valeurs dans le nouveau tableau. On va ajouter la valeur à la position indiquée par la somme partielle des occurrences de la valeur, puis on va décrémenter la somme partielle des occurrences de la valeur. Par exemple, pour la valeur 1, on va ajouter la valeur 1 à la position 2 du nouveau tableau, puis on va décrémenter la somme partielle des occurrences de la valeur 1 pour obtenir 1 (car il reste une occurrence de la valeur 1). On obtient ainsi le tableau trié [1, 1, 2, 2, 4, 5, 7]. L'inconvénient principal de cette méthode est qu'il faut un tableau intermédiaire pour stocker le tableau trié, ce qui augmente la complexité en mémoire de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Tri par base (radix sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-base-radix-sort","content":" Details Le tri par dénombrement permet de trier des données entières comprises entre 0 et k−1k-1k−1 en complexité linéaire. On va se servir de cet algorithme pour trier des données plus complexes, en associant à chaque donnée une valeur entière sur laquelle on va effectuer le tri (d'où l'intérêt de rendre le tri par dénombrement stable). On va considérer un tri de nombres entiers, mais cela peut s'appliquer à d'autres types de données. Un nombre entier peut être représenté en base 10, c'est-à-dire en utilisant les chiffres de 0 à 9. Par exemple, le nombre 123 peut être représenté en base 10 par la suite de chiffres 1, 2 et 3. On va donc pouvoir trier des nombres entiers en triant les chiffres de leur représentation en base 10. Par exemple, pour trier les nombres [123, 456, 324, 682, 789, 118, 321, 654, 987], on va trier les chiffres des nombres, en commençant par les unités, puis les dizaines, puis les centaines. Cela permet de trier les nombres en complexité linéaire grâce au tri par dénombrement. Dans notre exemple, le nombre le plus grand est 987, il a donc 3 chiffres, on va donc effectuer 3 itérations de tri par dénombrement pour trier les nombres. remarque Cette information peut être connue à l'avance, mais on peut aussi la calculer en parcourant le tableau une première fois. On trie les unités ce qui donne [321, 682, 123, 324, 654, 456, 987, 118, 789]On trie les dizaines ce qui donne [118, 321, 123, 324, 456, 654, 682, 987, 789]enfin, on trie les centaines ce qui donne [118, 123, 321, 324, 456, 654, 682, 789, 987]  ","version":"Next","tagName":"h3"},{"title":"Recherche dichotomique​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#recherche-dichotomique","content":" Avoir un tableau trié est très utile pour effectuer des recherches dans un tableau.  Par exemple, si on veut savoir si une valeur est présente dans un tableau, on peut le parcourir le tableau et comparer chaque élément avec la valeur recherchée.  Mais si le tableau est trié, on peut utiliser une méthode plus efficace: la recherche dichotomique.  La recherche dichotomique consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l'opération jusqu'à trouver la valeur ou jusqu'à ce qu'il ne reste plus qu'un seul élément dans le tableau.  Exemple simple avec le tableau suivant [1, 2, 2, 4, 5, 8, 12] (nombre d'éléments: 7) et la valeur recherchée 8:  On calcule l'indice du milieu du tableau, soit 3. On compare la valeur à l'indice 3 avec la valeur recherchée 8, comme 4 est plus petit que 8, on ne garde que la partie du tableau qui contient la valeur recherchée, c'est-à-dire la partie du tableau à partir de l'indice 4 (indice de début: 4, indice de fin: 6). On recommence l'opération avec la partie du tableau restante. Sous partie du tableau: [5, 8, 12] (nombre d'éléments: 3), indice du milieu: 5. On compare la valeur à l'indice 5 avec la valeur recherchée 8, comme 8 est égal à 8, on a trouvé la valeur recherchée. On peut donc s'arrêter et renvoyer l'indice 5.  ","version":"Next","tagName":"h2"},{"title":"Complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité","content":" La complexité de la recherche dichotomique est en O(log(n))O(log(n))O(log(n)).  (où logloglog est le logarithme en base 2 et pas lnlnln qui est le logarithme népérien)  En effet, à chaque itération, on divise le tableau en deux parties égales, ce qui permet de réduire la taille du tableau à chaque itération.  On peut donc calculer le nombre d'itérations nécessaires pour trouver la valeur recherchée en fonction de la taille du tableau.  Par exemple, pour un tableau de taille 8, on va effectuer au maximum 3 itérations pour trouver la valeur recherchée.  On divise le tableau en deux parties égales, on ne garde que la partie qui contient la valeur recherchée, soit 4 éléments.On divise le tableau en deux parties égales, on ne garde que la partie qui contient la valeur recherchée, soit 2 éléments.In reste 2 elements (dernière itération). On garde la valeur recherchée.  Ce qui fait un total de log2(8)=3log_2(8) = 3log2​(8)=3 itérations.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#résumé","content":" Les algorithmes de tri sont très importants en informatique, car ils permettent de trier des données, ce qui est une opération très courante.La complexité d'un algorithme est une mesure de la quantité de ressources (temps, mémoire, etc) que celui-ci va utiliser pour s'exécuter.La complexité en temps permet de quantifier la relation entre les conditions de départ (nombre d'éléments du tableau, valeurs des éléments, etc) et le temps effectué par l'algorithme.La complexité permet de savoir quel algorithme est le plus efficace quand on a un très grand nombre de données, mais ne permet pas de savoir si un algorithme est rapide ou lent pour un petit nombre de données (un algorithme avec une complexité en O(n2)O(n^2)O(n2) peut être plus rapide qu'un algorithme avec une complexité en O(n×log(n))O(n \\times log(n))O(n×log(n)) pour un petit nombre de données).Nous avons vu les algorithmes de tri suivants: Tri par sélection (selection sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par recherche successive du plus petit élément du tableau. Tri à bulles (bubble sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par comparaison successive de deux éléments consécutifs du tableau. Tri fusion (merge sort): O(n×log(n))O(n \\times log(n))O(n×log(n)) C'est un algorithme qui fonctionne par récursion en divisant le tableau en deux parties égales, en triant les deux parties, puis en fusionnant les deux parties triées. Tri rapide (quick sort): O(n×log(n))O(n \\times log(n))O(n×log(n)) C'est un algorithme qui fonctionne par récursion en choisissant un pivot, en divisant le tableau en deux parties en fonction du pivot, puis en triant les deux parties. Tri par dénombrement (counting sort): O(n)O(n)O(n) C'est un algorithme qui fonctionne en comptant le nombre d'occurrences de chaque valeur, puis en reconstruisant le tableau en plaçant les valeurs dans l'ordre. C'est un algorithme qui ne fonctionne que pour des données entières et où la valeur maximale des données est connue à l'avance et relativement petite. La recherche dichotomique est une méthode de recherche dans un tableau trié qui consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l'opération jusqu'à trouver la valeur souhaitée. ","version":"Next","tagName":"h2"},{"title":"TD7 - Structures","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 : déplacements​","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-1--déplacements","content":" Vous êtes le pilote d'un sous-marin, vous avez reçu des ordres de mouvement sous la forme d'une instruction et d'une distance à parcourir. Vous devez écrire un programme qui permet de calculer la position du sous-marin après avoir effectué les mouvements reçus.  Votre position initiale est (0, 0) et vous pouvez vous déplacer dans les directions suivantes: Up, Down, Forward, Backward.  Écrire une structure Position qui permet de stocker les coordonnées du sous-marin. Écrire un enum Direction qui permet de stocker les directions possibles. Écrire une structure Move qui représente un mouvement sous la forme d'une direction et d'une distance à parcourir. Écrire une fonction moveSubmarine qui permet de déplacer le sous-marin en fonction d'un mouvement. La fonction ne doit rien retourner et doit modifier la position du sous-marin passée en paramètre. Écrire une fonction display qui permet d'afficher la position du sous-marin passée en paramètre.  Le but est d'indiquer la position du sous-marin après avoir effectué les mouvements suivants:  Forward 10Down 5Backward 3Up 2Forward 5Down 1Backward 2Forward 3Down 1Up 3Forward 1Down 5Backward 2Forward 6  Vous pouvez représenter les mouvements sous la forme d'un vecteur de Move:  std::vector&lt;Move&gt; moves = { {Direction::Forward, 10}, {Direction::Down, 5}, {Direction::Backward, 3}, {Direction::Up, 2}, {Direction::Forward, 5}, {Direction::Down, 1}, {Direction::Backward, 2}, {Direction::Forward, 3}, {Direction::Down, 1}, {Direction::Up, 3}, {Direction::Forward, 1}, {Direction::Down, 5}, {Direction::Backward, 2}, {Direction::Forward, 6} };   (BONUS) Ajouter une structure Submarine qui contient une position (structure Position), une direction(enum Direction) et une méthode move qui permet de déplacer le sous-marin en fonction d'un mouvement.  info Exercice inspiré de de l'édition 2021 de l'advent of code: https://adventofcode.com/2021/day/2  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 : combats de Pokémons​","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-2--combats-de-pokémons","content":" Un pokémon a un Nom, des Points de Vie, une Attaque et une Vitesse. Un combat entre deux Pokémons se déroule ainsi:  À chaque tour, le pokémon avec la plus grande vitesse commence (si égalité, on choisit au hasard lequel de deux commence ce tour)Le pokémon attaquant réduit les Points de Vie de l'autre d'un montant égal à son attaque. Puis, si le deuxième pokémon n'est pas encore KO (Points de Vie encore &gt; 0), il attaque à son tour.  Faites une structure représentant un Pokémon, puis écrivez une fonction faisant le combat entre deux Pokémons. Par exemple:  Pokemon pokemon1{&quot;Poke1&quot;, 50, 10, 8}; Pokemon pokemon2{&quot;Poke2&quot;, 30, 20, 3}; combat(pokemon1, pokemon2);   doit afficher :  Tour 1: Poke1 attaque, il reste 20 PV à Poke2. Poke2 attaque, il reste 30 PV à Poke1. Tour 2: Poke1 attaque, il reste 10 PV à Poke2. Poke2 attaque, il reste 10 PV à Poke1. Tour 3: Poke1 attaque, il reste 0 PV à Poke2. Poke2 est KO, il ne peut pas attaquer. Poke1 gagne!   Un dresseur a un Nom et 3 pokémons. Dans un combat entre deux dresseurs, ils font combattre leurs pokémons les uns après les autres, jusqu'à ce que tous les pokémons d'un des dresseurs soient KOs.   Créer une structure Dresseur et une surcharge de la fonction combat pour faire combattre deux dresseurs.   Par exemple:  Dresseur dresseur1{&quot;Dresseur1&quot;, .pokemons = { Pokemon{&quot;Dresseur1_Poke1&quot;, 5, 10, 8}, Pokemon{&quot;Dresseur1_Poke2&quot;, 5, 10, 8}, Pokemon{&quot;Dresseur1_Poke3&quot;, 5, 10, 8}, }}; Dresseur dresseur2{&quot;Dresseur2&quot;, .pokemons = { Pokemon{&quot;Dresseur2_Poke1&quot;, 20, 10, 3}, Pokemon{&quot;Dresseur2_Poke2&quot;, 20, 10, 3}, Pokemon{&quot;Dresseur2_Poke3&quot;, 20, 10, 3}, }}; combat(dresseur1, dresseur2);   doit afficher par exemple :  Tour 1: Dresseur1_Poke1 attaque, il reste 10 PV à Dresseur2_Poke1. Dresseur2_Poke1 attaque, il reste 0 PV à Dresseur1_Poke1. Dresseur2_Poke1 gagne! Tour 2: Dresseur1_Poke2 attaque, il reste 0 PV à Dresseur2_Poke1. Dresseur2_Poke1 est KO, il ne peut pas attaquer. Dresseur1_Poke2 gagne! Tour 3: Dresseur1_Poke2 attaque, il reste 10 PV à Dresseur2_Poke2. Dresseur2_Poke2 attaque, il reste 0 PV à Dresseur1_Poke2. Dresseur2_Poke2 gagne! etc... Dresseur 2 a gagné!  ","version":"Next","tagName":"h2"},{"title":"TD2 - Variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (opérations)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-1-opérations","content":" Créer une variable de type int et initialiser la avec une valeur de votre choix. Appliquer les opérations suivantes sur cette variable et afficher le résultat de chaque opération: Incrémenter la variable de 1 (avec la méthode de votre choix).Multiplier la variable par 3.Diviser la variable par 2.  astuce Utiliser la fonction std::cout pour afficher la valeur de la variable.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (entrée utilisateur)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-2-entrée-utilisateur","content":" Créer un programme qui demande à l'utilisateur de saisir trois valeurs flottantes (de type float).  Calculer la somme de ces trois valeurs et stocker le résultat dans une variable de type float.Calculer de même la moyenne de ces trois valeurs.Afficher le résultat de la somme et de la moyenne.  astuce Utiliser la fonction std::cin pour lire la valeur saisie par l'utilisateur.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (cast)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-3-cast","content":" Créer une variable entière (de type int) et l'initialiser avec la valeur 11. Afficher la valeur de cette variable. Afficher la valeur de cette variable divisée par 2.  Vous devriez obtenir une valeur de 5 et non 5.5. Pourquoi ?  Utiliser un cast pour convertir la variable en un type flottant. Afficher la valeur de la variable divisée par 2.0f  astuce static_cast&lt;type&gt;(variable) permet convertir une variable en un autre type.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (conversion)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-4-conversion","content":" Écrire un programme qui demande un nombre de jours à l'utilisateur et affiche le nombre d'années, de mois et de jours correspondant à ce nombre de jours.  L’aﬀichage se fera sous la forme : &quot;J jours correspondent à: xx siecle xx annee xx mois xx semaine xx jours&quot;  info Pour simplifier le problème, on considérera que tous les mois ont 30 jours et toutes les années 360 jours.  exemple d'exécution Entrez un nombre de jours : 4096 4096 jours correspondent à : 0 siecle 11 annee 4 mois 2 semaine 2 jours   ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (ASCII)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-5-ascii","content":" Demander à l'utilisateur de saisir un nombre entier entre 1 et 26 et afficher la lettre correspondante dans l'alphabet.  exemple d'exécution Entrez un nombre entre 1 et 26 : 5 La lettre correspondante est : E   info Le type char permet de stocker un caractère. Il est possible de faire des opérations sur les caractères comme si c'était des entiers. Le code ASCII associe les caractères à des entiers. Par exemple, le caractère 'A' est associé à l'entier 65, 'B' à 66, etc. En ce qui nous concerne, nous allons utiliser le fait que les lettres majuscules sont associées aux entiers de 65 à 90 et les lettres minuscules aux entiers de 97 à 122. Vous pouvez trouver la table de correspondance ASCII complète ici.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (problème de compilation et d'exécution)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-6-problème-de-compilation-et-dexécution","content":" #include &lt;iotream&gt; int main() { float const pi {3.141592} int a {pi*3}; // je veux le résultat de pi (environ 3.141592) fois 3 int const b {8}; a += &quot;20&quot;; // je veux ajouter le nombre 20 à la valeur de a b = b * 15; // je veux modifier la valeur de b en la multipliant par 15 std::cout &lt;&lt; &quot;a: &quot; &lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl return 0; }   Vérifier que le code ne compile pas et essayez de corriger les erreurs.  ","version":"Next","tagName":"h2"},{"title":"Exercices Bonus​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercices-bonus","content":" Cuisine Un cuisinier doit aller au marché pour récupérer ses légumes. Il a besoin de sacs de pommes de terre, de carottes et de salades. Vous avez les informations suivantes : Un sac de pommes de terre pèse 2kg.Le prix d'un kg de pommes de terre est de 1.5€.Une carotte pèse 150g.Le prix d'un kg de carottes est de 2.5€.Une salade coûte 1.2€. Écrire un programme qui demande à l'utilisateur de saisir le nombre de sacs de pommes de terre, de carottes et de salades qu'il souhaite acheter. Le programme doit ensuite calculer le prix total de la commande et l'afficher. exemple d'exécution Entrez le nombre de sacs de pommes de terre : 2 Entrez le nombre de carottes : 3 Entrez le nombre de salades : 1 Le prix total de la commande est de 8.325 € Bonus En bonus, afficher le détail de la commande. ... Le prix total de la commande est de 8.325 € détails: - 2 sacs de pommes de terre : 6 € - 3 carottes : 1.125 € - 1 salade : 1.2 €  ","version":"Next","tagName":"h2"},{"title":"TD1 - Mise en place","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Setup","content":"","keywords":"","version":"Next"},{"title":"Premier programme​","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#premier-programme","content":" Une fois que vous avez installé les outils, vous pouvez créer votre premier programme.  Je vous invite à regarder la page suivante pour avoir les instructions : Premier programme  ","version":"Next","tagName":"h2"},{"title":"Plusieurs exécutables​","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#plusieurs-exécutables","content":" Comme je l'ai expliqué, il ne doit y avoir qu'un seul point d'entrée dans un programme C++ et donc une seule fonction main.  Cependant, dans le cadre des TDs, il est parfois utile de pouvoir tester plusieurs fonctions main différentes, une par exercice par exemple.  Pour cela, nous allons utiliser une fonctionnalité de CMake qui permet de créer plusieures targets ou exécutables.  Je vous invite à créer deux fichiers td01_ex01.cpp et td01_ex02.cpp dans un dossier src et à y mettre le contenu suivant :  src/td01_ex01.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 01&quot; &lt;&lt; std::endl; return 0; }   src/td01_ex02.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 02&quot; &lt;&lt; std::endl; return 0; }   Ensuite, nous allons créer un fichier CMakeLists.txt à la racine du projet avec le contenu suivant :  CMakeLists.txt cmake_minimum_required(VERSION 3.0) set(CMAKE_CXX_STANDARD 17) project(TD01) # On indique que l'on veut créer un exécutable &quot;ex01&quot; compilé à partir du fichier td01_ex01.cpp add_executable(ex01 src/td01_ex01.cpp) # On indique que l'on veut créer un exécutable &quot;ex02&quot; compilé à partir du fichier td01_ex02.cpp add_executable(ex02 src/td01_ex02.cpp)   Vous devriez avoir une arborescence de fichiers qui ressemble à ça:  td01 ├── CMakeLists.txt └── src ├── td01_ex01.cpp └── td01_ex02.cpp   Ouvrez ensuite le dossier td01 avec VSCode, il devrait vous proposer de configurer CMake comme pour le premier programme.  Pour que CMake vous affiche la liste des différentes targets disponibles, il faut aller changer un paramètre : ouvrez les settings de VSCode, cherchez &quot;cmake visibility&quot; et mettez l'option à &quot;compact&quot; :  Vous devriez ensuite avoir deux targets dans la barre à droite du bouton &quot;Run&quot; en bas :    Cela vous permet de choisir quelle target vous voulez exécuter pour travailler sur plusieurs exécutables dans le même projet.  info C'est la même chose pour les tâches de compilation (à droite du bouton &quot;Build&quot;).  Bravo, vous êtes maintenant prêt à faire du C++ sur vos propres machines ! 🥳  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin avec CMake​","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#pour-aller-plus-loin-avec-cmake","content":" Pour en apprendre plus sur CMake, vous pouvez aller lire ce petit cours sur CMake (au moins jusqu'aux sections Setting your C++ version et GLOB).  Il vous apprendra notamment ce que c'est qu'une target dans CMake, et quelles sont les bonnes pratiques autour des targets pour écrire un CMake qui marche bien.  Une fois que vous aurez lu ce cours, vous pouvez reprendre le CMake que vous avez écrit précédemment dans ce TP, et essayer de l'améliorer grâce à ce que vous avez appris. Vous pouvez notamment remplacer le set(CMAKE_CXX_STANDARD 17), et aussi éviter de devoir lister manuellement tous les fichiers .cpp de votre projet (certes vous n'en avez qu'un par target pour l'instant, mais le jour où vous en aurez plusieurs vous serez bien contents de ne pas avoir à tous les lister un par un). ","version":"Next","tagName":"h2"},{"title":"TD4 - Déduction de type et bibliothèque standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Vector and Algorithm)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-1-vector-and-algorithm","content":" Remplir un std::vector avec des nombres entiers aléatoires compris entre 0 et 100.Utiliser les itérateurs et les méthodes begin et end pour afficher les valeurs du vecteur à l'aide d'une boucle for.Chercher si un nombre saisi par l'utilisateur est présent dans le vecteur à l'aide de la fonction std::find et afficher un message adapté.Utiliser la fonction std::count pour compter le nombre d'occurrences d'un nombre entier dans le vecteur. Vous pouvez trouver la documentation de la fonction std::count ici.Utiliser la fonction std::sort pour trier le vecteur.Utiliser la fonction std::accumulate pour calculer la somme des éléments du vecteur (par défaut, la fonction std::accumulate utilise l'opérateur + entre les éléments).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (String)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-2-string","content":" Étant donnée une phrase composée de mots séparés par des espaces.  Nous avons utilisé dans le TD précédent une astuce avec les stream C++ qui permet de séparer les mots d'une phrase. L'idée est de coder une autre façon d'arriver au même résultat sans utiliser les stream.  Je vous donne la fonction lambda suivante qui permet de savoir si un caractère est un espace:  auto const is_space = [](char letter){ return letter == ' '; };   Le mot clé auto ici permet de &quot;stocker&quot; la fonction dans une variable pour la passé en paramètre. En réalité se cache derrière des pointeur de fonction ou le type std::function qui permet d'avoir une variable qui représente une fonction comme cela.  Cela va permettre d'utiliser les fonctions std::find_if_not et find_if (qui retourne des itérateurs) pour rechercher ou non des espaces dans une chaîne de caractère.  Écrire une fonction (à l'aide des fonctions std::find et std::distance) qui prendre en paramètre une référence constante sur une std::string et qui retourne le nombre de lettres du premier mot de la phrase.  info Vous allez avoir besoin de la fonction std::distance, qui retourne la distance entre deux itérateurs, sous forme d’un nombre entier.  Écrire une fonction qui permet de découper la phrase en mots et de les stocker dans un std::vector de std::string. Voilà le prototype de la fonction :  std::vector&lt;std::string&gt; split_string(std::string const&amp; str);   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Palindrome)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-3-palindrome","content":" Écrire une fonction qui prend en paramètre une référence constante sur une std::string et qui retourne true si la chaîne de caractères est un palindrome (qui peut se lire dans les deux sens), false sinon.  Utiliser la fonctions std::equal pour comparer les valeurs de deux itérateurs. Utiliser les fonctions std::begin, std::end et std::rbegin, std::rend pour obtenir les itérateurs de début et de fin d'une chaîne de caractères et de sa version inversée.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin (lambda)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#pour-aller-plus-loin-lambda","content":" Écrire une fonction qui prend en paramètre un std::vector et retourne la somme du carré de ses éléments. Vous devez utiliser la fonction std::accumulate et une fonction lambda.Écrire une fonction qui prend en paramètre un std::vector et retourne le produit de ses éléments pairs. Vous ne devez pas filtrer les éléments du vecteur, mais utiliser une fonction lambda pour déterminer si un élément est pair ou non et si oui, le prendre en compte dans le produit. Vous devez utiliser la fonction std::accumulate et une fonction lambda. ","version":"Next","tagName":"h2"},{"title":"TD8 - Encodage et compression","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Run-length encoding)​","type":1,"pageTitle":"TD8 - Encodage et compression","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression#exercice-1-run-length-encoding","content":" Écrire une fonction qui prend en paramètre une chaîne de caractères composée uniquement de caractères alphabétiques et qui retourne une chaîne de caractères encodée en utilisant le run-length encoding. Par exemple, si la chaîne de caractères en entrée est AAAABBBCCDAA, la chaîne de caractères encodée est 4A3B2C1D2A. Écrire une fonction qui prend en paramètre une chaîne de caractères encodée en utilisant le run-length encoding et qui retourne la chaîne de caractères décodée. Améliorer la fonction précédente pour qu'elle puisse décoder une chaîne de caractères même si cette chaîne de caractères contient des nombres à plusieurs chiffres. Par exemple, si la chaîne de caractères en entrée est 12A3B2C1D2A, la chaîne de caractères décodée est AAAAAAAAAAAABBBCCDAA. Écrire une fonction qui permet d'encoder en utilisant un caractère spécial (caractère de contrôle) suivit d'un nombre pour indiquer le nombre de fois qu'un caractère doit être répété. Par exemple, en se donnant le caractère de contrôle *, si la chaîne de caractères en entrée est AAAABBBCCDAA, la chaîne de caractères encodée est *4A*3B*2CD*2A. Améliorer la fonction précédente pour rendre le caractère de contrôle paramétrable et retourner la chaîne de caractères originale si la longueur de la chaîne de caractères encodée est plus grande que la chaîne de caractères originale. Écrire une fonction qui permet de décoder une chaîne de caractères encodée en utilisant un caractère de contrôle.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Huffman encoding)​","type":1,"pageTitle":"TD8 - Encodage et compression","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression#exercice-2-huffman-encoding","content":" Écrire une fonction frequency qui prend en paramètre une chaîne de caractères et retourne un std::unordered_map&lt;char, size_t&gt; qui associe à chaque caractère le nombre d'occurrences de ce caractère dans la chaîne de caractères.  Donnons nous la structure suivante pour la suite de l'exercice:  struct Node { char character; size_t frequency; Node* left { nullptr }; Node* right { nullptr }; };   attention Ce warning s'adresse à ceux qui ont essayé d'utiliser des smart pointers (std::unique_ptr) sur le TD précédent sur les arbres binaires et qui souhaitent continuer à utiliser des smart pointers pour cet exercice. Ici, on ne veut pas utiliser de std::unique_ptr pour simplifier l'écriture des fonctions. En effet, l'utilisation de std::unique_ptr impose de passer par des std::move (notion que l'on a pas encore vu) pour transférer la propriété d'un pointeur intelligent. Cela rendrait l'écriture des fonctions plus complexe et cela nous forcerait même à créer notre propre file de priorité (priority_queue) pour pouvoir les utiliser dans une file de priorité. Ce n'est pas l'objet de cet exercice on se limitera donc à des pointeurs classiques.  Surcharger l'opérateur &lt; pour la structure Node de telle sorte que l'opérateur &lt; retourne true si la fréquence du nœud de gauche est inférieure à la fréquence du nœud de droite. Écrire une fonction createNode qui prend en paramètre un caractère et une fréquence et qui retourne un Node*. Écrire une fonction createSymbolNode qui prend en paramètre (par valeur) deux Node* et qui retourne un Node* dont le caractère est 0 et la fréquence est la somme des fréquences des deux nœuds passés en paramètre et les deux nœuds passés en paramètre sont les fils du nœud retourné. Cette fonction va être utilisée pour créer un nœud qui représente un &quot;symbole&quot; (un ensemble de caractères) et qui va être utilisé pour construire l'arbre de Huffman. Écrire une fonction build_huffman_tree qui prend en paramètre (référence constante) un std::unordered_map&lt;char, size_t&gt; et qui retourne un Node* qui représente l'arbre de Huffman. Cet arbre va être construit en utilisant une std::priority_queue qui va permettre de trier les nœuds (symboles) en fonction de leur fréquence. Pour construire l'arbre, on va retirer les deux nœuds de plus petite fréquence de la file de priorité, créer un nouveau nœud dont la fréquence est la somme des fréquences des deux nœuds retirés et dont les fils sont les deux nœuds retirés, et ajouter ce nouveau nœud à la file de priorité. Écrire une fonction build_encoding_table qui prend en paramètre le sommet de l'arbre de Huffman et qui retourne un std::unordered_map&lt;char, std::string&gt; qui associe à chaque caractère le code de Huffman correspondant.  Pour construire le code de Huffman, on va parcourir l'arbre de Huffman en ajoutant un 0 à une chaîne de caractère à chaque fois qu'on descend à gauche et un 1 à chaque fois qu'on descend à droite. On va s'arrêter lorsqu'on arrive à une feuille et on va associer la chaîne de caractère obtenue à la feuille.  Il faudra utiliser une fonction intermédiaire fill_encoding_table qui prend en paramètre un nœud, la chaîne de caractères associé avec représentation binaire du nœud et qui remplit ta table (std::unordered_map&lt;char, std::string&gt;) passé par référence. C'est cette fonction qui va être appelée récursivement pour parcourir l'arbre de Huffman et remplir la table.  Voila les signatures des fonctions:  void fill_encoding_table(Node const* node, std::unordered_map&lt;char, std::string&gt;&amp; table, std::string str); std::unordered_map&lt;char, std::string&gt; build_encoding_table(Node const* root);   Écrire une fonction encode qui prend en paramètre une chaîne de caractères et un std::unordered_map&lt;char, std::string&gt; et qui retourne une chaîne de caractères représentant la chaîne de caractères encodée en utilisant le code de Huffman.  std::string encode(std::string str, std::unordered_map&lt;char, std::string&gt; const&amp; table);   Écrire une fonction decode qui prend en paramètre une chaîne de caractères encodée en utilisant le code de Huffman et le sommet de l'arbre de Huffman et qui retourne une chaîne de caractères représentant la chaîne de caractères décodée.  std::string decode(std::string const&amp; str, Node const* huffman_tree_root);   Écrire une fonction delete_huffman_tree qui prend en paramètre le sommet de l'arbre de Huffman et qui libère la mémoire allouée pour l'arbre.  Culture - Aller plus loin:  Dans la réalité, on ne souhaite pas encoder le caractères a par une chaîne de caractère (par exemple 110). Sinon on se retrouverait avec une chaîne de caractères plus grande que la chaîne de caractères originale. On va plutôt utiliser des bits. Par exemple, on va encoder le caractère a par les bits 110 (soit le nombre 6 en décimal).  Pour faire cela il faut manipuler des bits. En C++, on peut manipuler des bits en utilisant les opérateurs &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite), | (ou binaire), &amp; (et binaire), ^ (ou exclusif binaire), ~ (non binaire).  Pour ensuite pouvoir écrire en binaire dans un fichier on va utiliser des octets. Un octet est un ensemble de 8 bits. En C++, on peut manipuler des octets en utilisant le type unsigned char (ou uint8_t).  Ensuite, au lieu de retourner une chaîne de caractères, on va retourner un std::vector&lt;uint8_t&gt; qui contient les octets composés des bits de chaque caractère mis bout à bout. C'est un jeu d'operation binaire et de décalage qui permet de mettre bout à bout les octets pour obtenir la représentation binaire de la chaîne de caractères encodée.  On obtient ensuite un std::vector&lt;uint8_t&gt; qui contient la représentation binaire de la chaîne de caractères encodée. On peut ensuite écrire cet std::vector&lt;uint8_t&gt; dans un fichier.    Si l'on souhaite faire un programme qui compresse de bout en bout une chaîne de caractères dans un fichier, il faut pouvoir écrire dans un fichier la représentation binaire de la chaîne de caractères encodée. Pour cela, on peut utiliser la classe std::ofstream qui permet d'écrire dans un fichier. Il suffira d'écrire octet par octet dans le fichier.  Afin, de pouvoir décoder ce fichier, il faut pouvoir lire les octets du fichier et les transformer en une représentation binaire. Cela se fait en utilisant la classe std::ifstream qui permet de lire dans un fichier. Il suffira de lire octet par octet et de transformer chaque octet en une représentation binaire.  Enfin, pour décoder totalement et retrouver la chaîne originale, il faut non seulement avoir la représentation binaire de la chaîne de caractères encodée, mais également avoir l'arbre de Huffman pour pouvoir décoder la représentation binaire en caractères et ainsi retrouver la chaîne de caractères originale. Il faudra donc ajouter à ce fichier la représentation de l'arbre de Huffman pour pouvoir décoder totalement la chaîne de caractères encodée.  Je ne vous demande pas de faire cela, mais c'est pour vous donner une idée de ce à quoi cela peut servir en pratique et comment cela peut être utilisé. ","version":"Next","tagName":"h2"},{"title":"TD2 - Structures de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Evaluation NPI)​","type":1,"pageTitle":"TD2 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-1-evaluation-npi","content":" La notation polonaise inversée (NPI) est une notation mathématique qui permet d'exprimer des expressions arithmétiques sans utiliser de parenthèses. Elle a été inventée par le mathématicien polonais Jan Lukasiewicz en 1924.  La notation polonaise inversée est une notation postfixe, c'est-à-dire que l'opérateur est placé après les deux opérandes. Par exemple, l'expression 3 + 4 s'écrit 3 4 + en NPI.  Ce qui permet ensuite d'interpréter l'expression de gauche à droite, en empilant les opérandes sur une pile, et en déclenchant l'opération lorsque l'on rencontre un opérateur.  Par exemple, l'expression 3 4 + s'interprète comme suit :  On empile 3On empile 4On rencontre +, on dépile 4 et 3, on calcule 3 + 4 = 7, et on empile le résultat 7On a terminé, le résultat est 7  On va donc pouvoir se servir d'une pile(std::stack) pour évaluer une expression en NPI.  info Il faut cependant faire attention aux opérateurs non commutatifs, comme - ou /. 3 4 / ne s'interprète pas comme 4 / 3, mais comme 3 / 4. Il faut donc écrire 3 4 / pour évaluer 3 / 4. Dans l'algorithmique de l'évaluation, le premier élément défilé de la pile sera l'opérande de droite et le deuxième élément défilé sera l'opérande de gauche.  Le but de cet exercice est d'écrire un programme qui permet d'évaluer une expression en NPI sous forme d'une chaîne de caractères (les différents éléments de l'expression sont séparés par des espaces), et retourner le résultat de l'expression.  remarque Par simplicité, on se limitera à des expressions contenant des nombres (flottants), et les opérateurs +, -, * et / (Dans une expression en NPI il y a plus de parenthèses (( et ) car l'ordre des opérations est déterminé par l'ordre des opérateurs dans l'expression).  Écrire un programme qui permet de saisir une expression arithmétique en notation polonaise inversée (NPI) en tant que chaîne de caractère. On veut que les éléments de cette expression soient séparés par des espaces.  astuce Vous pouvez utiliser getline pour récupérer d'un flux (comme std::cin) une chaîne de caractères comportant des espaces.  Je vous donne le code suivant qui permet à l'aide d'une particularité des streams de séparer les éléments(mots) de la chaîne de caractères en utilisant les espaces comme séparateurs:  #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iterator&gt; std::vector&lt;std::string&gt; split_string(std::string const&amp; s) { std::istringstream in(s); // transforme une chaîne en flux de caractères, cela simule un flux comme l'est std::cin // l’itérateur va lire chaque element de &quot;in&quot;, comme un flux d'entrée, chaque élément est séparé par un espace return std::vector&lt;std::string&gt;(std::istream_iterator&lt;std::string&gt;(in), std::istream_iterator&lt;std::string&gt;()); }   Utilisez ce code pour séparer les éléments de l'expression en NPI entrée par l'utilisateur et créer un std::vector&lt;std::string&gt; qui représenterons les éléments (tokens) de l'expression en NPI.  Écrire une fonction qui prends une chaîne de caractères et permet de dire si celle-ci représente un nombre flottant ou non. On utilisera le prototype suivant:  bool is_floating(std::string const&amp; s);   astuce Pour y arriver il faut parcourir la chaîne de caractères et de tester si chaque caractère est un chiffre ou un point . (pour gérer les nombres flottants). Si c'est le cas, on continue, sinon on retourne false. Vous pouvez utiliser la fonction std::isdigit de la bibliothèque &lt;cctype&gt; qui permet de tester si un caractère représente un chiffre.  Cela va être utile pour distinguer si un token (sous forme d'une chaîne de caractère) est un nombre(opérandes) ou un opérateur dans l'expression en NPI.  solution C++17 Il existe une fonction plus récente qui permet de faire cela, la fonction std::from_chars de la bibliothèque &lt;charconv&gt;. Elle permet de convertir une chaîne de caractères en nombre, et de retourner un pointeur sur le premier caractère non converti, ainsi qu'un code d'erreur si la conversion a échoué. #include &lt;system_error&gt; #include &lt;charconv&gt; #include &lt;string&gt; bool is_floating(std::string const&amp; s) { float value; auto [p, ec] = std::from_chars(s.data(), s.data() + s.size(), value); return ec == std::errc() &amp;&amp; p == s.data() + s.size(); } Vous pouvez utiliser cette fonction si vous le souhaitez pour confirmer votre solution. Mais il est important de faire soit même l'implémentation de la fonction is_floating pour apprendre à manipuler les chaînes de caractères.  Écrire une fonction qui prend en paramètre un vecteur de chaînes de caractères représentant les tokens de l'expression en NPI, et qui retourne le résultat de l'expression.  On utilisera le prototype suivant:  float npi_evaluate(std::vector&lt;std::string&gt; const&amp; tokens);   Utilisez une pile (std::stack) pour évaluer l'expression comme dans l'exemple précédent.  Fonctionnement de l'algorithme L'algorithme va parcourir les éléments de l'expression en NPI (tokens) de gauche à droite. Lorsque l'on rencontre un nombre, on l'empile sur la pile des valeurs.Lorsque l'on rencontre un opérateur, on dépile les deux derniers nombres, on effectue l'opération, et on empile le résultat. Voilà un bout de code pour vous aider dans cette étape pour effectuer une opération: // Je récupère l'élément en haut de la pile float rightOperand { stack.top() }; // Je l'enlève de la stack (la méthode top ne fait que lire l’élément en dessus de la pile) stack.pop(); float leftOperand { stack.top() }; stack.pop(); // Il faut ensuite en fonction de l'opérateur calculer le résultat pour le remettre dans la pile float result { /* TODO */}; stack.push(result); l'algorithme se termine lorsque l'on a parcouru tous les éléments de l'expression, et que la pile ne contient plus qu'un seul élément, qui est le résultat de l'expression.  Expression invalide Si il reste plus d'un élément dans la pile à la fin de l'algorithme, cela signifie que l'expression en NPI est invalide. En effet, si l'expression est correcte, il ne doit rester qu'un seul élément dans la pile. Chaque opérateur binaire s'applique à deux nombres ainsi il doit normalement y avoir pour nnn nombres dans l'expression n−1n-1n−1 opérateurs.  astuce En utilisant la fonction is_floating de la question précédente, on peut déterminer si un élément de l'expression est un nombre ou un opérateur. Il faut ensuite utiliser la fonction std::stof de la bibliothèque &lt;string&gt; pour convertir la chaîne de caractères en nombre flottant si c'est le cas.  Enfin, utiliser les fonctions précédentes pour afficher le résultat d'une expression en NPI entrée par l'utilisateur.  Vous pouvez tester avec les expressions suivantes:  3 + 4 =&gt; 3 4 + = 72 + 12 + 5 =&gt; 2 12 + 5 + = 193 + 4 / ( 11 + 5 ) =&gt; 3 4 11 5 + / + = 3.254 + 5 * 2 =&gt; 4 5 2 * + = 14  (une plus complexe avec l'opérateur puissance en plus pour l'exemple si vous voulez ajouter cette fonctionnalité plus tard)  3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 =&gt; 3 4 2 ^ 1 5 - 6 ^ / + = 3.00391  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utiliser une structure et des énumérations)​","type":1,"pageTitle":"TD2 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-2-utiliser-une-structure-et-des-énumérations","content":" Le but est de réécrire le programme précédent en utilisant un enum pour représenter les différents opérateurs ainsi qu'une structure pour représenter un token (un élément de l'expression) avec un champ pour le type (opérateur ou opérande) et des champs pour les valeurs (opérateur ou opérande).  enum class Operator { ADD, SUB, MUL, DIV, OPEN_PAREN, CLOSE_PAREN}; enum class TokenType { OPERATOR, OPERAND }; struct Token { TokenType type; float value; Operator op; };   info Il existe des fonctionnalités plus avancés qui permettraient de faire ça plus proprement, et de se passer de l'enum TokenType dans la structure Token (les variantes). Vous pouvez vous renseigner ou me demander si vous voulez en savoir plus.  Créer deux fonctions (surchargées) qui permettent de construire la structure Token à partir d'un nombre flottant ou de la valeur de l’énumération Operator.  Token make_token(float value) Token make_token(Operator op);   Créer une fonction tokenize qui prends en paramètre un vecteur de chaîne de caractères (représentant les &quot;mots&quot; d'une phrase, nos anciens tokens) et retourne un vecteur de Token.  std::vector&lt;Token&gt; tokenize(std::vector&lt;std::string&gt; const&amp; words);   Créer une nouvelle fonction npi_evaluate qui utilise cette fois un vecteur de Token au lieu de manipuler directement des chaînes de caractères.  float npi_evaluate(std::vector&lt;Token&gt; const&amp; tokens);   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Conversion en NPI) (Optionnel)​","type":1,"pageTitle":"TD2 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-3-conversion-en-npi-optionnel","content":" Nous avons précédemment vu comment évaluer une expression en NPI. Mais comment faire pour convertir une expression en notation infixe (c'est-à-dire de manière &quot;classique&quot; avec des parenthèses) en une expression en NPI ?  Pour cela, il existe un algorithme appelé Shunting-yard algorithm (littéralement &quot;algorithme de la cour de triage&quot;).  Son principe est d'utiliser également une pile pour stocker les opérateurs rencontrés, et de les dépiler lorsque l'on rencontre un opérateur de priorité supérieure.  Voilà comment il fonctionne :  On parcourt l'expression de gauche à droite Si on rencontre un nombre, on l'ajoute à la sortie Si on rencontre un opérateur: Si on rencontre une parenthèse ouvrante ((), on la met sur la pile des opérateursSi on rencontre une parenthèse fermante ()), on dépile les opérateurs jusqu'à ce qu'on rencontre une parenthèse ouvrante, et on ajoute les opérateurs défilés à la sortieTant qu'il y a un opérateur sur la pile des opérateurs de priorité supérieure ou égale à l'opérateur courant, on dépile les opérateurs et on les ajoute à la sortie. Puis on ajoute l'opérateur courant à la pile des opérateurs. Enfin, on dépile les opérateurs restants et on les ajoute à la sortie.  Voici un exemple d'application de l'algorithme avec l'expression 3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 :  Entrée\tSortie\tPile des opérateurs\tcommentaire3\t3 on ajoute 3 à la sortie +\t3\t+\ton ajoute + à la pile des opérateurs 4\t3 4\t+\ton ajoute 4 à la sortie ^\t3 4\t+ ^\ton ajoute ^ à la pile des opérateurs 2\t3 4 2\t+ ^\ton ajoute 2 à la sortie /\t3 4 2 ^\t+\ton dépile ^ et on l'ajoute à la sortie car / a une priorité inférieure à ^ (\t3 4 2 ^\t+ / (\ton ajoute ( à la pile des opérateurs 1\t3 4 2 ^ 1\t+ / (\ton ajoute 1 à la sortie -\t3 4 2 ^ 1\t+ / ( -\ton ajoute - à la pile des opérateurs 5\t3 4 2 ^ 1 5\t+ / ( -\ton ajoute 5 à la sortie )\t3 4 2 ^ 1 5 -\t+ /\ton dépile les opérateurs jusqu'à ( et on les ajoute à la sortie ^\t3 4 2 ^ 1 5 -\t+ / ^\ton ajoute ^ à la pile des opérateurs 6\t3 4 2 ^ 1 5 - 6\t+ / ^\ton ajoute 6 à la sortie 3 4 2 ^ 1 5 - 6 ^\t+ /\ton dépile le reste des opérateurs et on les ajoute à la sortie  Résultat final : 3 4 2 ^ 1 5 - 6 ^ / +  info La suite de l'exercice est présenté en utilisant les fonctions et structures de l'exercice précédent. Si vous n'avez pas fait l'exercice 2 vous pouvez tout aussi bien travailler avec un vecteur de chaînes de caractères sans utiliser la structure Token.  Écrire une fonction operator_precedence qui prends en paramètre un Operator et retour sous forme d'un nombre entier positif la priorité de cet opérateur.  size_t operator_precedence(Operator const op);   Écrire une fonction qui prend en paramètre une chaîne de caractères représentant une expression en notation infixe, qui retourne un tableau de Token représentant l'expression en NPI.  std::vector&lt;Token&gt; infix_to_npi_tokens(std::string const&amp; expression);   astuce On utilisera la même structure Token que dans l'exercice précédent et les fonctions tokenize et split_string pour récupérer dans un premier temps une représentation de l'expression en notation infixe sous forme d'une liste de Token (dont les parenthèses ici). C'est ici que parenthèses en tant qu'opérateur vont être utile mais elles ne devrons pas se retrouver dans la liste de Token en NPI.  Maintenant que nous savons évaluer une expression en NPI et que nous savons convertir une expression en notation infixe en NPI, nous pouvons réaliser une calculatrice.  Essayez de réaliser un programme qui permet de lire une expression en notation infixe, de la convertir en NPI, de l'évaluer et d'afficher le résultat. ","version":"Next","tagName":"h2"},{"title":"TD7 - Graphes","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/graphs","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (construire un graphe)​","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#exercice-1-construire-un-graphe","content":" Implémenter la méthode add_vertex qui prend en paramètre un identifiant de sommet et ajoute un sommet au graphe si il n'existe pas déjà. Il faut donc tester si le sommet existe déjà avant de créer la liste des edges. (vous pouvez utiliser la méthode find de std::unordered_map pour cela). Implémenter la méthode add_directed_edge qui ajoute une arrête dans le graphe en prenant en paramètre les IDs des deux nœuds à connecter (source vers destination) et le poids de l'arrête.  remarque Si le nœuds de destination n'existe pas (comme clé du tableau associatif adjacency_list) il est possible et recommandé de l'ajouter au passage (en utilisant add_vertex). Ainsi, tout les sommets du graphe sont ajoutés automatiquement lors de l'ajout d'une arrête.  Implémenter la méthode add_undirected_edge en utilisant add_directed_edge pour ajouter deux edges dans les deux sens pour connecter deux nœuds passés en paramètre. Implémenter la fonction adjacency_list_from_adjacency_matrix qui prend en paramètre une matrice d'adjacence (sous la forme d'un vecteur de vecteurs d'entiers) et qui retourne un graphe.  Exemple Exemple pour le graphe suivant: Représenté par la matrice d'adjacence suivante: [0100200240000100000600000]\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 2 \\\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 6 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{bmatrix}​00000​10000​02000​04100​20060​​ la liste d'adjacence correspondante est la suivante: std::unordered_map&lt;int, std::vector&lt;WeightedGraphEdge&gt;&gt; adjacency_list { {0, {{1, 1.0f}, {4, 2.0f}}}, {1, {{2, 2.0f}, {3, 4.0f}}}, {2, {{3, 1.0f}}}, {3, {{4, 6.0f}}}, {4, {}}, };   Écrire dans la fonction main un exemple d'utilisation de la fonction adjacency_list_from_adjacency_matrix pour créer un graphe à partir d'une matrice d'adjacence et créer un deuxième graphe en utilisant les méthodes add_vertex et add_undirected_edge pour ajouter les mêmes sommets et les mêmes arrêtes que dans le premier graphe. Ensuite, comparer les deux graphes pour vérifier qu'ils sont égaux.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (traverser un graphe)​","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#exercice-2-traverser-un-graphe","content":" Implémenter la méthode print_DFS qui prend en paramètre l'id du sommet de départ et qui affiche les sommets du graphe en utilisant un parcours en profondeur (DFS) à partir du sommet de départ (depth-first search). Implémenter la méthode print_BFS qui utilise cette fois-ci un parcours en largeur (BFS) à partir du sommet de départ (breadth-first search). (Bonus) Implémenter le parcours en profondeur (BFS) à prenant en paramètre une fonction de callback pour chaque sommet visité. L'idée est de ne pas contraindre l'utilisateur à afficher les sommets mais de lui donner la possibilité de faire ce qu'il veut avec les sommets visités. Voilà la signature de la méthode à implémenter:  void DFS(int const start, std::function&lt;void(int const)&gt; const&amp; callback) const;   std::function (#include &lt;functional&gt;) est un objet qui peut &quot;stocker&quot; n'importe quelle fonction qui a la même signature que celle donnée en paramètre (entre &lt; et &gt; ). Cela permet de passer une fonction en paramètre d'une autre fonction. C'est très utile pour faire des fonctions génériques qui peuvent être utilisées de différentes manières. On peut passer en paramètre une fonction définit dans le code ou une fonction lambda (une fonction anonyme) qui est définie directement dans le code. C'est comme cela que fonctionne les fonctions std::sort, std::find_if, std::accumulate, ... de la STL.  Voilà à quoi ressemble l'appel de cette méthode avec une fonction lambda qui affiche les sommets visités (pour reproduire le comportement de la méthode print_DFS):  std::cout &lt;&lt; &quot;DFS from node 0:&quot; &lt;&lt; std::endl &lt;&lt; &quot;Visited nodes: &quot;; graph.DFS(0, [](int const node_id) { std::cout &lt;&lt; node_id &lt;&lt; &quot; &quot;; }); std::cout &lt;&lt; std::endl;   ","version":"Next","tagName":"h2"},{"title":"Dijkstra: algorithme de plus court chemin​","type":1,"pageTitle":"TD7 - Graphes","url":"/Learn--cpp_programming/TDs/S2/graphs#dijkstra-algorithme-de-plus-court-chemin","content":" L'algorithme de Dijkstra permet de trouver le plus court chemin entre un sommet de départ et un sommet d'arrivée dans un graphe pondéré.  Je vous invite à relire l'explication du cours ici;  Donnons nous le graphe suivant:    Écrivez les différentes étapes de l'algorithme de Dijkstra selon le même modèle que l'illustration du cours pour trouver le plus court chemin entre le sommet A et le sommet E.  (BONUS) En se donnant un bout de code pour démarrer l'implémentation de l'algorithme de Dijkstra, complétez le code pour implémenter l'algorithme de Dijkstra.(BONUS) Testez votre implémentation avec le graphe donné en exemple pour trouver le plus court chemin entre le sommet A et le sommet E.  std::unordered_map&lt;int, std::pair&lt;float, int&gt;&gt; dijkstra(WeightedGraph const&amp; graph, int const&amp; start, int const end) { // On crée un tableau associatif pour stocker les distances les plus courtes connues pour aller du sommet de départ à chaque sommet visité // La clé est l'identifiant du sommet et la valeur est un pair (distance, sommet précédent) std::unordered_map&lt;int, std::pair&lt;float, int&gt;&gt; distances {}; // On crée une file de priorité pour stocker les sommets à visiter // la pair contient la distance pour aller jusqu'au sommet et l'identifiant du sommet // Ce type compliqué permet d'indiquer que l'on souhaite trier les éléments par ordre croissant (std::greater) et donc les éléments les plus petits seront au début de la file (top) (Min heap) std::priority_queue&lt;std::pair&lt;float, int&gt;, std::vector&lt;std::pair&lt;float, int&gt;&gt;, std::greater&lt;std::pair&lt;float, int&gt;&gt;&gt; to_visit {}; // 1. On ajoute le sommet de départ à la liste des sommets à visiter avec une distance de 0 (on est déjà sur le sommet de départ) // Tant qu'il reste des sommets à visiter while (!to_visit.empty()) { // 2. On récupère le sommet le plus proche du sommet de départ dans la liste de priorité to_visit // 3.Si on atteins le point d'arrivé, on s'arrête if (/* TODO */) { return distances; } // 3. On parcoure la liste des voisins (grâce à la liste d'adjacence) du nœud courant for (/* TODO */) { // 4. on regarde si le nœud existe dans le tableau associatif (si oui il a déjà été visité) auto find_node { /* TODO */ }; bool const visited { /* TODO */ }; if (!visited) { // 5. Si le nœud n'a pas été visité, on l'ajoute au tableau associatif en calculant la distance pour aller jusqu'à ce nœud // la distance actuelle + le point de l'arrête) // 6. On ajout également le nœud de destination à la liste des nœud à visité (avec la distance également pour prioriser les nœuds les plus proches) }else { // 7. Si il a déjà été visité, On test si la distance dans le tableau associatif est plus grande // Si c'est le cas on à trouvé un plus court chemin, on met à jour le tableau associatif et on ajoute de nouveau le sommet de destination dans la liste à visité if (/* TODO */) { } } } } return distances; }  ","version":"Next","tagName":"h2"},{"title":"TD1 - Opérateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/operators","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (opérations)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-1-opérations","content":" Transformer les méthodes add, sub, mul et div en surcharge des opérateurs +, -, * et / pour pouvoir utiliser les opérateurs avec des fractions.  On peut appliquer une simplification sur les fractions retournées par les opérateurs pour éviter d'avoir des fractions non simplifiées.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (affichage)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-2-affichage","content":" Transformer la fonction display en surcharge de l'opérateur &lt;&lt; pour pouvoir afficher une fraction avec std::cout (opérateurs de flux).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (égalité)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-3-égalité","content":" Ajouter l'opérateur == pour comparer deux fractions.Ajouter l'opérateur != en se basant sur l'opérateur ==.  astuce Attention, cela ne fonctionnera pas si on compare deux fractions non simplifiées. (ex: 1/2 == 2/4) Une autre solution serait de simplifier les fractions dans l'opérateur avant de les comparer. Il existe une autre façon de faire en comparant les produits en croix des fractions: (ex: a/b == d/c &lt;=&gt; a * c == b * d)  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (comparaison)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-4-comparaison","content":" Ajouter l'opérateur &lt; pour comparer deux fractions.Ajouter les opérateurs &lt;=, &gt; et &gt;= en se basant sur l'opérateur &lt;.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (opérations d'affectation)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-5-opérations-daffectation","content":" Ajouter les opérateurs d'affectation +=, -=, *= et /=.Réécrire les opérateurs +, -, * et / en utilisant les opérateurs affectation afin d'éviter de dupliquer le code (deux-en-un) (Commenter l'ancienne version des opérateurs par exemple)  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (conversion)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-6-conversion","content":" Définir et implémenter une méthode to_float qui retourne la valeur de la fraction sous forme de float.  Il est aussi possible de définir des opérateurs de conversion pour convertir une fraction en un autre type.  la syntaxe est la suivante:  operator type() const { // code de conversion }   Ajouter l'opérateur de conversion float pour pouvoir convertir une fraction en float en utilisant la méthode to_float.  le prototype de la méthode pour notre structure Fraction sera le suivant:  Fraction::operator float() const;   Grâce à cet opérateur, on pourra convertir une fraction en float de la manière suivante:  Fraction f1 {1, 2}; float d1 {static_cast&lt;float&gt;(f1)}; // conversion explicite avec static_cast   remarque On pourrait très bien mettre directement le code de la conversion dans l'opérateur float sans passer par une méthode to_float. Mais je vous demande de le faire pour l'exercice et pour avoir la possibilité de réutiliser la méthode to_float ailleurs.  ","version":"Next","tagName":"h2"},{"title":"Aller plus loin​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#aller-plus-loin","content":" Ajouter des fonction libres pour les opérateurs +, -, * et / afin de pouvoir faire des opérations avec des fractions et des entiers. exemple: Fraction f1 {1, 2}; int i {2}; Fraction f2 {f1 + i}; Fraction operator+(Fraction const&amp; f, int const i); Fraction operator+(int const i, Fraction const&amp; f); astuce Pour que ce soit commutatif, il faut aussi définir la fonction avec l'entier en premier paramètre. Réutiliser la fonction précédente pour éviter de dupliquer le code. Ajouter des méthodes pour appliquer des opérations mathématiques sur les fractions. abs: valeur absolueceil: arrondi supérieurfloor: arrondi inférieurround: arrondi ","version":"Next","tagName":"h2"},{"title":"Arbres binaires de recherche","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/binaryTree","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Implémentation)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-1-implémentation","content":" Donnons nous pour commencer la structure suivante pour représenter un nœud d'un arbre binaire.  struct Node { int value; Node* left { nullptr }; Node* right { nullptr }; };   astuce Je vous conseil de créer un fichier node.hpp et d'y mettre la structure Node ainsi que le prototype des fonctions et méthodes que vous allez écrire. Avec une organisation de fichier comme celle-ci: src/ L main.cpp L node.hpp L node.cpp CmakeLists.txt   Affichage dans la console Je vous fourni une fonction qui permet d'afficher une représentation ASCII dans la console d'un arbre binaire: void pretty_print_left_right(Node const&amp; node, std::string const&amp; prefix, bool is_left) { if (node.right) { pretty_print_left_right(*node.right, prefix + (is_left ? &quot;| &quot; : &quot; &quot;), false); } std::cout &lt;&lt; prefix &lt;&lt; (is_left ? &quot;+-- &quot; : &quot;+-- &quot;) &lt;&lt; node.value &lt;&lt; std::endl; if (node.left) { pretty_print_left_right(*node.left, prefix + (is_left ? &quot; &quot; : &quot;| &quot;), true); } } void pretty_print_left_right(Node const&amp; node) { pretty_print_left_right(node, &quot;&quot;, true); }   Écrire une fonction create_node qui prend en paramètre une valeur et permet de créer (sur la heap avec new) un nœud contenant cette valeur et dont les fils sont pointeur nuls.  Node* create_node(int value);   Écrire une méthode is_leaf sur la structure Node qui retourne vrai si le nœud est une feuille (c'est à dire si ses deux fils sont nuls).  bool is_leaf() const;   Écrire une méthode insert à la structure Node qui prend en paramètre une valeur et qui insère un nouveau nœud contenant cette valeur dans l'arbre binaire. On insérera le nœud à gauche si la valeur est inférieure à la valeur du nœud courant et à droite sinon.  void Node::insert(int value);   astuce On utilisera la fonction create_node pour créer le nouveau nœud.  Écrire une méthode height qui retourne la hauteur de l'arbre binaire (c'est à dire la longueur du plus long chemin entre la racine et une feuille).  int Node::height() const;   astuce On peut utiliser de la récursivité pour calculer la hauteur de l'arbre.  Écrire une fonction delete_childs sur la structure Node qui permet de supprimer les fils d'un nœud (et de libérer la mémoire).  void Node::delete_childs();   astuce On peut utiliser de la récursivité pour supprimer les nœuds de l'arbre.  On va se donner la convention qu'un arbre binaire contenant un seul nœud a une hauteur de 1.  Écrire une méthode display_infixe qui affiche les valeurs des nœuds parcourus dans l'ordre infixe.  void Node::display_infixe() const;   Écrire une méthode prefixe qui retourne un vecteur contenant des pointeurs vers les nœuds de l'arbre binaire parcourus en prefixe.  std::vector&lt;Node const*&gt; Node::prefixe() const;   astuce Pour le faire par récursivité on pourra utiliser la méthode insert du std::vector qui permet d’insérer plusieurs éléments à l'aide d’itérateurs. auto left_nodes {left-&gt;infixe()}; nodes.insert(nodes.end(), left_nodes.begin(), left_nodes.end()); Cela va permettre de concaténer dans un seul vecteur les nœuds des sous arbres gauche et droit.  (BONUS) De même, écrire une autre méthode postfixe qui retournent les nœuds parcourus dans l'ordre postfixe.  BONUS: Itératif si tu le souhaites, tu peux essayer de le faire de manière itérative (sans récursivité). Pour faire cela tu peux utiliser une pile (std::stack) pour stocker les nœuds à parcourir. L'idée est de parcourir l'arbre en commençant par la racine (premier élément de la pile). Puis, de déplier un nœud de la pile, s'il a un fils droit, on le met dans la pile et on recommence. Sinon, s'il a un fils gauche, on le met dans la pile et on recommence. enfin s'il n'a pas de fils, on le traite (on peut l'ajouter à un vecteur par exemple). Il faut aussi faire attention à conserver un pointeur vers le nœud précédent afin de savoir si on remonte ou si on descend dans l'arbre. Exemple: Si on a l'arbre suivant: 5 / \\ 3 7 / \\ / \\ on va commencer par mettre le nœud 5 dans la pile. (le nœud précédent est nul) On va lire le nœud 5 et se rendre compte qu'il a un fils gauche, on le met dans la pile et on recommence (le nœud précédent est 5). On va lire le nœud 3 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le nœud précédent est 3). On va lire de nouveau le nœud 5 mais comme on a déjà traité le fils gauche (on le sait car le nœud précédent est le nœud 3), on va mettre le fils droit dans la pile et recommencer. (le nœud précédent devient 5). On va lire le nœud 7 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le nœud précédent est 7). On va lire de nouveau le nœud 5 mais comme on a déjà traité le fils droit (on le sait car le nœud précédent est le nœud 7), on va enfin traiter le nœud 5 et le retirer de la pile. Ce qui nous donne l'ordre postfixe: 3, 7, 5. C'est un peu plus compliqué que la version récursive mais c'est un bon exercice pour comprendre le fonctionnement des arbres binaires et des mécanismes de pile. Voilà un bout de code pour vous aider à démarrer: std::vector&lt;Node const*&gt; Node::postfixe() const { std::vector&lt;Node const*&gt; nodes {}; std::stack&lt;Node const*&gt; to_process {}; Node* previous {nullptr}; to_process.push(this); while (!to_process.empty()) { Node const* current { to_process.top() }; // Si on est en train de descendre dans l'arbre if (previous == nullptr || (previous-&gt;left == current || previous-&gt;right == current)) { if(/* ? */) { to_process.push(current-&gt;left); } else if(/* ? */) { // todo } else { // on traite le nœud (ajouter au vecteur) et on le retire de la pile // todo } // Si l'on remonte dans l'arbre en venant de la gauche }else if (/* ? */) { if(/* ? */) { // todo } else { // todo } // Si l'on remonte dans l'arbre en venant de la droite } else if (/* ? */) { // todo } previous = current; } return nodes; }   Écrire une fonction most_left qui retourne une référence vers le pointeur du nœud le plus à gauche de l'arbre binaire.   Node*&amp; most_left(Node*&amp; node);   ⚠️ Pourquoi retourner une référence vers un pointeur(*&amp;) ? Car on va ensuite utiliser cette fonction dans la fonction removeNode pour supprimer une valeur (donc un nœud) de l'arbre binaire. Mais dans certains cas on va devoir modifier le pointeur du nœud parent pour qu'il ne pointe plus vers le nœud que l'on veut supprimer. la référence va permettre de modifier directement le pointeur du nœud parent.  Écrire une fonction remove qui permet de supprimer une valeur de l'arbre binaire dont le nœud racine est passé en paramètre. La fonction retourne vrai si la valeur a été supprimée et faux sinon.  bool remove(Node*&amp; node, int value);   Prendre en paramètre une référence vers un pointeur permet de modifier directement le pointeur du nœud parent si le nœud est supprimé. C'est important dans le cas par exemple où l'on supprime une feuille de l'arbre il faut pouvoir réassigner le pointeur du nœud parent vers un pointeur nul pour éviter d'avoir un pointeur qui pointe vers un nœud supprimé.  if (value == node-&gt;value &amp;&amp; node-&gt;is_leaf()) { // On supprime le nœud courant delete node; // Comme on a une référence sur le pointeur du nœud courant, on le met à jour avec nullptr // Ainsi le parent du nœud courant aura un pointeur vers nullptr node = nullptr; // on retourne true car la suppression a été effectuée return true; }   astuce Il existe trois cas de figure lorsqu'on supprime un nœud d'un arbre binaire: Le nœud n'a pas de fils: on peut le supprimer directement (exemple précédent).Le nœud a un seul fils: on peut le supprimer et le remplacer par son fils.Le nœud a deux fils: Il faut remplacer la valeur du nœud à supprimer par une valeur préserver l'ordre de l'arbre. Pour cela, on utilisera la fonction most_left qui permettent de trouver le nœud le plus à gauche d'un arbre binaire (autrement dit, le nœud de valeur minimale). Il faut ensuite remplacer la valeur du nœud à supprimer par la valeur du nœud trouvé précédemment et supprimer ce dit nœud pour ne pas avoir de doublon. (cela revient à intervertir les deux nœuds sans avoir à modifier les pointeurs puis à supprimer le nœud dont la valeur a été copiée). Ce troisième cas est le plus compliqué à gérer. N'hésitez pas à demander de l'aide et prendre le temps de faire des schémas pour comprendre le fonctionnement. Il faudra utiliser la fonction most_left pour trouver le nœud le plus à gauche de l'arbre binaire.  attention Il faut faire attention à bien libérer la mémoire des nœuds supprimés.  Écrire une fonction delete_tree qui permet de supprimer un arbre binaire (et de libérer la mémoire).  void delete_tree(Node* node);   (BONUS) Écrire des méthodes min et max qui retournent respectivement les valeurs minimales et maximales de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utilisation)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-2-utilisation","content":" Testons maintenant notre implémentation en créant un programme qui permet de créer un arbre binaire et d'effectuer différentes opérations dessus.  Créer un arbre binaire et insérer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0. Afficher les valeurs des nœuds de l'arbre binaire dans l'ordre infixe. (BONUS) Afficher la valeur minimale et maximale de l'arbre. Afficher la somme des valeurs des nœuds de l'arbre binaire en utilisant la fonction prefixe qui retourne un vecteur contenant les nœuds parcourus dans l'ordre prefixe. Afficher la hauteur de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Aller plus loin​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Pointeurs intelligents) (Bonus)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-3-pointeurs-intelligents-bonus","content":" Nous allons maintenant améliorer et simplifier notre code en utilisant des pointeurs intelligents. En effet la partie la plus compliquée de notre code est la gestion de la mémoire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous débarrasser de cette gestion et de nous passer de la fonction delete_tree par exemple.  Copier coller votre fichier pour garder une version de votre code précédent et créer un nouveau fichier smartNode.hpp dans lequel vous allez réécrire votre code en utilisant des pointeurs intelligents. Renommer la structure Node en SmartNode pour pouvoir faire la différence entre les deux versions et remplacer les pointeurs &quot;bruts&quot; par des pointeurs intelligents std::unique_ptr dans la structure SmartNode.  Je vous donne le contenu du fichier smartNode.hpp:  #pragma once #include &lt;vector&gt; struct SmartNode { int value; std::unique_ptr&lt;SmartNode&gt; left { nullptr }; std::unique_ptr&lt;SmartNode&gt; right { nullptr }; bool is_leaf() const; void insert(int value); size_t height() const; int min() const; int max() const; }; std::unique_ptr&lt;SmartNode&gt; create_smart_node(int value); std::unique_ptr&lt;SmartNode&gt;&amp; SmartNode::most_left(std::unique_ptr&lt;SmartNode&gt;&amp; node); bool remove(std::unique_ptr&lt;SmartNode&gt;&amp; node, int value);   Modifier la fonction is_leaf pour utiliser le fait qu'un pointeur intelligent peut être converti implicitement en booléen (il vaut false si le pointeur est nul et true sinon).  std::unique_ptr&lt;float&gt; ptr {nullptr}; if (ptr) { // ptr est différent de nullptr } else { // ptr est égal à nullptr }   Renommer et modifier la fonction create_node (en create_smart_node) pour qu'elle retourne un pointeur intelligent std::unique_ptr au lieu d'un pointeur brut (on utilisera la fonction std::make_unique pour créer le pointeur).  Elle s'utilise de la manière suivante:  std::unique_ptr&lt;float&gt; ptr {std::make_unique&lt;float&gt;(3.14)};   Modifier la méthode most_left pour qu'elle retourne une référence vers un pointeur intelligent au lieu d'un pointeur brut. Modifier la méthode insert pour qu'elle utilise des pointeurs intelligents. Modifier la méthode remove pour qu'elle utilise des pointeurs intelligents.  astuce C'est un peu plus compliqué car il faut utiliser des références vers des pointeurs intelligents pour pouvoir les modifier. On peut utiliser les méthodes reset et release pour gérer la mémoire et les pointeurs intelligents. Ou utiliser un concept plus avancé std::move pour transférer la propriété d'un pointeur intelligent d'un objet à un autre. Si vous voulez essayer, n'hésitez pas à demander de l'aide.  ","version":"Next","tagName":"h3"},{"title":"Exercice 4 (Encapsulation) (Bonus)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-4-encapsulation-bonus","content":" Le but est de créer une structure BinaryTree qui encapsule la structure Node ou SmartNode et qui permet d'utiliser les même méthodes sans connaître la structure interne de l'arbre binaire. Cela permet aussi de gérer le cas où l'arbre binaire est vide (c'est à dire que la racine est un pointeur nul).  C'est moins pertinent dans notre cas pour ce TDs mais lorsque vous découvrirez la notion de visibilité vous comprendrez l'intérêt de cette encapsulation.  Voilà le contenu du fichier binaryTree.hpp:  #pragma once #include &lt;memory&gt; #include &quot;smartNode.hpp&quot; struct BinaryTree { std::unique_ptr&lt;SmartNode&gt; root { nullptr }; void insert(int value); bool remove(int value); void clear(); bool contains(int value) const; size_t height() const; }; bool contains(std::unique_ptr&lt;SmartNode&gt;&amp; node, int value);   Créer un fichier binaryTree.cpp et implémenter les méthodes de la structure BinaryTree.  info C'est grâce à cette encapsulation que l'on peut changer la structure interne de l'arbre binaire sans avoir à modifier le code qui l'utilise. Nous pourrions par exemple changer la structure SmartNode par une structure Node sans avoir à modifier le code qui utilise la structure BinaryTree. Ici avec l'utilisation des pointeurs intelligents, la mémoire va être gérée automatiquement à la destruction de l'objet BinaryTree et il n'y a plus besoin de la fonction delete_tree. C'est un grand avantage des pointeurs intelligents et permet d'éviter les erreurs de fuites mémoires. ","version":"Next","tagName":"h3"},{"title":"Planning","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Planning","content":"","keywords":"","version":"Next"},{"title":"Lundi​","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#lundi","content":"  Cours : Introduction Prise en main de la lib Quelques exercices de niveau 1 (⭐) et/ou 2 (⭐⭐)  ","version":"Next","tagName":"h2"},{"title":"Mardi​","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#mardi","content":"  Cours : Présentation de git Test et prise en main de git (l'un push quelque chose et l'autre le pull par exemple) Mettre sur le repository les exercices que vous avez fait hier Autonomie  ","version":"Next","tagName":"h2"},{"title":"Mercredi​","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#mercredi","content":"  Cours : Si besoin, point de rappel sur une notion mal acquise (N'hésitez pas à me demander si vous voulez que je réexplique quelque chose en particulier, que ce soit en C++ ou sur le sujet du workshop) Autonomie  ","version":"Next","tagName":"h2"},{"title":"Jeudi​","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#jeudi","content":"  Cours : Si besoin, point de rappel sur une notion mal acquise (N'hésitez pas à me demander si vous voulez que je réexplique quelque chose en particulier, que ce soit en C++ ou sur le sujet du workshop) Autonomie  ","version":"Next","tagName":"h2"},{"title":"Vendredi​","type":1,"pageTitle":"Planning","url":"/Learn--cpp_programming/Workshop/Planning#vendredi","content":"  Cours : Présentation de Markdown pour l'écriture du rapport Écriture du rapport (Vous avez jusqu'à lundi matin pour les rendre) Préparation de la présentation pour celleux concerné.es Présentations l'après-midi ","version":"Next","tagName":"h2"},{"title":"TD3 - Algorithmes de tri","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/sorting","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (tri itératif)​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-1-tri-itératif","content":" Dans cet exercice, vous devez écrire une fonction qui prend en paramètre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Vous avez le choix entre deux algorithmes de tri:  tri à bulletri par sélection  Voilà les prototypes des fonctions:  void bubble_sort(std::vector&lt;int&gt; &amp; vec); void selection_sort(std::vector&lt;int&gt; &amp; vec);   ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (tri récursif)​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-2-tri-récursif","content":" De nouveau, vous devez écrire une fonction qui prend en paramètre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Cette fois-ci, vous devez utiliser un algorithme de tri récursif.  Vous avez le choix entre deux algorithmes de tri:  tri fusiontri rapide  Voilà les prototypes des fonctions à utiliser et implémenter:  size_t quick_sort_partition(std::vector&lt;float&gt; &amp; vec, size_t left, size_t right, size_t const pivot); void quick_sort(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const right); void quick_sort(std::vector&lt;float&gt; &amp; vec) { quick_sort(vec, 0, vec.size() - 1); } void merge_sort_merge(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const middle, size_t const right); void merge_sort(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const right); void merge_sort(std::vector&lt;float&gt; &amp; vec) { merge_sort(vec, 0, vec.size() - 1); }   Dans ces deux algorithmes, on va trier des plages du tableau par récursivité. C'est pour cela que les fonctions prennent en paramètre les indices de début et de fin de la plage à trier (left et right). De plus, dans les deux algorithmes, on va utiliser une fonction auxiliaire pour séparer le tableau en deux parties (quick_sort_partition) ou pour fusionner deux tableaux triés (merge_sort_merge).  astuce Pour l'étape de merge du merge sort (merge_sort_merge), il faudra copier les valeurs dans des vecteurs temporaires pour stocker les deux parties du tableau à fusionner. Il existe plusieurs façons de copier les valeurs d'un vecteur dans un autre. La plus simple est de donner à la construction du vecteur les itérateurs de début et de fin du vecteur à copier. Cela fonctionne de la manière suivante: std::vector&lt;int&gt; vec1 {1, 2, 3, 4, 5}; // copie de vec1 dans vec2 std::vector&lt;int&gt; vec2(vec1.begin(), vec1.end()); // copie des éléments de vec1 dans vec3 à partir de l'élément d'indice 2 std::vector&lt;int&gt; vec3(vec1.begin() + 2, vec1.end()); // copie des éléments de vec1 dans vec4 à partir de l'élément d'indice 1 jusqu'à l'élément d'indice 3 std::vector&lt;int&gt; vec4(vec1.begin() + 1, vec1.begin() + 4); // il est également possible de copier un vecteur dans un autre à l'aide de la fonction std::copy std::vector&lt;int&gt; vec5(vec1.size()); std::copy(vec1.begin(), vec1.end(), vec5.begin()); // il faut que le vecteur de destination ait la bonne taille pour pouvoir copier les valeurs // ou à l'aide de la méthode assign std::vector&lt;int&gt; vec6; vec6.assign(vec1.begin(), vec1.end());   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Comparaison des algorithmes de tri)​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-3-comparaison-des-algorithmes-de-tri","content":" Une fois nos algorithmes de tri implémentés, nous allons les comparer en terme de complexité temporelle.  Je vous fournis une fonction qui permet de générer un tableau d'entiers aléatoires.  #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; std::vector&lt;int&gt; generate_random_vector(size_t const size, int const max = 100) { std::vector&lt;int&gt; vec(size); std::generate(vec.begin(), vec.end(), [&amp;max]() { return std::rand() % max;} ); return vec; }   Je vous fournis également une structure chronomètre, il suffit de télécharger le fichier ScopedTimer.hpp et le copier dans le dossier de votre projet et de l'inclure dans votre fichier source:  #include &quot;ScopedTimer.hpp&quot;   Elle fonctionne de la manière suivante:  { ScopedTimer timer(&quot;nom du chronomètre&quot;); // code à chronométrer }   Elle affichera le temps écoulé entre sa création et sa destruction(c'est à dire à la fin du bloc de code, c'est pourquoi il est déclaré dans un bloc entre accolades (Scope) dans l'exemple ci-dessus).  ","version":"Next","tagName":"h2"},{"title":"bibliothèque standard​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#bibliothèque-standard","content":" La bibliothèque standard de C++ fournit une fonction de tri std::sort qui permet de trier des conteneurs (incluse dans la bibliothèque &lt;algorithm&gt;)  Vous pouvez l'utiliser de la manière suivante:  std::vector&lt;int&gt; array {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::sort(array.begin(), array.end());   remarque begin et end sont des méthodes de std::vector qui permettent de récupérer des itérateurs sur le début et la fin du conteneur. Nous verrons les itérateurs plus tard dans le cours.  Avec cette fonction, vous pouvez comparer les temps d'exécution de vos algorithmes de tri avec celui de la bibliothèque standard.  Que constatez-vous ?Que pouvez-vous en dire ?  ","version":"Next","tagName":"h3"},{"title":"Exercice 4 (dichotomie)​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-4-dichotomie","content":" Écrire une fonction search qui prend en paramètre un tableau d'entiers (std::vector) trié par ordre croissant et une valeur entière et retourne l'indice de la valeur dans le tableau. Si la valeur n'est pas présente dans le tableau, la fonction retournera -1 (on pourrait utiliser quelques chose de plus propre comme std::optional que l'on découvrira dans le prochain cours pour éviter de retourner -1 pour indiquer que l'on ne trouve pas la valeur).  la fonction devra utiliser l'algorithme de recherche dichotomique.  astuce On utilisera deux indices pour définir la partie du tableau à traiter: left : indice du premier élément de la partie du tableau à traiterright : indice du dernier élément de la partie du tableau à traiter Exemple simple avec le tableau suivant [1, 2, 2, 3, 4, 8, 12] (nombre d'éléments: 7) et la valeur recherchée 8: left = 0 et right = 6 (indice du premier et dernier élément du tableau)middle = (left + right) / 2 = (0 + 6) / 2 = 3 (indice de l'élément au milieu du tableau) la valeur au milieu du tableau est 3 qui est inférieure à la valeur recherchée 8, on ne garde que la partie droite du tableau.left devient middle + 1 = 3 + 1 = 4 (indice du premier élément de la partie droite du tableau)left = 4 et right = 6middle = (left + right) / 2 = (4 + 6) / 2 = 5la valeur au milieu du tableau est 8 qui est égale à la valeur recherchée, on retourne l'indice 5 de la valeur dans le tableau.  tester la fonction search avec les tableaux suivants et afficher le résultat de la recherche: [1, 2, 2, 3, 4, 8, 12] (valeur recherchée: 8)[1, 2, 3, 3, 6, 14, 12, 15] (valeur recherchée: 15)[2, 2, 3, 4, 5, 8, 12, 15, 16] (valeur recherchée: 16)[5, 6, 7, 8, 9, 10, 11, 12, 13] (valeur recherchée: 6)[1, 2, 3, 4, 5, 6, 7, 8, 9] (valeur recherchée: 10)  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin: Counting sort​","type":1,"pageTitle":"TD3 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#pour-aller-plus-loin-counting-sort","content":" Le counting sort est un algorithme de tri qui permet de trier un tableau d'entiers en temps linéaire (c'est à dire en O(n)O(n)O(n)). Il est cependant limité par le fait qu'il ne peut trier que des entiers (&quot;positifs&quot; pour le cas le plus simple) et que la valeur maximale des entiers du tableau doit être connue (à calculer avant le tri ou connue en fonction du contexte).  Essaye d'implémenter cet algorithme de tri. Voilà le prototype de la fonction:  void counting_sort(std::vector&lt;int&gt; &amp; vec, int const max);  ","version":"Next","tagName":"h2"},{"title":"Exercices","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Exercices","content":"","keywords":"","version":"Next"},{"title":"⭐ Ne garder que le vert​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-ne-garder-que-le-vert","content":"   Indice Mettre le rouge et le bleu à 0.  ","version":"Next","tagName":"h2"},{"title":"⭐ Échanger les canaux​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-échanger-les-canaux","content":"   Par exemple, échangez le canal rouge et le canal bleu.  Indice Il existe std::swap(a, b) pour échanger deux valeurs.  ","version":"Next","tagName":"h2"},{"title":"⭐ Noir & Blanc​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-noir--blanc","content":"   Indice N'hésitez pas à aller chercher la formule sur internet si besoin !  ","version":"Next","tagName":"h2"},{"title":"⭐ Négatif​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-négatif","content":"   Indice Il faut trouver une formule simple, qui transforme le noir en blanc et le blanc en noir (i.e. qui transforme 0 en 1 et 1 en 0).  ","version":"Next","tagName":"h2"},{"title":"⭐ Dégradé​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-dégradé","content":"   info Vous pouvez créer une image noire avec sil::Image image{300/*width*/, 200/*height*/}; puis itérer sur les pixels pour les colorer.  Indice La couleur de chaque pixel doit dépendre de son x uniquement.  Indice 2 Quelle formule permettrait d'avoir 0 (noir) quand x vaut 0 (gauche), et 1 (blanc) quand x vaut image.width() - 1 (droite) ?  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ Miroir​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-miroir","content":"   Indice On cherche une formule qui, quand x vaut 0, le transforme en image.width() - 1, quand x vaut 1, le transforme en image.width() - 2, etc.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ Image bruitée​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-image-bruitée","content":"   info Pour obtenir des nombres aléatoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple à utiliser, et utilisent des générateurs aléatoires de meilleure qualité. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la même suite de nombres aléatoires à chaque fois que vous relancez votre programme, vous pouvez définir une seed avec set_random_seed(0) au début de votre main() (vous pouvez passer n'importe quel nombre autre que 0, ça définira quels seront les nombres générés par les fonctions random).  Indice Remplacez quelques pixels au hasard par une couleur aléatoire.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ Rotation de 90°​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rotation-de-90","content":"   La formule générique pour un angle quelconque est un peu plus compliquée, mais pour 90° il y a une formule plus simple, essayez de la trouver !  Indice Créez une nouvelle image avec sil::Image new_image{new_width, new_height}; pour stocker le résultat de votre effet, car elle n'aura pas la même taille que l'image originale.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ RGB split​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rgb-split","content":"   ⚠️ Piège à éviter Créez une nouvelle image et travaillez sur celle-ci. Il ne faut pas modifier l'image originale pendant que vous bouclez pour appliquer l'effet, sinon certains pixels n'utiliseront pas la bonne couleur de l'image originale, mais plutôt la couleur déjà modifiée par un pixel précédent, ce qui pourrait vous donner ce genre de rendu moins intéressant :  Indice Chaque pixel va prendre comme couleur le rouge d'un pixel un peu à sa droite, son propre vert, et le bleu d'un pixel un peu à sa gauche.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ Luminosité​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-luminosité","content":"  Image originale\tAprès éclaircissement\tAprès assombrissement  Indice On voudrait des courbes comme celles-ci, qui diminuent tous les nombres entre 0 et 1 (courbe bleue) (c-à-d assombrisse), ou les augmentent (courbe verte) (c-à-d éclaircisse), tout en gardant 0 à 0 et 1 à 1 (afin de garder la plage dynamique de l'image, pour conserver des noirs purs et des blancs purs).  Indice 2 Les fonctions puissance font exactement ce qu'on veut ! La preuve : https://www.desmos.com/calculator/c3ztk51mng  ","version":"Next","tagName":"h2"},{"title":"⭐⭐(⭐) Disque​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-disque","content":"   info Vous pouvez créer une image noire avec sil::Image image{500/*width*/, 500/*height*/}; puis itérer sur les pixels pour les colorer.  Indice Quelle est l'équation d'un disque ? Comment peut on s'en servir pour savoir si un pixel est à l'intérieur ou à l'extérieur du disque ?  ","version":"Next","tagName":"h2"},{"title":"⭐ Cercle​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-cercle","content":"   En reprenant et modifiant légèrement votre code pour le disque, écrivez le code qui donne un cercle. (Son contour aura une épaisseur donnée thickness).  ","version":"Next","tagName":"h3"},{"title":"⭐⭐⭐ Rosace​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-rosace","content":"   Maintenant que vous savez dessiner un cercle, dessinez-en plusieurs sur la même image, à des positions bien choisies, de sorte à dessiner une rosace. (PS : il va sûrement falloir faire de la trigo!)  Indice Comment passer de coordonnées polaires (angle et rayon) à des coordonnées cartésiennes (x et y) ?  ","version":"Next","tagName":"h3"},{"title":"⭐⭐ Mosaïque​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-mosaïque","content":"   Indice Une manière concise de faire ça est d'utiliser un modulo (%) quelque part.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐⭐ Mosaïque miroir​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-mosaïque-miroir","content":" Inversez une image sur deux :    ","version":"Next","tagName":"h3"},{"title":"⭐⭐⭐ Glitch​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-glitch","content":"   info Pour obtenir des nombres aléatoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple à utiliser, et utilisent des générateurs aléatoires de meilleure qualité. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la même suite de nombres aléatoires à chaque fois que vous relancez votre programme, vous pouvez définir une seed avec set_random_seed(0) au début de votre main() (vous pouvez passer n'importe quel nombre autre que 0, ça définira quels seront les nombres générés par les fonctions random).  Indice Prendre un rectangle de pixels et l'intervertir avec un autre rectangle de pixels, ailleurs dans l'image. Faire ça plusieurs fois.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐ Tri de pixels​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-tri-de-pixels","content":"   Voici une bonne vidéo expliquant l'algorithme (vous pouvez ignorer le début spécifique à Processing où on voit comment afficher l'image) :      Utilisez image.pixels() pour récupérer le tableau contenant tous les pixels de l'image et le trier.  Ensuite, au lieu de trier tous les pixels de l'image, triez par colonne (ou par ligne) pour un effet plus joli. (Il faudra trier des sous-parties du tableau image.pixels().) Ou encore, triez des sous-parties prises aléatoirement dans l'image.  info Pour trier un tableau, vous pouvez utiliser std::sort. Vous verrez ça plus en détail au S2, mais voici une brève explication : std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin(), v.end()); // Trie un tableau du début à la fin // {1, 3, 5, 8} std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin(), v.begin() + 2); // Trie les deux premiers éléments du tableau, c'est comme si on lui avait passé le tableau {8, 5} // {5, 8, 3, 1} std::vector&lt;int&gt; v{8, 5, 3, 1}; std::sort(v.begin() + 1, v.begin() + 3); // Trie le sous-tableau {5, 3} // {8, 3, 5, 1} Et vous pouvez aussi choisir selon quel critère de comparaison les éléments seront triés : std::vector&lt;glm::vec3&gt; v{/*...*/}; std::sort(v.begin(), v.end(), [](glm::vec3 const&amp; color1, glm::vec3 const&amp; color2) { return color1.r &lt; color2.r; // Trie selon la composante rouge }); std::vector&lt;glm::vec3&gt; v{/*...*/}; std::sort(v.begin(), v.end(), [](glm::vec3 const&amp; color1, glm::vec3 const&amp; color2) { return brightness(color1) &lt; brightness(color2); // Trie selon la luminosité des couleurs (NB : c'est à vous de coder la fonction `brightness`) }); On passe ce qu'on appelle une lambda en 3ème argument : c'est une fonction définie en plein milieu du code. Elle doit prendre en paramètre deux éléments du tableau (deux vec3 en l'occurrence) et retourner un booléen indiquant qui est le plus petit des deux éléments.  info Pour obtenir des nombres aléatoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple à utiliser, et utilisent des générateurs aléatoires de meilleure qualité. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la même suite de nombres aléatoires à chaque fois que vous relancez votre programme, vous pouvez définir une seed avec set_random_seed(0) au début de votre main() (vous pouvez passer n'importe quel nombre autre que 0, ça définira quels seront les nombres générés par les fonctions random).  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐(⭐) Fractale de Mandelbrot​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-fractale-de-mandelbrot","content":"   La fractale de Mandelbrot s'obtient ainsi : pour chaque nombre complexe c (correspondant à la position d'un pixel), on initialise un autre nombre complexe z à 0, puis on itère z = z * z + c un certain nombre de fois. Si le nombre z commence à devenir de plus en plus grand, alors c ne fait pas partie de la fractale et on colorie le pixel correspondant en noir. À l'inverse, si z reste de taille modérée peu importe le nombre d'itérations qu'on fait, alors le pixel fait partie de la fractale et on le colorie en blanc.  Plus précisément, on peut prouver que dès que std::abs(z) &gt; 2 alors le nombre z va forcément finir par grandir de plus en plus. On peut donc s'arrêter d'itérer dès que std::abs(z) &gt; 2. Et pour obtenir une fractale plus jolie, plutôt que d'assigner du noir pur on peut assigner un gris plus ou moins sombre en fonction du nombre d'itérations qu'il a fallu faire avant que std::abs(z) &gt; 2.  Conseil : si vous mappez directement le pixel (x, y) au nombre complexe x + i * y, vous allez visualiser les nombres complexes entre 0 et 500, et votre fractale va être beaucoup trop petite. Les nombres intéressants sont plutôt entre -2 et 2. Il va donc falloir appliquer une petite transformation à votre x et y pour les faire rentrer dans cet intervalle.  Conseil : vous pouvez inclure le header &lt;complex&gt; pour utiliser des nombres complexes. Un nombre complexe se définit comme ça :  #include &lt;complex&gt; int main() { std::complex&lt;float&gt; z{3.f, 2.f}; // Définis le nombre z = 3 + 2*i }   et s'utilise comme un nombre normal : vous pouvez faire des additions, multiplications etc.  info Vous pouvez créer une image noire avec sil::Image image{500/*width*/, 500/*height*/}; puis itérer sur les pixels pour les colorer.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐(⭐) Tramage​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-tramage","content":"   Vous pouvez lire ce super article sur le tramage (a.k.a. dithering en anglais).  Sur l'image ci-dessus j'ai utilisé de l'ordered dithering avec une matrice de Bayer 4x4 (a.k.a. de niveau 1). Tout est expliqué dans l'article ci-dessus ! (Plus précisément, j'ai repris la matrice et le code depuis cet autre article.)  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐(⭐) Normalisation de l'histogramme​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-normalisation-de-lhistogramme","content":" \tAvant\tAprès  L'algorithme consiste à trouver le pixel le moins lumineux et le pixel le plus lumineux de l'image, puis à appliquer une transformation à chaque pixel de sorte à ce que le pixel le plus sombre devienne un noir pur (0) et le plus lumineux devienne un blanc pur (1). (PS : testez avec l'image &quot;images/photo_faible_contraste.jpg&quot;, vous verrez bien l'intérêt de l'effet.)  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐⭐ Vortex​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-vortex","content":"   info Pour appliquer une rotation à un point point, autour d'un autre point center_of_rotation, d'un angle angle (exprimé en radians) vous pouvez utiliser #include &lt;glm/gtx/matrix_transform_2d.hpp&gt; glm::vec2 rotated(glm::vec2 point, glm::vec2 center_of_rotation, float angle) { return glm::vec2{glm::rotate(glm::mat3{1.f}, angle) * glm::vec3{point - center_of_rotation, 0.f}} + center_of_rotation; }   info Pour obtenir la distance entre deux points, vous pouvez utiliser glm::distance(p1, p2);  Details IndiceChaque pixel subit une rotation, de plus en plus importante au fur et à mesure qu'on s'éloigne du centre.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐⭐ Convolutions​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-convolutions","content":"  Box blur  Les convolutions permettent d'implémenter plein d'effets (flou, détection de contour, augmentation de la netteté, etc.). L'effet va varier en fonction du kernel que vous utilisez lors de votre convolution. Tout est expliqué dans cette excellente vidéo, entre 1m10 et 4m18 :      Conseil : une fois que vous savez que votre algo marche, si vous voulez tester avec des kernels plus gros, ça peut être lent, donc vous avez intérêt à build en release (demandez-moi si vous ne savez pas comment faire).  ","version":"Next","tagName":"h2"},{"title":"⭐ Netteté, Contours, etc.​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-netteté-contours-etc","content":"  Emboss\tOutline\tSharpen  Une fois que vous avez implémenté l'algo générique de convolution qui prend n'importe quel kernel, vous pourrez trouver sur ce site une liste de kernels pour faire différents effets.  ","version":"Next","tagName":"h3"},{"title":"⭐⭐ Filtres séparables​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-filtres-séparables","content":" Box blur naïf, 100x100\tBox blur séparé, 100x100 7.44 secondes\t0.18 secondes  Quand vous voulez faire un gros flou il faut augmenter la taille du kernel, ce qui peut considérablement ralentir l'algorithme. Heureusement, certains kernels ont une propriété qui nous permet de calculer leur convolution BEAUCOUP plus rapidement. Le box blur et le gaussian blur sont de tels kernels. Voici une vidéo expliquant tout ça :    ","version":"Next","tagName":"h3"},{"title":"⭐⭐ Différence de gaussiennes​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-différence-de-gaussiennes","content":"   Voici une vidéo expliquant l'algorithme :  NB 1 : Il parle de flou gaussien, mais vous pouvez tout aussi bien réutiliser votre box blur, pas la peine d'implémenter un flou gaussien.NB 2 : Ne faire que l'algo de base, présenté jusqu'à 4m09. Après ça ça devient très compliqué (mais très stylé néanmoins).    ","version":"Next","tagName":"h3"},{"title":"⭐⭐⭐⭐⭐ K-means : trouver les couleurs les plus présentes dans une image​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-k-means--trouver-les-couleurs-les-plus-présentes-dans-une-image","content":"  Originale\t2 couleurs\t3 couleurs\t16 couleurs  Trouvez les k couleurs les plus représentatives de l'image, puis assignez à chaque pixel la couleur dont il est le plus proche parmi les k.  Voici une bonne vidéo expliquant l'algorithme :      info Vous pouvez utiliser glm::distance(color1, color2) pour obtenir la distance entre deux couleurs.  info Pour obtenir des nombres aléatoires, vous pouvez soit utiliser srand et rand comme vu en TP, soit utiliser les fonctions qu'on vous a fournies dans #include &quot;random.hpp&quot;. Elles ont une syntaxe plus simple à utiliser, et utilisent des générateurs aléatoires de meilleure qualité. Vous avez soit random_int(min, max), soit random_float(min, max), soit true_with_probability(probability_of_beeing_true). Si vous voulez obtenir la même suite de nombres aléatoires à chaque fois que vous relancez votre programme, vous pouvez définir une seed avec set_random_seed(0) au début de votre main() (vous pouvez passer n'importe quel nombre autre que 0, ça définira quels seront les nombres générés par les fonctions random).  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐⭐⭐ Filtre de Kuwahara (effet peinture à l'huile)​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-filtre-de-kuwahara-effet-peinture-à-lhuile","content":"   Voici une vidéo expliquant l'algorithme : (La version simple de l'algo, qui est expliquée entre 3m11 et 3m30, suffit largement. (Mais si vous voulez aller plus loin, vous êtes les bienvenu.es bien sûr 😉))      info Vous pouvez utiliser glm::distance(color1, color2) pour obtenir la distance entre deux couleurs.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐⭐⭐⭐⭐ Diamond Square​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-diamond-square","content":"   Algorithme de génération de height map, qui peut ensuite être utilisée pour créer des terrains procéduraux dans des jeux vidéos par exemple.  Voici une bonne vidéo expliquant l'algorithme :      Conseil : commencez par travailler sur une image toute petite (e.g. 17x17), afin de bien voir les pixels et ce qu'il se passe.  info Vous pouvez créer une image noire avec sil::Image image{17/*width*/, 17/*height*/}; puis itérer sur les pixels pour les colorer.  ","version":"Next","tagName":"h2"},{"title":"⭐⭐ Colorer la height map​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#-colorer-la-height-map","content":"   Appliquez un dégradé de couleur en fonction du niveau de gris de la height map.  info Avec glm::mix(color1, color2, pourcentage); vous pouvez faire un mélange entre deux couleurs données.  Indice Essayez par exemple de faire un dégradé d'un bleu sombre à un bleu clair quand le niveau de gris est entre 0 et 0.5, et un autre dégradé entre du vert et du marron quand le niveau de gris est entre 0.5 et 1.  ","version":"Next","tagName":"h3"},{"title":"Vous pouvez aussi implémenter vos propres effets !​","type":1,"pageTitle":"Exercices","url":"/Learn--cpp_programming/Workshop/Exercices#vous-pouvez-aussi-implémenter-vos-propres-effets-","content":"","version":"Next","tagName":"h2"},{"title":"TD5 - Hachage et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (fonction de hachage)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-1-fonction-de-hachage","content":" Écrire une fonction de hachage qui prend en paramètre une chaîne de caractères, fait la somme des valeurs ASCII des caractères et renvoie un entier compris entre 0 et un maximum donné nommé max (le type de retour du hash doit être size_t).  Nous utiliserons une simple somme des codes ASCII des caractères suivie d'un modulo pour obtenir un entier compris entre 0 et max.  size_t folding_string_hash(std::string const&amp; s, size_t max);   Ce que nous venons de faire s'appel la technique dite de folding (pliage en français). Cela consiste à découper notre donnée en plusieurs parties, calculer une valeur(hash) pour chacune de ces parties, sommer ces valeurs et enfin appliquer un modulo pour obtenir un entier compris entre 0 et max. Ici on traite une chaîne de caractère, on va donc faire la somme des valeurs de hachage de chaque caractère.  info On veux se ramener à un entier compris entre 0 et max car cette valeur hachée sert généralement d'index dans un tableau (table de hachage). Hors on souhaite un tableau de taille &quot;raisonnable&quot; en mémoire, donc on limite la taille de ce tableau à max. Le choix de max dépend du contexte d'utilisation de la table de hachage, généralement on choisit une valeur qui est une puissance de 2 (par exemple 1024, 2048, 4096, etc.).  Écrire une nouvelle fonction de hachage sur une chaîne de caractères pour laquelle l'ordre des caractères a de l'importance. Par exemple, les chaînes de caractères &quot;abc&quot; et &quot;cba&quot; ne doivent pas avoir la même valeur hachée. Ce qui est le cas avec la fonction de hachage précédente.  Utiliser par exemple la somme des codes ASCII des caractères multipliée par leur position dans la chaîne de caractères.  size_t folding_string_ordered_hash(std::string const&amp; s, size_t max);   Écrire une fonction de hachage sur une chaîne de caractères utilisant la technique de polynomial rolling hash.  Voila le prototype de la fonction à écrire:  size_t polynomial_rolling_hash(const std::string&amp; s, size_t p, size_t m);   Nous allons utiliser la technique dite de polynomial rolling hash. Cette technique consiste à calculer le hash d'une chaîne de caractères en incorporant la position d'une manière plus complexe pour éviter les collisions. On va donc multiplier la valeur de chaque caractère par une puissance de p qui dépend de la position du caractère dans la chaîne de caractères. Pour cela, nous allons utiliser la formule suivante: hash(s)=∑i=0n−1((s[i]×pi)mod m)\\text{hash}(s) = \\sum_{i=0}^{n-1} ((s[i] \\times p^i) \\mod m)hash(s)=i=0∑n−1​((s[i]×pi)modm) Avec: sss la chaîne de caractèresnnn la taille de la chaîne de caractèress[i]s[i]s[i] le code ASCII du caractère à l'index iii dans la chaîne de caractèresppp un nombre (généralement un nombre premier)mmm un nombre (généralement une puissance de 2)  attention On ne veux pas utiliser la fonction std::pow de la bibliothèque standard car elle est &quot;lente&quot; est fonctionne avec des flottants (ce qui nous ferait faire des conversions inutiles). De plus on ne veux pas recalculer la puissance de p à chaque itération car c'est des calculs inutiles. Admettons qu'il faille n−1n-1n−1 multiplications pour calculer pnp^npn (p×p×p=p3p \\times p \\times p = p^3p×p×p=p3) et que l'on recalculait à chaque fois la puissance. Pour une chaîne de taille nnn on ferait donc 1+2+…+(n−2)+(n−1)1 + 2 + \\ldots + (n-2) + (n-1)1+2+…+(n−2)+(n−1) multiplications. On peut simplifier cette somme en n(n−1)/2n(n-1)/2n(n−1)/2 ce qui est de l'ordre de n2n^2n2 multiplications. On veut éviter ça. On va donc nous même faire les multiplications. Pour calculer pip^ipi on peut simplement multiplier par p le résultat de pi−1p^{i-1}pi−1 c'est à dire la valeur de la puissance à l'itération précédente. On va donc utiliser une variable power (initialisée à 1 au début) et multiplier cette variable par p à chaque itération pour obtenir les puissances de p.  choix de p et m Le choix de p et m va influencer la qualité (collision) et les performances de notre fonction de hachage. Sans rentrer dans les détails, on choisit généralement p un nombre premier et m un nombre suffisamment grand pour éviter les collisions tout en restant petit pour rester performant et éviter des erreur numériques. Par exemple, on peut choisir p = 31 et m = 10^9 + 9 (que l'on peut noter 1e9 + 9 en C++ ou tout simplement 1000000009).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Analyse du nombre d'insectes)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-2-analyse-du-nombre-dinsectes","content":" L'idée de cet exercice est d'utiliser une table associative pour résoudre un problème.  Vous êtes un entomologiste qui a pour mission de recenser les insectes dans un jardin afin de vérifier la biodiversité de ce jardin et confirmer vos hypothèses sur la présence de certaines espèces (probabilité de présence de certaines espèces, etc.).  Vous disposez d'une liste d'insectes que vous pouvez rencontrer dans ce jardin (sous forme d'énumération):  enum class Insect { ClassicBee, Ladybug, Butterfly, Dragonfly, Ant, Grasshopper, Beetle, Wasp, Caterpillar, Spider, GuimielBee };   Je vous fournis également une liste des valeurs de l'énumération Insect sous forme de vecteur (pour pouvoir itérer sur les valeurs de l'énumération et éviter de faire des static_cast pour obtenir les valeurs de l'énumération à partir d'un entier (index) ou encore avoir le nombre d'éléments de l'énumération). Rappels sur les cast avec enum ici.  #include &lt;vector&gt; const std::vector&lt;Insect&gt; insect_values { Insect::ClassicBee, Insect::Ladybug, Insect::Butterfly, Insect::Dragonfly, Insect::Ant, Insect::Grasshopper, Insect::Beetle, Insect::Wasp, Insect::Caterpillar, Insect::Spider, Insect::GuimielBee };   Ainsi qu'un tableau associatif qui permet de convertir une valeur de l'énumération Insect en une chaîne de caractères (pour pouvoir afficher le nom de l'insecte):  info Il n'existe pas de fonction dans la bibliothèque standard C++ pour obtenir le nom d'une valeur d'une énumération. L'astuce est donc de créer un tableau associatif pour faire cette correspondance. Il existe des bibliothèques comme Magic Enum qui permettent de manipuler plus facilement les énumérations mais nous n'utiliserons pas de bibliothèque dans cet exercice.  #include &lt;unordered_map&gt; #include &lt;string&gt; const std::unordered_map&lt;Insect, std::string&gt; insect_to_string = { {Insect::ClassicBee, &quot;ClassicBee&quot;}, {Insect::Ladybug, &quot;Ladybug&quot;}, {Insect::Butterfly, &quot;Butterfly&quot;}, {Insect::Dragonfly, &quot;Dragonfly&quot;}, {Insect::Ant, &quot;Ant&quot;}, {Insect::Grasshopper, &quot;Grasshopper&quot;}, {Insect::Beetle, &quot;Beetle&quot;}, {Insect::Wasp, &quot;Wasp&quot;}, {Insect::Caterpillar, &quot;Caterpillar&quot;}, {Insect::Spider, &quot;Spider&quot;}, {Insect::GuimielBee, &quot;GuimielBee&quot;} };   Enfin, vous disposez d'une liste de comptage d'insectes attendus pour un échantillon de 1000 insectes (obtenue en faisant la moyenne des observations de plusieurs entomologistes): Cette liste se présente sous forme d'un vecteur avec les nombres d'individus attendus pour chaque espèce d'insecte (dans le même ordre que l'énumération Insect):  #include &lt;vector&gt; const std::vector&lt;int&gt; expected_insect_counts { 75, // ClassicBee 50, // Ladybug 100, // Butterfly 20, // Dragonfly 400, // Ant 150, // Grasshopper 60, // Beetle 10, // Wasp 40, // Caterpillar 90, // Spider 5, // GuimielBee };   Vous avez un grand nombre d'insectes à recenser et vous avez besoin d'une méthode pour compter le nombre d'apparitions de chaque insecte.  Le plus simple pour vous est juste de noter au fur et à mesure vos observations (espèce et nombre d'individus observés) et de faire le compte à la fin. (par exemple, vous notez &quot;2 abeilles&quot; lorsque vous voyez 2 abeilles et &quot;1 coccinelle&quot; lorsque vous voyez une coccinelle).  Voilà une fonction qui génère une liste d'observations aléatoires pour simuler vos observations:  #include &lt;functional&gt; #include &lt;random&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; std::vector&lt;std::pair&lt;Insect, int&gt;&gt; get_insect_observations( const size_t number_of_observations, std::vector&lt;float&gt; const&amp; insect_probabilities, const unsigned int seed = std::random_device{}()) { // Create a random engine with a given seed std::default_random_engine random_engine(seed); auto randInsectIndex { std::bind(std::discrete_distribution&lt;size_t&gt;{insect_probabilities.begin(), insect_probabilities.end()}, random_engine) }; std::vector&lt;std::pair&lt;Insect, int&gt;&gt; observations {}; observations.reserve(number_of_observations); for(size_t i {0}; i &lt; number_of_observations; ++i) { size_t const random_insect_index { randInsectIndex() }; Insect const random_insect { insect_values[random_insect_index] }; //If we have already seen the same insect, increment the count on the last observation auto&amp; previous_observation { observations.back() }; if(previous_observation.first == random_insect) { previous_observation.second++; i -= 1; } else { observations.push_back({random_insect, 1}); } } return observations; }   Créer une fonction std::vector&lt;float&gt; probabilities_from_count(std::vector&lt;int&gt; const&amp; counts) qui prend en paramètre un vecteur de comptages et retourne un vecteur de probabilités à partir de ces comptages. (on divise chaque comptage par la somme de tous les comptages pour obtenir une probabilité normalisée). Utiliser la fonction get_insect_observations pour générer une liste suffisamment grande d'observations (par exemple 10000 observations) puis utiliser une table de hachage std::unordered_map pour compter le nombre d'apparitions de chaque insecte dans les observations précédemment générées et afficher le résultat (le nombre d'individus observés pour chaque insecte).  astuce On utilisera la valeur de l'énumération Insect comme clé dans la table de hachage et le nombre d'individus observés (initialisé à 0) comme valeur associée à cette clé (std::unordered_map&lt;Insect, int&gt;).  info Le paramètre seed de la fonction get_insect_observations permet de fixer la graine du générateur de nombres aléatoires. Cela permet de reproduire les mêmes observations à chaque exécution du programme. Si vous ne spécifiez pas de graine, le générateur de nombres aléatoires utilisera une graine aléatoire à chaque exécution du programme sinon vous pouvez le fixer à une valeur de votre choix pour obtenir les mêmes observations à chaque exécution.  Utiliser de nouveau la fonction probabilities_from_count pour obtenir les probabilités des insectes observés. Il faudra au préalable convertir le résultat de la table de hachage en un vecteur de comptage pour pouvoir utiliser la fonction probabilities_from_count. Afficher et comparer les probabilités des insectes observés avec les probabilités initiales. Si la différence entre les probabilités observées et les probabilités initiales est trop grande, indiquer que les observations ne sont pas conformes aux probabilités initiales. On pourra se fixer un seuil de 1% (0.01) pour considérer que les observations sont conformes.  exemple de présentation des résultats:  Probabilities of observed insects vs expected probabilities ClassicBee : 0.076 vs 0.075 OK Ladybug : 0.048 vs 0.050 OK Butterfly : 0.100 vs 0.100 OK Dragonfly : 0.035 vs 0.020 BAD ...   info Avec un grand nombre d'observations, on s'attend à ce que les probabilités observées se rapprochent des probabilités initiales. C'est le principe des lois des grands nombres. Plus on a d'observations, plus les probabilités observées se rapprocheront des probabilités initiales. Avec 10 000 vous devriez être sous le seuil de 1% pour chaque insecte (OK).  astuce Vous pouvez utiliser l'include &lt;iomanip&gt; pour formater l'affichage des nombres à virgule flottante. Ajouter std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3); avant d'afficher les nombres pour afficher les nombres avec 3 chiffres après la virgule.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (hash sur une structure)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-3-hash-sur-une-structure","content":" Donnons nous les enums et structures suivantes:  enum class CardKind { Heart, Diamond, Club, Spade, }; enum class CardValue { Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace, }; struct Card { CardKind kind; CardValue value; };   L'idée de cet exercice est de créer une fonction de hachage pour la structure Card pour que l'on puisse utiliser cette structure comme clé dans une table de hachage.  la bibliothèque standard C++ fournit une fonction de hachage pour les types de base (entiers, flottants, etc.) et les chaînes de caractères. Mais elle ne fournit pas de fonction de hachage pour nos structures.  De la même façon que l'on a surchargé les opérateurs pour nos structures, on va pouvoir surcharger la fonction de hachage de notre structure.  Il faut deux choses pour pouvoir utiliser une structure comme clé dans une table de hachage:  un opérateur == pour comparer deux structuresune fonction de hachage de cette structure  Surchargez l'opérateur == pour la structure Card (deux cartes sont égales si elles ont la même valeur et la même couleur). Écrire une méthode hash constante pour la structure Card qui retourne un entier.  Vous pouvez utiliser la méthode de hachage que vous souhaitez et qui vous semble la plus adaptée. Mais je vous donne un indice pour trouver une fonction de hachage parfaite pour notre structure Card dans la question suivante (vous pouvez donc passer à la question suivante si vous le souhaitez).  Trouvez un moyen simple (à l'aide d'une multiplication et de static_cast) d'améliorer la fonction de hachage de notre structure Card pour quelle soit parfaite.  astuce Trouver une bonne fonction de hachage de notre structure Card revient à trouver une façon de transformer une carte en un entier unique. Il y a de nombreuses façons de s'y prendre comme on l'a vu précédemment. Mais pour ce cas précis, il existe une fonction de hachage dite parfaite. On peut se rendre compte qu'il y a seulement 52 cartes différentes. On peut donc utiliser une fonction de hachage qui retourne un entier compris entre 0 et 51 avec un nombre différent pour chaque carte et donc sans collision.    Je vous donne ensuite le code suivant qui permet de faire en sorte que la bibliothèque standard utilise notre méthode hash pour la structure Card:  namespace std { template&lt;&gt; struct hash&lt;Card&gt; { size_t operator()(Card const&amp; card) const { return card.hash(); } }; }   Je ne vous demande pas de comprendre ce code, il y a des notions plus complexes que vous découvrirez l'année prochaine. Gardez simplement en tête que ce code permet de faire en sorte que la bibliothèque standard utilise notre méthode hash pour la structure Card. (Notamment les tables associatives ont besoin de ça pour indexer les objects). On aurait pu écrire le contenu de la fonction hash directement ici mais je préfère que vous ayez une méthode hash dans la structure Card pour que vous puissiez l'utiliser ailleurs (en appelant card.hash()).  attention ⚠️ Votre méthode hash doit être const pour pouvoir être appelée dans cette fonction qui est const.  Je vous donne également une fonction qui permet de générer une liste de cartes aléatoires:  #include &lt;vector&gt; std::vector&lt;Card&gt; get_cards(size_t const size) { std::vector&lt;Card&gt; cards {}; cards.reserve(size); for (size_t i {0}; i &lt; size; ++i) { cards.push_back({static_cast&lt;CardKind&gt;(rand() % 4), static_cast&lt;CardValue&gt;(rand() % 13)}); } return cards; }   Utiliser la fonction get_cards pour générer une liste de 100 cartes aléatoires. Utiliser une table de hachage std::unordered_map pour compter le nombre de fois que chaque carte apparaît dans la liste et afficher le résultat.  Pour pouvoir afficher, je vous donne la fonction suivante qui permet d'obtenir une représentation sous forme de chaîne de caractères de notre structure Card:  std::string card_name(Card const&amp; card) { std::string name {}; unsigned int card_value {(static_cast&lt;unsigned int&gt;(card.value)+2) % 14}; if (card_value &lt; 10) { name += '0' + card_value; }else if (card_value == 10) { name += &quot;10&quot;; }else if (card_value == 11) { name += 'V'; }else if (card_value == 12) { name += 'Q'; }else if (card_value == 13) { name += 'K'; } name += &quot; of &quot;; if (card.kind == CardKind::Heart) { name += &quot;Heart&quot;; }else if (card.kind == CardKind::Diamond) { name += &quot;Diamond&quot;; }else if (card.kind == CardKind::Club) { name += &quot;Club&quot;; }else if (card.kind == CardKind::Spade) { name += &quot;Spade&quot;; } return name; }  ","version":"Next","tagName":"h2"},{"title":"Sujet","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Workshop/Sujet","content":"","keywords":"","version":"Next"},{"title":"Pitch​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#pitch","content":" Durant ce workshop vous aller apprendre à coder des effets sur des images. (Comme on peut en trouver dans Photoshop, les filtres Instagram, etc.). Ce sera une première introduction à certains concepts de synthèse d'image, et une bonne occasion de vous entraîner en C++ !     ","version":"Next","tagName":"h2"},{"title":"Attendus​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#attendus","content":" Nous allons vous proposer une liste d'exercices, plus ou moins difficiles (la difficulté est indiquée par le nombre d'étoiles ⭐). Nous ne nous attendons pas à ce que vous fassiez tous les exercices, mais faites en un maximum ! Et il faudra au minimum faire un exercice de niveau 3 ou plus (⭐⭐⭐). Vous êtes aussi les bienvenu.es pour inventer vos propres effets ou en faire que vous avez vu quelque part, même si ils ne sont pas dans la liste !  Vous êtes évalué.es non seulement sur la qualité du travail rendu, mais aussi – de manière tout aussi importante – sur votre sérieux et votre implication tout au long de la semaine de workshop.  À la fin de la semaine il y aura une mini-soutenance (optionnelle, et qui est plus un exercice de vulgarisation qu'autre chose), et il faudra rendre un mini-rapport.  Le rendu se fera par groupes de 2 (et 1 groupe de 3 si vous êtes un nombre impair). Cependant, je m'attend à ce que vous fassiez un maximum de choses individuellement, surtout les exercices les plus faciles (niveau 1 et 2). Essayez de ne vous mettre à deux sur le même algo que quand ça commence à devenir compliqué et que réfléchir à deux dessus devient bénéfique.  ","version":"Next","tagName":"h2"},{"title":"Pour bien démarrer​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#pour-bien-démarrer","content":" Voici le template à utiliser. Vous pouvez télécharger ça et coder dedans, tout est déjà setup (CMake, librairies, images de test, etc.)Il peut arriver, surtout que vous changez des choses dans le setup / CMake, que vous ayez des erreurs bizarres : supprimez le dossier build et recommencez.Nous utiliserons la librairie sil pour lire, éditer et sauvegarder les images. Elle est très simple à utiliser et n'expose que le minimum nécessaire. Vous pouvez trouver sa documentation sur GitHub.Utilisez des images relativement petites (500x500 max), pour que le rendu soit quasi-instantané. Au moins pendant que vous faites vos tests. Vous avez déjà &quot;images/logo.png&quot; et &quot;images/photo.jpg&quot; dispos dans le template de projet. Certains effets marchent mieux sur une photo, et d'autres mieux sur une image flat, donc choisissez en fonction de l'effet sur quelle image l'appliquer. Vous pouvez aussi mettre vos propres images si vous voulez.Vous pouvez afficher l'image de sortie dans VSCode pour facilement voir le résultat en même temps que vous codez :Deux manières pour itérer sur l'image :  // On passe sur tous les x et tous les y, et on accède au pixel correspondant : for (int x{0}; x &lt; image.width(); x++) { for (int y{0}; y &lt; image.height(); y++) { image.pixel(x, y).r = 0.f; } } // Ou alors, si on n'a pas besoin de connaître le x et le y, on a une syntaxe plus concise pour itérer sur tous les pixels : for (glm::vec3&amp; color : image.pixels()) { color.r = 0.f; }   Nos couleurs sont stockées dans des glm::vec3 color: On peut accéder aux composantes rouge, verte et bleue avec color.r, color.g et color.b.Les valeurs vont de 0 à 1. Par exemple un rouge pur sera glm::vec3{1, 0, 0}, du blanc sera glm::vec3{1, 1, 1} et du noir glm::vec3{0, 0, 0}.Pour créer une couleur avec les trois composantes identiques (donc un niveau de gris), la syntaxe glm::vec3{grey} est équivalente à glm::vec3{grey, grey, grey}.Vous pouvez généralement faire vos opérations directement sur les couleurs, pas besoin de les faire 3 fois sur chacun des canaux :  glm::vec3 color1{}; glm::vec3 color2{}; glm::vec3 final_color{}; final_color = color1 + color2; // équivalent à : // final_color.r = color1.r + color2.r; // final_color.g = color1.g + color2.g; // final_color.b = color1.b + color2.b;   Pour faire les différents exos, je vous conseille de faire une fonction par exo, et de tout mettre dans le même fichier main.cpp. C'est le plus simple, et tant que le fichier ne devient pas trop gros et bordélique je pense que c'est une bonne solution. Par exemple :  void keep_green_only(sil::Image&amp; image) // Prend l'image par référence pour pouvoir la modifier { // ... } void channels_swap(sil::Image&amp; image) // Prend l'image par référence pour pouvoir la modifier { // ... } int main() { { sil::Image image{&quot;images/logo.png&quot;}; // Lis l'image keep_green_only(image); // Utilise la fonction pour modifier l'image image.save(&quot;output/keep_green_only.png&quot;); // Sauvegarde l'image } { sil::Image image{&quot;images/logo.png&quot;}; // Lis l'image channels_swap(image); // Utilise la fonction pour modifier l'image image.save(&quot;output/channels_swap.png&quot;); // Sauvegarde l'image } }   ","version":"Next","tagName":"h2"},{"title":"HELP mon effet ne fait rien !​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#help-mon-effet-ne-fait-rien-","content":" Est-ce que vous n'avez pas oublié une référence (&amp;) quelque part ?Est-ce que vous sauvegardez bien la bonne image ?Est-ce qu'il n'y a pas un crash ? Lancez avec le debugger pour savoir !Est-ce que vous ne faites pas une division entre entiers, du genre 1 / image.width() qui retourne toujours 0 parce que le résultat serait entre 0 et 1 et se retrouve arrondi ?  ","version":"Next","tagName":"h2"},{"title":"Rapport​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#rapport","content":" À rendre avant dimanche à 9h. Pour le rendu, il suffit de mettre votre lien git ici. Attention, vérifiez bien que votre repo est en public, ou si il est en privé, pensez à m'inviter dessus (julesfouchy).  Faites une section par exercice que vous avez fait. Montrez une image avant et après application de l'effet (comme c'est fait dans l'énoncé des exercices). Si vous jugez cela utile, vous pouvez mettre un petit texte expliquant des spécificités de l'algo que vous avez implémenté, et les pièges potentiels dans lesquels il ne faut pas tomber.  À faire en Markdown obligatoirement (si vous ne connaissez pas c'est l'occasion de découvrir, c'est super utile. Je vous montre tout ça vendredi).  À mettre directement en tant que ReadMe à la racine du repo.  ","version":"Next","tagName":"h2"},{"title":"Soutenance​","type":1,"pageTitle":"Sujet","url":"/Learn--cpp_programming/Workshop/Sujet#soutenance","content":" Présentez un des algos avancés que vous avez fait, en 5-10 minutes. C'est de la vulgarisation, il faut que tous vos camarades puissent comprendre. Expliquez l'algo dans les grandes lignes, et parlez des petits pièges de code auxquels il faut faire attention.  PS : la soutenance est optionnelle, on va essayer de ne pas présenter plusieurs fois le même algo, donc vous n'êtes pas obligé.es de passer. Et si plusieurs groupes souhaitent passer sur le même algo, on va essayer de vous regrouper pour que vous fassiez une seule présentation, ensemble. ","version":"Next","tagName":"h2"}],"options":{"languages":["fr"],"includeRoutes":["**/Lessons/**","**/TDs/**","**/Annexes/**","**/Workshop/**","**/Annals/**"],"id":"default"}}
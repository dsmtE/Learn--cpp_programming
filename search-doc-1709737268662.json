{"searchDocs":[{"title":"Compilation et Headers: Séparer en plusieurs fichiers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Headers","content":"","keywords":"","version":"Next"},{"title":"Mécanisme de compilation (en simple)​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#mécanisme-de-compilation-en-simple","content":" Revenons à la compilation quelques instants pour mieux comprendre.  Quand j'ai parlé de compilation j'ai fait un abus de langage et j'ai englobé plusieurs étapes. Pour faire simple, il y a en réalité trois grandes étapes lors de la compilation en C++:  Le préprocesseurLa compilationLe linkage  ","version":"Next","tagName":"h2"},{"title":"Le préprocesseur​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-préprocesseur","content":" La toute première étape est celle du préprocesseur. C'est le moment où toutes les directives préprocesseur sont traitées (toutes les lignes commençant par #).  Par exemple, nous avons déjà la directive préprocesseur #include qui permet d'inclure des fonctionnalités.  Cette directive fait simplement un copié-collé du contenu du fichier à inclure dans le fichier où la directive est utilisée.  Je ne vais pas en parler ici mais sachez qu'il existe d'autres directives permettant de faire des conditions en fonction des plateformes par exemple.  ","version":"Next","tagName":"h3"},{"title":"La compilation​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#la-compilation","content":" Ensuite nous avons la compilation à proprement parler.  Chaque fichier .cpp, obtenu après les modifications du préprocesseur, appelé unité de compilation, va être traité individuellement. Le but de cette étape est de transformer le code C++ (sous format texte) en langage compréhensible pour l'ordinateur.  C’est à cette étape que des vérifications du code ont lieu. Par exemple, dans le cas où le compilateur ne trouve pas la déclaration d’une fonction que vous appelez. Dans notre exemple précédent dans le fichier main.cpp, la compilation va s'arrêter avec un message d'erreur indiquant ce qui n’a pas fonctionné.  Cette étape va produire des fichiers objets.  Un fichier objet, reconnaissable à son extension en .o ou .obj, n’est rien d’autre que du langage machine mais seul, sans aucun lien avec le reste des autres fichiers. Tel quel, il n’est pas exécutable, car il lui manque des informations.  Il est possible de préciser aux compilateurs que l'on souhaite s'arrêter à ce stade en ajoutant des flags de compilation:  WindowsLinux et OSX Avec MSVC le flag est /c: cl /c helloImac.cpp   Cela indique au compilateur que l'on souhaite produire des fichiers objets et pas directement lier les fichiers pour en faire un exécutable.  Les fichiers d'objets peuvent faire référence à des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore entièrement définis. C'est le cas lorsque l'on utilise une fonction déclarée et que l'on n'a pas encore écrit le corps de celle-ci, nous allons le voir juste après. Le compilateur ne s'en préoccupe pas et produit le fichier objet demandé si le reste du code est correct.  remarque L'avantage est qu'il n'est pas nécessaire de tout recompiler si vous ne modifiez qu'un seul fichier. Si aucune modification n’est détectée depuis la dernière compilation, alors le compilateur réutilise le fichier objet précédemment créé lors d'une prochaine compilation ce qui accélère la compilation d’un projet. Cmake gère les fichiers objets lui même automatiquement dans le fameux dossier build.  ","version":"Next","tagName":"h3"},{"title":"Le linkage​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-linkage","content":" Nos fichiers objets ne sont pas utilisables en l'état et c'est la dernière étape de linkage qui va les lier entre eux pour produire un exécutable.  C'est ce qui va permettre de lier la déclaration d'une fonction dans un fichier et le corps de la fonction dans un autre fichier par exemple.  Il est aussi possible de faire cette opération en ligne de commande à partir des fichiers objets mais ce n'est pas très utile en pratique car des outils comme CMake se charge de cette étape pour nous.  ","version":"Next","tagName":"h3"},{"title":"En pratique​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#en-pratique","content":" Revenons à notre exemple avec les fichiers maths.cpp et main.cpp:  Premièrement, il manque la déclaration de la fonction sum (son prototype) dans le fichier main.cpp pour pouvoir produire un fichier objet valide:  main.cpp #include &lt;iostream&gt; int sum (int const a, int const b); int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   Ce fichier ne permet toujours pas de créer un exécutable à lui seul (car il manque le corps de la fonction sum) mais il est maintenant possible d'en faire un fichier objet.  ","version":"Next","tagName":"h2"},{"title":"Fichier d'en-tête​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#fichier-den-tête","content":" Pour une seule fonction dans mon exemple c'est simple de recopier le prototype de la fonction. Imaginons que notre fichier maths.cpp soit composé de dizaines de fonctions et que l'on souhaite les utiliser dans le fichier main.cpp mais aussi dans un autre fichier du même projet. Cela commence à être fastidieux de tout recopier.  On va donc regrouper les déclarations des fonctions dans un autre fichier d'extension .hpp que l'on appelle fichier d'en-tête (header en anglais).  Ainsi grâce à la directive préprocesseur #include on va pouvoir inclure (recopier) toutes les déclarations des fonctions facilement.  Dans notre exemple le fichier d'en-tête serait simplement:  maths.hpp int sum (int const a, int const b);   et le main.cpp devient:  main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   guillemets ou chevrons On peut noter une petite différence, j'utilise ici des guillemets &quot;&quot; pour l'inclusion et pas des chevrons &lt; &gt;. On pourrait très bien utiliser des guillemets tout le temps et faire: #include &quot;iostream&quot;. Cette différence est une question de convention et on réserve les chevrons &lt; &gt; pour les fichiers de qui viennent de bibliothèques comme la bibliothèque standard (iostream, string, vector, etc) et les guillemets &quot;&quot; pour le reste.  On va également inclure ce fichier d'en-tête dans notre fichier maths.cpp pour s'assurer que l'on implémente les bonnes fonctions listées dans le fichier d'en-tête.  maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   cpp ou hpp Les fichiers d’en-tête peuvent aussi utiliser l’extension .h. La différence n’est qu’une histoire de goût. Je préfère utiliser .hpp plutôt que .h pour mieux faire la distinction entre C et C++ par analogie aux fichiers sources, qui se terminent par .cpp en C++ mais .c en C.  ","version":"Next","tagName":"h3"},{"title":"Pragma once: éviter les doublons​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#pragma-once-éviter-les-doublons","content":" Mais se pose alors la question des doublons si l'on inclut de nombreux fichiers, les uns dépendants des autres.  Dans le cas des fonctions ce n'est pas bien grave car déclarer plusieurs fois une fonction (je parle du prototype pas du corps qui lui doit être unique) est autorisé bien que ce soit inutile.  Par contre ce n'est pas toujours le cas. Par exemple avec les Enums il n'est pas possible de les déclarer deux fois et on obtient une erreur de compilation si on le fait.  Un exemple Admettons que l'on a un autre fichier utils.cpp qui inclut maths.cpp pour fonctionner. utils.hpp contient les déclarations des fonctions propres au fichier utils.cpp. Le fichier maths.hpp définit un enum. Si maintenant on souhaite utiliser des fonctions des deux fichiers dans notre fichier principal main.cpp, on va se retrouver à inclure les deux: main.cpp #include &quot;utils.hpp&quot; #include &quot;maths.hpp&quot; int main() { // ... return 0; } Cela va provoquer une erreur lors de la compilation du fichier objet main car l'enum est déclaré deux fois. Une fois provenant de l'inclusion de utils.hpp (qui inclut lui-même maths.hpp) et une seconde fois en incluant directement le fichier maths.hpp.  #pragma once est une directive du préprocesseur là pour répondre à notre besoin.  Elle est utilisée pour empêcher que le contenu des fichiers d'en-tête soient inclus plusieurs fois. La directive #pragma once, présente dans un fichier d'en-tête, garantit que le contenu du fichier sera inclus une seule fois dans une compilation.  Le fichier maths.hpp dans notre exemple devient donc:  maths.hpp #pragma once int sum (int const a, int const b);   Un fichier d'en-tête doit toujours contenir cette directive au début du fichier.  Structures​  Bien que ce soit possible de mettre la déclaration d'une structure dans un fichier .cpp généralement on a besoin de s'en resservir dans plusieurs fichiers et la déclaration se trouve donc dans un fichier d'en-tête (.hpp).  Cependant, comme pour les enums, une structure ne peut être déclarée qu'une fois et il ne faut donc surtout pas oublier la directive préprocesseur #pragma once pour éviter un doublon lors d'inclusions.  On utilisera dans ce cas la déclaration de la structure avec les prototypes des fonctions qui lui sont associées dans notre fichier d'en-tête.  ","version":"Next","tagName":"h3"},{"title":"Utiliser Cmake​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#utiliser-cmake","content":" Pour résumer nous avons donc maintenant les fichiers suivants:  maths.hpp #pragma once int sum (int const a, int const b);   main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }   maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }   Nous allons les placer dans un dossier de projet puis dans un sous dossier /src (pour sources). Pour certains projets on peut avoir plusieurs sous dossiers comme /src, /include (pour séparer les fichiers d'en-tête). C'est une question d'organisation et de préférence.  Dans ce dossier de projet nous allons créer notre fichier CMakeLists.txt pour nous aider à compiler le projet.  Nous allons reprendre et modifier notre premier fichier Cmake.  Dans le fichier CMakeLists.txt il va falloir indiquer les répertoires où se trouvent les fichiers d'en-tête par target_include_directories().  On va également régler une variable Cmake CMAKE_RUNTIME_OUTPUT_DIRECTORY qui va permettre d'indiquer que l'on souhaite placer l'exécutable compilé dans un sous dossier bin.  CMakeLists.txt # la version de cmake à utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On souhaite placer l'exécutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # On indique que l'on souhaite faire un exécutable avec nos deux fichiers .cpp add_executable(helloImac &quot;src/main.cpp&quot; &quot;src/maths.cpp&quot;) # le dossier contenant les fichiers d'en-tête pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   CMAKE_SOURCE_DIR est une variable cmake qui indique le dossier dans lequel se trouve le fichier CMakeLists.txt (documentation ici).  attention Il faut s'assurer qu'il y a exactement une fonction d'entrée main() dans les fichiers sources listés pour un exécutable.  Petit résumé de notre dossier:  projet_folder/ ├── src/ │ ├── main.cpp │ ├── maths.cpp │ └── maths.hpp └── CMakeLists.txt   Vous pouvez maintenant ouvrir le dossier de projet dans VSCode et compiler votre projet.  ","version":"Next","tagName":"h2"},{"title":"Quelques améliorations​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#quelques-améliorations","content":" Je vous ai parlé de &quot;warnings&quot; de compilation à plusieurs reprises. Il est possible d'ajouter des options pour activer des warnings et avoir des informations supplémentaires lors de la compilation.  Je vous propose d'ajouter ces lignes dans votre fichier CMakeLists.txt:  if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif()   Cela va se complexifier avec un nombre plus important de fichiers sources. Avec Cmake il est possible de faire une recherche de fichier afin de ne pas avoir à lister tous les fichiers sources manuellement:  file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;)   Notre fichier CMakeLists.txt devient:  # la version de cmake à utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # Réglage du compilateur pour les warnings if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # On souhaite placer l'exécutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources message(STATUS &quot;Found source files:&quot;) foreach(SRC_FILE ${SRC_FILES}) message(STATUS &quot; - ${SRC_FILE}&quot;) endforeach() # On indique que l'on souhaite faire un exécutable avec nos fichiers sources add_executable(helloImac ${SRC_FILES}) # le dossier contenant les fichiers d'en-tête pour notre executable helloImac target_include_directories(helloImac PUBLIC &quot;src/&quot;)   ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Compilation et Headers: Séparer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#résumé","content":" Les fichiers d'en-tête ou headers (d'extension .hpp) sont là pour lister les différentes déclarations des fonctions (et d'autres choses comme les enums) afin de pouvoir les utiliser dans plusieurs fichiers. Les fichiers objets sont des fichiers générés pendant la compilation. Ils peuvent faire référence à des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore entièrement définis mais seulement déclarés (et inclus à l'aide des fichiers d'en-tête). Ils permettent aussi d'accélérer la compilation pour réutiliser des parties de code inchangées. La directive préprocesseur #include fait simplement un copier-coller du fichier cible dans le fichier actuel. La directive préprocesseur #pragma once permet d'éviter de copier deux fois des déclarations lors d'inclusions. C'est très utile pour les fichiers d'en-tête contenant des enums ou des structures. Il faut toujours l'utiliser dans les fichiers d'en-tête. il y a 3 étapes dans la compilation: Le préprocesseur qui transforme les directives préprocesseur comme #include ou #pragma once.La compilation qui génère des fichiers objets pour chaque unité de compilation (fichiers .cpp après traitement du préprocesseur).Le linkage qui permet de lier tous les fichiers objets ensemble pour obtenir un exécutable. Cmake permet de gérer ces étapes de compilation simplement. ","version":"Next","tagName":"h2"},{"title":"Un peu d'histoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/introduction","content":"","keywords":"","version":"Next"},{"title":"Pourquoi apprendre C++ ?​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#pourquoi-apprendre-c-","content":" Sa popularité : le C++ est un langage qui est utilisé dans de nombreux projets importants de développement logiciel. Il est également beaucoup utilisé dans l'industrie du jeu vidéo. Il est enseigné dans de nombreuses formations en informatique. Il possède une communauté très importante, beaucoup de documentation et d’aide en ligne ainsi qu'une bibliothèques préexistantes très riche. Sa rapidité : C’est cette caractéristique qui fait de lui un des langages de choix pour les gros logiciels, les calculs scientifiques et le domaine du jeu vidéo. Son ancienneté : C++ est un langage ancien d’un point de vue informatique, il a fait l'objet de plusieurs mises à jour ce qui donne une certaine garantie de maturité, de stabilité et de pérennité (il ne disparaîtra pas dans quelques années). Sa modernisation : depuis sa version de 2011, C++ est beaucoup plus facile à apprendre. La version C++11 le rend plus facile à utiliser et plus puissant dans les fonctionnalités qu’il propose.  ","version":"Next","tagName":"h2"},{"title":"Langage difficile ?​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#langage-difficile-","content":" Tout n’est tout de même pas parfait et le C++ a aussi ses défauts.  Son héritage du C : C++ est un descendant du langage C, inventé dans les années 1970. Certains choix de conception, sûrement pertinents pour l’époque, sont plus problématiques aujourd’hui, et C++ les traine avec lui.  Sa complexité : La liberté et les performances qu'il offre viennent avec leur lot de complexités. Avoir une certaine maîtrise du C++ est &quot;long&quot; et demandera des années d’expérience, notamment parce que certaines des fonctionnalités les plus puissantes demandent de bien connaître les bases.  Mais je vous rassure, nous allons commencer par les bases pour aborder pas à pas ce langage, que vous ayez déjà programmé ou non. Nous allons découvrir les notions petit à petit pour que ce soit le plus compréhensible possible (certaines notions plus complexes ne seront d'ailleurs vu qu'en deuxième année).  ","version":"Next","tagName":"h2"},{"title":"La documentation​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#la-documentation","content":" En programmation, un bon réflexe à adopter est d'aller consulter la documentation de l’outil concerné, et ce avant de demander de l’aide sur un forum par exemple.  Voici un lien vers une excellente documentation C++. Elle est en anglais, mais je suis également là pour vous aider. Je vous donnerai des liens, vous expliquerai comment comprendre et exploiter les informations fournies pour que, par la suite, vous puissiez le faire vous-même.  Enfin, sachez qu’il existe une référence ultime appelée la norme, produit par un organisme de validation international, l'ISO, qui explique tous les détails et les règles du C++ mais qui est un document (trop) complexe, même pour des professionels, et est donc largement hors de portée nous concernant. Je le mentionne simplement pour que vous soyez au courant de son existence, sans être surpris si, lors de vos recherches sur Internet, des réponses mentionnent ou citent la norme.  ","version":"Next","tagName":"h2"},{"title":"Compilé vs interprété​","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#compilé-vs-interprété","content":" Il existe deux grands types de langages informatiques, les langages interprétés et compilés.  Dans un langage interprété, le même code source pourra marcher directement sur tout ordinateur disposant de l'interpréteur nécessaire, c'est le cas du Python par exemple.  remarque L'interpréteur est un programme en lui même qui interprète le code pour le convertir en instructions compréhensibles pour la machine.  Avec un langage compilé, il faut compiler son programme (entièrement ou recompiler partiellement) à chaque fois pour pouvoir obtenir un exécutable utilisable sur la machine sur laquelle on veut lancer celui-ci.  Cela nécessite donc une étape supplémentaire (plus ou moins rapide): la compilation. Mais cela apporte également l'avantage de pouvoir optimiser et adapter l'exécutable pour une ou des machines spécifiques.  Dans la majorité des cas, l'exécutable compilé sera plus performant et plus rapide qu'un équivalent dans un langage interprété.  Dans votre cas, vous allez coder en C++ qui est un langage compilé et ce sera donc la première étape de ce cours.  Nous allons voir ensemble comment installer tous les outils nécessaires à tout développeur C++ sur votre machine afin d'exécuter votre premier programme C++. ","version":"Next","tagName":"h2"},{"title":"Des tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Tableaux​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#tableaux","content":" Les tableaux sont là pour résoudre ce problème et nous permettre de stocker plusieurs éléments.  Ils font partie de ce qu'on appelle les structures de données, des structures permettant d'organiser de façon particulière des données, on les nomme aussi des conteneurs.  En ce qui concerne les tableaux il en existe principalement deux types:  std::array qui permet de stocker un nombre fixé à l'avance d'élémentsstd::vector qui permet de stocker un nombre variable ou dynamique d'éléments  A retenir que les tableaux permettent seulement de stocker des variables de même type.  remarque Il existe bien d'autres structures de données qui stockent de façon différente (avec des avantages et des inconvénients) mais nous n'allons pas rentrer dans ce détail pour l'instant.  ","version":"Next","tagName":"h2"},{"title":"std::vector​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdvector","content":" Comme vous le remarquez, j'ai ajouté std:: devant vector ce qui nous indique que c'est une fonctionnalité déjà codée pour nous dans la bibliothèque standard. Pour pouvoir s'en servir on va donc inclure le fichier contenant cette fonctionnalité en faisant #include &lt; vector &gt;  std::vector est un tableau dynamique qui s'agrandit et se rétrécit en fonction du nombre d'éléments que l'on souhaite stocker à l'intérieur.  On l'initialise entre accolades en précisant entre chevrons (&lt; et &gt;) le type de variable que l'on souhaite stocker:  std::vector&lt;/* type des éléments du tableau */&gt; nom {};   des exemples #include &lt;vector&gt; int main() { // initialisation d'un tableau à remplir plus tard std::vector&lt;int&gt; vector01 {}; // il est aussi possible de le préremplir à sa création std::vector&lt;int&gt; vector02 { 12, 18, 8, 4, 9 }; // on peut rendre constant afin d'éviter de future modifications si c'est ce que l'on souhaite std::vector&lt;float&gt; const vector03 { 3.1415f, 5.2365f }; // il est aussi possible de l'initialiser en copiant les valeurs d'un autre tableau de cette manière std::vector&lt;float&gt; vector04 { vector03 }; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Manipuler notre tableau​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#manipuler-notre-tableau","content":" ","version":"Next","tagName":"h2"},{"title":"Accéder aux éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#accéder-aux-éléments","content":" Pour accéder aux éléments on utilise les crochets ([ et ]) après le nom de notre tableau, avec la position de l’élément à récupérer.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; &quot;the second élément is &quot; &lt;&lt; vector[1] &lt;&lt; std::endl; return 0; }   attention ⚠️ généralement en informatique (c'est le cas en C++), les éléments sont indexés à partir de 0 et non 1. c'est pour ça que 0 correspond au premier élément et 1 au deuxième dans notre exemple.  danger Et si j’accède à l’élément d'index 6 (donc le 7ème élément) alors que mon tableau n'en contient que 6, que se passe-t-il ? C'est un comportement indéterminé. Le programme peut continuer sans rien dire, ou alors s'arrêter brusquement avec des erreurs nommées généralement &quot;out of range&quot; (dépassement de capacité) ou &quot;segmentation fault&quot; (erreur de segmentation). Il ne faut pas utiliser d’indice inférieur à 0 ou supérieur ou égal à la taille de notre tableau.  ","version":"Next","tagName":"h3"},{"title":"Taille du tableau​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#taille-du-tableau","content":" Pour connaître la taille du tableau on va utiliser la fonction propre (appelée méthode) size() qui renvoie le nombre d'éléments.  remarque Une fonction est un regroupement d'instructions que permet de réutiliser du code à plusieurs endroits d'un programme. Une méthode est une fonction propre à un objet(ici notre std::vector) et qui peut le manipuler ou retourner des informations à son sujet. Nous en reparlerons plus en détail dans un prochain chapitre, mais nous pouvons dès maintenant en utiliser.  Le type de retour de cette méthode est un type nouveau, que nous n’avons pas rencontré jusque-là et qui s’appelle std::size_t. C’est un type entier non signé capable de stocker l'index d'un élément ou la taille de n’importe quel tableau, aussi grand soit-il. C'est, pour faire simple, un très grand entier positif équivalent à écrire unsigned long int.  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; std::size_t const size { vector.size() }; std::cout &lt;&lt; &quot;Mon tableau contient &quot; &lt;&lt; size &lt;&lt; &quot; éléments.&quot; &lt;&lt; std::endl; return 0; }   remarque Il existe aussi une fonction std::size(...) qui prends en paramètre le tableau et retourne sa taille. std::size_t const size { std::size(vector) }; Dans la pratique, j'utilise plutôt la méthode, plus lisible selon moi mais c'est un avis personnel et vous êtes libres de choisir ce qu’il vous plaît.  ","version":"Next","tagName":"h3"},{"title":"Premier et dernier élément​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#premier-et-dernier-élément","content":" On pourrait utiliser la taille pour accéder au dernier élément du tableau mais on peut aussi utiliser deux autres méthodes (front() et back()) pour accéder au premier et au dernier élément du tableau:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; // Façon de faire hérité du c en utilisant la taille du tableau (attention au -1 les index commencent à 0) std::cout &lt;&lt; &quot;Le dernier élément est &quot; &lt;&lt; vector[vector.size() - 1] &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le premier élément est &quot; &lt;&lt; vector.front() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le dernier élément est &quot; &lt;&lt; vector.back() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Vérifier si un tableau est vide​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#vérifier-si-un-tableau-est-vide","content":" Pour savoir si le tableau est vide on peut utiliser une condition sur la taille du tableau. Il y a aussi la méthode empty() qui fait ce test pour nous et permet d'écrire quelque chose de plus lisible:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector01 { }; std::vector&lt;int&gt; const vector02 { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.size() == 0 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.empty() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector02 est vide : &quot; &lt;&lt; vector02.empty() &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Afficher les éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#afficher-les-éléments","content":" Pour afficher les éléments du tableau on peut simplement utiliser sa taille et une boucle for pour itérer sur les différentes valeurs:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; for (std::size_t i {0}; i &lt; vector.size(); i++) { std::cout &lt;&lt; vector[i] &lt;&lt; std::endl; } return 0; }   Range-based for loop​  Depuis le C++ moderne (à partir de C++11) il existe une nouvelle façon de parcourir des conteneurs (qui se généralise sur d'autres structures de données):  for (/* type d'un élément du tableau */ nom : /* structure de données à parcourir */) { }   remarque On appelle cela un foreach dans d'autres languages.  Plus besoin de récupérer la taille et cela va rendre notre code plus lisible:  Petit exemple avec std::vector #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   ","version":"Next","tagName":"h3"},{"title":"Ajouter, supprimer et modifier des éléments​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#ajouter-supprimer-et-modifier-des-éléments","content":" Comme expliqué, le std::vector est dynamique dans le sens où il est possible d'ajouter ou de supprimer des éléments. C'est avec la méthode push_back que l'on ajoute un élément:  #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 42 }; // On ajoute des éléments vector.push_back(23); vector.push_back(5); for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }   attention On ne pourra pas ajouter un élément de type différent dans notre tableau, un tableau ne peut contenir qu'un seul type de variable.    Pour supprimer un élément on utilisera les méthodes pop_back ou clear.  Clear comme son nom l'indique permet de vider entièrement le tableau et pop_back permet de retirer et retourner le dernier élément.  #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 42, 12 }; std::cout &lt;&lt; &quot;Taille avant clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.clear(); std::cout &lt;&lt; &quot;Taille après clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.push_back(23); vector.push_back(42); vector.push_back(25); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; vector.pop_back(); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; if(!std::empty(vector)) { int last_value {vector.back()}; vector.pop_back(); std::cout &lt;&lt; &quot;La derniere valeur du tableau etait : &quot; &lt;&lt; last_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; } return 0; }   danger Appeler pop_back sur un tableau vide est aussi un comportement indéterminé. Une très bonne pratique est donc de s'assurer que le tableau n'est pas vide.    Enfin, pour pouvoir modifier une valeur il suffit d'accéder à l'élément (à condition que le tableau ou la variable ne soit pas constante évidemment) d'utiliser le symbole égal =.  #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 24, 12, 6 }; // On change la valeur du premier élément vector[0] = 15; return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::array​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdarray","content":" std::array est un tableau statique, c’est-à-dire que sa taille doit être connue à la compilation et ne peut pas varier. En contre-partie, cette structure de données est plus performant et plus rapide qu’un std::vector puisqu’il n’y a pas d’opération d’ajout ou de retrait d’éléments.  Pour l’utiliser, il faut inclure le ficher qui contient cette fonctionnalité (#include &lt; array &gt;).  On l'initialise en précisant entre chevrons le type de variable que l'on souhaite stocker et sa taille:  std::array&lt;/* type des éléments du tableau */, /* taille du tableau */&gt; nom {};   Contrairement à std::vector, un tableau statique doit contenir autant d'éléments que la taille précisée. Ainsi, si l'on ne précise donc rien ou pas la totalité des éléments à son initialisation, le tableau va être rempli avec des valeurs par défaut.  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array_of_integer { 24, 12, 6, 32, 8 }; // On change la valeur du deuxième élément array_of_integer[1] = 42; std::cout &lt;&lt; &quot;Le tableau d'entier contient: &quot;; for (int const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // les 4 autres valeurs non précisées seront donc égale à 0.0f std::array&lt;float, 6&gt; array_of_float { 45.3f, 142.857f }; std::cout &lt;&lt; &quot;Le tableau de flottant contient: &quot;; for (float const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // Ce tableau sera rempli de 4 valeurs par défaut égales à 0.0 std::array&lt;double, 4&gt; array_of_double { }; return 0; }   Il existe la méthode fill spécifique au std::array qui permet de le remplir avec une valeur donnée:  #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array { 1, 2, 3, 4, 5}; array.fill(3); std::cout &lt;&lt; &quot;Le tableau contient: &quot;; for (int const value : array) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; return 0; }   Le reste des fonctionnalités reste identique avec le std::vector (hors les ajouts et suppressions car le tableau ne change pas de taille ici).  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#pour-aller-plus-loin","content":" std::vector et std::array sont des structures qui disposent d'une multitude de méthodes très utiles, je vous laisse chercher par vous même dans la documentation ou revenir vers moi si vous avez des questions à ce sujet.  ","version":"Next","tagName":"h2"},{"title":"std::string: un tableau caché​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdstring-un-tableau-caché","content":" Nous avions découvert le type un peu particulier std::string dans le chapitre sur les variables.  Ce &quot;type&quot; est lui même une structure de données qui permet de stocker du texte, une suite de caractères (de type char donc).  Le type std::string n’est donc rien d’autre qu'un tableau &quot;dynamique&quot; de char, conçu et optimisé spécialement pour le stockage de texte.  On peut donc faire toutes les opérations que nous venons de voir, accéder à sa taille, accéder aux caracatères, les modifier, en ajouter ou supprimer et enfin boucler sur les caractères.  des exemples #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string phrase { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; &quot;Premier caractère : &quot; &lt;&lt; phrase.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dernier caractère : &quot; &lt;&lt; phrase.back() &lt;&lt; std::endl; phrase.pop_back(); phrase.push_back('.'); std::cout &lt;&lt; phrase &lt;&lt; std::endl; phrase[9] = ' '; std::cout &lt;&lt; phrase &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Cette phrase contient &quot; &lt;&lt; phrase.size() &lt;&lt; &quot; caractères.&quot; &lt;&lt; std::endl; // Il existe aussi &quot;phrase.length()&quot; qui fait exactement la même chose for (char lettre : phrase) { std::cout &lt;&lt; lettre &lt;&lt; ','; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Est ce que la phrase est vide ? &quot; &lt;&lt; std::empty(phrase) &lt;&lt; std::endl; return 0; }   std::string dispose de nombreuses autres méthodes permettant de faire d'autres choses spécifiques à la gestion de texte. Nous aurons l’occasion de le revoir, retenez simplement ici que std::string peut être manipulé comme un tableau.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#résumé","content":" Il existe plusieurs types de tableaux, statique quand la taille est fixe et dynamique quand elle peut varier.  std::vector est un tableau dynamique.std::array est un tableau statique.std::string est un tableau dynamique spécialement conçu pour la gestion du texte. ","version":"Next","tagName":"h2"},{"title":"Un peu de logique avec les conditions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Conditions","content":"","keywords":"","version":"Next"},{"title":"Les valeurs booléennes​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#les-valeurs-booléennes","content":" J'ai omis un type lors du précédent chapitre, il s'agit du type booléen, il s'utilise avec le mot clé bool.  Ce type peut prendre deux valeurs: soit true, signifiant vrai, soit false qui veut dire faux. C'est donc idéal pour stocker le résultat d'une condition.  Voici un petit exemple int main() { bool const condition { true }; return 0; }   Cela va devenir intéressant grâce à ce que l'on appelle les opérateurs de comparaison.  Opérateur\tSignification==\tÉgalité, compare si deux variables sont égales !=\tInégalité, compare si deux variables sont différentes &lt;\tStrictement inférieur, compare si la variable de gauche est strictement inférieure à celle de droite &lt;=\tInférieur ou égal, compare si la variable de gauche est inférieure ou égale à celle de droite &gt;\tStrictement supérieur, compare si la variable de gauche est strictement supérieure à celle de droite &gt;=\tSupérieur ou égal, compare si la variable de gauche est supérieure ou égale à celle de droite  Ces opérateurs vont nous permettre de créer des conditions (des valeurs booléennes) à partir de nos autres variables.  #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; != &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a != b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt; &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt; b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt;= &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt;= b) &lt;&lt; std::endl; // On peut aussi stocker le résultat de la condition dans une variable booléenne float const price { 24.5f }; bool const is_too_expensive { price &gt;= 100.f }; return 0; }   remarque Par défaut, std::cout affiche 1 pour une condition vraie (true) et 0 pour une condition fausse (false). Il est possible de changer ce comportement en ajoutant un &quot;modificateur&quot; sur le stream std::cout: #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"La logique booléenne​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#la-logique-booléenne","content":" Maintenant que nous disposons d'un moyen d'obtenir une valeur booléenne (via les opérateurs de comparaison) nous allons pouvoir manipuler ces valeurs avec ce que l'on nomme des opérateurs logiques.  Ces opérateurs vont permettre de combiner et modifier des valeurs booléennes afin d'en obtenir d'autres et faire ce que l'on appelle plus généralement de l’algèbre booléenne. Mais ne vous inquiétez pas, derrière ce nom très mathématique se cache des choses très simples.  ","version":"Next","tagName":"h2"},{"title":"NOT: La négation​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#not-la-négation","content":" L'opérateur ! (placé devant une valeur booléenne) permet d'exprimer la négation d'une condition.  remarque C'est ici un opérateur dit unaire (qui s'applique sur une seule valeur) et donne en retour la condition inverse.  Voici ce qu’on appelle la table de vérité de l’opérateur NOT, qui formalise les entrées et les sorties de cet opérateur.  A\tRésultattrue\tfalse false\ttrue  float price { 114.2f }; bool isExpensive { price &gt;= 100.f }; bool isCheap { !isExpensive };   ","version":"Next","tagName":"h3"},{"title":"AND​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#and","content":" L'opérateur &amp;&amp; (placé entre deux valeurs booléennes) permet d'exprimer la validité de deux conditions en même temps. On peut l'interpréter en français par : &quot;ma condition1 est vraie ET ma condition2 est aussi vraie&quot;.  A\tB\tRésultattrue\ttrue\ttrue true\tfalse\tfalse false\ttrue\tfalse false\tfalse\tfalse  ","version":"Next","tagName":"h3"},{"title":"OR​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#or","content":" L'opérateur || (placé entre deux valeurs booléennes) permet d'exprimer si au moins une des deux conditions est vraie. On peut l'interpréter en français par : &quot;ma condition1 est vraie OU ma condition2 est vraie&quot;.  A\tB\tRésultattrue\ttrue\ttrue true\tfalse\ttrue false\ttrue\ttrue false\tfalse\tfalse    remarque Il est également possible d'utiliser les mots-clés and, or et not pour remplacer respectivement les opérateurs &amp;&amp;, || et !. C'est possible mais très peu répandu en C++ c'est pourquoi je ne l'utiliserai pas personnellement mais sachez que ça existe également. Avec de vielles versions de Visual Studio il est possible que cette syntaxe ne fonctionne pas et dans ce cas il faut inclure le fichier &lt;ciso646&gt;.  danger Pour l'opérateur AND (&amp;&amp;) on note qu'il y a bien deux fois le symbole &amp;. C'est très important car il existe un autre opérateur (avec un seul &amp;) qui fait tout autre chose. Je ne détaillerai pas dans ce chapitre son utilité mais il est important de le souligner car c'est une erreur qui arrive fréquemment. De même pour l'opérateur OR (||) différent de |.  ","version":"Next","tagName":"h2"},{"title":"Des structures de contrôle​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#des-structures-de-contrôle","content":" C'est bien beau toutes ces valeurs booléennes mais comment on peut s'en servir pour exécuter une partie d'un code ou un autre en fonction d'une condition ?  ","version":"Next","tagName":"h2"},{"title":"Si​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#si","content":" Notre première structure de contrôle va s'utiliser avec le mot clé if. De l'anglais, ce mot clé signifiant &quot;si&quot;, exécute des instructions si et seulement si la condition donnée est vraie.  Un petit schéma d'explications:    Voilà comment l'utiliser. Toutes les instructions entre accolades seront exécutées si la condition est vraie.  if( /* condtion */ ) { // ... }   Un petit exemple #include &lt;iostream&gt; int main() { float price { 114.2f }; if ( price &gt;= 100.f ) { // appliquer une réduction si l'on dépasse un certain prix price *= 0.9f; } std::cout &lt;&lt; &quot;Le prix final est de &quot; &lt;&lt; price &lt;&lt; &quot;€&quot; &lt;&lt; std::endl; return 0; }   attention Il est possible de créer des variables à l'intérieur même des accolades de la structure de contrôle mais celles-ci sont restreintes à cette portée. C'est ce qu'on appelle la portée des variables (scope en anglais). Plus généralement, cette règle du C++ s'applique à n'importe quel bloc entre accolades.Une variable n’est utilisable que dans la portée, ou le bloc d’accolades où elle a été déclarée. Nous en reparlerons plus en détail dans d'autres chapitres.  attention Il n'est pas très utile de tester par une égalité le résultat d'une condition : float const price { 114.2f }; bool const isExpensive { price &gt;= 100.f }; if ( isExpensive == true ) { // ... } isExpensive ici étant déjà une valeur booléenne ajouter une égalité supplémentaire avec la valeur true ne va rien faire d'autre que de créer une nouvelle valeur booléenne qui a la même valeur. Il est donc plus clair et concis d'écrire directement: bool const isExpensive { price &gt;= 100.f }; if ( isExpensive ) { // ... }   ","version":"Next","tagName":"h3"},{"title":"Sinon​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#sinon","content":" C'est très bien de pouvoir effectuer quelque chose si une condition est vérifée mais comment faire si l'on veut effectuer une action A si la condition est vérifée et une autre action B si ce n'est pas le cas ?  On pourrait très bien enchaîner deux if avec la condition opposée:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } if ( temperature &lt; 35.f ) { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Mais c'est là que le mot-clé else (de l'anglais &quot;sinon&quot;) nous permet d'exécuter des instructions si la condition du if est fausse de manière plus compréhensible:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }   Ici le else n'a pas de parenthèse et indique donc &quot;tout le reste&quot; (ce qui ne vérifie pas la condition).  remarque L'opérateur logique de négation ! est parfois très utile dans le cas où l'on avait stocké une valeur mais l'on souhaite faire une suite d'instructions uniquement dans le bloc else du if. Au lieu de faire : #include &lt;iostream&gt; int main() { bool condition { false }; if ( condition ) { // ... ne rien faire } else { // effectuer nos instructions } return 0; } Il est préférable de faire: #include &lt;iostream&gt; int main() { bool condition { false }; if ( !condition ) { // effectuer nos instructions } return 0; }   Mais comment tester une succession de conditions différentes avant de faire &quot;tout le reste&quot; ?  ","version":"Next","tagName":"h3"},{"title":"Sinon si​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#sinon-si","content":" On pourrait très bien chaîner plusieurs if et else imbriqués de cette manière:  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( /* condition1 */ ) { // ... } else { if ( /* condition2 */ ) { // ... } else { if ( /* condition3 */ ) { //... } else { //... } } } return 0; }   Mais vous êtes sûrement d'accord pour dire que ça commence à être difficile à suivre et écrire à cause des imbrications. Le C++ est bien fait et nous permet de d'utiliser la combinaison else if pour ce cas de figure.  else if s’utilise entre un if et un else et signifie &quot;ou alors si cette condition est vraie&quot;.  #include &lt;iostream&gt; int main() { if ( /* condition1 */ ) { // ... } else if ( /* condition2 */ ) { // ... } else if ( /* condition3 */ ) { //... } else { //... } return 0; }   remarque Enfin, il existe une dernière syntaxe (le switch pour les curieux) qui permet de faire quelque chose de similaire au else if mais il nous manque quelques notions et je vous le présenterai donc au chapitre suivant sur les boucles.  ","version":"Next","tagName":"h3"},{"title":"Faux-ami​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#faux-ami","content":" danger Attention le test d'égalité == est différent de l'opérateur d'affectation =.  int number { 20 }; if ( number = 10 ) { // ... }   En C++, l'assignation retourne la valeur de la variable assignée. Ici, la condition sera vraie car number vaut 10 après l'assignation et 10 est considéré comme vrai.  Les valeurs numériques non nulles sont considérées comme vraies et la valeur 0 est considérée comme fausse.  ","version":"Next","tagName":"h2"},{"title":"Combinaison d'expressions​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#combinaison-dexpressions","content":" Avec tous les opérateurs logiques vu précédemment il est même possible de tester plusieurs conditions dans un même if.  #include &lt;iostream&gt; int main() { float temperature { 24.0f }; bool const isRaining { false }; bool const wantToGoOut { true }; bool const ownsAnUmbrella { false }; if ( wantToGoOut &amp;&amp; (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella) ) ) { // ... } else { //... } return 0; }   danger Les opérateurs logiques sont comme les opérateurs mathématiques que nous avons vus dans les chapitres précédents: ils ont une priorité. Le plus prioritaire est la négation !Ensuite c'est le ET &amp;&amp;Enfin, le OU || est le moins prioritaire Par exemple avec le code a &amp;&amp; b || c &amp;&amp; d, dans l’ordre, on évalue a &amp;&amp; b, c &amp;&amp; d et enfin (a &amp;&amp; b) || (c &amp;&amp; d). Pour des raisons de lisibilité je vous recommande très fortement d'ajouter des parenthèses (comme dans mon exemple ci-dessus) pour expliciter quelles opérations vous voulez prioriser dans ce genre de cas plus &quot;complexe&quot;.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#pour-aller-plus-loin","content":" Enfin, pour aller encore plus loin il est possible de manipuler les opérateurs &amp;&amp;, || et ! et trouver des expressions donnant le même résultat. Cela permet parfois de simplifier le code ou alors d'exprimer la condition sous une forme plus lisible ou compréhensible.  Dans mon exemple précédent la condition (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella)) est équivalente à écrire (!isRaining || ownsAnUmbrella).  Il existe aussi le théorème de De Morgan qui permet d'exprimer la négation d'un ET avec un OU et inversement.  Il est possible d'exprimer mon exemple précédent sous cette forme:  (!isRaining || ownsAnUmbrella) équivalent à !(isRaining &amp;&amp; !ownsAnUmbrella)  On peut s'en convaincre en essayant de traduire ces conditions en phrases:  (!isRaining || ownsAnUmbrella): c'est le cas où il ne pleut pas ou alors j'ai un parapluie.!(isRaining &amp;&amp; !ownsAnUmbrella) ce n'est pas le cas où il pleut et je n'ai pas de parapluie.  Vous trouverez des exemples de propriétés et simplifications possibles sur la page Wikipédia suivante:Algèbre de Boole  ","version":"Next","tagName":"h3"},{"title":"En résumé​","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#en-résumé","content":" Une valeur booléenne est du type bool et peut prendre comme valeur true ou false. On obtient une valeur booléenne avec une condition sur nos variables (avec les opérateurs de comparaison ==, !=, &lt;, &lt;=, &gt; ou &gt;=) Les opérateurs &amp;&amp;, || et ! permettent de modifier et combiner les valeurs booléennes. On utilise les structures de contrôle if, else, else if pour exécuter des instructions différentes en fonction des conditions. ","version":"Next","tagName":"h2"},{"title":"Fonctions : Découper son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Structure d'une fonction​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#structure-dune-fonction","content":" Une fonction est un ensemble d'instructions délimité par des accolades { et } ce qui défini sa portée (scope).  Elle a un nom et peut ou non prendre des informations en entrée et peut ou non fournir une information en sortie.  type_de_retour nom(paramètres) { instructions }   Un exemple bien connu Dès notre premier programme nous avions rencontré une fonction, la fonction main. Celle-ci est le point d’entrée de tous les programmes que nous codons en C++. int main() { // Instructions diverses return 0; } Ici, main est le nom de la fonction. Le int situé juste avant indique son type de retour. Dans ce cas, la fonction renvoie une valeur entière (via le return 0;) qui indique que tout s’est bien passé. Après, le nom, il y a des parenthèses vides (), ce qui signifie que la fonction n’attend aucune information en entrée. Enfin, entre les accolades , nous avons les instructions qui la composent.  ","version":"Next","tagName":"h2"},{"title":"Choisir un nom​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#choisir-un-nom","content":" Les règles de nommage des fonctions sont les mêmes que pour nommer nos variables, vous pouvez aller les relire ici si nécessaire.  De même que pour les variables, il est important de donner un nom explicite aux fonctions afin de définir clairement ce qu’elles font.  ","version":"Next","tagName":"h3"},{"title":"Type de retour​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#type-de-retour","content":" Une fonction peut ou non renvoyer une valeur de retour, comme nous l’avons vu avec la fonction main. Il faut simplement préciser le type de la valeur à retourner comme vu précédemment.  Pour renvoyer une valeur, on utilise le mot-clé return, exactement comme dans la fonction main.  info Il peut y avoir plusieurs return dans une fonction. Un si un if est vrai, l’autre s’il est faux par exemple. Mais dès que l'instruction return est exécutée, on sort de la fonction en cours et tout le code restant n’est pas exécuté. Cela coupe le flot d’exécution de la fonction comme avec les mots-clés break et continue avec les boucles.  Si votre fonction ne doit rien renvoyer, alors on utilise le mot-clé void, qui signifie &quot;vide&quot; et qui, dans ce contexte, indique que la fonction ne retourne pas d'information (dans ce cas il n'est pas nécessaire d'utiliser l'instruction return mais peut tout de même être utilisée pour couper le flot d’exécution).  ","version":"Next","tagName":"h3"},{"title":"Des paramètres​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#des-paramètres","content":" Maintenant, parlons des paramètres. C'est via des paramètres que la fonction décrit ce qu'elle attend pour travailler.  On les déclare entre les parenthèses (()). Il faut que chaque paramètre ait un type et un nom. S’il y en a plusieurs, ils seront séparés par des virgules.  Des exemples #include &lt;iostream&gt; int sum (int a, int b) { return a + b; } int pgcd(int a, int b) { int r { a % b }; while (r != 0) { a = b; b = r; r = a % b; } // On peut tout à fait renvoyer la valeur d'un paramètre return b; } int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le PGCD de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; pgcd(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }   attention Une fonction doit être déclarée avant son utilisation. Il faut donc la déclarer avant la fonction main afin d'être en mesure de l'utiliser dans la fonction main par exemple.  Le nom donné aux paramètres d'une fonction est spécifique à cette fonction et n'est pas partagé par le reste du code. Il est possible de donner en argument à une fonction une variable qui porte le même nom qu’un des paramètres.  Inversement, il n’est pas possible d’utiliser un paramètre de fonction en dehors de celle-ci. Le code suivant produit donc une erreur.  int function(int parameter) { parameter += 5; return parameter; } int main() { int const a { function(37) }; int const b { function(a) }; // La variable parameter n'existe pas ici parameter = 410; return 0; }   Argument vs paramètre Attention, il faut bien faire la distinction entre paramètre et argument. Un paramètre, c’est ce qu’attend une fonction pour travailler et qui est inscrit dans sa déclaration, le nom du paramètre est propre à la fonction et utilisable uniquement dans celle-ci. Un argument, c’est la valeur transmise à la fonction quand on l’utilise. Dans notre exemple précédent parameter est le paramètre de la fonction. 37 est l'argument de la fonction pour l'assignation de la variable a. Ensuite a devient lui même argument de la fonction pour l'assignation de b. En pratique, il y a souvent un abus de langage et les deux termes s'utilisent de façon interchangeable et je ne vous en voudrais si vous faites de même mais je tenais à vous expliquer la différence.  ","version":"Next","tagName":"h3"},{"title":"Petit point vocabulaire: les méthodes​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#petit-point-vocabulaire-les-méthodes","content":" Dans le précédent chapitre sur les tableaux nous avons vu des fonctions propres ou méthodes.  On parle de méthode quand une fonction est associée à un objet. C'est le cas par exemple de la fonction size() sur l'objet std::vector. Elle s'utilise avec un point . après le nom de la variable en question. On dit que size() est une méthode de std::vector. Une méthode a donc &quot;connaissance&quot; de l'objet en question pour le modifier, lire des informations, etc.  std::vector&lt;int&gt; const array { 12, 18, 8, 4, 9 }; std::size_t const size { array.size() };   Nous y reviendrons plus tard, pour l'instant gardez simplement à l'esprit que c'est réservé à des type &quot;particuliers&quot; comme le std::vector ou std::string et que l'on appelle ça des méthodes.  ","version":"Next","tagName":"h3"},{"title":"Une portée limitée​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#une-portée-limitée","content":" J'avais déjà évoqué la notion de portée (ou scope) lors de l'introduction des stuctures de contrôle. Cette notion est aussi vraie avec les fonctions. Les instructions d'une fonction sont contenues entre des accolades et donc restreignent la portée des variables à l'intérieur de ce bloc.  C’est une bonne pratique de déclarer ses variables dans la plus petite portée possible.  Cela permet premièrement de limiter son utilisation à cette portée et éviter un usage malencontreux plus tard. Déclarer une variable proche de son utilisation évite de devoir chercher et parcourir un code parfois long et complexe pour comprendre pourquoi cette variable est utilisée à cet endroit précis. Cela aide donc à la lecture et la compréhension du code.  Enfin, lorsqu’on atteint la fin d'un bloc (accolade }), le programme libère dans la mémoire les emplacements qu’il avait réservés pour les variables du bloc en question. C'est donc plus propre et plus performant (niveau mémoire) de déclarer les variables à l’intérieur d'un bloc (fonction, condition, etc) si elles ne sont pas destinées à être utilisées ailleurs.  ","version":"Next","tagName":"h2"},{"title":"Paramètre par copie​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#paramètre-par-copie","content":" J’ai expliqué précédemment que les paramètres d’une fonction étaient dans une portée différente concernant le nommage.  La portée différente implique une copie. Pour chaque utilisation de la fonction, le compilateur va réserver un nouvel espace mémoire et copier l'argument (la variable) qu’on lui passe en paramètre. Une variable dans la fonction est donc totalement différente. C’est ce qu'on appelle un passage par copie.  On peut donc nommer nos paramètres avec le même nom qu'une de nos variables.  Un exemple #include &lt;iostream&gt; void addOne(int a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   On pourrait penser que cela va afficher 9 mais en réalité a est toujours égal à 8. la fonction addOne a reçu une copie de la variable a (nommée a elle aussi) mais elle ne peut pas modifier la variable a originale.  Dans le cas d’un entier ou d’un caractère par exemple ce n'est pas très grave, mais dans le cas d’un tableau de plusieurs d’éléments, on perd du temps inutilement à copier toutes les valeurs du tableau (même si on ne veut en lire que quelques unes dans la fonction).  ","version":"Next","tagName":"h2"},{"title":"Référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#référence","content":" Mais, en C++, il existe un moyen de créer un alias, une référence vers une variable. Cette référence devient manipulable comme si nous avions la variable originale entre les mains.  On indique qu'une variable est une référence vers une autre en ajoutant une esperluette (&amp;) après le type de notre variable.  #include &lt;iostream&gt; int main() { int a { 8 }; // refA est une référence vers la variable a int &amp; refA { a }; // ici je modifie donc la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   danger On ne peut pas créer de référence qui ne cible rien, ni changer la cible d’une référence une fois qu’on l’a créée. Une référence est un alias vers une autre variable, si on essaye de l'assigner de nouveau cela revient à modifier la variable originale et pas à réatribuer la référence. #include &lt;iostream&gt; int main() { int a { 8 }; int b { 42 }; int &amp; refA { a }; refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; // ici refA reste une référence vers la variable a qui prend la valeur de b // refA ne devient PAS une référence vers la variable b refA = b; // Je modifie ici toujours la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#passage-par-référence","content":" Cela devient intéressant dans nos fonctions où il va aussi être possible de déclarer un paramètre en tant que référence et non pas comme une copie de la variable originale.  Pour indiquer que l'on souhaite recevoir une référence il faut ajouter une esperluette (&amp;) après le type de notre paramètre.  remarque Bien entendu on ne pourra passer en argument qu'une variable du même type que le type de la référence attendue par la fonction.  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Référence constante​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#référence-constante","content":" Je vous avais dit que les variables constantes allaient prendre tout leur importance et bien c'est ici ! :partying_face:  En effet, si on manipule une référence, on peut très bien modifier la variable originale comme vu précédemment. Mais parfois on aimerait utiliser une référence (pour éviter une copie d'un tableau par exemple) mais protéger la variable originale et interdire les modifications de celle-ci, un mode lecture seule.  On peut donc rajouter le mot clé const dans notre paramètre comme cela:  #include &lt;iostream&gt; #include &lt;vector&gt; float sum(std::vector&lt;float&gt; const&amp; list) { float sum {0}; for(float const value: list) { sum += value; } return sum; } int main() { std::vector&lt;float&gt; list { 8.f, 4.2f, 3.1415f, 43.8f }; float sum { sum(list) }; std::cout &lt;&lt; &quot;La somme des valeurs de mon tableau est de &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   Si vous essayez de modifier un paramètre constant vous allez obtenir une erreur (et c'est tant mieux !).  #include &lt;iostream&gt; void addOne(int const&amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   main.cpp: In function ‘void addOne(const int&amp;)’: main.cpp:4:7: error: assignment of read-only reference ‘a’ 4 | a += 1; | ~~^~~~   Le compilateur nous indique qu'il y a une tentative de modification d'un paramètre déclaré comme constant.  C'est donc une sécurité importante pour éviter des erreurs et je vous recommande d'utiliser des variables ou paramètres constants dès que possible.  remarque Une référence constante ne peut évidemment pas redevenir modifiable et le code ci-dessous va aussi produire une erreur de compilation. #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } void readyOnlyFunction(int const &amp; a) { addOne(a); } int main() { int a { 8 }; readyOnlyFunction(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Le cas des littéraux​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#le-cas-des-littéraux","content":" Avec les litéraux il se passe un autre mécanisme.  Le code ci-dessous ne va pas compiler, à cause de la ligne 15.  #include &lt;iostream&gt; void display(int &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { display(42); displayConst(42); return 0; }   En effet, nous passons un litéral à notre fonction qui attend une référence, un alias, sur une variable modifiable. Un litéral n'est pas à proprement parlé une variable, il est invariable et n’existe nulle part en mémoire, il n'est pas modifiable.  Par contre, supprimez-la et le code compilera, la fonction displayConst ne pose pas de problème de compilation. La seule différence entre les deux fonctions, c’est la présence du mot-clé const.  Ici, le compilateur va créer une variable constante temporaire, qui n’existera que le temps que la fonction, et va lui assigner le litéral comme valeur. Cela revient à faire cela par exemple:  #include &lt;iostream&gt; void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { { int const temporaryVariable { 42 }; displayConst(temporaryVariable); // A la sortie de ce scope (délimité entre accolades) la variable temporaire va être détruite } return 0; }   C'est donc préférable d'utiliser des paramètres constants car cela permet également de rendre compatible nos fonctions avec les littéraux.  ","version":"Next","tagName":"h3"},{"title":"Retour par référence​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#retour-par-référence","content":" Les références ont une contrainte particulière : elles doivent toujours être valides.  Dans le cas d’un paramètre de fonction il n'y a pas de problème car l’argument transmis à la fonction existera toujours quand celle-ci se terminera:  #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; // la variable a est passée en argument addOne(a); // Ici la variable a existe toujours return 0; }   Mais, dans le cas où l’on souhaite qu’une fonction retourne une référence, cela peut être dangereux et on peut renvoyer une référence sur une variable qui n’existera plus à la fin de la fonction !  #include &lt;iostream&gt; int&amp; test() { int a { 33 }; return a; // A la fin du scope de la fonction la variable 'a' va être détruite } int main() { int &amp; reference { test() }; // ici notre référence est invalide ! return 0; }   C'est un comportement indéterminé. Il ne produira pas d'erreur de compilation mais l'utilisation de la référence est invalide.  danger Il ne faut jamais renvoyer une référence vers une variable locale à une fonction.  ","version":"Next","tagName":"h3"},{"title":"Références et types standard​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#références-et-types-standard","content":" Utiliser des références pour std::vector ou std::string d’accord, mais qu’en est-il des types standard comme int, char et double ? Y a-t-il un intérêt à utiliser des références ? Doit-on bannir toutes les copies de notre code ?  Les types standard sont petits (en mémoire) et le coût de la création d’une référence sur des types aussi simples est souvent plus élevé ou équivalent que celui d’une &quot;bête&quot; copie. En effet, le compilateur arrive très souvent à optimiser les copies et les rendre extrêmement rapides, bien plus qu’avec les références.  Donc ne tombez pas dans le piège de l’optimisation prématurée. Pensez au références lorsqu'il s'agit d'objets &quot;gros&quot;. Vouloir mettre des références partout n'est pas une erreur (et je ne vous en tiendrai pas compte au contraire cela veux dire que vous pensez aux références). Mais, garder à l'esprit que cela a aussi un coût de créer une référence et que laisser juste un int const parameter permet au compilateur de mieux optimiser le code.  ","version":"Next","tagName":"h2"},{"title":"Signature et fonctions surchargées​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#signature-et-fonctions-surchargées","content":" Ce qui différencie deux fonctions, ça n’est pas seulement leur nom mais également leurs paramètres. C’est ce qu’on appelle la signature d’une fonction.  On peut donc très bien avoir deux fonctions qui ont le même nom mais pas les mêmes paramètres:  #include &lt;iostream&gt; void testDisplay(int const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void testDisplay(float const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { testDisplay(42); testDisplay(63.5f); return 0; }   Ici, le compilateur voit deux signatures différentes testDisplay(int const a) et testDisplay(float const a) il n'y a donc pas de problème.  On appelle cela la surcharge, de l’anglais &quot;overloading&quot;. Cela rend le code plus simple et le compilateur appelle la bonne surcharge de la fonction pour les arguments précisés (si elle existe évidemment).  Par contre, le type de retour n'est pas une forme de surcharge. Deux fonctions avec le même nom, les mêmes paramètres et des types de retour différents ne compileront pas. Et c’est logique, car comment savoir quelle fonction utiliser et quoi retourner sans ambiguïté sinon ?  ","version":"Next","tagName":"h2"},{"title":"Prototype: déclaration des fonctions​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-déclaration-des-fonctions","content":" J'ai expliqué précédemment qu'une fonction a besoin d'être déclarée avant son utilisation. C'est vrai mais incomplet.  Cette déclaration peut se faire à l'aide de ce qu'on appelle le prototype de la fonction.  Le prototype est très similaire à la signature et est composé du nom, des paramètres(et leur type) ET du type de retour de la fonction.  Voilà un petit exemple de fonction et son prototype:  // la déclaration de la fonction sum avec son prototype int sum (int a, int b); // Le corps de la fonction qui contient les instructions de la fonction int sum (int a, int b) { return a + b; }   Il est possible d'utiliser une fonction dès lors qu'elle est déclarée avec son prototype seulement.  #include &lt;iostream&gt; int sum (int const a, int const b); int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; } int sum (int const a, int const b) { return a + b; }   Je complète donc:  Une fonction doit être déclarée avant son utilisation. Cela peut se faire avec le prototype de la fonction ou le corps lui même. Une fonction peut être utilisée même si le corps de la fonction est écrit plus tard du moment que son prototype est écrit avant toute utilisation de la fonction.  Le prototype est là pour déclarer/signaler au compilateur que le corps de la fonction qu'on appelle sera bien défini plus tard dans le programme.  remarque Évidemment le programme ne va pas compiler si le corps de la fonction déclarée n'existe pas et va nous l'indiquer (undefined reference): in function `main': main.cpp: undefined reference to `sum(int, int)'   remarque C'est une notion qui va être utile quand on verra la séparation du code en plusieurs fichiers.  ","version":"Next","tagName":"h2"},{"title":"Prototype vs signature​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-vs-signature","content":" Il y a souvent un abus de langage et les termes de prototype et signature sont souvent interchangés. Je ne vous en voudrais donc pas si vous utilisez le terme de signature ou de prototype.  Si on veut être pointilleux le prototype désigne le nom, les paramètres et le type de retour d'une fonction alors que la signature indique seulement son nom et ses paramètres (permettant de faire de la surcharge de fonction).  ","version":"Next","tagName":"h3"},{"title":"Récursivité​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#récursivité","content":" Enfin, il est possible d'utiliser une fonction dans elle même, on parle alors de récursivité.  Cela peut être utile quand le problème que l'on souhaite résoudre est de nature récursive, se répète sur lui même.  ","version":"Next","tagName":"h2"},{"title":"Un petit exemple​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#un-petit-exemple","content":" Par exemple si l'on souhaite calculer le produit de tous les entiers de 1 à une valeur n.  Pn=1×2×⋯×n−1×nP_n = 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\Pn​=1×2×⋯×n−1×n  On pourrait voir ce problème de manière récursive en exprimant cette somme en fonction de la somme à l'étape d'avant (n-1):  Pn=1×2×⋯×n−1×nPn=(1×2×⋯×n−1)×nPn=Pn−1×n\\begin{aligned} P_n &amp;= 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\ P_n &amp;= (1 \\times 2 \\times \\dots \\times n-1) \\times n \\\\ P_n &amp;= P_{n-1} \\times n \\end{aligned}Pn​Pn​Pn​​=1×2×⋯×n−1×n=(1×2×⋯×n−1)×n=Pn−1​×n​  On a finalement exprimé le produit des entiers de 1 à n comme étant n fois le produit des entiers de 1 à n-1.  remarque On nomme ce résulat la factorielle de n en Mathématiques.  Sous forme de fonction récursive cela nous donnerait:  int fact(int n) { return fact(n-1) * n; }   On oublie cependant un ingrédient très important des fonctions récursives: la condition d'arrêt.  En effet, dans notre problème on a bien précisé que c'était de 1 à n. On fait donc attention de s'arrêter quand n &lt;= 1. La factorielle de 1 étant égale à 1 je retourne donc 1.  int fact(int n) { if( n &lt;= 1 ) { return 1; } return fact(n-1) * n; }   Il faut faire attention à ne pas oublier cette condition d'arrêt et bien s'assurer qu'il est possible de la vérifier pour s'arrêter sinon notre fonction ne va jamais se terminer et notre programme va sûrement planter.    Dans la plupart des cas, il existe une version alternative non récursive (avec des boucles par exemple).  int fact(int n) { int P { 1 }; // Ici si n est négatif alors la condition i &lt;= n est directement invalide et on ne passe pas dans la boucle if et on retourne 1 for(int i {2}; i &lt;= n; i++) { P *= i; } return P; }   Il est préférable d'utiliser des fonctions non récursives quand c'est possible car elle sont généralement plus performantes et moins propices à l'erreur (condition d'arrêt jamais valide, etc).  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Fonctions : Découper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#résumé","content":" Une fonction est un ensemble d'instructions délimité par des accolades ().Elle peut retourner une valeur en précisant le type de retour avant le nom ou le mot-clé void dans le cas où l'on souhaite ne rien retourner.Elle peut avoir des paramètres.Les arguments passés en paramètre sont par défaut copiés.Il est possible de manipuler la variable d'origine à l'aide de référence (en ajoutant une esperluette (&amp;) après le type de notre variable).Il est possible de surcharger un fonction, c'est à dire avoir le même nom mais des paramètres différents, on parle de signatures différentes.Il est recommandé d'utiliser des paramètres constants (avec le mot-clé const) pour éviter des erreurs, éviter des copies et protéger nos variables. ","version":"Next","tagName":"h2"},{"title":"Mise en place des outils","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/","content":"Mise en place des outils Comme expliqué précédemment le C++ est un langage compilé et il va donc falloir installer un compilateur. Mais ce n'est pas tout, il est aussi préférable d'utiliser un éditeur ou IDE (Integrated Development Environment) adapté pour coder et je vous propose d'utiliser Visual Studio Code. De plus, nous installerons également un petit outil supplémentaire pour simplifier grandement l'étape de compilation (et particulièrement plus tard pour un projet composé de plusieurs fichiers).","keywords":"","version":"Next"},{"title":"Cmake","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Cmake","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Cmake","url":"/Learn--cpp_programming/Lessons/S1/Setup/Cmake#installation","content":" Vous pouvez vous rendre .css-q8raqo{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-q8raqo.Mui-disabled{opacity:0.38;pointer-events:none;}.css-q8raqo .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-q8raqo .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-q8raqo .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-q8raqo .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-q8raqo .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-q8raqo .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-q8raqo .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-q8raqo .MuiChip-deleteIcon:hover,.css-q8raqo .MuiChip-deleteIcon:active{color:#fff;}.css-q8raqo:hover{background-color:rgba(0, 0, 0, 0.12);}.css-q8raqo.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-q8raqo:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-q8raqo:hover,.css-q8raqo.Mui-focusVisible{background-color:#1565c0;} .css-1giu1bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1giu1bt::-moz-focus-inner{border-style:none;}.css-1giu1bt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1giu1bt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1giu1bt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1giu1bt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1giu1bt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1giu1bt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1giu1bt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1giu1bt .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-1giu1bt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-1giu1bt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1giu1bt .MuiChip-deleteIcon:hover,.css-1giu1bt .MuiChip-deleteIcon:active{color:#fff;}.css-1giu1bt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1giu1bt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1giu1bt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1giu1bt:hover,.css-1giu1bt.Mui-focusVisible{background-color:#1565c0;} ici et sélectionner l'installeur qui correspond à votre OS.   WindowsLinuxOSX Choisis Windows x64 Installer.  Vous pouvez ensuite vérifier que c'est bien installé en exécutant la commande suivante dans un terminal :  cmake --version    ","version":"Next","tagName":"h2"},{"title":"Installation d'un compilateur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler","content":"","keywords":"","version":"Next"},{"title":"Vérifier que le compilateur est installé​","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#vérifier-que-le-compilateur-est-installé","content":" Dans un premier temps, vous allez pouvoir vérifier que le compilateur est bien installé avec la commande suivante:  WindowsLinuxOSX cl Avec MSVC c'est un peu particulier et la commande du compilateur ne sera accessible qu'à travers un terminal particulier. Vous pouvez le trouver en cherchant &quot;developer powershell&quot; ou &quot;developer Command Prompt&quot; dans le Menu Windows. Vous pouvez ouvrir un terminal développeur et essayer d'exécuter la commande précédente. Vous devriez voir un retour comme celui là : C:\\Program Files\\Microsoft Visual Studio\\2022\\Community&gt; cl Microsoft (R) C/C++ Optimizing Compiler Version 19.31.31105 for x86 Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option... ] filename... [ /link linkoption... ]   attention Cela peut ne pas fonctionner si le répertoire contenant le compilateur n'est pas &quot;accessible&quot;. Les commandes sont elles-mêmes des exécutables sous forme de fichiers situés quelque part sur votre ordinateur. Depuis un terminal, l'ordinateur a une liste de tous les endroits dans lesquels il va essayer de chercher les dits fichiers (commandes) à exécuter. Ces endroits (sous forme de chemins de dossier) sont listés dans ce qu'on appelle des variables d'environnement et particulièrement la variable d'environnement PATH. Pour pouvoir avoir accès à la commande du compilateur depuis n'importe où dans votre ordinateur il va donc falloir ajouter le chemin où est installé l'exécutable (les outils de compilation dans notre cas) à cette variable PATH. WindowsLinuxOSX Vous pouvez y accéder en allant dans le Panneau de configuration et en cliquant sur le lien Paramètres système avancés puis sur Variables d'environnement. Ou plus simplement en cherchant &quot;path&quot; ou &quot;variable&quot; dans le Menu démarrer. Dans la section Variables système recherchez la variable d'environnement PATH et sélectionnez-la. Cliquez sur Modifier. Dans la fenêtre qui vient de s'ouvrir, ajoutez une valeur avec le chemin vers le dossier contenant la commande. (Pour MSVC par exemple c'est quelque chose comme : &quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\19.09.26726\\bin\\HostX86\\x64&quot;)Cliquez sur OK.Fermez toutes les fenêtres restantes en cliquant sur OK. C'est également expliqué ici avec des illustrations si nécessaire. ","version":"Next","tagName":"h2"},{"title":"Des boucles pour gagner du temps","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Loops","content":"","keywords":"","version":"Next"},{"title":"While - \"Tant que ...\"​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#while---tant-que-","content":" La première est la boucle while, de l'anglais qui signifie &quot;tant que&quot;. Elle exécute une série d’instructions tant qu'une condition est vraie. Une fois que la condition devient fausse la boucle s’arrête et passe à la suite.    Un petit exemple #include &lt;iostream&gt; int main() { int count { 0 }; // initialisation (d'un compteur ou autre chose lié à la boucle) while ( count &lt; 10 /* condition */) { std::cout &lt;&lt; count &lt;&lt; std::endl; // Instructions count++; // Itération (mise à jour du compteur généralement) } return 0; }   Le code évalue la condition avant d'effectuer quoi que ce soit. Dans notre cas si le compte est supérieur à 0 alors on va afficher le nombre et le décrémenter. Quand finalement count vaut 0, la condition devient fausse, on passe à la suite du code. (on ne va donc pas afficher la valeur 0)  attention Attention aux boucles infinies ! Lorsque vous créez une boucle, assurez-vous qu'elle puisse s'arrêter à un moment ! Si la condition est toujours vraie, votre programme ne s'arrêtera jamais !  ","version":"Next","tagName":"h2"},{"title":"Do while​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#do-while","content":" De manière très similaire il existe la boucle Do... while, qui signifie &quot;fait .. tant que...&quot;  Ce type de boucle est moins utilisé. La seule chose qui change par rapport à une boucle while, c'est la position de la condition : au lieu d'être au début de la boucle, la condition est à la fin.  remarque La boucle while peut très bien ne jamais être exécutée si la condition est fausse dès le départ. Dans mon exemple précédent, si on avait initialisé le count à -1, la condition aurait été fausse dès le début, et on ne serait jamais rentré dans la boucle.  Pour la boucle Do... while, on rentre au moins une fois à l'intérieur. Le test se fait à la fin.  Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.  #include &lt;iostream&gt; int main() { int sum {0}; int number; do { std::cout &lt;&lt; &quot;Entre un nombre: &quot;; std::cin &gt;&gt; number; sum += number; } while (number != 0); std::cout &lt;&lt; &quot;La somme vaut &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }   attention Il y a une petite spécificité supplémentaire ici, il faut ajouter un &quot;;&quot; à la fin de la ligne contenant la condition while.  ","version":"Next","tagName":"h2"},{"title":"For​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#for","content":" Un des cas les plus fréquents avec les boucles est d'avoir un compteur et un nombre d'itérations prédéfini.  On pourrait très bien le faire avec la boucle while:  int count { 0 }; // initialisation (d'un compteur ou autre chose lié à la boucle) while ( count &lt; 10 /* condition */) { // Instructions count++; // Itération (mise à jour du compteur généralement) }   Mais il existe une boucle dédiée à cela qui permet de séparer le reste de notre code de ce qui est lié à la boucle. Cela rend le code plus clair et plus compréhensible surtout dans le cas ou l'on connait à l'avance le nombre d'itérations.  C'est la boucle for (&quot;pour&quot; en anglais) et elle s'utilise selon le schéma suivant:  for (int count {0} /*initialisation*/ ; count &lt; 10 /*condition*/ ; count++/*Itération*/) { // Instructions }   Voilà le même exemple qu'avec la boucle while mais ici avec la boucle for :  #include &lt;iostream&gt; int main() { for (int count { 0 }; count &lt; 10 ; count++) { std::cout &lt;&lt; count &lt;&lt; std::endl; } return 0; }   L'avantage ici est que le détail de ce que fait la boucle est concentré sur la même ligne.  info Un autre gros avantage est que la portée de la variable (scope) est limitée à la boucle et donc rend notre code plus sûr et propre. #include &lt;iostream&gt; int main() { for (int count { 10 }; count &gt; 0 ; count--) { std::cout &lt;&lt; count &lt;&lt; std::endl; } std::cout &lt;&lt; count &lt;&lt; std::endl; return 0; } La variable count ici est uniquement nécessaire pour la boucle en question et n'a donc pas lieu d'être partagée ensuite avec le reste du code pour éviter des erreurs. Si on essaye de le faire le compilateur nous donne l'erreur suivante: Compilation failed due to following error(s) main.cpp: In function ‘int main()’: main.cpp:17:18: error: ‘count’ was not declared in this scope 17 | std::cout &lt;&lt; count &lt;&lt; std::endl; | ^~~~~   Mais alors quand choisir une boucle while ou une boucle for ?  C'est une question légitime et il n'y a pas de bonne réponse, vous êtes libre. En général on utilise une boucle for dans le cas où l'on connait le nombre d'itérations à l'avance (un compteur, un nombre de niveaux ou de joueurs dans un jeu, etc...). La boucle while, quant à elle, est généralement utilisée pour effectuer des actions sans savoir à l'avance le nombre d'itérations que l'on va effectuer (par exemple la gestion de l'entrée utilisateur ou dans un jeu faire bouger un ennemi tant qu'il n'a pas atteint sa cible)  astuce Plus simplement, essayez de dire ce que vous voulez faire et si votre phrase contient &quot;pour&quot; ou &quot;pour chaque ... faire ...&quot; il est préférable d'utiliser une boucle for. Et si vous vous dîtes &quot;Tant que ... faire ...&quot; alors vous devriez utiliser une boucle while.  ","version":"Next","tagName":"h2"},{"title":"Contrôler l'exécution​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#contrôler-lexécution","content":" Les boucles sont très utiles, mais parfois on aimerait pouvoir contrôler plus finement les instructions à l’intérieur des accolades et pouvoir s'arrêter plus tôt ou ne pas exécuter les instructions pour un cas particulier.  Il existe en C++ deux mots-clés: break et continue  ","version":"Next","tagName":"h2"},{"title":"Break​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#break","content":" Break (de anglais &quot;casser&quot;/&quot;interrompre&quot;) permet d'interrompre une boucle et mettre fin à l’exécution de celle-ci peu importe où on en est.  Voyons un exemple plus &quot;complexe&quot; ensemble:  for (int i { 0 }; i &lt; 5; ++i) { std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; for (int j { 0 }; j &lt; i; ++j) { if (j == 2) { std::cout &lt;&lt; &quot;break j == 2&quot; &lt;&lt; std::endl; break; } std::cout &lt;&lt; &quot;j : &quot; &lt;&lt; j &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl; }   qui nous donne le résultat suivant:  i: 0 i: 1 j: 0 i: 2 j: 0 j: 1 i: 3 j: 0 j: 1 break j == 2 i: 4 j: 0 j: 1 break j == 2   Ici il y a plusieurs choses qui se passent:  il y a déjà deux boucles imbriquées, et oui rien ne nous empêche de faire cela en C++la deuxième boucle (sur la variable j) dépend de la variable i de la première (c'est parfois utile de le faire et je vous montre donc un petit exemple)ici le mot clé break permet d'interrompre la boucle de la variable j si la valeur de j est égale à 2.  Une petite analyse des itérations s'impose:  la première fois i est égal à 0 et donc la condition j &lt; i est directement fausse vu que j aussi est égal à 0. ensuiteensuite i est égal à 1 et donc on passe une fois seulement dans la boucle du j car à la seconde itération j devient égal à i et invalide la condition j &lt; i.la troisième fois c'est le break qui entre en jeu et permet d'interrompre la boucle quand j est égal à 2 (à noter que la condition de la boucle aurait aussi invalidé la condition j &lt; i)enfin ici le break prend tout son sens car s'il n'était pas là, on aurait encore continué un tour car j étant égal à 3, la condition (j &lt; i) serait valide car i est égal à 4 et que 3 &lt; 4.  attention Comme nous venons de le voir, dans le cas de boucles imbriquées cela arrête seulement la boucle du niveau au dessus et pas toutes les boucles.  ","version":"Next","tagName":"h3"},{"title":"Continue​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#continue","content":" L’autre mot-clé, continue, permet de sauter l’itération courante.  Toutes les instructions restantes du bloc sont ignorées et la boucle continue au tour suivant.  for (int i { 0 }; i &lt; 5; ++i) { if( i == 3) { continue; } std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; }   Ce qui nous donne:  i : 0 i : 1 i : 2 i : 4   danger Comme cela interrompt la totalité des instructions suivantes de la boucle cela peut être dangereux dans le cas d'une boucle while: #include &lt;iostream&gt; int main() { int count { 10 }; while (count &gt; 0) { std::cout &lt;&lt; count &lt;&lt; std::endl; if (count == 5) { continue; } count--; } return 0; } Ici, l'instruction de count--; ne sera donc jamais appelée une fois que count devient égal à 5.count restera donc égal à 5 indéfiniment: C'est une boucle infinie.  ","version":"Next","tagName":"h3"},{"title":"Switch​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#switch","content":" Mainteant que nous avons toutes les cartes en main revenons brièvement au switch dont je vous parlais au chapitre précédent sur les conditions.  Très souvent on veut tester la valeur d'une variable et effectuer telle ou telle action en fonction. On pourrait très bien écrire cela avec des else if:  #include &lt;iostream&gt; int main() { int value { 42 }; if ( value == 12 ) { // ... } else if ( value == 33 ) { // ... } else if ( value == 52) { //... } else { //... } return 0; }   C'est avec le mot clé switch que l'on va pouvoir faire cela de façon plus lisible:  #include &lt;iostream&gt; int main() { int value { 42 }; switch (value) { case 12: // ... break; // permet de quitter le bloc switch case 33: // ... break; case 52: // ... break; default: // ... break; } return 0; }   Lorsque l'expression testée est égale à une des valeurs listées avec les mots-clés case la totalité des instructions qui suivent sont exécutées. Le mot clé break indique la sortie de la structure de contrôle. Le mot clé default indique quelles instructions exécuter si l'expression n'est jamais égale à une des valeurs.  danger De manière générale, n'oubliez pas d'insérer des instructions break entre chaque test, ce genre d'oubli est difficile à détecter car aucune erreur n'est signalée... En effet la totalité des instructions suivant le case sont exécutées et donc on pourrait se retrouver à exécuter des instructions de manière involontaire. #include &lt;iostream&gt; int main() { int value { 33 }; switch (value) { case 12: std::cout &lt;&lt; &quot;value est égale à 12&quot; &lt;&lt; std::endl; case 33: std::cout &lt;&lt; &quot;value est égale à 33&quot; &lt;&lt; std::endl; default: std::cout &lt;&lt; &quot;value est différent de 12 ou 33&quot; &lt;&lt; std::endl; } return 0; } qui nous donne: value est égale à 33 value est différent de 12 ou 33 Cela peut être parfois voulu mais ici on se rend bien compte qu'il y a un problème et il ne faut donc pas oublier le mot clé break. Voici un exemple où cela peut être utile: #include &lt;iostream&gt; int main() { char letter { 'e' }; switch(letter) { case 'a': case 'e': case 'i': case 'o': case 'u': case 'y': std::cout &lt;&lt; &quot;You entered a vowel.&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;You entered a consonant.&quot; &lt;&lt; std::endl; break; } return 0; } Certains warnings de compilateur permette d'indiquer ce genre de cas mais c'est mieux d'y faire attention.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#résumé","content":" Il existe trois types de boucle: la boucle while qui permet d'exécuter des instructions tant qu'une condition est vérifiée.la boucle Do while qui permet de faire la même chose que la boucle while mais en faisant le test seulement à la fin et permettant d'exécuter les instructions au moins une fois.la boucle for plus utile en pratique quand l'on connait à l'avance le nombre d'itérations à effectuer. Elle permet aussi de mieux &quot;scoper&quot; les variables et limiter leur portée. Il existe deux mots-clés break et continue qui permettent de contrôler plus finemment les boucles. La structure de contrôle switch est une alternative au else if. ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#installation","content":" Tout d'abord il s'agit d'installer l'IDE.  Rendez-vous .css-q8raqo{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-q8raqo.Mui-disabled{opacity:0.38;pointer-events:none;}.css-q8raqo .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-q8raqo .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-q8raqo .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-q8raqo .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-q8raqo .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-q8raqo .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-q8raqo .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-q8raqo .MuiChip-deleteIcon:hover,.css-q8raqo .MuiChip-deleteIcon:active{color:#fff;}.css-q8raqo:hover{background-color:rgba(0, 0, 0, 0.12);}.css-q8raqo.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-q8raqo:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-q8raqo:hover,.css-q8raqo.Mui-focusVisible{background-color:#1565c0;} .css-1giu1bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1giu1bt::-moz-focus-inner{border-style:none;}.css-1giu1bt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1giu1bt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1giu1bt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1giu1bt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1giu1bt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1giu1bt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1giu1bt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1giu1bt .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-1giu1bt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-1giu1bt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1giu1bt .MuiChip-deleteIcon:hover,.css-1giu1bt .MuiChip-deleteIcon:active{color:#fff;}.css-1giu1bt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1giu1bt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1giu1bt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1giu1bt:hover,.css-1giu1bt.Mui-focusVisible{background-color:#1565c0;} ici et sélectionnez l'installeur adapté à votre système d'exploitation.   ","version":"Next","tagName":"h2"},{"title":"Les extensions​","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#les-extensions","content":" Les extensions sont, comme le nom l'indique, des modules qui permettent d'étendre les fonctionnalités de l'IDE.  Elles sont listées ici et vous pouvez également les parcourir pour les installer à l'intérieur de l'IDE via le raccourci CTRL+SHIFT+X ou en cliquant sur cet onglet:    N'hésitez pas à consulter les extensions recommandées par langage ou découvrir ce que d'autres personnes utilisent.  Concernant le C++, nous avons besoin au minimum d'installer ces extensions:  cpptools-extension-packcmake  Ces extensions vont nous permettre de lancer notre programme C++ sans difficulté.  Si vous voulez aller plus loin et connaître un peu mieux VSCode, je vous invite à aller regarder la page suivante. ","version":"Next","tagName":"h2"},{"title":"Compiler votre premier programme","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac","content":"","keywords":"","version":"Next"},{"title":"Utiliser CMake et VSCode​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#utiliser-cmake-et-vscode","content":" C'est donc possible de le faire uniquement avec des lignes de commandes mais par simplicité nous allons dès maintenant utiliser CMake dont j'ai parlé précédemment qui s'intègre facilement avec VSCode.  Pour utiliser CMake il faut tout d'abord créer un fichier nommé CMakeLists.txtVoici le premier qu'on va utiliser (quelques explications en commentaire &quot;#&quot; du fichier):  CMakeLists.txt # Nous voulons un cmake &quot;récent&quot; pour utiliser les dernières fonctionnalités cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On indique que l'on veut créer un exécutable &quot;helloImac&quot; compilé à partir du fichier helloImac.cpp add_executable(helloImac helloImac.cpp)   Ce fichier CMakeLists.txt va être bien pratique car il est reconnu par divers IDE et en ce qui nous concerne on va l'utiliser avec VSCode.  Il suffit d'avoir au préalable installé l'extension dont je vous ai parlé .css-173r67b{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-173r67b.Mui-disabled{opacity:0.38;pointer-events:none;}.css-173r67b .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-173r67b .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-173r67b .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-173r67b .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-173r67b .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-173r67b .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-173r67b .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-173r67b:hover{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-173r67b:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-173r67b.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b .MuiChip-avatar{margin-left:4px;}.css-173r67b .MuiChip-avatarSmall{margin-left:2px;}.css-173r67b .MuiChip-icon{margin-left:4px;}.css-173r67b .MuiChip-iconSmall{margin-left:2px;}.css-173r67b .MuiChip-deleteIcon{margin-right:5px;}.css-173r67b .MuiChip-deleteIconSmall{margin-right:3px;} .css-1aq2sw4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-1aq2sw4::-moz-focus-inner{border-style:none;}.css-1aq2sw4.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1aq2sw4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1aq2sw4.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1aq2sw4 .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1aq2sw4 .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1aq2sw4 .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1aq2sw4 .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-1aq2sw4 .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-1aq2sw4 .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1aq2sw4:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1aq2sw4:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1aq2sw4.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4 .MuiChip-avatar{margin-left:4px;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-icon{margin-left:4px;}.css-1aq2sw4 .MuiChip-iconSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-deleteIcon{margin-right:5px;}.css-1aq2sw4 .MuiChip-deleteIconSmall{margin-right:3px;} cmake et d'ouvrir le dossier contenant le fichier CMakeLists.txt dans VSCode (il est recommandé de créer un dossier dédié au &quot;projet&quot; contenant les fichiers sources et le fichier CMakeLists.txt ). L'extension devrait normalement reconnaître automatiquement qu'il y a un fichier cmake et vous proposer d'initialiser celui-ci automatiquement.     Si c'est la première fois que vous l'ouvrez ce qui est sûrement le cas il devrait vous demander de choisir un kit de compilation et faudra donc sélectionner MSVC ou GCC en fonction de votre plateforme.    astuce Si ce n'est pas le cas vous pouvez toujours utiliser le raccourci Ctrl+Shift+P puis taper et sélectionner &quot;CMake: select a kit&quot;  Une fois tout initialisé, vous devriez voir des logs dans un terminal ressemblant à cela (dans mon cas sous Linux avec le compilateur GCC ici):  [variant] Loaded new set of variants [kit] Successfully loaded 1 kits from /home/user/.local/share/CMakeTools/cmake-tools-kits.json [proc] Executing command: /usr/bin/cmake --version [proc] Executing command: /usr/bin/gcc -v [proc] The command: ninja --version failed with error: Error: spawn ninja ENOENT [proc] The command: ninja-build --version failed with error: Error: spawn ninja-build ENOENT [proc] Executing command: /usr/bin/cmake &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [main] Configuring project: helloImac [proc] Executing command: /usr/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/gcc -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/g++ &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [cmake] Not searching for unused variables given on the command line. [cmake] -- Configuring done [cmake] -- Generating done [cmake] -- Build files have been written to: /home/user/DATA/Cours IMAC1/helloImac/build   Vous pouvez maintenant cliquer sur le bouton &quot;play&quot; dans la barre en bas pour exécuter le programme. :partying_face:  remarque En cliquant sur ce bouton, l'IDE compile automatiquement si nécessaire puis exécute l'exécutable.    remarque Cmake devrait normalement créer un dossier build, c'est normal. CMake est un outil de compilation mais ne compile pas directement, il permet de générer des fichiers permettant ensuite de compiler un projet. Vous n'avez pas besoin d'aller voir ce qui s'y trouve, CMake gère automatiquement ce dossier build pour vous.  attention Pour qu'un projet CMake soit fonctionnel, il faut que le dossier ouvert dans votre IDE contienne un fichier CMakeLists.txt à la racine du dossier. Sinon, l'extension CMake ne détectera pas le dossier ouvert comme un projet CMake et il ne va pas s'initialiser automatiquement. Les fonctionnalités de l'extension ne seront donc pas disponibles.  ","version":"Next","tagName":"h2"},{"title":"Quelques explications sur le programme​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#quelques-explications-sur-le-programme","content":" ","version":"Next","tagName":"h2"},{"title":"include ?​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#include-","content":" #include &lt;iostream&gt;   Le but de notre programme est d’afficher un message. Des développeurs experts ont déjà créé un outil qui permet de le faire facilement. Il se trouve dans un fichier nommé iostream, acronyme de &quot;Input Output Stream&quot;, soit &quot;Flux d’Entrées Sorties&quot;. Ce fichier fait partie de la bibliothèque standard C++ STD (pour &quot;C++ STandarD library&quot;), un ensemble de fonctionnalités déjà pré-codées et inclues partout avec chaque compilateur C++.  Pour utiliser les fonctionnalités offertes par ce fichier, notamment écrire un message, on doit l’importer dans notre programme. On dit qu’on l’inclut, d’où l’anglais &quot;include&quot;. Nous utiliserons beaucoup cette fonctionnalité en C++.  info #include s'appelle une directive préprocesseur. Le préprocesseur est un programme exécuté lors de la première phase de la compilation qui effectue des modifications textuelles sur le fichier source à partir de directives. Ces directives commencent par le caractère # et doivent se terminer par un saut de ligne. Retenez simplement que #include nous permet d’importer des fichiers pour les inclure dans le programme que l'on est en train d'écrire, et je le détaillerai plus tard dans le semestre.  ","version":"Next","tagName":"h3"},{"title":"La fonction main​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#la-fonction-main","content":" int main() { // ... return 0; }   Lorsqu’on lance le programme, celui-ci doit savoir par où commencer. On parle de point d’entrée. Ce point d'entrée doit être une fonction nommée main et renvoyer une valeur avec le mot clé return.  Nous reviendrons sur les fonctions dans un autre chapitre mais retenez que c'est un ensemble d'instructions délimité par des accolades { et }, et auquel on donne un nom (main dans ce cas).&quot;  remarque La valeur de retour (de type int) du main indique si le programme s’est terminé sans erreur. Si tout se passe bien, il faut retourner 0. N’importe quelle autre valeur indique une erreur.  ","version":"Next","tagName":"h3"},{"title":"Hello and welcome to IMAC !​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#hello-and-welcome-to-imac-","content":" L’instruction ci-dessous permet d’afficher le texte (qu'on appelle &quot;chaîne de caractères&quot;, ou &quot;string&quot;, en programmation) &quot;Hello and welcome to IMAC !&quot; sur la sortie standard du programme.  std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl;   Premièrement &quot;std&quot; fait référence à la bibliothèque standard C++ dont je parlais précédemment.  std**::** permet d'indiquer que l'on veut utiliser une fonctionnalité particulière de cette bibliothèque ici cout:  Il s’agit de l'objet (on parle de stream dans le jargon C++) permettant de renvoyer des caractères, généralement pour les afficher dans le terminal. Le 'c' fait référence à caractère et ‘out’ indique ‘sortie’.  Enfin, std::endl indique ici &quot;end-line&quot; soit la 'fin de ligne'.  ","version":"Next","tagName":"h3"},{"title":"Dernier point (virgule)​","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#dernier-point-virgule","content":" Chaque instruction doit être identifiable afin de que compilateur puisse faire son travail et produire un programme exécutable.  C'est le rôle du point-virgule ; de délimiter chaque instruction et il est donc important de ne pas l'oublier.  On le retrouve par exemple dans notre programme à la fin du return 0;.  attention Ce n'est pas le cas pour les directives préprocesseur comme #include vu précédemment qui, elles, doivent avoir leur propre ligne et ne doivent pas se terminer par un point-virgule ; mais un saut de ligne.  Les sauts de lignes et espacements sont là pour améliorer la lisibilité mais pas pour le bon fonctionnement du compilateur en lui même et on pourrait très bien écrire:  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl; return 0; }   Je vous recommande tout de même d'utiliser des espacements et sauts de ligne pour mieux s'y retrouver et c'est ce que je vais faire tout au long de ce cours.    Et voilà ! Vous avez exécuté votre premier programme C++ à l'aide de VSCode ! 🎉 ","version":"Next","tagName":"h3"},{"title":"Allouer et manipuler la mémoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Mode d'allocation​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#mode-dallocation","content":" Il existe trois principaux modes d’allocation de la mémoire:  l’allocation statiquel’allocation sur la Stackl’allocation sur la Heap  ","version":"Next","tagName":"h2"},{"title":"Allocation statique​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-statique","content":" Lorsque le programme s’initialise, il demande une quantité de mémoire spécifiée dans le code source du programme, laquelle ne pourra pas changer par la suite.  Nous n'avons pas rencontré ce type d'allocation pour l'instant mais sachez que ça existe.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Stack​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-stack","content":" Jusqu'a présent, nous avons principalement rencontré des allocations de mémoire sur la Stack. C'est le cas de toutes nos variables locales (dans des fonctions, y compris dans la fonction main).  La Stack (ou pile en français) est une zone mémoire qui sert d’espace de stockage aux variables déclarées par les fonctions et permet aussi de garder une trace des appels de fonctions.  Elle tient son nom de son mode de fonctionnement, semblable à une pile de dossiers. Il s’agit d’une structure de données fondée sur le principe “dernier posé sur le dessus de la pile, premier à sortir”. Cet ordonnancement s’appelle LIFO (Last In, First Out). La Stack possède donc deux actions principales : push, pour ajouter un élément, et pop pour retirer et récupérer cet élément. Cela rend très simple le suivi de la pile pour libérer ou demander de la mémoire.  Comme les accès à la Stack sont contiguës et que les mêmes adresses mémoire tendent à être réutilisées, les lectures et écritures dans la Stack sont très performantes. Cependant cela manque de souplesse car son allocation doit être &quot;prévue&quot; lors de l’écriture du programme (Pour des variables de taille déjà connue à la compilation).  info La Stack a une taille fixée (qui dépend des machines et systèmes d'exploitation(OS)). Pour garder une trace de l’emplacement mémoire actuel, il existe un pointeur appelé Stack Pointer. Chaque fois que quelque chose doit être écrit ou retiré dans la Stack, on déplace simplement ce pointeur. Le pointeur ne peut pas aller au delà des limites de la Stack, cela risque de provoquer un crash du programme appelé Stack overflow. Cela peut se produire avec une fonction récursive avec de nombreux appels récursifs ou sans condition d'arrêt par exemple.  La syntaxe pour allouer de la mémoire sur la Stack est la suivante:  int x {};   Vous connaissez déjà cette syntaxe, c'est simplement la déclaration d'une variable locale.  ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Heap​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-heap","content":" L’allocation sur la Heap se fait de manière dynamique pendant l’exécution d’un programme (on parle de runtime). L’espace nécessaire n’a pas besoin d'être défini en amont dans le code. Le programme effectue la demande d’allocation d’espace à l’OS au cours de son exécution.  remarque Il y a généralement un abus de langage et ce que l'on qualifie d'allocation dynamique désigne ce type d'allocation sur la Heap. L'allocation sur la Stack est également dynamique dans le sens où elle se produit pendant l'exécution du programme en fonction des variables déclarées.  La Heap permet donc le contrôle complètement arbitraire de l’allocation et de la libération. Lorsque le processus nécessite plus de mémoire, il en fait simplement la demande à l’OS (dans la limite où il est en mesure de fournir un tel emplacement mémoire). C'est donc aussi ce type d'allocation que l'on privilégie dans le cas de gros volumes de données.  Cependant, cela demande de maintenir des pointeurs pour chacune des valeurs stockées, afin de savoir où se trouve la mémoire demandée pour pouvoir la manipuler mais aussi la libérer. Cette gestion de la mémoire étant plus &quot;complexe&quot;, les performances n’en sont généralement pas aussi bonnes, mais parfois on n'a tout simplement pas le choix.  La syntaxe pour allouer de la mémoire sur la Heap est la suivante:  int* x { new int };   Je vous expliquerai plus en détail ce que cela signifie dans la suite de ce chapitre.  ","version":"Next","tagName":"h3"},{"title":"Adresse et pointeurs​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#adresse-et-pointeurs","content":" J'ai évoqué le terme de pointeur mais qu'est ce que c'est ?  Une variable est localisée quelque part dans notre mémoire. On peut voir la mémoire de notre ordinateur comme une grande étagère à livres dans laquelle chaque emplacement est numéroté. Chaque variable a une adresse (un numéro) qui permet de savoir où elle se trouve en mémoire.  Cette adresse est simplement un nombre (généralement représenté sous forme hexadécimale).  On peut récupérer l'adresse d'une variable en ajoutant le symbole &quot;esperluette&quot; &amp; devant le nom de la variable en question.  Essayons: #include &lt;iostream&gt; int main() { int integer {4}; std::cout &lt;&lt; &amp;integer &lt;&lt; std::endl; return 0; }   qui nous donne un truc qui ressemble à ça:  0x7ffe08bf5854   Ce nombre indique où est stockée la valeur de notre variable en mémoire (que ce soit la heap ou la stack).  Maintenant que nous savons où se trouve notre variable on va pouvoir stocker cette adresse.  C'est justement le rôle du pointeur de stocker l'adresse d'une variable.  On indique que l'on souhaite manipuler un pointeur en ajoutant le symbole * après le type de la variable. Cela indique donc que l'on stocke une adresse vers une variable du type indiqué et non une valeur.  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Déréférencement​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#déréférencement","content":" Avec ce pointeur, il est possible de faire ce qu'on appelle un déréférencement et aller voir le contenu de l'emplacement situé à l'adresse stockée. C'est-à-dire, la valeur de la variable pointée.  Pour faire un déréférencement on utilise également le symbole * devant le nom de notre pointeur comme cela:  #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; *integer_pointer &lt;&lt; std::endl; // On peut même modifier la valeur de notre variable par ce biais *integer_pointer = 18; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Null pointer​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#null-pointer","content":" Il est possible d'indiquer qu'un pointeur ne pointe actuellement sur rien en lui attribuant une valeur nulle avec le mot-clé nullptr:  Il s'agit alors d'un pointeur nul (ou null pointer en anglais). Le déréférencement d'un pointeur nul provoque une erreur:  #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { float* float_pointer {nullptr}; displayPointer(float_pointer); // null return 0; }   info Il existe également le mot-clé NULL qui vient du C pour indiquer un pointeur nul. Il a cependant des inconvénients et je vous demande d'utiliser nullptr en C++ qui est plus sûr.  ","version":"Next","tagName":"h3"},{"title":"Allocation dynamique en pratique: New & delete​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-dynamique-en-pratique-new--delete","content":" Comme je l'ai évoqué précédemment avec l’allocation dynamique dans la Heap on va donc demander un emplacement mémoire et le libérer plus tard. Cela se fait avec les mots-clés new et delete. Cette demande de mémoire va retourner un pointeur.  #include &lt;iostream&gt; int main() { // je demande un emplacement mémoire pour un entier int* integer_ptr {new int}; // je peux aussi demander et initialiser un entier int* number_ptr {new int{5}}; std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; // Une fois que l'on en a plus besoin, on libère les zones mémoire demandées delete number_ptr; delete integer_ptr; return 0; }   qui nous donne: 0x557590f93eb0 5   danger Le pointeur est toujours &quot;existant&quot; après avoir été libéré. Le pointeur n'est rien d'autre qu'un nombre représentant l'adresse mémoire. Cela ne veut pas dire que nous avons le droit de manipuler cette mémoire. Si l'espace mémoire pointé par le pointeur est libéré, il ne faut pas l'utiliser car cet emplacement mémoire ne nous appartient plus. #include &lt;iostream&gt; int main() { int* number_ptr {new int{2}}; delete number_ptr; // Ici l'adresse étant un nombre, elle est toujours valide std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; // Mais la valeur contenue à cette adresse peut prendre n'importe quelle valeur en fonction de l'usage nouveau de cet emplacement mémoire std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; return 0; } Il est donc recommandé d'assigner au pointeur la valeur nullptr une fois libéré pour éviter tout problème. int* number_ptr {new int{2}}; delete number_ptr; number_ptr = nullptr; // ...   ","version":"Next","tagName":"h2"},{"title":"Tableaux​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#tableaux","content":" Il est également possible de demander plusieurs emplacements mémoire contiguës (autrement dit un tableau) d'un coup en précisant entre crochets la taille du tableau [ ] . Le pointeur va contenir alors l'adresse du premier élément du tableau.  L'adresse stockée par le pointeur étant un nombre (représenté en hexadécimal) il est possible de faire des opérations dessus comme l'addition ou la soustraction. Cela permet de se positionner sur un emplacement mémoire précis du tableau.  Pour libérer un tableau alloué dynamiquement, il faut utiliser le mot-clé delete suivi de crochets [ ] .  int main() { // attention ici les valeurs ne sont pas initialisées int* array_ptr {new int[5]}; // Je me positionne sur le 3ème élément du tableau et j'utilise le déréférencement pour modifier sa valeur *(array_ptr + 2) = 42; // On peut aussi utiliser la notation avec les crochets qui est équivalente array_ptr[2] = 42; // Je libère l'espace mémoire alloué delete[] array_ptr; return 0; }   remarque Si la taille est connue à l'avance (à la compilation), il est aussi possible de déclarer un tableau sur la Stack avec la taille entre crochets [ ]. int main() { int array[5]; // Je peux accéder aux valeurs du tableau avec les crochets array[0] = 42; return 0; }   danger Il est important de noter que le pointeur ne contient pas la taille du tableau. Il est donc important de la conserver quelque part pour ne pas dépasser la taille du tableau. Si vous dépassez, vous risquez de modifier des valeurs qui ne vous appartiennent pas et donc de causer des erreurs. int main() { int* array_ptr {new int[5]}; // Ici je dépasse la taille du tableau et j'essaie de modifier une valeur qui ne m'appartient pas array_ptr[5] = 42; return 0; } Il s'agit d'une erreur très courante appelée &quot;erreur de segmentation&quot;. Elle se produit lorsque votre programme essaie de lire ou d'écrire dans une zone mémoire qui ne lui a pas été attribuée (ou ne l'est plus).  C'est la façon de gérer les tableaux en C. Cependant, en C++ il existe des structures de données plus adaptées pour gérer les tableaux comme std::array ou std::vector que nous avons vu précédemment.  ","version":"Next","tagName":"h2"},{"title":"std::vector: explications​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdvector-explications","content":" Justement, parlons un peu de std::vector. Comme dit précédemment, l'allocation dynamique (sur la Heap) est particulièrement intéressante lorsque l’on ne sait pas à l’avance la taille dont on va avoir besoin. C'est exactement le cas d'utilisation du std::vector.  En effet, std::vector n'est rien d'autre qu'une structure de donnée qui gère en interne un pointeur vers une zone mémoire contiguë. Lorsque celui-ci est trop petit et que l'on souhaite tout de même ajouter une valeur, la structure demande un nouvel espace mémoire plus grand, copie les données dans ce nouvel espace mémoire et enfin libère l'ancien espace mémoire qui n'est donc plus utilisé.  Ce changement (allocation, copie, libération de mémoire) a un coût c'est pourquoi std::vector prévoit un espace plus grand que nécessaire lors d'une allocation pour anticiper de futurs ajouts dans le tableau dynamique.  Il est possible de connaître la taille de l'espace de stockage alloué pour le std::vector avec sa méthode capacity() qui retourne cette taille exprimée en nombre d'éléments. C'est différent de la taille actuellement utilisée qui s'obtient avec la méthode size().   Une implémentation simplifiée struct IntegerVector { size_t size {0}; size_t capacity {0}; int* pointer {nullptr}; void reserve(size_t const newCapacity) { if (newCapacity &lt;= capacity) { return; } // Je demande un nouvel espace mémoire int* newPointer {new int[newCapacity]}; // Si j'avais déjà un espace mémoire if (pointer != nullptr) { // Je copie les données de l'ancien espace mémoire vers le nouveau std::copy(pointer, pointer + size, newPointer); // Je libère l'ancien espace mémoire delete [ ] pointer; } // Je met à jour les informations de la structure capacity = newCapacity; pointer = newPointer; } void push_back(int const value) { // Si je n'ai plus de place dans mon tableau, j'en demande plus if( size == capacity ) { reserve( 2 * capacity + 1 ); } // J'ajoute la valeur à la fin du tableau objects[size] = value; size++; } void pop_back() { if (size &gt; 0) { size--; } } int &amp; at(size_t const index) { // Si l'index est en dehors du tableau, je lève une exception (erreur) // Nous n'avons pas encore vu les exceptions, mais c'est un mécanisme qui permet de gérer les erreurs if (index &gt;= size) { throw std::out_of_range(&quot;Index out of range&quot;); } // Je retourne la valeur à l'index demandé return pointer[index]; } //... }; std::vector est bien sûr plus complexe que cela et a été fait par des experts du C++ mais cela permet de comprendre le principe qui se cache derrière cette structure de donnée.  ","version":"Next","tagName":"h2"},{"title":"Structure et This​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#structure-et-this","content":" Vous vous souvenez de l'utilisation du mot-clé this dans les méthodes de nos structures ?  this est en fait un pointeur vers la structure elle même !  On peut donc faire un déréférencement et avoir accès à la structure pour la modifier.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { (*this).price = price; // this-&gt;price = price; } };   C'est ce qui permet ici de faire la différence entre price qui est un paramètre de la méthode et this-&gt;price qui est le membre de la structure.  info La syntaxe -&gt; est en réalité un raccourci de syntaxe qui permet de faire un déréférencement puis d'accéder à un membre ou une méthode de la structure: Ces deux écritures sont donc équivalentes: this-&gt;member (*this).member.  ","version":"Next","tagName":"h2"},{"title":"Les références dans tout ça​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#les-références-dans-tout-ça","content":" Vous avez remarqué des ressemblances entre les pointeurs et les références ? C'est normal c'est le même mécanisme sous-jacent. La référence utilise l'adresse mémoire de la variable ciblée.  attention Cependant, une référence ne peut pas être nulle comme avec nullptr pour les pointeurs. Une référence est forcément associée à une variable.  Une référence peut être considérée comme un pointeur avec déréférencement automatique, c'est-à-dire que le compilateur applique en quelque sorte l'opérateur * pour vous.  comparaison #include &lt;iostream&gt; void addOneUsingPtr(int * a) { *a += 1; } void addOneUsingRef(int &amp; a) { a += 1; } void constDisplayUsingRef(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void constDisplayUsingPtr(int const * a) { std::cout &lt;&lt; *a &lt;&lt; std::endl; }   La référence a donc l'avantage d'être plus lisible et simple à utiliser.  remarque Utiliser les pointeurs directement est plutôt réservé à des cas spécifiques. Comme par exemple dans le cas où on souhaite une &quot;référence&quot; optionnelle (qui peut être nulle) ou alors réassigner la référence à une autre variable. #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { int a {42}; int b {24}; int&amp; ref {a}; ref = b; // a = b int* ptr {&amp;a}; *ptr = 12; // a = 12 ptr = &amp;b; // ptr pointe sur b *ptr = 36; // b = 36 displayPointer(ptr); // 36 ptr = nullptr; displayPointer(ptr); // null return 0; }   ","version":"Next","tagName":"h2"},{"title":"Pointeurs intelligents​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#pointeurs-intelligents","content":" Pendant l’exécution d'un programme, le système ne peut pas écraser ce que les développeurs ont demandé. C’est à nous, humains, de le gérer avec le mot-clé delete sinon cela provoque une fuite de mémoire.  Une fuite de mémoire est la mémoire qui a été demandée par l’utilisateur et qui n’a jamais été libérée, lorsque le programme s’est terminé ou que des pointeurs vers son emplacement ont été perdus. Pour éviter cela, chaque fois que nous n’avons plus besoin d’un élément de la Heap alloué, nous devons absolument le libérer.  L'accumulation de fuites de mémoire risque de provoquer un crash du programme ou de ralentir le système d'exploitation ou même dans le pire des cas faire planter l'ordinateur.    Pour éviter ce problème, et nous aider à gérer la mémoire le C++11 a introduit des pointeurs dits intelligents (smart pointer en anglais) dans la bibliothèque standard.  Lorsque le pointeur est détruit, la mémoire allouée précédemment est également libérée. Il n'est donc pas nécessaire de libérer la mémoire explicitement avec delete, c'est le pointeur intelligent qui s'en charge.  Un pointeur intelligent est en quelque sorte une structure enveloppant un pointeur et permettant de s'assurer que la mémoire est libérée une fois que le pointeur n'est plus utilisé.  ","version":"Next","tagName":"h2"},{"title":"unique_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#unique_ptr","content":" std::unique_ptr est un pointeur intelligent qui gère une zone mémoire allouée dynamiquement. Il est, comme son l'indique, l'unique responsable de cette zone mémoire. Elle sera détruite dès que le pointeur est détruit.  Il ne peut pas être copié, c'est à dire que l'on ne peut pas avoir deux std::unique_ptr pointant vers le même objet. Sinon, lors de la destruction des deux pointeurs, l'objet serait détruit deux fois.  #include &lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; ptr {new int{42}}; // On ne peut pas copier un unique_ptr // std::unique_ptr&lt;int&gt; ptr2 {ptr}; // A la fin du bloc (de la fonction main ici), ptr est détruit et l'espace mémoire est libéré }   ","version":"Next","tagName":"h3"},{"title":"shared_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#shared_ptr","content":" std::shared_ptr est un pointeur intelligent qui gère une zone mémoire allouée dynamiquement. La responsabilité de cette zone mémoire peut-être partagée entre plusieurs std::shared_ptr, et elle ne sera détruite que quand tous les std::shared_ptr responsables auront été détruits. Il est possible de copier un std::shared_ptr pour partager la responsabilité de la zone mémoire. Il utilise un compteur interne pour savoir combien de std::shared_ptr pointent vers la zone mémoire. Lorsque ce compteur tombe à zéro, la zone mémoire est libérée.  #include &lt;memory&gt; int main() { std::shared_ptr&lt;int&gt; ptr1 {new int{42}}; { // On peut copier un shared_ptr std::shared_ptr&lt;int&gt; ptr2 {ptr1}; // Changer la valeur de ptr1 *ptr1 = 24; // ptr1 et ptr2 pointent vers la même zone mémoire std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 24 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 24 *ptr2 = 12; std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 12 // Ici ptr2 est détruit mais la zone mémoire n'est pas libérée car ptr1 pointe toujours vers cette zone mémoire } std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 // A la fin du bloc (de la fonction main ici), ptr1 est détruit et l'espace mémoire est libéré return 0; }   C'est utile lorsque l'on souhaite partager un objet entre plusieurs parties du code.  ","version":"Next","tagName":"h3"},{"title":"std::weak_ptr​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdweak_ptr","content":" Il existe également un pointeur intelligent std::weak_ptr qui est un pointeur qui permet de pointer vers un objet gérer par un std::shared_ptr sans augmenter le compteur de références. C'est utile pour éviter des références circulaires et mieux gérer le cycle de vie des objets mais nous n'irons pas plus loin dans ce cours.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Allouer et manipuler la mémoire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#résumé","content":" Il existe plusieurs types d'allocation de mémoire: L'allocation de mémoire statique est effectuée à la compilation. Elle est donc très rapide mais ne permet pas de modifier la taille de la mémoire allouée.L'allocation de mémoire sur la stack est effectuée à l'exécution. Elle est utilisée pour allouer nos variables locales et est à privilégier car elle est rapide.L'allocation de mémoire dynamique sur la heap est effectuée à l'exécution. Elle est utilisée si on ne connaît pas la taille de la mémoire à allouer à la compilation ou si on veut modifier la taille de la mémoire allouée. Cela permet de gérer plus finement la mémoire mais est plus lente que l'allocation de mémoire sur la stack. Un pointeur est une variable qui contient une adresse mémoire (un nombre représenté en hexadécimal). C'est un type de variable à part entière qu'on différencie avec le symbole * après le type de la variable. On utilise les mots-clés new et delete pour allouer et désallouer de la mémoire sur la heap. Le déréférencement d'un pointeur permet d'accéder à la valeur de la variable pointée. Cela s'effectue avec l'opérateur * devant le nom du pointeur. Il est possible d'attribuer à un pointeur la valeur nullptr qui représente un pointeur nul. Cela permet d'indiquer qu'un pointeur ne pointe sur rien. On l'utilise pour vérifier qu'un pointeur est valide avant de l'utiliser. std::vector est un conteneur qui permet de gérer les allocations dynamiques de tableaux à notre place. le mot-clé this est un pointeur vers la structure elle même. Cela permet de faire la différence entre un paramètre de méthode et un membre de la structure. Il existe des pointeurs intelligents (smart pointer) qui permettent de gérer la mémoire à notre place. Ils sont très pratiques car ils permettent d'éviter les fuites mémoires et les erreurs de désallocation de mémoire. ","version":"Next","tagName":"h2"},{"title":"Structure: organiser nos données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Déclaration​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#déclaration","content":" C'est en utilisant le mot-clé struct que l'on va créer une nouvelle structure. La syntaxe de déclaration est la suivante:  struct nom { // liste des membres // type nom; // type nom; };   Cette structure est ensuite utilisable comme n'importe quel autre type de variable.  Un exemple de déclaration:  struct People { std::string name; std::string lastName; unsigned int age; };   ","version":"Next","tagName":"h2"},{"title":"Initialisation​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#initialisation","content":" Pour initialiser une structure, il y a plusieurs façons de faire similaire à la déclaration des variables &quot;classiques&quot;.  // Initialisation avec des valeurs (elles doivent être ordonnées comme les membres de la structure) People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Syntaxe possible utilisant le signe = (comme en C) People people = { &quot;name&quot;, &quot;lastName&quot;, 42 };   remarque Lors de l'initialisation avec des valeurs, elles doivent être ordonnées dans l’ordre dans lequel elles sont définies dans la structure. On ne peut pas donner juste un entier comme première valeur pour l'age dans notre cas.  danger Comme pour les variables, ne pas initialiser une structure est un comportement indéterminé. // Initialisation indéterminée People defaultPeople; Dans ce cas, il faut s'assurer de bien définir les membres de la structure ensuite !  ","version":"Next","tagName":"h2"},{"title":"Valeurs par défaut​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#valeurs-par-défaut","content":" Lors de l'initialisation, si il n'y a pas de valeur fournie entre accolades () pour les membres de la structure, ils seront initialisés avec une valeur par défaut. Pour les types primitifs (comme int, float, double, char, bool, etc.) la valeur par défaut est zéro. Pour les objets (comme std::string, std::vector, etc.) la valeur par défaut est l'objet vide.  Si une valeur est fournie en même temps que la déclaration d'un membre, c'est cette valeur qui sera utilisée lors de l'initialisation par défaut de la structure.  un exemple #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name {&quot;unknown&quot;}; float price {0.f}; unsigned int quantity {1}; }; void Display(Product const&amp; product) { std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; product.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; product.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; product.quantity &lt;&lt; std::endl; } int main() { Product unknownProduct {}; Display(unknownProduct); return 0; }   Name: unknown Price: 0 Quantity: 1   Résumé de toutes les possibilités d'initialisation Si une structure est initialisée avec accolades (ce qu'il fait faire tout le temps comme pour les variables) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur explicite est utilisée.Si une valeur est manquante dans les accolades et qu'il existe une valeur de variable membre par défaut, cette valeur est utilisée. (c'est l'exemple de la structure Product ci-dessus)Si une valeur est manquante dans les accolades et qu'il n'y a pas valeur par défaut dans la structure, l'initialisation par défaut pour le type de la variable est utilisée. Si une structure est initialisée sans accolades (ce qui est à éviter) : S'il existe une valeur d'initialisation explicite dans les accolades, cette valeur est utilisée.Si une valeur est manquante dans les accolades, la variable membre reste non initialisée. (comportement indéterminé)  Bonne pratique Une bonne pratique est de toujours initialiser les variables membres de la structure avec une valeur par défaut explicite ou à défaut d'utiliser des accolades vide pour éviter le risque de variables non initialisées et de comportement indéterminé. #include &lt;string&gt; struct Product { std::string name {}; float price {}; unsigned int quantity {1}; };   ","version":"Next","tagName":"h3"},{"title":"Utilisation​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#utilisation","content":" Pour manipuler un membre, c’est-à-dire une variable appartenant à la structure, il suffit d’utiliser la syntaxe structure.membre.  #include &lt;iostream&gt; #include &lt;string&gt; struct People { std::string name; std::string lastName; unsigned int age; }; int main() { People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Modification de l'age people.age = 19; // Lecture des membres std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; people.name &lt;&lt; &quot; &quot; &lt;&lt; people.lastName &lt;&lt; &quot; and i'm &quot; &lt;&lt; people.age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Passage par référence​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#passage-par-référence","content":" Une structure étant un agrégat de données (plus ou moins gros) il est intéressant d'utiliser des références pour passer en paramètres nos structures afin d'éviter des copies.  #include &lt;string&gt; #include &lt;iostream&gt; struct Product { std::string name; float price; unsigned int quantity; }; float GetTotalPrice(Product const&amp; product) { return product.price * product.quantity; } int main() { Product product { &quot;Tomatos&quot;, 0.32, 12 }; // Lecture des membres std::cout &lt;&lt; &quot;The total price for &quot; &lt;&lt; product.name &lt;&lt; &quot; is &quot; &lt;&lt; GetTotalPrice(product) &lt;&lt; &quot; €.&quot; &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des méthodes​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#des-méthodes","content":" Maintenant que nous avons nos propres structures cela va devenir intéressant d'utiliser des méthodes. En effet, dans mon exemple précédent j'ai créé des fonctions GetTotalPrice et Display. Mais j'aurais bien aimé pouvoir faire : product.TotalPrice(). Autrement dit, créer et utiliser une méthode TotalPrice() pour ma structure Product.  Il suffit simplement de déclarer notre fonction au sein même des accolades de notre structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() { return price * quantity; } };   remarque Vous pouvez remarquer qu'ici je peux accéder aux membres de ma struct sans avoir à faire struct.membre. En effet, la méthode a connaissance de la structure elle-même et peut manipuler ses membres directement.  ","version":"Next","tagName":"h2"},{"title":"Prototype de méthodes​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#prototype-de-méthodes","content":" Comme pour les fonctions, il est possible de déclarer seulement le prototype de la méthode et d'implémenter le corps de la méthode plus tard. Il y a juste un petit détail en plus, il faut indiquer à l'aide du nom de la structure et des caractères :: ,l'appartenance de la méthode à la structure (comme avec std::).  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; }   remarque C'est une notion qui va être utile quand on verra la séparation du code en plusieurs fichiers.  ","version":"Next","tagName":"h3"},{"title":"Méthode constante​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#méthode-constante","content":" Ici, il est aussi possible de préciser qu'une méthode ne modifie pas la structure, on parle de méthode constante. Il faut ajouter le mot-clé const à la fin de la déclaration de la méthode, avant le point virgule ;.  struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() const; }; float Product::TotalPrice() const { return price * quantity; }   C'est important car si on ne le fait pas on ne pourra pas appeler une méthode non constante d'une variable constante car celle-ci est susceptible de modifier la structure alors que c'est interdit par la variable constante.  #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; } int main() { Product const tomatos { &quot;Tomatos&quot;, 0.32, 12 }; // erreur ici: la variable tomatos est constante mais la méthode 'TotalPrice' ne l'est pas float tomatosPrice { tomatos.TotalPrice() }; return 0; }   Il faut donc indiquer que la méthode est constante:  // le prototype float GetTotalPrice() const; // et la fonction float Product::GetTotalPrice() const { return price * quantity; }   ","version":"Next","tagName":"h3"},{"title":"Conflit de noms​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#conflit-de-noms","content":" Comme pour les fonctions, il est possible de passer des paramètres à notre méthode.  Mais si le paramètre a le même nom qu'un des membres de la structure il y a un conflit de noms.  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float price) { price = price; } };   Ici la variable price manipulée dans la fonction n'est plus le membre mais le paramètre, les paramètres ont la priorité sur les membres de la structure.  attention Sur certains compilateurs bien configurés on peut avoir des warnings : Warning généré par clang Explicitly assigning value of variable of type 'float' to itself; did you mean to assign to member 'price'? Mais ce n'est pas toujours le cas. Avec un paramètre constant on aurait généré des erreurs de compilation et pas seulement un warning et c'est donc préférable pour mieux se rendre compte des erreurs. - Cannot assign to variable 'price' with const-qualified type 'const float' - assignment of read-only parameter 'price'   Pour éviter la confusion, il est préférable d'utiliser le mot clé this suivi des caractères -&gt; devant le nom d'un membre de la structure comme cela:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { this-&gt;price = price; } };   Ici, plus de problème, this-&gt;price fait référence à notre membre et price est le paramètre constant de la méthode.  Une autre solution préférable et recommandée est de renommer le nom du paramètre pour éviter cette confusion:  struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const newPrice) { price = newPrice; // this-&gt;price = newPrice; } };   Vous êtes libre de laisser ou non le this-&gt; pour indiquer plus explicitement l'utilisation du membre de la structure surtout si c'est plus compréhensible pour vous.  Je ne rentre pas dans le détail ici. Je reviendrai sur le fonctionnement du mot-clé this dans un autre chapitre. Retenez simplement ici que cela permet d'indiquer explicitement que l'on souhaite manipuler la structure.  ","version":"Next","tagName":"h3"},{"title":"Aller plus loin: Forward Declaration​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#aller-plus-loin-forward-declaration","content":" Parfois deux structures ont besoin l'une de l'autre, on veut utiliser une struct A dans une struct B et inversement.  Problème, l'une est définie avant l'autre et donc dans la première structure A il y a une erreur, B est encore inconnue.    Pour résoudre ce problème on va faire une déclaration anticipée (Forward Declaration en anglais).  Un peu à la manière d'un prototype on va indiquer que la structure existe, sans en définir précisément encore son contenu.  #include &lt;vector&gt; // Déclaration anticipée de la structure Book struct Book; struct Author { std::string name; // Je peux donc l'utiliser ici std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); };   attention Cela ne permet pas de manipuler la structure vu que l'on ne sait pas encore ce qu'elle contient. De ce fait, les méthodes de la structure Author qui utilisent la structure Book doivent se trouver après la déclaration complète de la structure Book.  Un exemple plus complet #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; struct Book; struct Author { std::string name; std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); }; void Author::Display() { std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Books: &quot; &lt;&lt; std::endl; for (Book const&amp; book : books) { std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; book.title &lt;&lt; std::endl; } } void Author::AddBook(std::string title) { // le &quot;*this&quot; permet de récupérer une référence vers l'objet courant // Ce mécanisme sera détaillé dans un prochain chapitre Book book {title, *this}; // Ici une copie de l'objet book est faite dans le vecteur books.push_back(book); // La variable book va être détruite à la fin de la fonction // mais le vecteur books contient une copie de l'objet book donc pas de problème } void Book::Display() { std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author.name &lt;&lt; std::endl; } int main() { Author author {&quot;Jules Verne&quot;, {}}; author.AddBook(&quot;Vingt mille lieues sous les mers&quot;); author.Display(); return 0; }   ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Structure: organiser nos données","url":"/Learn--cpp_programming/Lessons/S1/Struct#résumé","content":" Une structure est un agrégat de données, on la déclare avec le mot-clé struct. Les membres de la structure sont les variables qui la composent. On y accède avec un point . après le nom de la variable. Une structure peut avoir des méthodes qui se déclarent comme pour les fonctions mais au sein même des accolades de la structure. Le corps d'une méthode peut être déclaré plus tard (du moment que le prototype de la méthode est dans la structure). Il faut utiliser le nom de la structure suivi des caractères :: pour indiquer l'appartenance de la méthode à la structure si elle est déclarée en dehors des accolades délimitant la structure. Une méthode peut être constante pour indiquer qu'elle ne va pas modifier la structure. Il faut ajouter le mot-clé const après les paramètres de la fonction et avant le point virgule ;. On peut utiliser le mot-clé this pour expliciter que l'on souhaite manipuler la structure et éviter des conflits de nommages entre les membres et les paramètres d'une méthode. ","version":"Next","tagName":"h2"},{"title":"Arbres binaires","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree","content":"","keywords":"","version":"Next"},{"title":"Profondeur d'un nœud​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#profondeur-dun-nœud","content":" La profondeur d'un nœud est le nombre de nœuds qui le séparent du nœud racine. En considérant que la profondeur du nœud racine est 1.  Dans notre exemple, la profondeur du nœud racine A est 1. La profondeur du nœud B est 2. La profondeur du nœud E est 3. etc..  ","version":"Next","tagName":"h3"},{"title":"Hauteur d'un arbre​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#hauteur-dun-arbre","content":" La hauteur d'un arbre est la profondeur maximale de ses nœuds. C'est à dire la profondeur du nœud le plus profond.  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires","content":" Il existe plusieurs types d'arbres qui ont des propriétés différentes. On peut par exemple se limiter à un nombre maximum de fils par nœud, imposer un ordre sur les fils d'un nœud, ou encore imposer que chaque nœud ait un nombre fixe de fils.  C'est le cas des arbres binaires. Un arbre binaire est un arbre dont chaque nœud a au maximum deux fils. Un fils gauche et un fils droit.  C'est une structure de données très utilisée en informatique et c'est ce que nous allons étudier.  ","version":"Next","tagName":"h2"},{"title":"Représentation d'un arbre binaire​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#représentation-dun-arbre-binaire","content":" ","version":"Next","tagName":"h2"},{"title":"Structure par récursivité​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-récursivité","content":" Pour représenter un arbre binaire une solution qui peut sembler naturelle est d'utiliser une structure récursive. C'est à dire une structure qui contient des éléments de son propre type.  En effet, n'importe quel nœud de l'arbre, peut être vu comme un sous arbre binaire dont la racine est ce nœud. Ce jeu de l'esprit permet de comprendre qu'un nœud pointe vers deux autres nœuds qui sont les fils gauche et droit de ce nœud.  Il peut ne pointer vers aucun nœud, dans ce cas il est une feuille. Sinon, ce nœud représente un embranchement de l'arbre.  Mais on peut se demander comment représenter ce lien (qui peut ne pas exister dans le cas d'une feuille) entre un nœud et ses fils.  C'est là qu'interviennent les pointeurs. On peut représenter ce lien en utilisant des pointeurs vers les nœuds fils.  attention On ne peut pas utiliser des références car elles doivent être une référence vers un objet existant. Or, dans le cas d'une feuille, il n'y a pas de nœud fils.  Le pointeur lui peut être nul, c'est à dire qu'il ne pointe vers aucun objet. C'est cette particularité qui permet de représenter le cas d'une feuille.  Voilà à quoi ressemble la structure que l'on va utiliser pour représenter un arbre binaire:  struct Node { int value; Node* left; Node* right; };   Elle est composée d'un entier qui représente la valeur du nœud (cela peut être n'importe quel type de donnée), et de deux pointeurs vers des nœuds qui représentent les fils gauche et droit.  C'est pratique mais cela s'accompagne des inconvénients des pointeurs. Il faut faire attention à ne pas avoir de fuites mémoires (gérer l'allocation et la désallocation de la mémoire) et il faut faire attention à ne pas utiliser(déréférencer) un pointeur qui ne pointe vers rien (pointeur nul).  Exemple d'utilisation:  Node* root { new Node {1, nullptr, nullptr}}; root-&gt;left = { new Node {2, nullptr, nullptr}}; root-&gt;right = { new Node {3, nullptr, nullptr}}; root-&gt;left-&gt;left = { new Node {4, nullptr, nullptr}}; delete root-&gt;left-&gt;left; delete root-&gt;left; delete root-&gt;right; delete root;   attention ⚠️ Il faut faire attention à désallouer la mémoire dans le bon ordre ! Si on désalloue le nœud racine avant ses fils, on ne pourra plus accéder aux fils pour les désallouer. Cela provoque une fuite de mémoire.  info On pourrait se limiter seulement à cette structure de nœud pour représenter un arbre binaire. Mais cela peut être pratique d'avoir une structure dédiée à l'arbre binaire qui contient un pointeur vers le nœud racine. Cela permet de gérer le cas où l'arbre est vide (qui n'a pas encore de nœud racine). Cela permet aussi de cacher la structure interne de l'arbre. On peut par exemple changer la structure interne Node (la structure de nœud) sans avoir à modifier le code qui l'utilise (la structure de l'arbre). L'utilisateur de l'arbre n'a pas besoin de savoir comment est représenté l'arbre en interne, il n'est pas censé manipuler directement les nœuds. Cette notion de cacher la structure interne d'un objet est appelée encapsulation. C'est une notion importante en programmation orientée objet. Vous découvrirez cela plus en détail l'année prochaine et cela sera encore plus pertinent avec la notion de visibilité. struct BinaryTree { Node* root; };    Pointeurs intelligents Il existe des pointeurs intelligents qui permettent de gérer automatiquement la mémoire. Ils sont définis dans la bibliothèque &lt;memory&gt;. On pourrait se servir dans notre cas du pointeur intelligent std::unique_ptr qui permet de gérer automatiquement la mémoire d'un objet alloué dynamiquement. struct Node { int value; std::unique_ptr&lt;Node&gt; left; std::unique_ptr&lt;Node&gt; right; }; On peut alors utiliser la fonction std::make_unique pour créer un objet alloué dynamiquement et initialiser les pointeurs intelligents. std::unique_ptr&lt;Node&gt; root { std::make_unique&lt;Node&gt;(1, nullptr, nullptr)}; root-&gt;left = std::make_unique&lt;Node&gt;(2, nullptr, nullptr); root-&gt;right = std::make_unique&lt;Node&gt;(3, nullptr, nullptr); Cela permet de ne pas avoir à gérer la désallocation de la mémoire. La structure est automatiquement désallouée lorsque le pointeur intelligent est détruit. Cela va se faire dans le bon ordre naturellement car pour détruire une structure, il faut d'abord détruire ses membres. Ses enfants seront donc détruits avant le nœud parent.  ","version":"Next","tagName":"h3"},{"title":"Structure par tableau​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#structure-par-tableau","content":" Une autre façon de représenter un arbre binaire est d'utiliser un tableau. Cela peut sembler étrange mais c'est possible.  On peut représenter un arbre binaire en utilisant un tableau en utilisant la relation entre les indices du tableau et les nœuds de l'arbre.  On commence par numéroter le nœud racine avec l'indice 0. Ensuite, on définit une relation entre les indices des nœuds et les indices de leurs fils.  On définit que le fils gauche d'un nœud d'indice i est le nœud d'indice 2*i + 1. Et que le fils droit d'un nœud d'indice i est le nœud d'indice 2*i + 2.  Un exemple avec l'arbre suivant:    On peut représenter cet arbre avec le tableau suivant:  [A, B, C, D, E, F, G]   En effet, le nœud A est à l'indice 0. Son fils gauche est le nœud B qui est à l'indice 2*0 + 1 = 1. Son fils droit est le nœud C qui est à l'indice 2*0 + 2 = 2. Pour le nœud B(d'indice 1) , son fils gauche est le nœud D qui est à l'indice 2*1 + 1 = 3. Son fils droit est le nœud E qui est à l'indice 2*1 + 2 = 4. Etc...  info On peut remarquer qu'il faut un tableau de taille 2n−12^n - 12n−1 pour représenter un arbre binaire complet de hauteur n. C'est à dire un arbre binaire dont tous les niveaux sont remplis sauf éventuellement le dernier niveau qui peut ne pas être rempli.  Dans le cas où l'arbre n'est pas complet (c'est à dire que tous les feuilles ne sont pas sur le même niveau ou que des nœuds de l'arbre n'ont pas forcément deux fils), on peut avoir des trous dans le tableau. C'est à dire des cases du tableau qui ne sont pas utilisées.  Par exemple, pour l'arbre suivant:    On peut représenter cet arbre avec le tableau suivant:  [A, B, C, _, _, D, E, _, _, _, _, H, _, F, _]   Cette représentation est intéressante car elle permet de représenter un arbre binaire sans avoir à utiliser de pointeurs. Mais elle a aussi l'inconvénient de ne pas être très efficace quand l'arbre n'est pas complètement rempli. En effet, on peut avoir beaucoup de trous dans le tableau. Cela peut être problématique si l'arbre a une hauteur importante.  De plus il faut un moyen de représenter les trous dans le tableau. On peut par exemple utiliser une valeur spéciale qui ne peut pas être une valeur valide pour un nœud. Par exemple, on peut utiliser la valeur -1 pour représenter un trou dans le tableau. Ou alors on peut utiliser std::optional pour représenter un nœud qui n'existe pas.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un arbre binaire​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-dun-arbre-binaire","content":" Il existe plusieurs façons de parcourir les différents nœuds d'un arbre binaire. On peut par exemple parcourir l'arbre en largeur ou en profondeur.  Donnons nous l'arbre suivant:    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-largeur","content":" Le parcours en largeur consiste à parcourir l'arbre en commençant par le nœud racine puis en parcourant les nœuds de chaque niveau de profondeur de l'arbre de gauche à droite.  astuce Cela correspond à l'ordre dans lequel sont rangées les données lorsque l'on représente un arbre binaire par un tableau.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#parcours-en-profondeur","content":" Le parcours en profondeur consiste à parcourir l'arbre de la racine vers les feuilles par récursion dans les sous-arbres gauche et droite. On peut parcourir l'arbre en profondeur de différentes façons:  Parcours en profondeur préfixe (ou pré-ordre): on parcourt d'abord le nœud racine, puis le sous-arbre gauche et enfin le sous-arbre droit.Parcours en profondeur infixe (ou symétrique): on parcourt d'abord le sous-arbre gauche, puis le nœud racine et enfin le sous-arbre droit.Parcours en profondeur postfixe (ou post-ordre): on parcourt d'abord le sous-arbre gauche, puis le sous-arbre droit et enfin le nœud racine.  Exemple de parcours Pour l'arbre suivant:    Parcours en largeur: A B C D E F GParcours en profondeur préfixe: A B D E C F GParcours en profondeur infixe: D B E A F C GParcours en profondeur postfixe: D E B F G C A  ","version":"Next","tagName":"h3"},{"title":"Arbres binaires de recherche​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#arbres-binaires-de-recherche","content":" Une fois que l'on a vu comment représenter un arbre binaire, on peut se demander à quoi cela peut servir. On peut par exemple se demander comment faire une recherche efficace dans un arbre binaire.  Un arbre binaire de recherche est un arbre binaire qui a la particularité d'être ordonné. On va imposer un ordre sur les valeurs des nœuds de l'arbre.  Dans notre cas on va imposer que pour chaque nœud, toutes les valeurs des nœuds du sous-arbre gauche sont inférieures à la valeur du nœud et toutes les valeurs des nœuds du sous-arbre droit sont supérieures à la valeur du nœud.  Le premier élément inséré dans l'arbre devient la racine. Ensuite, il suffit de mettre à gauche les éléments plus petits et à droite les éléments plus grands. C'est cette particularité qui rend les arbres binaires de recherche intéressants.  Cela permet de faire des recherches efficaces dans l'arbre. Grâce à la relation d'ordre entre les nœuds, on peut savoir dans quel sous-arbre se trouve la valeur recherchée et effectuer une recherche rappelant le fonctionnement de la recherche dichotomique.  ","version":"Next","tagName":"h2"},{"title":"Insertion​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#insertion","content":" L'insertion dans un arbre binaire de recherche est assez simple. Il suffit de trouver le bon endroit pour insérer le nouveau nœud en respectant la relation d'ordre entre les nœuds.  On commence par comparer la valeur du nouveau nœud avec la valeur du nœud racine. Si la valeur du nouveau nœud est inférieure à la valeur du nœud racine, on insère le nouveau nœud dans le sous-arbre gauche. Sinon, on insère le nouveau nœud dans le sous-arbre droit.  On répète cette opération jusqu'à trouver un nœud qui n'a pas de fils dans la direction où l'on souhaite insérer le nouveau nœud. On insère alors le nouveau nœud à cet endroit.  ","version":"Next","tagName":"h3"},{"title":"Recherche​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#recherche","content":" La recherche dans un arbre binaire de recherche est similaire à la recherche dichotomique. Pour commencer, on compare la valeur recherchée avec la valeur du nœud racine. Si la valeur recherchée est inférieure à la valeur du nœud racine, on effectue la recherche dans le sous-arbre gauche. Sinon, on effectue la recherche dans le sous-arbre droit.  On répète cette opération jusqu'à trouver la valeur recherchée ou jusqu'à arriver à un nœud qui n'a pas de fils dans la direction où l'on souhaite continuer la recherche. Dans ce cas, on peut conclure que la valeur recherchée n'est pas dans l'arbre.  L'intérêt de la recherche dans un arbre binaire de recherche est que l'on peut exclure une partie de l'arbre à chaque étape de la recherche. Cela permet de réduire le nombre de comparaisons nécessaires pour trouver un élément dans l'arbre. C'est ce qui rend la recherche dans un arbre binaire de recherche efficace. C'est une complexité en O(log(n))O(log(n))O(log(n)).  ","version":"Next","tagName":"h3"},{"title":"Suppression​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#suppression","content":" La suppression dans un arbre binaire de recherche est plus complexe que l'insertion et la recherche. Il faut faire attention à ne pas casser la relation d'ordre entre les nœuds.  Il existe trois cas de figure:  Le nœud à supprimer est une feuille: il suffit de supprimer le nœud.Le nœud à supprimer a un seul fils: il suffit de supprimer le nœud et de le remplacer par son fils.Le nœud à supprimer a deux fils: il faut trouver le nœud qui va remplacer le nœud à supprimer tout en conservant la relation d'ordre entre les nœuds.  Dans le cas 3, il faut faire attention à ne pas casser la relation d'ordre entre les nœuds. Je rappelle que pour chaque nœud, toutes les valeurs des nœuds du sous-arbre gauche sont inférieures à la valeur du nœud et toutes les valeurs des nœuds du sous-arbre droit sont supérieures à la valeur du nœud. Pour conserver cette relation d'ordre, il faut alors que le nœud qui remplace le nœud à supprimer soit plus grand que tous les nœuds du sous-arbre gauche ou plus petit que tous les nœuds du sous-arbre droit.  On va donc par exemple chercher le nœud le plus à gauche du sous-arbre droit. Ce nœud est le plus petit nœud du sous-arbre droit. Il est donc plus grand que tous les nœuds du sous-arbre gauche et plus petit que tous les nœuds du sous-arbre droit. Il peut donc remplacer le nœud à supprimer tout en conservant la relation d'ordre entre les nœuds.  ","version":"Next","tagName":"h3"},{"title":"Une multitude d'arbres binaires​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#une-multitude-darbres-binaires","content":" Il existe une multitude d'arbres binaires différents qui ont des propriétés différentes. Cela permet de s'adapter à différents cas d'utilisation.  Par exemple, dans le cadre d'une recherche, on peut vouloir que l'arbre soit le plus équilibré possible (c'est à dire que la hauteur de l'arbre soit la plus petite possible). Cela permet de réduire le nombre de comparaisons nécessaires pour trouver un élément dans l'arbre. C'est le cas des arbres binaires de recherche AVL. Cela nous force à implémenter des algorithmes d'insertion et de suppression plus complexes pour maintenir l'équilibre de l'arbre.  Dans d'autres cas, on peut vouloir privilégier la rapidité d'insertion et de suppression. C'est le cas des arbres binaires de recherche Rouge-Noir. C'est un autre type d'arbre binaire de recherche qui permet de maintenir un arbre équilibré mais qui ne garantit pas à tout moment que l'arbre soit le plus équilibré possible. Cela permet de simplifier les algorithmes d'insertion et de suppression tout en restant efficace la majorité du temps.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Arbres binaires","url":"/Learn--cpp_programming/Lessons/S2/BinaryTree#résumé","content":" Un arbre est une structure de données qui permet de représenter des données hiérarchiques.Un arbre est composé de nœuds. Chaque nœud peut avoir un nombre quelconque de fils. Un nœud qui n'a pas de fils est appelé une feuille.Un arbre est composé d'un nœud racine qui est le nœud de départ de l'arbre. Il est possible d'accéder à tous les autres nœuds de l'arbre à partir du nœud racine.La profondeur d'un nœud est le nombre de nœuds qui le séparent du nœud racine.La hauteur d'un arbre est la profondeur maximale de ses nœuds. C'est à dire la profondeur du nœud le plus profond.Un arbre binaire est un arbre dont chaque nœud a au maximum deux fils. Un fils gauche et un fils droit.Un arbre binaire peut être représenté par une structure récursive (C'est à dire une structure qui contient des éléments de son propre type) ou par un tableau.Un arbre binaire de recherche est un arbre binaire qui a la particularité d'être ordonné. On va imposer un ordre sur les valeurs des nœuds de l'arbre. Cela va permettre de faire des recherches efficaces dans l'arbre.Il existe une multitude d'arbres binaires différents qui ont des propriétés différentes. Cela permet de s'adapter à différents cas d'utilisation (pour optimiser la recherche, l'insertion, la suppression, etc...) ","version":"Next","tagName":"h2"},{"title":"Structures de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Piles et files (LIFO, FIFO)​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#piles-et-files-lifo-fifo","content":" Une pile est une structure de données qui permet de stocker des éléments de façon à ce que le dernier élément ajouté soit le premier à être retiré. On parle de structure de données LIFO (Last In First Out).  Une file est une structure de données qui permet de stocker des éléments de façon à ce que le premier élément ajouté soit le premier à être retiré. On parle de structure de données FIFO (First In First Out).  ","version":"Next","tagName":"h2"},{"title":"std::stack — Une pile​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdstack--une-pile","content":" La classe std::stack permet de représenter une pile. Elle est définie dans la bibliothèque &lt;stack&gt;.  On utilise la méthode push pour ajouter un élément au sommet de la pile et la méthode pop pour retirer l'élément au sommet de la pile.  Elle s'utilise de la même façon que d'autres conteneurs de la bibliothèque standard.  #include &lt;stack&gt; #include &lt;iostream&gt; int main() { std::stack&lt;int&gt; stack; stack.push(1); stack.push(2); stack.push(3); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 3 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 2 stack.pop(); std::cout &lt;&lt; stack.top() &lt;&lt; std::endl; // Affiche 1 stack.pop(); }   ","version":"Next","tagName":"h3"},{"title":"std::queue — Une file​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdqueue--une-file","content":" La classe std::queue permet de représenter une file. Elle est définie dans la bibliothèque &lt;queue&gt;.  On utilise la méthode push pour ajouter un élément à la fin de la file et la méthode pop pour retirer l'élément au début de la file.  #include &lt;queue&gt; #include &lt;iostream&gt; int main() { std::queue&lt;int&gt; queue; queue.push(1); queue.push(2); queue.push(3); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 1 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 2 queue.pop(); std::cout &lt;&lt; queue.front() &lt;&lt; std::endl; // Affiche 3 queue.pop(); }   ","version":"Next","tagName":"h3"},{"title":"std::pair — Un conteneur de paires d'éléments​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdpair--un-conteneur-de-paires-déléments","content":" La classe std::pair (définie dans la bibliothèque &lt;utility&gt;) permet de représenter une paire d'éléments de types différents.  On peut accéder aux éléments de la paire avec les attributs first et second.  ","version":"Next","tagName":"h2"},{"title":"Définition d'une paire​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#définition-dune-paire","content":" Pour définir une paire, on peut utiliser la fonction std::make_pair ou assigner les valeurs directement aux attributs first et second.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 = std::make_pair(3, 4); std::pair&lt;int, int&gt; p3 {}; p3.first = 5; p3.second = 6; std::cout &lt;&lt; p1.first &lt;&lt; &quot; &quot; &lt;&lt; p1.second &lt;&lt; std::endl; // Affiche 1 2 std::cout &lt;&lt; p2.first &lt;&lt; &quot; &quot; &lt;&lt; p2.second &lt;&lt; std::endl; // Affiche 3 4 std::cout &lt;&lt; p3.first &lt;&lt; &quot; &quot; &lt;&lt; p3.second &lt;&lt; std::endl; // Affiche 5 6 }   Si rien n'est spécifié, les attributs first et second sont initialisés avec des valeurs par défaut.  info La fonction std::make_pair permet d'expliciter le type de la paire. C'est utile dans certains cas où le type de la paire ne peut pas être déduit automatiquement.  ","version":"Next","tagName":"h3"},{"title":"Comparaison de paires​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#comparaison-de-paires","content":" La paire intègre également un opérateur de comparaison qui compare les éléments de la paire dans l'ordre lexicographique.  Ordre lexicographique L'ordre lexicographique est comparable à l'ordre alphabétique. Si l'on se limite aux mots et lettres c'est l'ordre utilisé pour comparer les mots dans un dictionnaire. On compare les premières lettres des mots. Si les premières lettres sont égales, on compare les secondes lettres, etc. Cela peut être étendu à des éléments plus complexes comme des nombres. On compare les premiers éléments. Si les premiers éléments sont égaux, on compare les seconds éléments, etc.  Dans le cas des paires, on compare les premiers éléments. Si les premiers éléments sont égaux, on compare les seconds éléments.  #include &lt;utility&gt; #include &lt;iostream&gt; int main() { std::pair&lt;int, int&gt; p1 {1, 2}; std::pair&lt;int, int&gt; p2 {1, 3}; std::pair&lt;int, int&gt; p3 {2, 1}; std::pair&lt;int, int&gt; p4 {1, 2}; std::cout &lt;&lt; (p1 &lt; p2) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p3) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; (p1 &lt; p4) &lt;&lt; std::endl; // Affiche 0 }   ","version":"Next","tagName":"h3"},{"title":"Utilisation de std::pair​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#utilisation-de-stdpair","content":" On peut se servir de la classe std::pair et de son ordre lexicographique pour trier des éléments dans un tableau.  #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;std::pair&lt;int, int&gt;&gt; pairs { {1, 2}, {3, 4}, {1, 3}, {2, 1}, {1, 1} }; std::sort(pairs.begin(), pairs.end()); for (auto const&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl; } }   Dans cet exemple, on trie les paires dans l'ordre lexicographique sur les premiers éléments. Si les premiers éléments sont égaux, on trie les paires dans l'ordre lexicographique sur les seconds éléments.  Ce qui donne le résultat suivant :  1 1 1 2 1 3 2 1 3 4     Cela peut aussi être utile pour retourner plusieurs valeurs dans une fonction.  #include &lt;utility&gt; #include &lt;vector&gt; std::pair&lt;float, float&gt; minMax(std::vector&lt;float&gt; const&amp; array) { float min {array[0]}; float max {array[0]}; for (float const&amp; value: array) { if (value &lt; min) { min = value; } if (value &gt; max) { max = value; } } return std::make_pair(min, max); }   info La classe std::pair est également utilisée par d'autres conteneurs de la bibliothèque standard comme std::map que nous verrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"std::tuple — Un conteneur de données hétérogènes​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#stdtuple--un-conteneur-de-données-hétérogènes","content":" La classe std::tuple (définie dans la bibliothèque &lt;tuple&gt;) permet de représenter un ensemble de données hétérogènes  C'est similaire à std::pair mais on peut stocker plus de deux éléments.  On peut accéder aux éléments de la paire avec la fonction std::get.  Exemple :   #include &lt;tuple&gt; #include &lt;iostream&gt; int main() { std::tuple&lt;int, float, std::string&gt; t {1, 3.14f, &quot;Hello&quot;}; std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl; // Affiche 1 std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl; // Affiche 3.14 std::cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl; // Affiche Hello }   attention On privilégie l'utilisation de structures de données avec des membres explicites plutôt que des tuples ou des pairs quand c'est pertinent. Nommés les membres d'une structure permet de rendre le code plus lisible et plus facile à maintenir. Les tuples et pair sont utiles dans certains cas, mais il faut faire attention à ne pas en abuser.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#pour-aller-plus-loin","content":" std::variant La classe std::variant (définie dans la bibliothèque &lt;variant&gt;) permet de stocker un élément parmi un ensemble d'éléments possibles. Similaires aux aux enums, mais avec la possibilité de stocker des types différents. #include &lt;variant&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::variant&lt;int, float, std::string&gt; v {}; v = 42; // v contient un int v = 3.14f; // v contient un float v = &quot;Hello&quot;; // v contient une std::string if (std::holds_alternative&lt;int&gt;(v)) { std::cout &lt;&lt; &quot;v contient un int dont la valeur est &quot; &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;float&gt;(v)) { std::cout &lt;&lt; &quot;v contient un float dont la valeur est &quot; &lt;&lt; std::get&lt;float&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;std::string&gt;(v)) { std::cout &lt;&lt; &quot;v contient une std::string dont la valeur est &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl; }   std::optional La classe std::optional (définie dans la bibliothèque &lt;optional&gt;) permet de stocker un élément optionnel. C'est-à-dire un élément qui peut être présent ou non. Pour représenter un élément optionnel qui ne contient rien, on peut utiliser la valeur std::nullopt. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::optional&lt;int&gt; o {}; o = 42; // o contient un int if (o.has_value()) { std::cout &lt;&lt; &quot;o contient un int dont la valeur est &quot; &lt;&lt; o.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;o ne contient rien&quot; &lt;&lt; std::endl; } C'est un objet qui peut être utile pour représenter des valeurs optionnelles, comme par exemple le résultat d'une recherche dans un tableau ou un paramètre optionnel d'une fonction. #include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; // Recherche la valeur dans le tableau et retourne son index si elle est trouvée sous forme d'un std::optional std::optional&lt;size_t&gt; find(std::vector&lt;int&gt; const&amp; array, int value) { for (size_t i {0}; i &lt; array.size(); ++i) { if (array[i] == value) { return i; } } return std::nullopt; } int main() { std::vector&lt;int&gt; array {1, 2, 3, 4, 5}; std::optional&lt;size_t&gt; index {find(array, 3)}; if (index.has_value()) { std::cout &lt;&lt; &quot;3 se trouve à l'index &quot; &lt;&lt; index.value() &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;3 ne se trouve pas dans le tableau&quot; &lt;&lt; std::endl; } } info Cela permet de ne pas avoir à utiliser des valeurs spéciales pour représenter l'absence de valeur comme par exemple -1 pour un index comme on retrouve souvent en C.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Structures de données","url":"/Learn--cpp_programming/Lessons/S2/dataStructures#résumé","content":" Les piles et les files sont des structures de données qui permettent de stocker des éléments de façon à ce que le dernier élément ajouté soit le premier à être retiré (LIFO) ou le premier élément ajouté soit le premier à être retiré (FIFO). On utilise les classes std::stack et std::queue pour les représenter dans la bibliothèque standard de C++. La classe std::pair (&lt;utility&gt;) permet de représenter une paire d'éléments de types différents. C'est une classe qui est utilisée par d'autres conteneurs de la bibliothèque standard comme std::map. La classe std::tuple (&lt;tuple&gt;) permet de représenter un ensemble de données hétérogènes. std::optional La classe std::optional (&lt;optional&gt;) permet de stocker un élément optionnel. C'est utile pour éviter d'avoir recours à des valeurs spéciales pour représenter l'absence de valeur. std::variant La classe std::variant (&lt;variant&gt;) permet de stocker un élément parmi un ensemble d'éléments possibles. C'est comparable aux enums, mais permet de stocker des types différents. ","version":"Next","tagName":"h2"},{"title":"Déduction de type et bibliothèque standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"Itérateurs​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#itérateurs","content":" Les itérateurs sont des objets propres à la STL qui permettent de parcourir les conteneurs et structures de données sans se soucier de la manière dont ils sont implémentés. Cela permet d'abstraire le conteneur utilisé et de pouvoir utiliser des algorithmes de manière générique.  Les itérateurs sont des objets qui se comportent un peu comme des pointeurs. Ils permettent de cibler un élément dans un conteneur, de le manipuler et permettent de passer d'un élément à l'autre.  Pour un tableau (comme std::array ou std::vector) le passage d'un élément à l'autre se fait généralement en incrémentant un compteur mais pour d'autres conteneurs, le passage d'un élément à l'autre est plus complexe. Grâce aux itérateurs, nous n'avons pas à nous soucier de la manière dont le conteneur est implémenté.  info Il existe plusieurs types d'itérateurs qui permettent de parcourir les conteneurs de différentes manières (parcours en lecture seule, parcours en lecture et écriture, parcours seulement dans un sens, ...). Nous n'allons pas rentrer dans les détails des différents types d'itérateurs mais sachez qu'il existe plusieurs types d'itérateurs qui permettent de parcourir les conteneurs de différentes manières.  Les itérateurs ont des opérateurs et méthodes qui permettent de les manipuler comme avec l'opérateur * pour déréférencer et accéder à la valeur pointée par l'itérateur et l'opérateur ++ pour passer à l'élément suivant.  ","version":"Next","tagName":"h2"},{"title":"Begin et end​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#begin-et-end","content":" Il existe principalement deux méthodes sur les conteneurs qui permettent de récupérer un itérateur sur le premier élément du conteneur et un itérateur permettant d'indiquer la fin du conteneur.  Voici un exemple avec un vecteur (std::vector) :  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur sur le vecteur v std::vector&lt;int&gt;::iterator begin_iterator { v.begin() }; // Déclaration d'un itérateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() };   remarque Ici, nous utilisons l'itérateur std::vector&lt;int&gt;::iterator qui permet de parcourir un vecteur. Il existe aussi l'itérateur std::vector&lt;int&gt;::const_iterator qui permet de parcourir un vecteur en lecture seule (const) (on peut obtenir des itérateurs constants avec les méthodes cbegin et cend).  attention L'itérateur end ne pointe pas sur le dernier élément du conteneur mais vers un élément invalide qui indique la fin du conteneur (généralement un élément après le dernier élément du conteneur comme c'est le cas pour std::vector par exemple). Il ne faut donc pas déréférencer l'itérateur end car cela provoquerait une erreur. Il sert uniquement à indiquer la fin du conteneur.  ","version":"Next","tagName":"h3"},{"title":"Utilisation des itérateurs​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#utilisation-des-itérateurs","content":" Pour illustrer le fonctionnement des itérateurs, reprenons l'exemple précédent avec un vecteur pour utiliser l'itérateur pour parcourir le vecteur.  std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur permettant d'indiquer la fin du vecteur v std::vector&lt;int&gt;::iterator end_iterator { v.end() }; // Parcours du vecteur avec l'itérateur for (std::vector&lt;int&gt;::iterator it { v.begin() }; it != end_iterator; ++it) { std::cout &lt;&lt; *it &lt;&lt; std::endl; }   Quelques explications sur ce code : Nous déclarons un itérateur sur le premier élément du vecteur v et un itérateur sur le dernier élément du vecteur v. Ensuite, nous parcourons le vecteur avec une boucle for en incrémentant l'itérateur (pour passer à l'élément suivant). Nous utilisons l'opérateur != pour comparer l'itérateur actuel avec l'itérateur qui indique la fin du vecteur afin de savoir quand nous avons parcouru tout le vecteur. L'opérateur * permet de récupérer la valeur pointée par l'itérateur (à l'instar du déréférencement d'un pointeur).  for range based loop Il existe une syntaxe plus simple pour parcourir un conteneur avec un itérateur. Il s'agit de la boucle for avec la syntaxe for (element : container). Nous avons déjà vu cette syntaxe avec les tableaux. Cette syntaxe est aussi valable pour les autres conteneurs de la STL et utilise en fait les itérateurs. Voilà le même exemple que précédemment avec la boucle for et la syntaxe for (element : container) : std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Parcours du vecteur avec l'itérateur for (int const element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } C'est cette syntaxe que nous privilégierons en pratique pour parcourir les conteneurs.  ","version":"Next","tagName":"h3"},{"title":"Déduction de type​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#déduction-de-type","content":" Jusqu'à présent, nous avons toujours déclaré nos variables en précisant leur type. Cependant, il existe une syntaxe qui permet de déduire le type d'une variable à partir de son initialisation. Nous avons vu avec les itérateurs que le type de l'itérateur dépend du conteneur sur lequel il est utilisé (par exemple std::vector&lt;int&gt;::iterator pour un vecteur de int et std::vector&lt;float&gt;::iterator pour un vecteur de float)  Il est donc impossible de déclarer un itérateur sans connaître le type du conteneur. De plus, le type de l'itérateur est généralement très long et compliqué à écrire.  Dans ce cas, nous pouvons utiliser la déduction de type pour déclarer notre itérateur. Cela se fait avec le mot clé auto à la place du type de la variable.  std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Déclaration d'un itérateur sur le vecteur v auto it { v.begin() };   Pourquoi ne pas utiliser la déduction de type pour toutes les variables ? C'est une question de lisibilité du code. Il est plus facile de comprendre le code si les types sont précisés. De plus, la déduction de type ne fonctionne que si la variable est initialisée et que le type peut être déduit. Cela peut être problématique dans certains cas où le type ne peut pas être déduit ou conduit à des erreurs (par exemple avec {1, 2, 3, 4, 5} qui peut être un std::vector ou un std::array).  Finalement, la déduction de type est une fonctionnalité très utile mais qui doit être utilisée avec parcimonie quand cela est pertinent. Il est préférable de préciser le type des variables pour rendre le code plus lisible quand cela est possible.  On préférera donc écrire float plutôt que auto pour déclarer une variable de type float. Mais on préférera utiliser la déduction de type pour déclarer un itérateur sur un conteneur.  remarque C'est généralement considéré comme une mauvaise pratique de ne pas préciser le type des variables (comme c'est le cas en Python ou en JavaScript). Il existe pour ces langages des surcouches qui permettent de vérifier le type des variables (comme TypeScript pour JavaScript et le module typing pour Python). Le C++ est un langage fortement typé et nous impose de préciser le type des variables mais c'est pour une bonne raison et la déduction de type (auto) est une fonctionnalité qui permet de simplifier le code dans certains cas et n'a pas pour but de remplacer la déclaration de type.  ","version":"Next","tagName":"h2"},{"title":"Exemples et algorithmes​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#exemples-et-algorithmes","content":" L'intérêt de l'itérateur pour boucler sur un conteneur est limité. En effet, il est plus simple d'utiliser la boucle for avec la syntaxe for (element : container) pour parcourir un conteneur.  L'intérêt des itérateurs est de pouvoir utiliser des algorithmes de la STL qui permettent de manipuler les conteneurs de manière générique.  Toutes ces fonctions sont définies dans le fichier d'en-tête algorithm de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-tête sur le site cppreference.com (attention, la documentation est en anglais).  Nous allons voir quelques exemples d'algorithmes les plus courants de la STL.  ","version":"Next","tagName":"h2"},{"title":"Find​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#find","content":" L'algorithme std::find permet de rechercher un élément dans un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur, un itérateur sur le dernier élément du conteneur et la valeur à rechercher.  L'algorithme std::find renvoie un itérateur sur l'élément trouvé ou l'itérateur end si l'élément n'est pas trouvé.  Voici un exemple avec un vecteur (std::vector) :  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {1, 2, 3, 4, 5}; // Recherche de l'élément 3 dans le vecteur v auto it { std::find(v.begin(), v.end(), 3) }; // On compare l'itérateur avec l'itérateur sur le dernier élément du vecteur if (it != v.end()) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Sort​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#sort","content":" L'algorithme std::sort permet de trier un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur et un itérateur sur le dernier élément du conteneur.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {5, 2, 3, 1, 4}; // Tri du vecteur v std::sort(v.begin(), v.end()); // Parcours du vecteur avec l'itérateur for (int element : v) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Remove et Erase​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#remove-et-erase","content":" Pour le std::vector, il existe une méthode std::erase qui permet de supprimer des éléments du vecteur. Cependant, cette méthode n'existe pas pour tous les conteneurs.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v {14, 25, 36, 42, 53}; // Suppression de tous les éléments du vecteur v qui sont égaux à 36 std::erase(v, 36); }   Cette fonction propre au std::vector ne permet pas de supprimer un élément d'un conteneur générique.  Pour cela, il existe l'algorithme std::remove qui permet de supprimer un élément d'un conteneur. Il prend en paramètre un itérateur sur le premier élément du conteneur, un itérateur sur la fin du conteneur et la valeur à supprimer. C'est ce qu'utilise la méthode std::erase pour supprimer un élément du std::vector.  attention std::remove ne supprime pas réellement les éléments du conteneur. Il déplace les éléments à supprimer à la fin du conteneur et renvoie un itérateur sur le premier élément à supprimer pour définir la nouvelle fin du conteneur. Il faut ensuite utiliser la méthode erase pour supprimer les éléments à supprimer du conteneur. v.erase(std::remove(v.begin(), v.end(), 5), v.end());   C'est ce qu'on appelle l'idiome remove-erase.  A partir du C++20, il existe de nouvelles fonctions qui permettent de supprimer des éléments d'un conteneur de manière générique: std::erase_if et std::erase_if. Ces fonctions prennent en paramètre des itérateurs et fonctionnent donc avec tous les conteneurs.  Vous trouverez une explication ici.  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Les fonctions lambda​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#les-fonctions-lambda","content":" Details Il existe de nombreux autres algorithmes dans la STL. Il est impossible de tous les présenter dans ce cours. Je vous invite à consulter la documentation de la STL sur le site cppreference.com pour découvrir les autres algorithmes. Certains utilisent des fonctions lambda pour permettre de personnaliser le comportement de l'algorithme. C'est le cas de l'algorithme std::transform qui permet d'appliquer une fonction à tous les éléments d'un conteneur. Je ne vais pas rentrer dans les détails des fonctions lambda mais sachez que c'est une syntaxe qui permet de définir une fonction anonyme (généralement petite) et permet de passer une fonction en paramètre d'une autre fonction. C'est quelque chose de très utilisé avec la STL. Cela reste une notion avancée et je ne vais pas rentrer dans les détails des fonctions lambda dans ce cours. Vous pouvez seulement retenir deux choses : La syntaxe est la suivante : [] (paramètres) { instructions }.Si l'on souhaite accéder à une variable définie en dehors de la fonction lambda (sans que ce soit un paramètre), il faut ajouter le symbole &amp; entre les crochets et les paramètres de la fonction lambda ([&amp;] (paramètres) { instructions }) (c'est ce que l'on appelle une capture). Je vais présenter quelques algorithmes qui utilisent des fonctions lambda pour vous montrer comment cela fonctionne.  ","version":"Next","tagName":"h3"},{"title":"Transform​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#transform","content":" Details L'algorithme std::transform permet d'appliquer une fonction à tous les éléments d'un conteneur. Il prend en paramètre un itérateur sur le premier et le dernier élément du conteneur, un itérateur sur le premier élément du conteneur de destination et la fonction à appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {0, 0, 0, 0, 0}; // Application de la fonction lambda à tous les éléments du vecteur v std::transform(v.begin(), v.end(), v2.begin(), [](int element) { return element * 2; }); // Parcours du vecteur avec l'itérateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } } attention Il faut faire attention à la taille du conteneur de destination. Si le conteneur de destination est trop petit, il y aura un dépassement et soit le programme plantera soit il y aura des résultats inattendus (le vecteur de destination ne sera pas rempli, etc...). Avec des conteneurs pour lesquels on peut ajouter des éléments à la fin (comme std::vector), il est possible d'utiliser la fonction std::back_inserter pour ajouter des éléments à la fin du conteneur de destination. Cela permet de ne pas avoir à se soucier de la taille du conteneur de destination. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; std::vector&lt;int&gt; v2 {}; // Application de la fonction lambda à tous les éléments du vecteur v std::transform(v.begin(), v.end(), std::back_inserter(v2), [](int element) { return element * 2; }); // Parcours du vecteur avec l'itérateur for (int const element : v2) { std::cout &lt;&lt; element &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h3"},{"title":"Accumulate et reduce​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#accumulate-et-reduce","content":" Details Lorsque l'on souhaite agréger les éléments d'un conteneur pour en extraire une valeur, il existe deux algorithmes qui permettent de faire cela : std::accumulate et std::reduce. Il sont inclus dans le fichier d'en-tête numeric de la STL. Vous pouvez retrouver la documentation de ce fichier d'en-tête sur le site cppreference.com. L'algorithme std::accumulate permet d’accumuler les éléments d'un conteneur selon une opération. Pour en faire la somme par exemple. Il prend en paramètre un itérateur sur le premier et le dernier élément du conteneur, la valeur initiale et l'opération à appliquer. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des éléments du vecteur v int sum { std::accumulate(v.begin(), v.end(), 0, [](int acc, int current_element) { return acc + current_element; }) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; } A chaque itération, l'opération est appliquée entre la valeur accumulée et l'élément courant du conteneur. La valeur accumulée est initialisée avec la valeur initiale. Les valeurs sont parcourues dans l'ordre du conteneur. L'algorithme std::reduce fonctionne de la même manière que std::accumulate mais il n'y a pas de valeur initiale. Les valeurs sont parcourues dans n'importe quel ordre. C'est utile quand l'opération est commutative (l'ordre des opérandes n'a pas d'importance). Somme #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() { std::vector&lt;int&gt; const v {1, 2, 3, 4, 5}; // Somme des éléments du vecteur v int sum { std::reduce(v.begin(), v.end(), [](int a, int b) { return a + b; }) }; // Ou en utilisant std::plus pour faire la somme (une fonction somme déjà implémentée dans la STL dans l'entête &lt;functional&gt;) // int sum { std::reduce(v.begin(), v.end(), std::plus&lt;int&gt;()) }; std::cout &lt;&lt; sum &lt;&lt; std::endl; }   ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm#résumé","content":" La STL fournit des algorithmes et des fonctions qui permettent de simplifier la manipulation des conteneurs.La STL fournit des itérateurs qui permettent de parcourir les conteneurs de manière générique.Un itérateur est un objet qui se comporte un peu comme un pointeur et permet de cibler un élément dans un conteneur, de le manipuler et permet de passer d'un élément à l'autre.Il existe deux méthodes sur les conteneurs qui permettent de récupérer un itérateur sur le premier élément du conteneur et un itérateur sur le dernier élément du conteneur : begin et end.La syntaxe for (element : container) utilise les itérateurs pour parcourir un conteneur.La déduction de type permet de déduire le type d'une variable à partir de son initialisation. Cela se fait avec le mot clé auto à la place du type de la variable.La déduction de type est une fonctionnalité très utile mais qui doit être utilisée avec parcimonie quand cela est pertinent. Il est préférable de préciser le type des variables pour rendre le code plus lisible quand cela est possible.L'algorithme std::find permet de rechercher un élément dans un conteneur.L'algorithme std::sort permet de trier un conteneur.L'algorithme std::erase permet de supprimer un élément d'un std::vector.Les fonctions lambda permettent de définir une fonction anonyme (généralement petite) pour personnaliser le comportement d'un algorithme.L'algorithme std::transform permet d'appliquer une fonction à tous les éléments d'un conteneur.Les algorithmes std::accumulate et std::reduce permettent d'agréger les éléments d'un conteneur pour en extraire une valeur. ","version":"Next","tagName":"h2"},{"title":"Graphes","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/graphs","content":"","keywords":"","version":"Next"},{"title":"Quelques définitions​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#quelques-définitions","content":" Un graphe est un ensemble de sommets reliés par des arêtes. On peut représenter un graphe par un ensemble de points reliés par des traits. Les points sont les sommets et les traits sont les arêtes.    Un graphe est dit orienté si les arêtes ont un sens. Dans ce cas, on parle d'arc. Un graphe est dit non orienté si les arêtes n'ont pas de sens.    Un graphe est dit pondéré si les arêtes ont un poids. Dans ce cas, on parle de poids d'une arête. Un graphe est dit non pondéré si les arêtes n'ont pas de poids.    Un graphe est dit connexe si tous les sommets sont reliés entre eux par une arête ou une suite d'arêtes.    Un graphe est dit cyclique si il contient au moins un cycle. Un cycle est une suite d'arêtes qui permet de revenir au point de départ.    ","version":"Next","tagName":"h2"},{"title":"Les arbres​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#les-arbres","content":" On a précédemment vu les arbres binaires. Un arbre n'est rien d'autre qu'un graphe particulier. Un arbre est un graphe non orienté, non pondéré, connexe et acyclique.  ","version":"Next","tagName":"h3"},{"title":"Représentation d'un graphe​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#représentation-dun-graphe","content":" Il existe plusieurs manières de représenter un graphe en mémoire. Nous allons voir les deux plus courantes.  ","version":"Next","tagName":"h2"},{"title":"Matrice d'adjacence​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#matrice-dadjacence","content":" La première manière de représenter un graphe est d'utiliser une matrice d'adjacence. Une matrice d'adjacence est une matrice carrée dont les lignes et les colonnes représentent les sommets du graphe. Si le sommet iii est relié au sommet jjj, alors la case (i,j)(i,j)(i,j) de la matrice vaut 1. Sinon, elle vaut 0. Si le graphe est pondéré, la case (i,j)(i,j)(i,j) de la matrice vaut le poids de l'arête.  Voici un exemple de matrice d'adjacence pour un graphe non orienté et non pondéré :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t1\t0\t1\t1\t0 C\t1\t1\t0\t0\t1 D\t0\t1\t0\t0\t1 E\t0\t0\t1\t1\t0  Et le graphe correspondant :    Dans le cas d'un graphe orienté, la matrice n'est plus symétrique. Voici un exemple de matrice d'adjacence pour un graphe orienté et non pondéré :  \tA\tB\tC\tD\tEA\t0\t1\t1\t0\t0 B\t0\t0\t1\t1\t0 C\t0\t0\t0\t0\t1 D\t0\t0\t0\t0\t1 E\t0\t0\t0\t0\t0  Et le graphe correspondant :    ","version":"Next","tagName":"h3"},{"title":"Liste d'adjacence​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#liste-dadjacence","content":" La deuxième manière de représenter un graphe est d'utiliser une liste d'adjacence. Une liste d'adjacence est une liste de listes. Pour chaque sommet, on a une liste des sommets adjacents. Si le graphe est pondéré, on a une liste des sommets adjacents avec leur poids (avec une paire par exemple).  Voici un exemple de liste d'adjacence pour un graphe non orienté et non pondéré :  Sommet\tAdjacentsA\tB, C B\tA, C, D C\tA, B, E D\tB, E E\tC, D  En pratique, on utilise plutôt la liste d'adjacence pour représenter un graphe car la matrice d'adjacence peut être très coûteuse en mémoire. En effet, une matrice d'adjacence est une matrice carrée. Donc, si on a nnn sommets, on a n2n^2n2 cases. Même si le graphe possède peu d'arêtes, la matrice d'adjacence est quand même de taille n2n^2n2. Cela peut être légèrement optimisé dans le cas des graphes non orientés car la matrice est symétrique. On peut donc ne stocker que la moitié de la matrice. Mais cela reste quand même très coûteux en mémoire.  L'utilité de la matrice d'adjacence est qu'elle permet de savoir si deux sommets sont reliés en temps constant. Dans les cas où c'est acceptable de stocker une matrice d'adjacence, on peut donc utiliser cette propriété pour gagner du temps. Cela a aussi des applications en théorie des graphes pour analyser des graphes.  ","version":"Next","tagName":"h3"},{"title":"Parcours d'un graphe​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-dun-graphe","content":" Maintenant que nous avons vu comment représenter un graphe en mémoire, nous allons voir comment parcourir un graphe. Il existe principalement deux manières de parcourir un graphe : en largeur et en profondeur.  Donnons-nous le graphe suivant :    ","version":"Next","tagName":"h2"},{"title":"Parcours en largeur​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-largeur","content":" Le parcours en largeur consiste à parcourir le graphe en partant d'un sommet et en visitant tous les sommets adjacents avant de passer aux sommets adjacents de ces sommets adjacents. On visite donc les sommets par niveau.  Pour parcourir un graphe en largeur, on utilise une file. On commence par ajouter le sommet de départ dans la file. Tant que la file n'est pas vide, on retire le premier élément de la file et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file. On recommence jusqu'à ce que la file soit vide.  Voici le déroulement du parcours en largeur au départ du nœud A pour le graphe précédent :  On commence par ajouter le sommet A dans la file.Comme la file n'est pas vide, on retire le premier élément (A) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc B et C dans la file.On retire le premier élément (B) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc D et E dans la file. La file contient maintenant C, D et E.On retire le premier élément (C) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc F et G dans la file. La file contient maintenant D, E, F et G.On retire le premier élément (D) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc rien dans la file. La file contient maintenant E, F et G.On fait de même pour E, F et G. La file est maintenant vide. On a donc parcouru tous les sommets du graphe.  Cela nous donne donc le parcours suivant : A, B, C, D, E, F, G.  ","version":"Next","tagName":"h3"},{"title":"Parcours en profondeur​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-profondeur","content":" Le parcours en profondeur consiste à parcourir le graphe en partant d'un sommet et en visitant ses sommets adjacents puis les sommets adjacents de ces sommets adjacents, etc. On visite donc les sommets en profondeur. On peut voir le parcours en profondeur comme une descente dans le graphe.  Pour parcourir un graphe en profondeur, on utilise une pile. On commence par ajouter le sommet de départ dans la pile. Tant que la pile n'est pas vide, on retire le premier élément de la pile et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la pile. On recommence jusqu'à ce que la pile soit vide.  Voici le déroulement du parcours en profondeur au départ du nœud A pour le graphe précédent :  On commence par ajouter le sommet A dans la pile.Comme la pile n'est pas vide, on retire le premier élément (A) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc B et C dans la pile.On retire le premier élément (C) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc F et G dans la pile. La pile contient maintenant B, F et G.On retire le premier élément (G) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile. La pile contient maintenant B et F.On retire le premier élément (F) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile. La pile contient maintenant B.On retire le premier élément (B) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc D et E dans la pile. La pile contient maintenant D et E.On fait de même pour E et D. La pile est maintenant vide. On a donc parcouru tous les sommets du graphe.  Ce qui nous donne le parcours suivant : A, C, G, F, B, E, D.  ","version":"Next","tagName":"h3"},{"title":"En pratique​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#en-pratique","content":" Maintenant que nous avons vu ce qu'est un graphe il est légitime de se demander à quoi cela peut bien servir. En effet, on peut se demander si on a déjà rencontré des graphes dans la vie de tous les jours. La réponse est oui. Les graphes sont utilisés dans de nombreux domaines. En voici quelques exemples :  Les réseaux sociaux : les graphes sont utilisés pour modéliser les relations entre les utilisateurs.Les jeux vidéos : les graphes sont utilisés pour modéliser les niveaux, les cartes ou encore pour de la recherche de chemin (intelligence artificielle des ennemis par exemple).Les bases de données : les graphes sont utilisés pour modéliser les relations entre les données.Les problèmes de transport : les graphes sont utilisés pour modéliser les réseaux de transport (routes, métro, etc.) et permettent de résoudre des problèmes d'optimisation (par exemple, trouver le plus court chemin entre deux villes).Des algorithmes de programmation dynamique : les graphes sont beaucoup utilisés dans les algorithmes dis de programmation dynamique où le problème est si complexe qu'il est nécessaire de le décomposer en sous-problèmes, de faire des estimations et d'explorer les solutions possibles à travers un graphe de solutions.  ","version":"Next","tagName":"h2"},{"title":"Dijkstra​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#dijkstra","content":" Je vous propose de voir un exemple d'algorithme de graphe : l'algorithme de Dijkstra. Cet algorithme permet de trouver le plus court chemin entre deux sommets d'un graphe pondéré. Il est très répandu et est utilisé dans de nombreux domaines.  L'algorithme de Dijkstra est simplement une application du parcours en largeur. On part d'un sommet de départ et on visite tous les sommets adjacents. On ajoute ensuite les sommets adjacents de ces sommets adjacents dans la file. On recommence jusqu'à ce qu'on ait trouvé le sommet d'arrivée. On peut alors remonter le chemin en partant du sommet d'arrivée et en remontant les sommets précédents jusqu'au sommet de départ.  Il faut une liste de même taille que le nombre de sommets du graphe pour stocker les distances. On initialise toutes les distances à l'infini sauf la distance du sommet de départ qui est à 0. On utilise également une file pour stocker les sommets à visiter et une liste pour stocker les sommets déjà visités. On commence par ajouter le sommet de départ dans la file des sommets à visiter. Tant que la file n'est pas vide, on retire le premier élément de la file et on l'ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file s'ils n'ont pas déjà été visités. Pour chaque sommet adjacent, on met à jour sa distance si la distance actuelle est plus grande que la distance du sommet actuel plus le poids de l'arête entre le sommet actuel et le sommet adjacent. On recommence jusqu'à ce que la file soit vide.  astuce Dans la pratique, on utilise une file de priorité pour stocker les sommets à visiter. Cela permet de toujours retirer le sommet avec la plus petite distance en premier. Cela permet d'optimiser l'algorithme. De plus, généralement, cet algorithme est utilisé pour trouver le plus court chemin entre deux sommets. On peut donc s'arrêter dès qu'on a trouvé le sommet d'arrivée.  attention L'algorithme de Dijkstra ne fonctionne que pour les graphes pondérés positivement. En effet, si le graphe contient des arêtes de poids négatif, l'algorithme peut boucler indéfiniment. Pour éviter ces problèmes,il est aussi possible d'utiliser une variante: l'algorithme de Bellman-Ford qui est plus lent mais qui fonctionne pour les graphes avec des cycles et des arêtes de poids négatif.  Pour illustrer l'algorithme de Dijkstra, donnons-nous le graphe suivant :    on considère que le sommet de départ est A .  A\tB\tC\tD\tE\tSommets à visiter\tSommets visités0\t∞\\infty∞\t∞\\infty∞\t∞\\infty∞\t∞\\infty∞\t[A]\t[-]  On commence par ajouter le sommet de départ A dans la file de priorité des sommets à visiter. On initialise également la distance du sommet de départ à 0 et les autres distances à l'infini.  B et C sont les sommets adjacents de A. On ajoute donc B et C dans la file de priorité des sommets à visiter. On met également à jour les distances de B et C. La distance de B est la distance de A plus le poids de l'arête entre A et B. La distance de C est la distance de A plus le poids de l'arête entre A et C.  A\tB\tC\tD\tE\tSommets à visiter\tSommets visités0\t1(A)\t3(A)\t∞\\infty∞\t∞\\infty∞\t[B, C]\t[A]  On continue en retirant le sommet B. Il a comme sommets adjacents C et D. C a déjà une distance de 3(venant de A) mais la distance depuis B est plus petite (1 venant de A plus 1 venant de B). On met donc à jour la distance de C. La distance de D est la distance de B plus le poids de l'arête entre B et D. On ajoute ensuite D dans la file de priorité des sommets à visiter (C est déjà dans la file).  A\tB\tC\tD\tE\tSommets à visiter\tSommets visités0\t1(A)\t2(B)\t3(B)\t∞\\infty∞\t[C, D]\t[A, B]  Voilà l'étape suivante en considérant C. C a comme sommets adjacents E. La distance de E est la distance de C plus le poids de l'arête entre C et E. On ajoute ensuite E dans la file de priorité des sommets à visiter.  A\tB\tC\tD\tE\tSommets à visiter\tSommets visités0\t1(A)\t2(B)\t3(B)\t3(C)\t[D, E]\t[A, B, C]  On continue en retirant le sommet D. Il a comme sommets adjacents E. La distance de E est la distance de D plus le poids de l'arête entre D et E. Or la distance actuelle de E (venant de C) est plus petite. On ne met donc pas à jour la distance de E. E est déjà dans la file de priorité des sommets à visiter. On ne fait donc rien.  A\tB\tC\tD\tE\tSommets à visiter\tSommets visités0\t1(A)\t2(B)\t3(B)\t3(C)\t[E]\t[A, B, C, D]  Enfin on retire le sommet E. Il n'a pas de sommets adjacents. On ne fait donc rien.  On a fini de parcourir le graphe. On a donc trouvé les distances de tous les sommets depuis le sommet de départ A. Si l'on souhaite trouver le plus court chemin entre A et E, il suffit de remonter le chemin en partant de E et en remontant les sommets précédents jusqu'à A. Le plus court chemin entre A et E est donc A →\\rightarrow→ B →\\rightarrow→ C →\\rightarrow→ E.  astuce En pratique pour pouvoir remonter le chemin, il faut stocker pour chaque sommet la distance la plus courte depuis le sommet de départ mais aussi le sommet précédent (d'où l'on vient pour obtenir cette distance). On peut stocker cela dans une liste de paires (distance, sommet précédent). On peut aussi stocker si un sommet a déjà été visité ou non dans une liste de booléens de la taille du nombre de sommets plutôt que dans une liste de sommets visités.  ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin: A*​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#pour-aller-plus-loin-a","content":" L'algorithme de Dijkstra peut être amélioré. En effet, il explore tous les sommets adjacents d'un sommet avant de passer au sommet suivant. Cela peut être très coûteux en temps si le graphe est très grand et ou si le sommet de départ et le sommet d'arrivée sont très éloignés. L'algorithme de Dijkstra explore alors beaucoup de sommets inutilement.  L'algorithme A* est une amélioration de l'algorithme de Dijkstra. Il utilise une heuristique pour guider la recherche. L'heuristique est une fonction qui permet d'estimer la distance entre un sommet et le sommet d'arrivée. L'algorithme A* explore alors en priorité les sommets qui sont les plus proches(selon cette estimation) du sommet d'arrivée. Cela permet de réduire le nombre de sommets explorés et donc de gagner du temps.  Pour donner un exemple concret, on peut utiliser la distance euclidienne comme heuristique. La distance euclidienne est la distance à vol d'oiseau entre deux points. On peut l'utiliser pour guider la recherche dans un labyrinthe par exemple. On peut alors utiliser la distance euclidienne entre le sommet actuel et le sommet d'arrivée comme heuristique. Cela permet d'explorer en priorité les sommets qui sont les plus proches (à vol d'oiseau) du sommet d'arrivée.  ","version":"Next","tagName":"h3"},{"title":"Simplification 2D​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#simplification-2d","content":" La représentation en liste d'adjacence est très pratique pour représenter un graphe arbitraire. Cependant, dans certains cas, on peut utiliser une représentation plus simple. C'est le cas par exemple quand on cherche le plus court chemin entre deux points dans une grille. Dans ce cas les sommets sont les centres des cases de la grille et les arêtes sont les côtés des cases de la grille. Il n'est alors pas nécessaire de stocker la représentation complète du graphe car celle-ci est connue à l'avance. On peut donc utiliser une représentation plus simple.  Dans le cas où le coup de déplacement d'une case à une autre est le même pour toutes les cases, appliquer Dijkstra sur une grille devient alors très simple. Il suffit de parcourir la grille en largeur en partant du point de départ et en s'arrêtant quand on a trouvé le point d'arrivée. On peut alors remonter le chemin en partant du point d'arrivée et en remontant les points précédents jusqu'au point de départ (parfois aussi nommé Breadth First Search ou BFS).  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#résumé","content":" Un graphe est un ensemble de sommets reliés par des arêtes.Un graphe est dit orienté si les arêtes ont un sens. Dans ce cas, on parle d'arc.Un graphe est dit pondéré si les arêtes ont un poids.Un graphe est dit connexe si tous les sommets sont reliés entre eux par une arête ou une suite d'arêtes.Un arbre est un graphe(Un graphe non orienté, non pondéré, connexe et acyclique)Il existe deux manières de représenter un graphe en mémoire : la matrice d'adjacence et la liste d'adjacence.Il existe deux manières de parcourir un graphe : en largeur et en profondeur.L'algorithme de Dijkstra permet de trouver les distances les plus courtes entre un sommet de départ et tous les autres sommets d'un graphe pondéré positivement.L'algorithme A* est une amélioration de l'algorithme de Dijkstra qui utilise une heuristique pour guider la recherche.Dans le cas d'un graphe non pondéré, Dijkstra n'est rien d'autre qu'un parcours en largeur.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Graphes","url":"/Learn--cpp_programming/Lessons/S2/graphs#sources","content":" Voilà quelques sources qui peuvent vous aider à approfondir le sujet et mieux comprendre les graphes et la recherche de chemin :  https://www.redblobgames.com/pathfinding/a-star/introduction.htmlhttps://www.youtube.com/watch?v=GazC3A4OQTEhttps://www.youtube.com/watch?v=i3_V90yUfcAhttps://www.youtube.com/watch?v=-L-WgKMFuhE ","version":"Next","tagName":"h2"},{"title":"Compression et encodage de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression","content":"","keywords":"","version":"Next"},{"title":"Compression de données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression-de-données","content":" La compression de données est une technique qui permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.  C'est un domaine crucial en informatique moderne. Sans la compression de données, il serait impossible de stocker des milliers de photos sur un téléphone portable, ou de regarder des vidéos en streaming sur Internet.  Il existe deux types de compression de données : la compression avec perte et la compression sans perte. La compression avec perte permet de réduire la taille des données, mais on ne garantit pas que les données décompressées seront identiques aux données d'origine. C'est le cas par exemple de la compression d'images au format JPEG où la perte de qualité est relativement maîtrisée pour cela soit le moins perceptible par l'œil humain. La compression sans perte permet de retrouver les données d'origine après les avoir décompressées. C'est le cas par exemple de la compression d'images au format PNG.  note concernant le format JPEG Le format JPEG est un format de compression avec perte.Le processus de compression JPEG est assez complexe et est composé de plusieurs étapes. Certaines de ces étapes sont des étapes de compression avec perte, et d'autres sont des étapes de compression sans perte (dont l'encodage RLE et l'encodage de Huffman que nous allons voir dans ce cours). C'est pour cela que l'on dit que le format JPEG est un format de compression avec perte.  ","version":"Next","tagName":"h2"},{"title":"Prérequis​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#prérequis","content":" Pour ce cours, il est nécessaire de connaître quelques notions de base sur la représentation des données en informatique. Voici un résumé des notions à connaître :  Un bit est la plus petite unité de stockage en informatique. Il ne peut prendre que deux valeurs : 0 ou 1. Un octet est un groupe de 8 bits. Il peut donc prendre 256 valeurs différentes (de 0 à 255). Chaque donnée peut être représentée par une suite de bits. Par exemple, le nombre 42 peut être représenté en binaire par la suite de bits 101010. Avec un octet, on peut représenter au maximum 256 nombres différents. Un caractère est généralement codé sur un octet (cela peut dépendre de l'encodage utilisé). Cela signifie que l'on peut représenter 256 caractères différents. Cela inclut les lettres de l'alphabet, les chiffres, les caractères spéciaux, etc.  ","version":"Next","tagName":"h2"},{"title":"Encodage et représentation des données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#encodage-et-représentation-des-données","content":" Un encodage est une manière de représenter les données. Par exemple, on peut représenter le nombre 42 de la manière suivante : 101010. C'est un encodage binaire. On peut aussi représenter le nombre 42 de la manière suivante : 2A. C'est un encodage hexadécimal.  Encoder des données revient à associer à chaque donnée un code.  Dans la suite de ce cours nous allons nous intéresser à l'encodage binaire. C'est l'encodage utilisé par les ordinateurs et qui permet de représenter les données de manière la plus compacte possible. C'est aussi l'encodage utilisé par les algorithmes de compression.    Dans un fichier texte, chaque lettre est représentée par un caractère. Ce caractère est généralement encodé sur un octet. Cela signifie que l'on peut représenter au maximum 256 caractères différents. Cela inclut les lettres de l'alphabet, les chiffres, les caractères spéciaux, etc.  Mais cela dépend des données du problème. Cet encodage sur un octet est simplement une convention qui permet d'associer à chaque caractère un code unique et d'uniformiser la manière dont les caractères sont représentés (chaque caractère est représenté par un octet). C'est bien pratique et flexible pour communiquer des fichiers texte entre ordinateurs.  ","version":"Next","tagName":"h2"},{"title":"Compression​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#compression","content":" Mais généralement lorsqu'il s'agit de compresser des données, les données du problème sont plus simples. Par exemple on pourrait se limiter aux lettres de l'alphabet. Dans ce cas, avoir un octet pour représenter chaque lettre est une perte d'espace. En effet, on pourrait se contenter de 5 bits pour représenter les 26 lettres de l'alphabet. Cela permettrait de réduire la taille du texte de 37.5% !  info Plus généralement, si on se limite à n possibilités de données et que l'on souhaite utiliser un encodage avec le même nombre de bits pour chaque donnée, il faut ⌈log⁡2(n)⌉\\lceil \\log_2(n) \\rceil⌈log2​(n)⌉ bits pour représenter chaque donnée. Par exemple, si on se limite aux 26 lettres de l'alphabet, il faut ⌈log⁡2(26)⌉=⌈4.7⌉=5\\lceil \\log_2(26) \\rceil = \\lceil 4.7 \\rceil = 5⌈log2​(26)⌉=⌈4.7⌉=5 bits pour représenter chaque lettre.  De plus pour n'importe quelle façon d'encoder les données, il faut respecter deux règles pour que l'encodage puisse être décodé :  Chaque donnée doit être associée à un code uniqueIl ne doit pas y avoir d'ambiguïté lors du décodage des données. Cela signifie qu'il ne faut pas associer à une donnée le code 01 et à une autre donnée le code 011 sinon impossible de savoir si l'on doit décoder les deux premiers bits 01 ou si cela faisait en fait partie du code 011. Un tel codage sans ambiguïté est appelé préfixe, nous y reviendrons plus tard.  ","version":"Next","tagName":"h3"},{"title":"Codage par plages (Run-Length Encoding)​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-par-plages-run-length-encoding","content":" Le codage par plages est une technique de compression sans perte. Cela signifie que l'on peut retrouver les données d'origine après les avoir décompressées. Elle est très utilisée pour compresser des images, comme par exemple les images au format BMP ou JPEG.  Le principe du codage par plages est de tenir compte de la répétition des données. Admettons que l'on ait un texte de 8 caractères, composé uniquement de la lettre a : aaaaaaaa. Si l'on veut stocker ce texte sur un support de stockage, il faudra donc 8 octets pour le stocker (1 octet par caractère).  Mais si l'on tient compte du fait que le texte est composé uniquement de la lettre a, on peut le représenter de la manière suivante : 8a.  On peut donc stocker ce texte sur un support de stockage en utilisant seulement 2 octets. Cela permet de réduire la taille du texte de 75% !  C'est le principe du codage par plages : on remplace une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère. Par exemple, le texte suivant aaaabbbcddddd peut être représenté par 4a3b1c5d. Pour un gain de 13-8=5 octets, soit 38% de gain.  ⚠️ Quand il y a peu de répétitions cependant le codage par plages peut augmenter la taille des données. Par exemple, si on applique le codage par plage sur le texte suivant abcdefgh on obtient 1a1b1c1d1e1f1g1h. Cela prend plus de place que la chaîne d'origine ! Dans ce cas de figure, pour minimiser cet effet, on choisit plutôt d'ajouter un caractère de contrôle et un nombre n pour indiquer que les n prochains caractères ne sont pas compressés. Par exemple, on pourrait utiliser le caractère * comme caractère de contrôle et la chaîne abcdefgh serait compressée en *8abcdefgh.  ","version":"Next","tagName":"h2"},{"title":"En pratique​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#en-pratique","content":" L'encodage RLE peut être exprimé de multiples façons en pratique pour tenir compte des propriétés des données ainsi que d'algorithmes de compression supplémentaires. Cela permet de compresser les données seulement lorsque cela est nécessaire et de laisser la chaîne telle quelle lorsque la compression induit un gaspillage.  Par exemple on pourrait se donner les règles suivantes :  Lorsque trois éléments ou plus se répètent consécutivement alors la méthode de compression RLE est utilisée. On insère alors le nombre d'éléments répétés, suivi du caractère répété.Sinon un caractère de contrôle (*) est inséré, suivi du nombre d'éléments de la chaîne non compressée puis de cette dernière.  Ainsi la chaîne aaaabccdeeeeefgh serait compressée en 4a*4bccd5e*3fgh et la chaîne abcdefgh serait compressée en *8abcdefgh.  On pourrait aussi plutôt se dire que l'on utilise le caractère de contrôle pour indiquer que la chaîne est compressée. Dans ce cas, la chaîne aaaabccdeeeeefgh serait compressée en *4abccd*5efgh.  Enfin on pourrait aussi se dire que l'on utilise le caractère lui même comme caractère de contrôle. de sorte que chaque fois qu'un caractère apparaît deux fois, il indique une longueur d'exécution. Dans l'exemple précédent, cela donnerait pour la chaîne aaaabccdeeeeefgh l'encodage aa4bcc1dee5fgh.  ","version":"Next","tagName":"h3"},{"title":"Dans les images​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#dans-les-images","content":" Dans les images il est courant de trouver des zones de couleurs uniformes. Par exemple, une image de ciel bleu peut être représentée par une suite de pixels bleus. Dans ce cas, le codage par plages permet de réduire considérablement la taille de l'image.  Il existe donc des variantes pour parcourir les pixels d'une image dans un certain sens pour maximiser les zones de couleurs uniformes (ou de valeurs identiques). Par exemple, on peut parcourir les pixels de gauche à droite, de haut en bas ou même encore en zigzag.  ","version":"Next","tagName":"h3"},{"title":"Codage de Huffman​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#codage-de-huffman","content":" Le codage de Huffman est aussi une technique de compression sans perte. C'est une technique très utilisée pour compresser des fichiers, comme par exemple des fichiers texte. Cette technique est utilisée par de nombreux formats de fichiers, comme par exemple le format JPEG pour les images.  Par exemple, si on se limite aux quatre lettres a, b, c et d (on a donc besoin seulement de 2 bits pour coder chaque lettre ). Voilà un encodage possible :  a est codé sur 00b est codé sur 01c est codé sur 10d est codé sur 11  Le texte abbacada peut donc être représenté par 0001010010001100. C'est déjà mieux que l'encodage ASCII, qui utilise 8 bits pour coder chaque lettre. On se limite à des données particulières, et on utilise un encodage plus compact.  Mais on peut faire mieux !  ","version":"Next","tagName":"h2"},{"title":"Fréquence d'apparition des données​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#fréquence-dapparition-des-données","content":" Le principe du codage de Huffman est de tenir compte de la fréquence d'apparition des données.  Pour un texte composé de 100 caractères (toujours avec notre alphabet de 4 lettres) il faudra donc 200 bits pour le représenter.  Dans le cas de notre exemple précédent abbacada, on peut remarquer que la lettre a apparaît 4 fois, la lettre b apparaît 2 fois et les lettres c et d apparaissent 1 fois. On peut donc se demander si l'on ne pourrait pas utiliser un encodage différent pour chaque lettre, en tenant compte de la fréquence d'apparition de chaque lettre. Cela permettrait de réduire la taille du texte.  On pourrait donc utiliser moins d'un octet pour coder les lettres les plus utilisées, et plus d'un octet pour coder les lettres les moins utilisées. Cela permettrait de réduire la taille du texte.  Admettons que l'on code les lettres de la manière suivante :  a est codé sur 0b est codé sur 10c est codé sur 110d est codé sur 111  remarque J'ai fait attention à ce que chaque code soit préfixe. Cela signifie qu'il n'y a pas de code qui est préfixe d'un autre code. Cela permet de décoder les données sans ambiguïté.  Le texte abbacada peut donc être représenté par 01010011001110 (soit 14 bits). C'est mieux que l'encodage précédent, qui utilisait 16 bits.  Mais comment faire pour trouver le meilleur encodage possible ?  ","version":"Next","tagName":"h3"},{"title":"Arbre binaire​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#arbre-binaire","content":" Dans la suite de ce cours, nous allons utiliser un arbre binaire (strict) pour trouver l'encodage de Huffman (en fonction de la fréquence d'apparition des données). Mais j'aimerais d'abord vous expliquer pourquoi on utilise un arbre binaire.  remarque Dans un arbre binaire strict (ou localement complet), chaque nœud a soit 0, soit 2 fils. C'est donc soit un nœud interne (qui a deux fils), soit une feuille (qui n'a pas de fils).  Une propriété intéressante des arbres binaires est que pour chaque feuille il existe un chemin unique de la racine à la feuille. Ce chemin va permettre d'associer un code à chaque donnée. En plus d'être unique, ce chemin est aussi préfixe. Cela signifie que l'on ne peut pas avoir un chemin qui est préfixe d'un autre chemin.  Reprenons notre exemple précédent avec les lettres a, b, c et d. Admettons que les quatre lettres apparaissent avec la même fréquence.    Chaque feuille de l'arbre va permettre de représenter une donnée, ici une lettre.  Dans cet arbre, si l'on parcourt le chemin 0-0 (successivement le fils gauche puis le fils gauche), on arrive à la lettre a. De même pour les autres feuillets. On peut donc associer à chaque lettre un code unique :  a est codé sur 00b est codé sur 01c est codé sur 10d est codé sur 11  On retrouve bien l'encodage que l'on avait utilisé précédemment dans le cas de données équiprobables.  ","version":"Next","tagName":"h3"},{"title":"Algorithme​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#algorithme","content":" Revenons maintenant à notre cas avec des données non équiprobables. Admettons que l'on ait le texte suivant : abbacada. On peut calculer la fréquence d'apparition de chaque lettre :  Lettre\tFréquencea\t4/8=0.54/8 = 0.54/8=0.5 b\t2/8=0.252/8 = 0.252/8=0.25 c\t1/8=0.1251/8 = 0.1251/8=0.125 d\t1/8=0.1251/8 = 0.1251/8=0.125  On peut remarquer qu'en utilisant une représentation en arbre binaire complet, les lettres les moins fréquentes seront codées sur des codes plus gros (chemins les plus longs dans l'arbre) et donc sur les feuilles les plus basses de l'arbre. Les lettres les plus fréquentes seront codées sur des codes plus petits (chemins les plus courts dans l'arbre) et donc sur les feuilles les plus hautes de l'arbre.    C'est donc en suivant cette logique que l'on va construire l'arbre binaire. On va commencer par construire un arbre binaire avec les lettres les moins fréquentes.  On va donc commencer par construire un arbre binaire avec les lettres c et d. On va donc créer un nœud cd qui va avoir deux fils c et d. On va associer à chaque nœud la somme des fréquences de ses fils. On va donc associer à cd la fréquence 0.125 + 0.125 = 0.25.  On va considérer maintenant que cd est un substitut aux lettres c et d et représente donc une seule donnée avec un fréquence de 0.25.  Je vais appeler ce regroupement de données un symbole. Un symbole est donc une donnée qui peut être composée de plusieurs données. Par exemple, le symbole cd est composé des données c et d.  On va donc construire un arbre binaire avec les lettres b et cd (qui sont les deux symboles les moins fréquents parmi a, b et cd). On va donc créer un nœud bcd qui va avoir deux fils b et cd.  En répétant cette opération, on va finir par n'avoir plus que deux symboles : a et bcd. Cela va conduire à créer l'arbre final qui contient tous les lettres initiales.  Cela nous donne finalement l'arbre suivant:    Ce qui peut se traduire par l'encodage suivant :  a: 0b: 10c: 110d: 111  On retrouve bien l'encodage que j'avais proposé précédemment.  Mathématiquement, on peut démontrer que l'encodage de Huffman est optimal. Cela signifie que l'encodage de Huffman permet de compresser les données de manière optimale.  remarque En pratique, pour pouvoir décoder les données, il faut stocker l'arbre binaire quelque part. Cela peut être fait de différentes manières. Par exemple, on peut stocker l'arbre binaire dans le fichier compressé. Cela ajoute un peu de poids au fichier compressé, mais cela permet de décoder les données ce qui est tout de même pratique 😃.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#résumé","content":" La compression de données permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.Il existe deux types de compression de données : la compression avec perte et la compression sans perte.L'encodage est le fait d'associer à chaque donnée un code.Le codage par plages (RLE) est une technique de compression sans perte et consiste à remplacer une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère.Le codage de Huffman est une technique de compression sans perte et consiste à tenir compte de la fréquence d'apparition des données. Chaque donnée est associée à un code unique et préfixe. L'encodage de Huffman est optimal. On peut construire l'encodage de Huffman en utilisant un arbre binaire complet.Un code préfixe est un code dans lequel aucun code n'est préfixe d'un autre code. Cela permet de décoder les données sans ambiguïté.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Compression et encodage de données","url":"/Learn--cpp_programming/Lessons/S2/EncodingAndCompression#sources","content":" Super vidéo sur la théorie de l'information et l'encodage de Huffman : https://www.youtube.com/watch?v=B3y0RsVCyrw ","version":"Next","tagName":"h2"},{"title":"Un monde de variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Les littéraux​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-littéraux","content":" Un littéral est une valeur donnée explicitement dans le code. Il y a plusieurs types de littéraux en C++.  ","version":"Next","tagName":"h2"},{"title":"Les caractères​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-caractères","content":" En effet, la phrase &quot;Hello and welcome to IMAC !&quot; précédemment rencontrée représente simplement du texte. C'est ce qu'on appelle une chaîne de caractères.  Qui dit chaîne de caractères dit caractères et il est également possible de représenter un unique caractère avec des guillemets simples '.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'a' &lt;&lt; std::endl; std::cout &lt;&lt; '7' &lt;&lt; std::endl; std::cout &lt;&lt; '?' &lt;&lt; std::endl; return 0; }   #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'H' &lt;&lt; 'e' &lt;&lt; 'l' &lt;&lt; 'l' &lt;&lt; 'o' &lt;&lt; ' ' &lt;&lt; 'I' &lt;&lt; 'M' &lt;&lt; 'A' &lt;&lt; 'C' &lt;&lt; '!' &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Les chaînes de caractères​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-chaînes-de-caractères","content":" On pourrait simplement se contenter de caractères me direz vous mais c'est un peu fastidieux et les chaînes de caractères sont donc là pour nous simplifier la vie.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello IMAC!&quot; &lt;&lt; std::endl; return 0; }   remarque On différencie les caractères simples (utilisant des ') des chaines de caractères par les guillemets &quot;.  Les caractères spéciaux​  Avez vous une idée de comment afficher des guillemets ?  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello &quot;IMAC&quot;!&quot; &lt;&lt; std::endl; return 0; }   Si j'essaie d'utiliser des guillemets cela ne compile pas comme dans l'exemple ci-dessus.  En effet, les guillemets permettent déjà de signaler le début et la fin d'une chaîne de caractères.  C'est également le cas quand on essaye de représenter un chemin de dossier au format Windows, par exemple, avec le chemin de fichier &quot;C:\\Program Files&quot; et on obtient une erreur du type warning: unknown escape sequence: '\\P'.  Il existe en C++ des caractères dits spéciaux, appelés séquences d’échappement. Le symbole \\ permet d'indiquer au compilateur d’afficher et non interpréter ces caractères.  Il faut donc préfixer les guillemets du caractère \\ pour pouvoir les afficher:  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello \\&quot;IMAC\\&quot;!&quot; &lt;&lt; std::endl; return 0; }   Vous pouvez trouver tous les caractères d'échappement ici.  Voilà les plus utiles en pratique:  \\' qui permet d’afficher un guillemet simple '\\&quot; qui permet d’afficher un guillemet double &quot;\\n qui permet d’aller à la ligne, comme std::endl\\t qui permet de faire une tabulation horizontale\\\\ qui permet d’afficher un antislash \\  ","version":"Next","tagName":"h3"},{"title":"Les nombres​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-nombres","content":" On peut également manipuler des nombres.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; -1 &lt;&lt; std::endl; std::cout &lt;&lt; 0 &lt;&lt; std::endl; std::cout &lt;&lt; 42 &lt;&lt; std::endl; return 0; }   On les appelle nombres entiers mais il est aussi possible d'utiliser des nombres à virgule, appelés flottants.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 3.141593 &lt;&lt; std::endl; std::cout &lt;&lt; -1.5 &lt;&lt; std::endl; return 0; }   info On remarque que l'on peut utiliser des nombres négatifs sans aucun problème. On y reviendra un peu plus tard.  Concernant les nombres (entiers ou flottants) les opérateurs arithmétiques usuels sont utilisables:  Opérateur\tDescription+\tAddition -\tSoustraction *\tMultiplication /\tDivision %\tModulo (reste de la division)  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Opérateurs arithmétiques :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Addition: 1 + 2 = &quot; &lt;&lt; 1 + 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Soustraction: 6 - 2 = &quot; &lt;&lt; 6 - 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Multiplication: 3.14 * 2 = &quot; &lt;&lt; 3.14 * 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Division: 42.5 / 3.2 = &quot; &lt;&lt; 42.5 / 3.2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Modulo: 7 % 3 = &quot; &lt;&lt; 7 % 3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; 5 / 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5. / 2 = &quot; &lt;&lt; 5. / 2 &lt;&lt; std::endl; return 0; }   C'est aussi vrai pour les règles de distributivité, associativité, commutativité ou priorité des opérateurs, rien de bien étonnant me direz vous.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Associativité :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 + (3 + 6) = &quot; &lt;&lt; 2 + (3 + 6) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(2 + 3) + 6 = &quot; &lt;&lt; (2 + 3) + 6 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distributivité :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 * (4 + 3) = &quot; &lt;&lt; 2 * (4 + 3) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Priorité des opérateurs :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;42 * 3 + (2 + 8 / 4) = &quot; &lt;&lt; 42 * 3 + (2 + 8 / 4) &lt;&lt; std::endl; return 0; }   attention Ne remarquez vous pas quelque chose d'étonnant ? 5 / 2 et 5. / 2 ne donne pas la même chose ? La raison est que pour le C++, si on fait une opération sur deux nombres entiers, le résultat doit rester un nombre entier. Si l’on veut que le résultat soit un flottant, il faut qu’au moins un des deux nombres soit un flottant. C'est pour cela d'ailleurs que mon exemple 3.14 * 2 fonctionne bien car au moins un des deux nombres est un flottant et le résultat est donc un flottant également.  Pour résumer, toutes ces valeurs écrites dans notre code s'appellent des littéraux.  Les variables  Les littéraux c'est sympa mais comment faire si l'on veut se resservir d'un résultat précédemment calculé ? C'est avec les variables que l'on va pouvoir faire ça !  C’est un concept commun à beaucoup de langages de programmation qui permet de stocker une valeur et de lui associer un nom, afin de pouvoir l'identifier et la manipuler facilement.  Nous ne rentrons pas dans le détail de comment sont stockées ces valeurs dans la mémoire de l'ordinateur car ce n'est pas le propos ici.  ","version":"Next","tagName":"h3"},{"title":"Créer une variable​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#créer-une-variable","content":" Pour déclarer une variable en C++, il faut trois choses:  Préciser d'abord son type, qui indique ce que la variable va stocker (un entier, un flottant, une chaîne de caractères, etc)Un nom qui permet d'identifier la variableEnfin, la valeur à stocker dans notre variable. Ceci se fait en mettant la valeur entre accolades   #include &lt;iostream&gt; #include &lt;string&gt; int main() { int number { 42 }; char letter { 'A' }; float pi { 3.1415927f }; double pi_double { 1415926535897931 }; std::string text { &quot;Hello IMAC!&quot; }; return 0; }   Syntaxe héritée Il existe également une syntaxe alternative, de la forme type nom = valeur;. Essayez, vous verrez que ça marche. #include &lt;iostream&gt; int main() { int number { 42 }; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0; } Cette syntaxe est héritée du C et est toujours valable en C++. Dans ce cours je vous conseille fortement d'utiliser la syntaxe dite moderne utilisant les accolades . De plus la syntaxe avec le symbole = a d'autres subtilités et peut parfois induire en erreur (des conversions implicites non desirées par exemple), c'est pourquoi nous ne l'utiliserons pas dans la majorité des cas. Ne soyez pas surpris si vous rencontrez cette syntaxe, elle est encore très utilisée et je l'ai moi même utilisé pendant très longtemps.  ","version":"Next","tagName":"h2"},{"title":"Les types​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-types","content":" Dans l'exemple précédent j'ai utilisé divers mots-clés qui font chacun référence à un type de variable spécifique:  Pour les nombres entiers c'est le mot-clé int, (abréviation de l’anglais integer signifiant nombre entier). Grâce à ce type, on peut stocker des entiers négatifs ou positifs.Pour les flottants(les nombres à virgule), nous avons le mot-clé &quot;float&quot;, (abréviation de floating point numbers en anglais). Il existe aussi le mot clé &quot;double&quot; pour stocker des nombres à virgule plus précis quand c'est nécessaire.  remarque Il est recommandé de faire la distinction entre float et double en ajoutant le suffixe f à la fin du nombre: #include &lt;iostream&gt; int main() { float pi { 3.141592f }; double price { 4.14 }; return 0; } Pour l'instant ça n'a pas beaucoup d'importance mais essayez de le mettre car c'est une bonne pratique et a son importance avec des concepts plus avancés en C++.  Pour les caractères, nous avons char.Pour les chaînes de caractères nous avons std::string.  Chaîne de caractères Pour les chaînes de caractères c'est légèrement différent, nous avons le type std::string. Ce type est particulier car il n’existe pas nativement en C++. Pour ceux qui sont attentifs à std:: c'est un type issu de la bibliothèque standard dont j'ai déjà parlé. Ce sont des programmeurs experts qui ont codé ce type afin de manipuler aisément des chaînes de caractères. Afin de pouvoir manipuler des std::string, il faut donc inclure le bon fichier, ce que l’on fait grâce à la ligne #include &lt;string&gt;. #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string hello { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; hello &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h2"},{"title":"Des préfixes modificateurs​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-préfixes-modificateurs","content":" Il est possible d'utiliser des mot-clés modificateurs sur les entiers (type int) devant le type de la variable pour altérer son fonctionnement (et implicitement la façon dont ils sont stockés en mémoire).  signed: permet d'indiquer que le nombre est signé (+ ou -) unsigned: permet d'indiquer que le nombre n'a pas de signe (une valeur absolue ou une taille) short: le nombre sera stocké sur 16 bits minimum (dans le cas des petits nombres) long: le nombre sera stocké sur 32 bits minimum (dans le cas de plus grands nombres) long long: le nombre sera stocké sur 64 bits minimum  remarque Ces préfixes sont une indication pour le compilateur. Cela donne donc un minimum mais le compilateur est libre de choisir une représentation mémoire s'il estime que c'est mieux ou plus adapté à un ordinateur spécifique. Pour garantir une taille très précise en mémoire il existe depuis le C++11 des entiers de taille fixée (Fixed width integer types en anglais) disponible dans le fichier à inclure &lt; cstdint &gt;. On retrouve donc par exemple int16_t pour un entier sur 16 bits ou uint32_t pour représenter un entier non signé de 32 bits. Une liste exhaustive est disponible ici. C'est vraiment un usage très spécifique et nous allons pas du tout nous en servir.  ","version":"Next","tagName":"h2"},{"title":"Comportement indéterminé​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#comportement-indéterminé","content":" Mais qu'est ce qui se passe si je ne précise rien comme valeur pour ma variable (sans les accolades ) ?  int my_varaible;   C'est ce qu'on appelle un comportement indéterminé, en anglais &quot;undefined behaviour&quot;. La variable se voit attribuée une valeur indéterminée. Cela peut être 0 comme 142857, on ne peut pas le prévoir.  C'est donc quelque chose qu'il faut absolument éviter !  remarque Le compilateur l'autorise pour des questions d'optimisation et d'héritage avec le C. Certains warnings de compilation indique ces erreurs.  Il faut toujours initialiser ses variables.  Valeur par défaut Si on ajoute les accolades mais sans préciser de valeur, notre variable va contenir une valeur par défaut. Ce sera par exemple une chaîne de caractères vide (&quot;&quot;) pour les std::string ou un 0 dans le cas d'un entier. Je vous laisse essayer: #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string default_string { }; std::cout &lt;&lt; default_string &lt;&lt; std::endl; // &quot;&quot; int default_int { }; std::cout &lt;&lt; default_int &lt;&lt; std::endl; // 0 float default_float { }; std::cout &lt;&lt; default_float &lt;&lt; std::endl; // 0.0f return 0; } Pour commencer, nous écrirons toujours les valeurs explicitement pour éviter de mauvaise surprise... Plus tard, avec un peu plus de pratique, vous aurez la liberté d'utiliser l’initialisation par défaut, en connaissance de cause.  ","version":"Next","tagName":"h2"},{"title":"Quelques règles de nommage​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-règles-de-nommage","content":" Les noms des variables sont tout de même soumis à quelques règles de nommage.  Premièrement, de son origine américaine, le C++ n’autorise que les 26 lettres de l’alphabet anglais (plus les chiffres et l’underscore _), on peut donc malheureusement dire adieu à nos jolis accents français. Les espaces et les signes de ponctuation sont aussi interdits (', ?, etc). Il ne peut pas commencer par un chiffre, c’est interdit. L'usage de l'underscore _ au début, bien que possible, est conventionnellement utilisé dans un cadre spécifique et je vous déconseille donc de l'utiliser pour commencer. Enfin, il n'est pas possible d'utiliser un mot-clé du C++ comme nom de variable. Par exemple, il est interdit de déclarer une variable s’appelant int.  Quelques exemples int main() { int variable42 { 42 }; int 42variable { 42 }; // Erreur : ne peut pas commencer par un chiffre. int my_variable { 0 }; int my variable { 0 }; // Erreur : espace interdit. float result { 2.71f }; float return { 2.71f }; // Erreur : mot-clé réservé par le C++ return 0; }   ","version":"Next","tagName":"h2"},{"title":"Un joli petit nom​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#un-joli-petit-nom","content":" Au-delà des règles de nommage, trouver un nom adapté à une variable est un casse tête que même les programmeurs expérimentés rencontrent.  En effet, respecter les règles ne suffit pas à bien nommer une variable. Le nom d'une variable permet de l'identifier, de comprendre ce qu'elle stocke et comment on la manipule.  remarque Le nom d'une variable est destiné à un lecteur humain. On choisit un nom de variable pour qu'il soit compréhensible pour nous et nos futurs lecteurs, amis, collègues, etc Une fois le code compilé, l'ordinateur ne fait aucune différence entre un nom ou un autre.  ","version":"Next","tagName":"h3"},{"title":"Quelques mauvais exemples​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-mauvais-exemples","content":" lpi: Un acronyme ? Que signifie t'il ?value: Que stocke-t-elle ? Dans quel contexte ? Pourquoi existe-t-elle ?multiplication_of_two_by_sqrt_of_pi: Clair mais un peu trop long.dIsTanCe: Court et compréhensible mais les majuscules / minuscules peuvent rendre la lecture moins facile.qsqffqedfqzdjzqoid: Sûrement un chat qui est passé sur mon clavier.  Avec l'expérience et le temps vous arriverez à trouver plus facilement des noms clairs et simples.  Je vous demande dès maintenant de faire quelques efforts pour réfléchir aux noms des variables. Cela peut vous sembler peu important, jusqu'au jour où vous perdrez une semaine de travail à comprendre ce que votre programme ou variable est supposée faire.  ","version":"Next","tagName":"h3"},{"title":"Enum: Un type supplémentaire​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#enum-un-type-supplémentaire","content":" Vous allez sûrement le découvrir en pratiquant mais parfois on souhaite stocker un nombre limité de possibilités.  Par exemple les points cardinaux (Nord, Sud, Est, Ouest), les saisons (été, printemps, automne, hiver), les jours de la semaine, etc  On pourrait bien associer un entier à chaque possibilité (c'est une pratique très répandue en C) mais ce n'est pas la meilleure façon de faire. Un entier peut stocker des valeurs négatives ou alors être supérieur au nombre de possibilités voulues ce qui n'a pas vraiment de sens.  C'est là qu'entre en jeu les enum (de l'anglais Enumeration).  On le déclare en utilisant le préfixe enum class puis le nom de notre énumération suivis des valeurs possibles entre accolades.  Un exemple enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; return 0; }   remarque On utilise ici aussi la syntaxe avec :: pour signifier l'appartenance de la valeur à l'enum (de la même façon qu'avec la bibliothèque standard comme avec std::string).  attention Mais pourquoi le mot clé class ici ? Il est également possible de l'omettre mais cette syntaxe est un autre &quot;type&quot; d'enum hérité du C qui a de nombreux inconvénients: Il n'est pas possible de déclarer deux enums utilisant la même valeur (mais dans un contexte différent).Déclarer une variable ayant le même nom qu'une valeur d'un enum peut avoir des comportements imprévus. #include &lt;iostream&gt; enum PrimaryColor { Red, Yellow, Blue }; enum EyesColor { Brown, Hazel, Blue, // Erreur de compilation ici car la valeur Blue est aussi utilisée dans l'enum PrimaryColor Green, Grey, Amber }; int main() { // Ici Red fait référence à la valeur dans l'enum PrimaryColor std::cout &lt;&lt; Red &lt;&lt; std::endl; int Red { 35 }; // Maintenant, bien que la ligne soit identique, Red fait référence à la variable créée ci-dessus std::cout &lt;&lt; Red &lt;&lt; std::endl; return 0; } On parle de &quot;Scoped enumerations&quot; avec enum class (autrement dit ayant une portée limitée pour éviter les collisions de valeurs). Pour faire simple on écrira systématiquement enum class en C++ moderne pour s'éviter des problèmes.  ","version":"Next","tagName":"h2"},{"title":"Des opérateurs pour manipuler nos variables​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-opérateurs-pour-manipuler-nos-variables","content":" Il n'est pas seulement possible d'afficher nos variables (via std::cout), il est aussi possible de faire des opérations dessus.  Pour cela nous allons utiliser des opérateurs.  Les opérateurs sont des symboles qui permettent de manipuler des variables, c'est-à-dire effectuer des opérations, les évaluer, etc.  Il y a principalement deux catégories d'opérateurs:  Les opérateurs binaires qui utilisent deux valeurs pour en produire une nouvelle (comme a + b par exemple)Les opérateurs unaires qui s'appliquent sur une valeur pour en produire une nouvelle.  Nous avons par exemple vu précédemment les opérateurs arithmétiques (+, -, *, / et %) sur les nombres. Ces opérateurs sont binaires.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'affectation​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#opérateurs-daffectation","content":" Pour attribuer une nouvelle valeur à une variable, on utilise l’opérateur d’affectation =, précédé du nom de la variable et suivi de la valeur à affecter : nom = valeur;.  #include &lt;iostream&gt; int main() { int x { 0 }; std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3; std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }   C++ s'occupe en premier lieu de tout ce qui se trouve à droite du signe =. On peut donc utiliser la valeur d'une variable pour faire un calcul avant de l'assigner à cette même variable.    Dans le cas où l'on veut effectuer une opération sur une variable et assigner le résultat à cette même variable il existe des opérateurs binaires nommés opérateurs d'assignation composés.  On retrouve principalement ces opérateurs composées avec les opérateurs arithmétiques:+=, -=, *=, /= et %=  int integer { 42 }; // équivalent à écrire &quot;integer = integer + 3&quot; integer += 3; integer -= 1; integer *= 4; integer /= 2; integer %= 2;   Il existe d'autres opérateurs d'affectation composés mais nous les découvrirons le moment venu.  ","version":"Next","tagName":"h3"},{"title":"Opérateurs d'incrémentation​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#opérateurs-dincrémentation","content":" Cela va même plus loin, il existe un raccourci supplémentaire lorsque l'on souhaite ajouter ou soustraire 1 à un nombre. On parle d'incrémentation et de décrémentation.  a++ ou ++a pour incrémenter de 1 la valeur de la variable a.a-- ou --a pour décrémenter de 1 la valeur de la variable a.  info Les deux syntaxes sont quasiment équivalentes, il y a une petite différence lorsque l'on souhaite utiliser le résultat de l'incrémentation: On parle de Post-incrémentation avec a++: Cette forme signifie que la variable a est d'abord utilisée, puis elle est incrémentée de 1. Cela signifie que l'effet de l'incrémentation ne sera visible qu'après l'évaluation de l'expression qui contient a++. int a { 5 }; int result { a++ }; // result prend la valeur de a (5) puis a est incrémenté à 6. // Maintenant, a vaut 6 et result vaut 5. On parle de Pré-incrémentation avec ++a: Cette forme signifie que la variable a est d'abord incrémentée, puis cette nouvelle valeur est utilisée. Cela signifie que l'effet de l'incrémentation sera visible immédiatement dans l'expression qui contient ++a. int a { 5 }; int result { ++a }; // a est incrémenté à 6, puis result prend la nouvelle valeur de a (6). // Maintenant, a et result valent tous les deux 6. En résumé, la seule différence entre les deux formes réside dans le moment où l'incrémentation est réalisée (avant ou après l'utilisation de sa valeur actuelle). Lorsque vous voulez récupérer le résultat de l'incrémentation, assurez-vous de choisir celle qui convient le mieux à votre situation pour obtenir le comportement souhaité dans votre programme. Dans la plupart des cas, je vous recommande tout simplement de ne pas l'utiliser! C'est une grosse source d’erreurs. Faites plutôt: int a { 5 }; a++; int result { a }; ou int a { 5 }; int result { a }; a++; Aussi, je recommandes même d’utiliser a += 1 à la place. Comme ça pas de surprise on est certain de ce qu’on fait. int a { 5 }; a += 1; int result { a };   ","version":"Next","tagName":"h3"},{"title":"Quelques exemples​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-exemples","content":" #include &lt;iostream&gt; int main() { int variable { 42 }; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je donne une nouvelle valeur à ma variable variable = 2 + (3 * 9); std::cout &lt;&lt; variable &lt;&lt; std::endl; // J'utilise la valeur de ma variable pour un calcul et réaffecte le résultat à la même variable variable = variable + 7; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je me sers de ma variable pour en créer une nouvelle int other_value { variable * 3 }; std::cout &lt;&lt; other_value &lt;&lt; std::endl; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux utiliser d'autres variables également variable = other_value - 1; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux incrémenter ma variable de deux façons variable += 1; variable++; std::cout &lt;&lt; variable &lt;&lt; std::endl; return 0; }   ","version":"Next","tagName":"h3"},{"title":"Variables constantes​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#variables-constantes","content":" Il existe enfin un dernier mot clé important, le mot clé const. Il va permettre, comme son nom l'indique, de rendre constant une variable et ainsi empêcher toute modification de celle-ci. Si l’on essaye de modifier une constante, on obtient une erreur de compilation.  int main() { float const gravity { 9.80665f }; gravity = 9.0f; // Erreur de compilation return 0; }   Pour l'instant cela ne va pas être très utile. Mais c'est une très (très (très)) bonne pratique et permet de protéger des variables et donner des contraintes fortes à notre code. Je vais l'utiliser régulièrement dans des exemples et on découvrira ensemble plus tard où cela prendra vraiment toute son importance d'utiliser des const dès que possible.  info Vous verrez souvent des codes qui inversent l’ordre de const et écrivent const float variable ;. C'est tout à fait possible car le const respecte la règle suivante : Il s’applique à ce qui est à sa gauche, sauf s’il n’y a rien, auquel cas il s’applique à ce qu’il y a à droite. Je vais le placer à droite dans la suite de ce cours car c'est le fonctionnement voulu initialement du const. C'est une question de préférence et de lisibilité, vous êtes libre de choisir ce que vous préférez.  ","version":"Next","tagName":"h2"},{"title":"Entrée / Sortie​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#entrée--sortie","content":" Jusque là, nous avons régulièrement rencontré std::cout qui nous permet d'afficher des caractères.  Il est également possible de faire l'inverse en manipulant ce qu'on appelle une entrée.  Grâce aux variables, il est possible de demander des informations à l’utilisateur et de stocker cette information afin d'en faire quelque chose.  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Entre ton age : &quot; &lt;&lt; std::endl; int age { 0 }; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Tu as &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl; return 0; }   Ici std::cin est très similaire à std::cout et signifie &quot;character input&quot;.  Il faut le préfixer par std::, car lui aussi appartient à la bibliothèque standard. De plus, on utilise ici les chevrons &gt;&gt; dans le sens inverse pour signifier que l'on &quot;insère&quot;&quot; ce qui vient de notre entrée pour le stocker dans notre variable.  attention Dans notre cas le C++ comprend que c'est un nombre et le convertit en entier (int). Mais que se passe t'il si l'on entre des lettres ? Dans ce cas de figure la variable (age ici) n'est pas modifiée. Mais pas seulement, std::cin n'arrive pas à convertir notre entrée, il passe dans un état invalide, mémorise tous les caractères invalides et toutes les utilisations suivantes de std::cin seront érronées. Nous verrons plus tard comment gérer ce cas de figure et détecter si une erreur survient.  ","version":"Next","tagName":"h2"},{"title":"Cast​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast","content":" Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast.  Il existe plusieurs types de cast dont le plus courant est le cast statique (static_cast).  static_cast permet de convertir un type en un autre type. Par exemple, un int en float. C'est un cast sûr car il fait des vérifications. Il est à utiliser par défaut pour les conversions de type.  #include &lt;iostream&gt; int main() { int integer {42}; float floating {3.14f}; float floatingFromInteger {static_cast&lt;float&gt;(integer)}; int integerFromFloating {static_cast&lt;int&gt;(floating)}; std::cout &lt;&lt; &quot;integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // static_cast std::cout &lt;&lt; &quot;static_cast&lt;float&gt;(integer): &quot; &lt;&lt; floatingFromInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;static_cast&lt;int&gt;(floating): &quot; &lt;&lt; integerFromFloating &lt;&lt; std::endl; return 0; }   integer: 42 floating: 3.14 static_cast&lt;float&gt;(integer): 42 static_cast&lt;int&gt;(floating): 3   remarque Il existe également un cast hérité du C qui s'effectue avec des parenthèses ( ( ) ) autour du type vers lequel on veut caster devant la variable à caster. int integer {42}; float floating {3.14f}; float floatingFromInteger {(float)integer}; int integerFromFloating {(int)floating}; Il est à éviter car il est dangereux et fonctionne de différentes manières en fonction des cas sans vérifications et peut donc provoquer des erreurs ou comportements inattendus.  ","version":"Next","tagName":"h2"},{"title":"En résumé​","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#en-résumé","content":" Nous venons de découvrir les variables en C++. C'est la base de tout programme informatique, ce qui permet d'échanger et de manipuler des informations.  C++ nous permet de manipuler différents types de données: des caractères simples (char)des chaînes de caractères (via std::string)des nombres entiers (int)des nombres réels (float ou double)Des énumérations (avec enum class) Il est possible d'utiliser toutes les opérations usuelles qui existent sur les nombres. Les variables nous permettent de stocker des valeurs et d'y associer un nom (en tenant compte de certaines règles de nommage). Il est important de choisir un nom de variable qui a du sens et le plus simple possible. Il est possible de spécifier qu'une variable est non modifiable avec le mot-clé const. On utilise des opérateurs pour manipuler nos variables. Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast. Le plus courant est le cast statique (static_cast). Il fait des vérifications et est donc plus sûr. Il est à utiliser par défaut pour les conversions de type. Nous pouvons demander des informations à l’utilisateur grâce à std::cin. ","version":"Next","tagName":"h2"},{"title":"Hash et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Hachage​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#hachage","content":" En informatique, le hachage est une technique qui consiste à associer à une donnée une empreinte numérique, appelée hash qui permet d'identifier rapidement et efficacement cette donnée.  On nomme fonction de hachage une fonction qui prend en entrée une donnée et qui retourne le hash de cette donnée.  La fonction de hachage doit être déterministe, c'est-à-dire que pour une donnée donnée, elle doit toujours retourner le même hash. Idéalement, la fonction de hachage doit être aussi:  Rapide à calculerDonner des résultats différents pour des données différentes (résistance aux collisions)Donner des résultats différents pour des données similaires (résistance aux attaques par force brute)  En pratique, il est compliqué de trouver une fonction de hachage qui vérifie toutes ces propriétés. On essaye donc de trouver une fonction de hachage qui vérifie au mieux ces propriétés et notamment la résistance aux collisions. Cela permet d'éviter que deux données différentes aient le même hash.  Cela dépend aussi de l'application. Par exemple, pour une application qui stocke des mots de passe, il est important que la fonction de hachage soit résistante aux collisions et aux attaques par force brute. Cela permet d'éviter que deux mots de passe différents aient le même hash, ce qui permettrait à un attaquant de trouver un mot de passe valide sans avoir à le deviner par exemple.  Il existe de nombreux algorithmes et fonctions de hachage complexes pour des applications réelles. Vous trouverez par exemple l'algorithme MD5 (considéré comme obsolète) ou la famille de fonctions SHA-2 et notamment SHA-256 qui est réputée pour être résistante aux collisions et aux attaques par force brute et beaucoup utilisée aujourd’hui.  ","version":"Next","tagName":"h2"},{"title":"Table de hachage​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#table-de-hachage","content":" Dans notre exemple, on a associé à chaque nom de jour de la semaine un indice, une valeur numérique entière, qui permet de l'identifier (dans l'idéal de manière unique).  Ensuite on a utilisé cet indice comme indice dans un tableau pour récupérer une information associée à ce nom de jour de la semaine: le numéro de jour de la semaine.  C'est ce que l'on appelle une table de hachage.  Une table de hachage est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant un hash de la clé comme indice dans un tableau.  Une façon de gérer les collisions est d'utiliser une liste pour stocker les valeurs associées aux clés qui ont le même hash. Une fois que l'on a calculé le hash de la clé, on utilise ce hash comme indice dans un tableau pour trouver la liste des valeurs associées. S'il y a plusieurs valeurs associées à la clé, on peut parcourir la liste pour trouver la valeur qui correspond à la clé en comparant les clés.    ","version":"Next","tagName":"h2"},{"title":"Tableau associatif​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#tableau-associatif","content":" La structure de données que l'on vient de décrire est ce que l'on appelle un tableau associatif.  Un tableau associatif est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant la clé.  ","version":"Next","tagName":"h2"},{"title":"std::unordered_map​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdunordered_map","content":" La bibliothèque standard de C++ fournit une implémentation de tableau associatif utilisant une table de hachage: la classe std::unordered_map( définie dans la bibliothèque &lt;unordered_map&gt;).  Implicitement, cette classe utilise la fonction de hachage std::hash pour calculer le hash des clés. Cette fonction de hachage est définie pour les types de base et les types de la bibliothèque standard (comme std::string par exemple).  Elle utilise aussi la fonction std::equal_to pour comparer les clés dans le cas des collisions. Cette fonction est aussi définie pour les types de base et les types de la bibliothèque standard.  On utilise la méthode insert pour ajouter une valeur associée à une clé et la méthode find pour retrouver la valeur associée à une clé.  #include &lt;unordered_map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::unordered_map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5}, {&quot;dimanche&quot;, 6} }; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber = days.find(dayName); if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour numéro &quot; &lt;&lt; dayNumber-&gt;second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info Il est possible de définir une fonction de hachage personnalisée pour la classe std::unordered_map afin de pouvoir utiliser des types personnalisés comme des structures ou des classes comme clés. Mais cela dépasse le cadre de ce cours. Si c'est quelque chose qui vous intéresse, n'hésitez pas à faire des recherches ou à me contacter.  ","version":"Next","tagName":"h3"},{"title":"std::map​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdmap","content":" Il existe une autre implémentation de tableau associatif dans la bibliothèque standard de C++: la classe std::map (définie dans la bibliothèque &lt;map&gt;).  Cette classe utilise un arbre binaire de recherche pour stocker les données. Cela permet de stocker les données dans un ordre défini par une relation d'ordre sur les clés.  Elle utilise une opération de comparaison pour stocker les données. Cette opération de comparaison est définie pour les types de base et les types de la bibliothèque standard (comme std::string par exemple).  Elle s'utilise de la même façon que std::unordered_map.  #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; // On peut ajouter des éléments à une std::map avec l’opérateur [] days[&quot;dimanche&quot;] = 6; std::string dayName; std::cout &lt;&lt; &quot;Entrez un nom de jour : &quot;; std::cin &gt;&gt; dayName; auto dayNumber = days.find(dayName); if (dayNumber != days.end()) { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; est le jour numéro &quot; &lt;&lt; dayNumber-&gt;second &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Le jour &quot; &lt;&lt; dayName &lt;&lt; &quot; n'existe pas&quot; &lt;&lt; std::endl; } }   info La classe std::map utilise un arbre binaire de recherche pour stocker les associations clé-valeur sous la forme de paires (std::pair). On peut donc aussi utiliser la classe std::pair pour ajouter des éléments à une std::map. #include &lt;map&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::map&lt;std::string, int&gt; days { {&quot;lundi&quot;, 0}, {&quot;mardi&quot;, 1}, {&quot;mercredi&quot;, 2}, {&quot;jeudi&quot;, 3}, {&quot;vendredi&quot;, 4}, {&quot;samedi&quot;, 5} }; days.insert(std::make_pair(&quot;dimanche&quot;, 6)); return 0; }   ","version":"Next","tagName":"h3"},{"title":"std::set — Un ensemble d'éléments uniques​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#stdset--un-ensemble-déléments-uniques","content":" Une autre structure de données fournie par la bibliothèque standard de C++ est la classe std::set (définie dans la bibliothèque &lt;set&gt;).  Elle permet de représenter un ensemble d'éléments uniques.  Cette classe est similaire à std::map mais elle ne stocke pas de valeurs associées aux clés. Elle ne stocke que les clés. Cela permet de stocker des ensembles d'éléments uniques.  Elle s'utilise de la même façon que std::map.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Hash et tableaux associatifs","url":"/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables#résumé","content":" Une fonction de hachage est une fonction qui prend en entrée une donnée et qui retourne le hash de cette donnée (un nombre entier)Une table de hachage est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant un hash de la clé comme indice dans un tableau.Une table de hachageUn tableau associatif est une structure de données qui permet d'associer à une donnée que l'on appelle clé une valeur. On peut ensuite retrouver la valeur associée à une clé en utilisant la clé.La bibliothèque standard de C++ fournit deux implémentations de tableau associatif: std::unordered_map qui utilise une table de hachagestd::map qui utilise un arbre binaire de recherche La bibliothèque standard de C++ fournit aussi une implémentation d'ensemble d'éléments uniques: std::set. ","version":"Next","tagName":"h2"},{"title":"TD5 - Tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (min & max)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-1-min--max","content":" Des nains partent en expédition dans les montagnes. Ils transportent chacun une certaine quantité de provisions (exprimée en calories).  Votre mission est de déterminer la quantité de provisions la plus grande transportée par un nain.  Je vous donne le programme suivant qui génère la liste des calories transportées par chaque nain:  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; int main() { size_t const dwarf_count { 20 }; std::vector&lt;int&gt; calories {}; // std::srand permet de fixer la &quot;seed&quot; du générateur aléatoire (pour avoir des résultats reproductibles) std::srand(42); for (int i = 0; i &lt; dwarf_count; ++i) { calories.push_back(rand() % 24000 + 100); } // affichage optionnel des calories transportées par chaque nain for (int const c : calories) { std::cout &lt;&lt; c &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // TODO: afficher la quantité de provisions la plus grande transportée par un nain return 0; }   Trouver la quantité de provisions la plus grande transportée par un nain. Trouver la quantité de provisions la plus petite transportée par un nain (arrivez vous à le faire sans utiliser de boucle supplémentaire ?). Essayez de faire fonctionner le programme avec plus de nains, par exemple 200, 2000 ou même 20000 nains. (Attention, il ne faut pas afficher les calories transportées par chaque nain dans ce cas). Si vous avez eu besoin de changer autre chose que la variable dwarf_count pour répondre à la question précédente, essayez de trouver une solution qui fonctionne avec n'importe quel nombre de nains sans avoir à modifier le code. Pour aller plus loin: Trouver les trois nains transportant le plus de provisions et afficher la somme des provisions transportées par ces trois nains.  info Exercice inspiré de de l'édition 2022 de l'advent of code: https://adventofcode.com/2022/day/1C'est un évènement annuel qui propose un problème de code par jour sous forme de calendrier de l'avent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Luhn)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-2-luhn","content":" Le numéro de carte bancaire est un nombre de 16 chiffres. Il est composé de 4 groupes de 4 chiffres séparés par un espace.  Tous les numéros de carte bancaire ne sont pas valides et il existe des algorithmes pour le vérifier. Cela permet de vérifier rapidement si un numéro de carte bancaire est valide ou non sans avoir à contacter la banque et permet de détecter rapidement certaines erreurs de saisie (comme l'inversion de deux chiffres par exemple).    L'algorithme de Luhn est l'un de ces algorithmes.  Son principe est de calculer, à partir d'un nombre (ou une suite de chiffres), une clé de contrôle (appelée checksum) qui permet de vérifier que le numéro est correct (car la clé est un nombre qui est dépendant des autres et doit respecter certaines conditions).  Dans notre cas, la clé de contrôle est calculée de la manière suivante:  On multiplie un chiffre sur deux par 2 (en commençant par le deuxième chiffre).Si le résultat de la multiplication est supérieur à 9, on additionne les chiffres du résultat (par exemple, 8 * 2 = 16, 1 + 6 = 7).On additionne tous les chiffres (y compris ceux qui n'ont pas été multipliés par 2).  Si le résultat (la clé de contrôle) est un multiple de 10, alors le numéro est valide.  Un exemple Prenons le numéro de carte bancaire suivant: 1234 5678 9002 3456. On multiplie un chiffre sur deux par 2 (en commençant par le dernier chiffre): 1 2 3 4 5 6 7 8 9 0 0 2 3 4 5 6 x2 x2 x2 x2 x2 x2 x2 x2 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 On additionne les chiffres du résultat si le résultat est supérieur à 9: 1 4 3 8 5 12 7 16 9 0 0 4 3 8 5 12 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 On additionne tous les chiffres: 1 4 3 8 5 3 7 7 9 0 0 4 3 8 5 3 1 + 4 + 3 + 8 + 5 + 3 + 7 + 7 + 9 + 0 + 0 + 4 + 3 + 8 + 5 + 3 = 70 La clé de contrôle est 70. 70 est un multiple de 10, donc le numéro de carte bancaire est valide.  Vous devez écrire un programme qui demande à l'utilisateur de saisir un numéro de carte bancaire et qui affiche si ce numéro est valide ou non.  Pour la saisie, vous êtes libre de choisir le format ou syntaxe que vous voulez (via une chaîne de caractères, avec ou sans espaces, un nombre ou une boucle sur plusieurs chiffres).  astuce Convertissez premièrement la chaîne de caractères en un tableau de chiffres.Pour convertir un caractère en un nombre, vous pouvez utiliser la fonction std::stoi (string to integer) ou la valeur ASCII du caractère. (voir l'Exercice 5 du TD2).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Points d'énergie)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-3-points-dénergie","content":" Dans un jeu vidéo de type RPG, dès que le joueur termine un niveau, il gagne des points d’énergie.  Les points d'énergie sont calculés en fonction du niveau terminé et du nombre et du niveau de difficulté des ennemis tués.  Le nombre de points d'énergie gagnés est calculé de la manière suivante:  Pour chaque ennemi tué, trouver tous les multiples de son niveau de difficulté inférieurs au niveau terminé par le joueur.Combiner tous les multiples trouvés pour chaque ennemi tué en supprimant les doublons.Additionnez tous les nombres restants pour obtenir le nombre de points d'énergie gagnés.  Voici un exemple:  Le joueur termine le niveau 20.Il tue 2 ennemis de niveau 3, 5.  Les multiples de 3 inférieurs à 20 sont: 3, 6, 9, 12, 15, 18. Les multiples de 5 inférieurs à 20 sont: 5, 10, 15.  En supprimant les doublons, nous obtenons: 3, 5, 6, 9, 10, 12, 15, 18.  En additionnant tous les nombres, nous obtenons 78 points d'énergie.  Vous devez écrire un programme qui demande à l'utilisateur de saisir le niveau terminé et le nombre et le niveau de difficulté des ennemis tués et qui affiche le nombre de points d'énergie gagnés.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Palindrome)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-4-palindrome","content":" Un palindrome est un mot qui peut être lu de la même manière de gauche à droite et de droite à gauche.  Par exemple, kayak est un palindrome.  Écrire un programme qui demande à l'utilisateur de saisir un mot et qui affiche si ce mot est un palindrome ou non.  astuce Une chaîne de caractères est un tableau de caractères.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Comptage)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-5-comptage","content":" Écrire un programme qui demande un nombre entier positif (supérieur à 1 000 000) à l'utilisateur et qui remplit un tableau avec les chiffres de ce nombre. Le programme doit ensuite compter le nombre d'occurrences de chiffre et afficher le chiffre qui apparaît le plus souvent.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Suppression et tassement)​","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-6-suppression-et-tassement","content":" Écrire un programme qui demande à l'utilisateur de saisir 10 entiers compris entre 0 et 5 et qui les stocke dans un tableau. (vous pouvez aussi demander à l'utilisateur de saisir un nombre puis le décomposer en chiffres et stocker les chiffres dans un tableau).  Vous devez ensuite supprimer toutes les valeurs valant 3 dans le tableau en décalant tous les éléments vers la gauche et en complétant le tableau avec des 0.  Tableau avant:  [1, 3, 2, 3, 3, 4, 5, 3, 0, 2]   Tableau après:  [1, 2, 4, 5, 0, 2, 0, 0, 0, 0]  ","version":"Next","tagName":"h2"},{"title":"Sémantique et opérateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Operators","content":"","keywords":"","version":"Next"},{"title":"Opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs","content":" Les opérateurs sont des symboles qui permettent de manipuler des données. Par exemple, l'opérateur + permet d'additionner deux nombres entre eux.  En C++, il est possible de définir des opérateurs pour nos structures, c'est ce que l'on appelle la surcharge d'opérateurs. Cela permet ensuite d'utiliser l'opérateur sur nos structures sans devoir passer par une méthode.  Pour définir un opérateur, on utilise le mot clé operator suivi du symbole de l'opérateur. Par exemple, pour définir l'opérateur +, on utilise operator+.  Par exemple, on peut définir un opérateur + pour notre structure Point qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet opérateur sur nos structures comme si elles étaient des nombres.  struct Point { int x; int y; }; Point operator+(Point const&amp; a, Point const&amp; b) { return {a.x + b.x, a.y + b.y}; } int main() { Point a {1, 2}; Point b {3, 4}; Point c {a + b}; // c = {4, 6} }   ","version":"Next","tagName":"h2"},{"title":"Égalité​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#égalité","content":" Ce qui fait généralement sens pour une structure, c'est de pouvoir comparer deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont égaux ou non.  Pour être en mesure de définir l’égalité, on doit respecter les conditions suivantes.  Pour n'importe quel a, a == a doit être vrai, c'est ce qu'on appelle la réflexivité.Pour n'importe quel a et b de même type, si a == b est vrai, alors b == a doit être vrai, c'est ce qu'on appelle la symétrie et la commutativité.Pour n'importe quel a, b et c de même type, si a == b et b == c sont vrais, alors a == c doit être vrai, c'est ce qu'on appelle la transitivité.  Pour définir l'opérateur d'égalité, on utilise operator==. On peut ensuite utiliser cet opérateur sur nos structures de la même façon que pour les types de base.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } int main() { Point a {1, 2}; Point b {1, 2}; if (a==b) { std::cout &lt;&lt; &quot;Les points a et b ont les mêmes coordonnées&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Les points a et b ont des coordonnées différentes&quot; &lt;&lt; std::endl; } }   ","version":"Next","tagName":"h2"},{"title":"Fonction ou méthode​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#fonction-ou-méthode","content":" On peut définir l'opérateur d'égalité comme une fonction (en dehors de la définition de la structure) ou comme une méthode (à l'intérieur de la définition de la structure).  La différence est que dans le cas d'une méthode, le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode.  struct Point { int x; int y; bool operator==(Point const&amp; b) const { return x == b.x &amp;&amp; y == b.y; } };   Cela a une influence sur la façon dont on utilise l'opérateur.  remarque Ici la méthode est définie comme const car elle ne modifie pas l'instance sur laquelle on l'appelle. Cela permet d'appeler la méthode sur une instance constante.  Par exemple si l'on souhaite multiplier un point par un nombre, on peut définir l'opérateur comme une méthode.  struct Point { int x; int y; Point operator*(int const a) const { return {x * a, y * a}; } }; int main() { Point a {1, 2}; Point b {a * 2}; // b = {2, 4} }   Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas définir l'opérateur comme une méthode car le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode.  Il faut donc définir l'opérateur comme une fonction libre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} }   Les deux syntaxes sont donc valables, mais il faut garder en tête que la syntaxe avec une méthode implique que le premier paramètre est implicite et correspond à l'instance sur laquelle on appelle la méthode. Il y a plusieurs écoles, en général on préfère la syntaxe avec une fonction libre concernant les opérateurs binaires (qui prennent deux paramètres). Cela permet par exemple, dans le cas d'opérateurs binaires commutatifs (dans lequel l'ordre des paramètres n'a pas d'importance), de définir les deux opérateurs en fonction l'un de l'autre.  struct Point { int x; int y; }; Point operator*(int const a, Point const&amp; b) { return {a * b.x, a * b.y}; } Point operator*(Point const&amp; b, int const a) { return a * b; } int main() { Point a {1, 2}; Point b {2 * a}; // b = {2, 4} Point c {a * 3}; // b = {3, 6} }   ","version":"Next","tagName":"h3"},{"title":"Réutilisation des opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#réutilisation-des-opérateurs","content":" Je vous ai déjà parlé de l’intérêt de la réutilisation avec les fonctions. C'est aussi valable pour les opérateurs.  L’habitude que beaucoup prennent est de définir les opérateurs == et &lt;, puis de définir les autres en fonction de ces deux-là.  On va donc définir l'opérateur != en fonction de ==.  struct Point { int x; int y; }; bool operator==(Point const&amp; a, Point const&amp; b) { return a.x == b.x &amp;&amp; a.y == b.y; } bool operator!=(Point const&amp; a, Point const&amp; b) { return !(a == b); }   Dans notre cas définir les opérateurs de comparaison &lt;, &lt;=, &gt;, &gt;= fait moins sens car on ne peut pas vraiment dire qu'un point est plus grand qu'un autre.   ## default et C++ 20 Il est parfois possible de définir automatiquement certains opérateurs. Dans le cas de structures simples, on peut définir automatiquement les opérateurs `==` et `!=` avec le mot clé `default`. ```cpp struct Point { int x; int y; bool operator==(Point const&amp; p) const = default; bool operator!=(Point const&amp; p) const = default; };   Cela permet de définir automatiquement les opérateurs == et != en fonction des opérateurs == et != de chaque membre de la structure.  Depuis C++20, il est même possible de définir automatiquement l'opérateur d'égalité et les opérateurs de comparaison (&lt;, &lt;=, &gt;, &gt;=) d'un coup avec l'opérateur &lt;=&gt; (appelé three-way comparison operator).  struct Point { int x; int y; auto operator&lt;=&gt;(Point const&amp; p) const = default; };   L'opérateur &lt;=&gt; est un opérateur qui permet de donner un ordre à une structure. Avec le mot clé default, on délègue la définition de l'opérateur &lt;=&gt; à chaque membre de la structure. On défini donc automatiquement l'ordre de la structure en fonction de l'ordre de chaque membre (dans notre cas, on compare d'abord x puis y).  C'est très pratique dans le cas où nos structures sont composées de types de base ou de structures qui ont déjà des opérateurs de comparaison définis.  Dans le cadre de ce cours nous allons définir les opérateurs manuellement pour bien comprendre le principe. Mais dans la pratique, il est préférable d'utiliser default ou default avec &lt;=&gt; si possible.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'assignation composés​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-dassignation-composés","content":" Les opérateurs d'assignation composés permettent de combiner une opération et une assignation. Par exemple, l'opérateur += permet d'additionner une valeur à une variable et de stocker le résultat dans la variable.  Il est aussi possible de définir des opérateurs d'assignation composés pour nos structures. Par exemple, on peut définir l'opérateur += pour notre structure Point qui permet d'additionner un point à un autre point et de stocker le résultat dans le premier point.  Cela fait sens dans ce cas de les définir comme des méthodes.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; p) { x += p.x; y += p.y; return *this; } };   astuce L'expression *this peut sembler étrange. this est un pointeur sur l'instance courante. *this est donc une référence sur l'instance courante. On retourne une référence sur l'instance courante pour pouvoir faire des opérations en chaîne. Par exemple, on peut écrire a += b += c qui est équivalent à a += (b += c). Cela nous permet d’avoir le même comportement pour notre structure que s’il s’agissait d’un type natif comme int.  ","version":"Next","tagName":"h2"},{"title":"Deux en un​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#deux-en-un","content":" Pour chaque opérateur d'assignation composé, il existe un opérateur binaire (prenant deux paramètres) correspondant. Par exemple, l'opérateur += a pour opérateur binaire correspondant +.  Dans un souci de réutilisation, on peut définir l'opérateur binaire en fonction de l'opérateur d'assignation composé.  struct Point { int x; int y; Point&amp; operator+=(Point const&amp; b) { x += b.x; y += b.y; return *this; } }; Point operator+(Point a, Point const&amp; b) { a += b; return a; }   Ici le principe de passage par copie (ou par valeur) du paramètre a est important. Puisque qu'il est copié, on peut le modifier avec l’opérateur += sans risque modifier l'instance originale. On obtient donc l'opérateur binaire + en fonction de l'opérateur d'assignation composé +=.  L'avantage est que si l'on doit modifier ou corriger le comportement de l'addition, on n'a pas besoin de modifier l'opérateur binaire + puisqu'il est défini en fonction de l'opérateur d'assignation composé +=.  ","version":"Next","tagName":"h3"},{"title":"Opérateurs de flux​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-de-flux","content":" Les opérateurs de flux permettent de définir comment afficher une structure ou la lire depuis un flux (comme std::cout ou std::cin). Par exemple, on peut définir l'opérateur &lt;&lt; pour notre structure Point qui permet d'afficher un point dans un flux.  struct Point { int x; int y; }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; ')'; }   L'opérateur &lt;&lt; prend en premier paramètre un flux de sortie (std::ostream&amp;) et en deuxième paramètre un point (Point const&amp;). Il retourne le flux de sortie pour pouvoir faire des opérations en chaîne.   Opérateur &gt;&gt; Il existe aussi l'opérateur &gt;&gt; qui permet de lire depuis un flux pour construire une structure. Il se définit ainsi: std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Point&amp; p) { // gestion de la lecture is &gt;&gt; p.x &gt;&gt; p.y; if( /* Erreur, impossible de construire notre structure */ ) { is.setstate(std::ios::failbit); } return is; } Notez que dans ce cas il faut signaler si l’entrée est invalide en mettant le flux dans un état invalide avec std::ios::failbit, ce qui permet à l’utilisateur de faire if (std::cin.fail()).  Ces opérateurs s’écrivent toujours sous la forme libre car leur premier argument est toujours un flux.  ","version":"Next","tagName":"h2"},{"title":"Opérateurs d'affectation par copie​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#opérateurs-daffectation-par-copie","content":" Parfois, on a besoin de copier une structure. Pas seulement à l'initialisation (dans ce cas là on peut utiliser la syntaxe d'initialisation {}), mais on a besoin d'affecter une nouvelle valeur à une structure déjà existante.  Point const point {3, 4}; Point copie {1, 1}; // ... copie = point;   Pour faire cela il faut définir l'opérateur d'affectation par copie =. Cet opérateur est appelé quand on affecte une valeur à une structure déjà existante.   struct Point { int x; int y; Point&amp; operator=(Point const&amp; b) { x = b.x; y = b.y; return *this; } };   C'est intéressant de le définir s'il a un comportement spécifique à notre structure. Sinon, il est préférable de ne pas le définir car il y a déjà un opérateur d'affectation par copie par défaut qui fait une copie membre à membre. Ce qui correspond souvent à ce que l'on veut (c'est le cas pour notre structure Point).  ","version":"Next","tagName":"h2"},{"title":"Quelques bonnes pratiques​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#quelques-bonnes-pratiques","content":" Il est important de garder en tête que la surcharge d'opérateurs est une facilité et non une nécessité. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Il est aussi important de respecter la sémantique des opérateurs. Par exemple, l'opérateur + doit faire une addition et non une soustraction. Si un opérateur a une sémantique déjà définie pour un domaine, tenez vous-y. Si la signification de l'opérateur n'est pas évidente et indiscutable, il faut éviter de le surcharger. Il est préférable de définir une méthode explicite dans les cas où la sémantique n'est pas évidente. Si pour une raison ou une autre, vous devez surcharger un opérateur qui n'a pas de sémantique évidente, il faut le commenter absolument. Enfin, certains opérateurs sont liés entre eux. Par exemple, si vous surchargez l'opérateur ==, il est conseillé de surcharger l'opérateur != (en fonction de == si possible). De même, si vous surchargez l'opérateur &lt;, les utilisateurs de votre structure s'attendront à ce que les opérateurs &gt;, &lt;= et &gt;= soient définis également.  ","version":"Next","tagName":"h2"},{"title":"D'autres opérateurs​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#dautres-opérateurs","content":" On peut aussi surcharger les opérateurs [] et () pour définir un accès à un élément de notre structure ou les opérateurs -- et ++ pour définir un incrément ou un décrément.  Il existe de nombreux opérateurs que l'on peut surcharger mais le principe reste le même.  ","version":"Next","tagName":"h2"},{"title":"Résumé​","type":1,"pageTitle":"Sémantique et opérateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#résumé","content":" On peut définir des opérateurs pour nos structures, c'est ce que l'on appelle la surcharge d'opérateurs.Pour définir un opérateur, on utilise le mot clé operator suivi du symbole de l'opérateur. Par exemple, pour définir l'opérateur +, on utilise operator+.Les opérateurs permettent de donner du sens à nos structures et de les manipuler comme si elles étaient des types de base. Cela donne de la sémantique à nos structures.C'est intéressant de réutiliser les opérateurs entre eux. Par exemple, on peut définir l'opérateur + en fonction de l'opérateur +=.L'expression *this permet de retourner une référence sur l'instance courante pour pouvoir faire des opérations en chaîne.Il est important de garder en tête que la surcharge d'opérateurs est une facilité et non une nécessité. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est préférable de définir une méthode avec un nom explicite.On peut surcharger les opérateurs de flux &lt;&lt; et &gt;&gt; pour définir comment afficher une structure ou la lire depuis un flux.Vous trouverez la page de documentation sur la surcharge d'opérateurs ici. ","version":"Next","tagName":"h2"},{"title":"TD6 - Fonctions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Somme)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-1-somme","content":" Écrire une fonction somme qui retourne la somme de deux entiers.  Utiliser des paramètres par copie et le prototype suivant: int somme(int a, int b); Utiliser des paramètres constants pour les arguments de la fonction. Utiliser des références pour les arguments de la fonction. Vérifier que cela fonctionne aussi bien avec des variables que des littéraux dans le cas des références.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Factorielle)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-2-factorielle","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif.Écrire une fonction récursive qui retourne la factorielle de n. info La factorielle d'un entier n est le produit des nombres entiers strictement positifs inférieurs ou égaux à n. Afficher le résultat.Gérer les cas d'erreur (nombre négatif, nombre trop grand, etc.).Utiliser une fonction itérative (non récursive).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Fibonacci)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-3-fibonacci","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif.Écrire une fonction récursive qui retourne sous la forme d'un tableau les n premiers termes de la suite de Fibonacci. info La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le précèdent. Ses premiers termes sont 0 et 1. Afficher les n premiers termes de la suite de Fibonacci à l'aide de la fonction précédente. Par exemple, si l’utilisateur saisit 7, le programme affichera 0, 1, 1, 2, 3, 5, 8.Pour aller plus loin: Essayer de trouver une solution itérative (non récursive).  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Surcharges)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-4-surcharges","content":" Écrire une fonction qui permet de calculer la moyenne d'un tableau d'entiers.Écrire une fonction surchargée portant le même nom qui permet de calculer la moyenne d'un tableau de flottants.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Suite)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-5-suite","content":" Écrire sous forme récursive les fonctions UnU_nUn​ et VnV_nVn​ conformément à la description suivante:  U0=1U_0 = 1U0​=1 et Un+1=3Un+2VnU_{n+1} = 3U_n + 2V_nUn+1​=3Un​+2Vn​V0=2V_0 = 2V0​=2 et Vn+1=2Vn+Un+1V_{n+1} = 2V_n + U_n + 1Vn+1​=2Vn​+Un​+1  Afficher les dix premiers termes de chacune des suites.  Vous devez obtenir les résultats suivants:  U0 = 1 et V0 = 2 U1 = 7 et V1 = 6 U2 = 33 et V2 = 20 U3 = 139 et V3 = 74 U4 = 565 et V4 = 288 U5 = 2271 et V5 = 1142 U6 = 9097 et V6 = 4556 U7 = 36403 et V7 = 18210 U8 = 145629 et V8 = 72824 U9 = 582535 et V9 = 291278   astuce Il est possible d'exprimer UnU_nUn​ et VnV_nVn​ en fonction de Un−1U_{n-1}Un−1​ et Vn−1V_{n-1}Vn−1​.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Pangramme)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-6-pangramme","content":" Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne true si la chaîne est un pangramme, false sinon.  Il faut faire attention à la casse (majuscules/minuscules), un même lettre majuscule et minuscule compte pour la même lettre.  info Un pangramme est une phrase contenant toutes les lettres de l'alphabet au moins une fois.  ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (String)​","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-7-string","content":" Écrire une fonction qui prend en paramètre une chaîne de caractères et qui modifie cette chaîne en remplaçant les lettres minuscules par des lettres majuscules et vice-versa. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne le nombre de voyelles de cette chaîne. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne le nombre de mots de cette chaîne. On considère que les mots sont séparés par un ou plusieurs espaces. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne la même chaîne écrite à l'envers. Écrire une fonction qui prend en paramètre une chaîne de caractères et qui retourne true si la chaîne est un nombre entier. astuce L'idée est de parcourir la chaîne de caractères et de vérifier si chaque caractère est un chiffre ou non. Pour tester si un caractère est un chiffre vous pouvez comparer la valeur ASCII du caractère avec les valeurs ASCII des chiffres (voir l'Exercice 5 du TD2). Il existe aussi la fonction std::isdigit (voir la documentation) qui permet de tester si un caractère est un chiffre ou non. ","version":"Next","tagName":"h2"},{"title":"TD3 - Conditions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Conditions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Positif ou négatif)​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-1-positif-ou-négatif","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier et aﬀiche si cet entier est positif ou négatif.  Exemples d’exécution:  Saisir un entier : 42 42 est positif   Saisir un entier : -5 -5 est négatif   ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Pair ou impair)​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-2-pair-ou-impair","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier et aﬀiche si cet entier est pair ou impair.  astuce Vous pouvez utiliser l'opérateur modulo % qui donne le reste de la division entière.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-3","content":" Écrire un programme qui demande à l’utilisateur de saisir son âge (un nombre entier) et aﬀiche s’il est majeur ou mineur.  Gérer la saisie d'un âge à stocker dans une variable.Gérer le cas où l’utilisateur saisit un âge négatif et afficher un message d’erreur dans ce cas.Gérer le cas où l’utilisateur saisit un âge avec des lettres et afficher et gérer l’erreur.  info std::cin &gt;&gt; x renvoie true si tout est correct ou false si on a rencontré une erreur lors de la saisie. Dans notre cas, si l'utilisateur saisit un âge avec des lettres, la saisie échoue et la variable âge n'est pas modifiée. Il est aussi possible de tester si la saisie précédente a échoué avec std::cin.fail() qui renvoie true si la saisie a échoué et false sinon. std::cin.fail() équivaut à !(std::cin &gt;&gt; x). Dans le cas où la saisie a échoué, il faut réinitialiser la saisie de l'utilisateur pour pouvoir saisir à nouveau un âge. std::cin.clear() restaure std::cin à un état fonctionnel, sans erreur.std::cin.ignore() permet d’ignorer un nombre défini de caractères, soit jusqu’à un nombre maximum (exemple 500), soit jusqu’à un caractère précis (exemple '\\n' ou 'a'). Dans notre cas, nous allons utiliser ceci pour réinitialiser la saisie de l'utilisateur si on a rencontré une erreur. std::cin.clear(); // On remet std::cin dans un état fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caractères mémorisés.   ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Soldes)​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-4-soldes","content":" C'est les soldes !  Créer un programme qui demande à l'utilisateur:  le type de produit (à stocker dans un enum)le prix du produit (un nombre flottant)s'il a une carte de fidélité (boolean)son age (un nombre entier)  En fonction des informations saisies, le programme affiche le prix final après réduction.  Vous disposez des informations suivantes:  Type d'article\tRéduction\tRéduction avec carte de fidélitéAlimentation\t5%\t8% Vêtements\t10%\t15% Chaussures\t12%\t18% Autre\t0%\t0%  S'il à moins de 26 ans, il a 10% de réduction supplémentaire sur tous les articles après réduction.  Je vous fourni le code suivant pour l'énumération et la gestion de la saisie de l'utilisateur:  enum class Article { Alimentation, Vetements, Chaussures, Autre }; // C'est un mécanisme avancé, vous n'avez pas besoin de comprendre comment ça marche. // On en reparlera au second semestre. // retenez juste que ça permet de convertir une entrée de l'utilisateur en Article. std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; }   Cela nous permet d'utiliser l'opérateur &gt;&gt; pour lire un enum comme on pourrait le faire avec un int ou un float. Sans cela, on aurait du utiliser une variable intermédiaire de type string ou int pour stocker la saisie de l'utilisateur et faire la conversion nous même.  Exemple de saisie d'un enum #include &lt;iostream&gt; enum class Article { Alimentation, Vetements, Chaussures, Autre }; std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } int main() { Article article; std::cin &gt;&gt; article; // On vérifie si la saisie a échoué. if (std::cin.fail()) { std::cout &lt;&lt; &quot;Erreur de saisie, il faut saisir un type d'article valide (\\&quot;Alimentation\\&quot;, \\&quot;Vetements\\&quot;, \\&quot;Chaussures\\&quot; ou \\&quot;Autre\\&quot;)&quot; &lt;&lt; std::endl; std::cin.clear(); // On remet std::cin dans un état fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caractères mémorisés. // le programme s'arrête si on a rencontré une erreur de saisie et renvoie 1 pour indiquer une erreur. return 1; } if (article == Article::Alimentation) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Alimentation&quot; &lt;&lt; std::endl; } else if (article == Article::Vetements) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Vetements&quot; &lt;&lt; std::endl; } else if (article == Article::Chaussures) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Chaussures&quot; &lt;&lt; std::endl; } else if (article == Article::Autre) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Autre&quot; &lt;&lt; std::endl; } return 0; }   Demander à l'utilisateur de saisir le type d'article, le prix, s'il a une carte de fidélité et son âge. Gérer les cas où l'utilisateur saisit des informations incorrectes (enum incorrect, prix ou âge négatif, etc.) et afficher un message d'erreur dans ce cas. Vous pouvez reprendre mon exemple de saisie d'un enum. Calculer le prix final en fonction des informations saisies et afficher le résultat. L'enseigne offre également un bon d'achat de 10% du montant total du ticket de caisse, à valoir sur un prochain achat. Le bon d'achat ne peut pas être supérieur à 30€. Calculer le montant du bon d'achat et l'afficher en fin de programme.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-5","content":" Calcul du temps d'ébullition de l'eau en fonction de l'altitude en mètres (un nombre entier), de la température ambiante (un nombre flottant) et de l'ajout ou non de sel (boolean).  Vous disposez des informations suivantes:  A 0 mètre d'altitude, l'eau bout à 100°C.Tout les 300 mètres d'altitude supplémentaires, l'eau atteint son point d'ébullition 1°C plus bas.L'action d'ajouter du sel dans l'eau fait augmenter son point d'ébullition de 1.5°C.Il faut 1 min pour que l'eau gagne 10°C de température.La température de l'eau initiale est la température ambiante.  Demander à l'utilisateur de saisir l'altitude, la température ambiante et s'il ajoute du sel.Gérer le cas où l'utilisateur saisit une altitude négative et afficher un message d'erreur.En fonction des informations saisies, afficher le temps d'ébullition de l'eau en minutes.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6​","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-6","content":" Essayer de refaire les exercices 1 et 2 en utilisant des ternaires.  remarque Un ternaire est une expression conditionnelle qui permet de faire un test comme un if/else et de retourner une valeur en fonction du résultat du test. int a {5}; int b {10}; // condition ? valeur si vrai : valeur si faux int c {(a &gt; b) ? a : b }; // c = 10 C'est réservé aux cas simples qui peuvent s'écrire sur une seule ligne. Il ne faut pas abuser des ternaires car cela peut rendre le code illisible. ","version":"Next","tagName":"h2"},{"title":"TD8 - Headers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/headers","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Fraction)​","type":1,"pageTitle":"TD8 - Headers","url":"/Learn--cpp_programming/TDs/S1/headers#exercice-1-fraction","content":" Le but de cet exercice est de créer une structure permettant de représenter une fraction. Cette structure devra contenir deux entiers positifs, un pour le numérateur et un pour le dénominateur.  On va utiliser un fichier d'en-tête pour définir la structure et les fonctions qui vont permettre de manipuler les fractions.  Créer un fichier fraction.hpp qui contiendra la définition de la structure et les prototypes des méthodes. La structure devra s'appeler Fraction et contenir deux entiers positifs nommés numerator et denominator de type unsigned int avec comme valeur par défaut 0/1. La structure devra contenir une méthode display et qui permet d'afficher (std::cout) la fraction sous la forme numerator/denominator. Vous devrez également définir les prototypes des fonctions suivantes : add : prend deux fractions en paramètre et retourne la somme des deux fractions.sub : prend deux fractions en paramètre et retourne la différence des deux fractions.mul : prend deux fractions en paramètre et retourne le produit des deux fractions.div : prend deux fractions en paramètre et retourne le quotient des deux fractions.  info Pour simplifier on va considérer que les fractions sont toujours positives et on ne va pas gérer le cas ou le résultat d'une opération est négatif ou le problème de division par zéro. Vous êtes toute fois libre de gérer ces cas si vous le souhaitez (et donc changer le type des attributs de la structure et utiliser des entiers signés).  astuce Petit rappel sur la définition des prototypes de méthodes pour les structures ici.  Créer un fichier fraction.cpp qui contiendra les définitions des méthodes et fonctions. Implémenter les fonctions dans le fichier fraction.cpp.  attention Les fonctions add, sub, mul et div ne doivent pas modifier les fractions passées en paramètre mais bien retourner une nouvelle fraction qui est le résultat de l'opération.  Créer un fichier utils.hpp qui contiendra les fonctions suivantes : gcd : prend deux entiers positifs en paramètre et retourne le plus grand diviseur commun.simplify : prend une fraction en paramètre et retourne la fraction simplifiée. Créer un fichier utils.cpp et implémenter les fonctions.  astuce Pour simplifier une fraction, il faut diviser le numérateur et le dénominateur par le plus grand diviseur commun. On va donc utiliser la fonction gcd pour calculer le plus grand diviseur commun et ensuite diviser le numérateur et le dénominateur par ce nombre. la fraction 4/6 devient 2/3 car gcd(4, 6) = 2 et 4/2 = 2 et 6/2 = 3. Il faut importer le fichier fraction.hpp dans le fichier utils.hpp pour pouvoir utiliser la structure Fraction dans la fonction simplify.  info Pour trouver le plus grand diviseur commun, on peut utiliser l'algorithme d'Euclide qui consiste à diviser le plus grand nombre par le plus petit et à répéter l'opération avec le reste de la division jusqu'à obtenir un reste nul. Dans ce cas, le plus petit nombre non nul est le plus grand diviseur commun. exemple avec 22 et 8: 22 % 8 = 6 (reste de la division de 22 par 8) 6 est différent de 0 donc on continue8 % 6 = 2 (reste de la division de 8 par 6) 2 est différent de 0 donc on continue6 % 2 = 0 (reste de la division de 6 par 2) 0 est égal à 0 donc on s'arrête et le plus grand diviseur commun est 2.  Modifier vos fonctions add, sub, mul et div pour simplifier le résultat avant de le retourner. Créer un fichier main.cpp qui contiendra le programme principal. Ce programme devra : Créer deux fractions f1 et f2 avec les valeurs de votre choix. (idéalement avec des valeurs aléatoires ou saisies par l'utilisateur)Afficher les deux fractions.Afficher la somme des deux fractions.Afficher la différence des deux fractions.Afficher le produit des deux fractions.Afficher le quotient des deux fractions.  info Vous découvrirez au prochain semestre comment améliorer ce programme en utilisant la surcharge d'opérateurs 🛠. ","version":"Next","tagName":"h2"},{"title":"Algorithmes de tri, complexité et recherche dichotomique","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Sorting","content":"","keywords":"","version":"Next"},{"title":"Tri par comparaison​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-comparaison","content":" Les premiers algorithmes de tri que nous allons voir sont des algorithmes de tri par comparaison (Comparison based strategies).  Ils consistent à comparer deux à deux les éléments du tableau puis de les échanger ou non en fonction du résultat de la comparaison.  ","version":"Next","tagName":"h2"},{"title":"Tri par sélection (selection sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-sélection-selection-sort","content":" L'algorithme de tri par sélection est un algorithme de tri qui consiste à trouver le plus petit élément du tableau, et à le placer en première position (ou le plus grand élément en dernière position). On répète cette opération jusqu'à ce que le tableau soit trié.  Un exemple, avec le tableau suivant [6, 2, 8, 1, 5, 3, 9]:  On, parcourt le tableau pour trouver le plus petit élément qui est 1. Son indice est 3, on l'échange avec l'élément à l'indice 0 (le premier élément du tableau). 1\t2\t8\t6\t5\t3\t9 Le premier élément du tableau est désormais le plus petit élément du tableau. On recommence l'opération, mais en ignorant le premier élément du tableau, car il est déjà trié. info Toute l'astuce de cet algorithme est donc de trier un sous-tableau plus petit à chaque itération jusqu'à ce que le tableau soit trié.  Voilà les itérations suivantes:  Le deuxième plus petit élément est 2, il est déjà à la bonne place, on ne fait rien. 1\t2\t3\t6\t5\t8\t9 1\t2\t3\t5\t6\t8\t9 Il reste trois éléments à trier ([6, 8, 9]), il sont déjà triés, on ne fait rien.  Voilà, le tableau est trié.  Je t'invite à regarder le fonctionnement de cet algorithme sur cette animation ou encore ici (clique sur &quot;SEL&quot; ou &quot;Selection Sort&quot; dans la barre de navigation).  ","version":"Next","tagName":"h3"},{"title":"Tri à bulles (bubble sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-à-bulles-bubble-sort","content":" Le tri à bulles est un autre algorithme de tri très connu. Il consiste à comparer deux à deux les éléments du tableau, et à les échanger si ils ne sont pas dans le bon ordre. On répète cette opération jusqu'à ce que le tableau soit trié.  remarque Cela va avoir pour effet de faire &quot;remonter&quot; les plus grands éléments du tableau vers la fin du tableau, comme des bulles d'air qui remontent à la surface.  Un exemple, avec le même tableau [6, 2, 8, 1, 5, 3, 9]:  On compare les deux premiers éléments du tableau, 6 et 2. Comme 6 est plus grand que 2, on les échange. 2\t6\t8\t1\t5\t3\t9  On recommence l'opération avec les deux éléments suivants, 6 et 8. Comme 6 est plus petit que 8, on ne fait rien. On procède ainsi jusqu'à la fin du tableau.  On obtient après un premier passage sur l'ensemble du tableau:  2\t6\t1\t5\t3\t8\t9  On recommence l'opération, mais en ignorant le dernier élément du tableau, car il est déjà trié.  Voilà les itérations suivantes:  2\t1\t5\t3\t6\t8\t9 1\t2\t3\t5\t6\t8\t9 Dernier passage, aucun échange n'est effectué. Le tableau est trié.  ","version":"Next","tagName":"h3"},{"title":"Parlons un peu de complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#parlons-un-peu-de-complexité","content":" La complexité d'un algorithme est une mesure de la quantité de ressources (temps, mémoire, etc) que celui-ci va utiliser pour s'exécuter.  En général, on s'intéresse à la complexité en fonction de la taille des données en entrée de l'algorithme.  Il existe plusieurs types de complexité, la plus souvent utilisée est la complexité en temps.  Cela revient à se poser la question:  Si je donne à mon programme une entrée de taille n, quel est l'ordre de grandeur (en fonction de n) du nombre d'opérations qu'il va effectuer ?  remarque La complexité permet de quantifier la relation entre les conditions de départ et le temps effectué par l'algorithme.  ","version":"Next","tagName":"h2"},{"title":"Opérations de base​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#opérations-de-base","content":" Pour &quot;compter les opérations&quot;, il faut décider de ce qu'est une opération. Ce choix dépend du problème (et même de l'algorithme) considéré. Il faut en fait choisir soi-même quelques petites opérations que l'algorithme effectue souvent, et que l'on veut utiliser comme opérations de base pour mesurer la complexité. Les opérations qui caractérisent le mieux l'algorithme et représentent le mieux le temps d'exécution de celui-ci. Les opérations de base sont souvent les opérations arithmétiques, les comparaisons, les affectations, etc. Par exemple, pour un algorithme de tri, on va compter le nombre de comparaisons et d'échanges d'éléments du tableau.  En fonction des algorithmes, certaines opérations peuvent être plus significatives que d'autres. Par exemple, la multiplication est plus coûteuse que l'addition, on peut donc ne considérer que les opérations de multiplication pour mesurer la complexité d'un algorithme.  info On ne compte pas les opérations qui ne dépendent pas de la taille des données en entrée (comme l'initialisation de variables, etc). Ces opérations sont considérées comme constantes et pas significatives pour la complexité en fonction de la taille des données en entrée.  ","version":"Next","tagName":"h3"},{"title":"Notation \"grand O\"​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#notation-grand-o","content":" On exprime la complexité en fonction de la taille des données en entrée avec la notation &quot;grand O&quot;. La notation &quot;grand O&quot; est une notion mathématique qui permet d'exprimer un ordre de grandeur.  Par exemple, des algorithmes effectuant environ nnn opérations, 2n+202n+202n+20 opérations ou n/2n/2n/2 opérations ont tous la même complexité : on la note O(n)O(n)O(n) (lire &quot;grand O de nnn&quot;). De même, un algorithme en 3n2+4n+23n^2 + 4n + 23n2+4n+2 opérations aura une complexité de O(n2)O(n^2)O(n2) : on néglige les termes de plus faible degré (ici 4n4n4n et 222) et les coefficients (ici 333). On cherche seulement à savoir comment évolue le nombre d'opérations en fonction de la taille des données en entrée et on considère le terme de plus haut degré qui est celui qui va croître le plus vite en fonction de la taille des données en entrée.  VOilà un graphique récapitulatif des différentes notations &quot;grand O&quot; communes:    ","version":"Next","tagName":"h3"},{"title":"Exemple de calcul de complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#exemple-de-calcul-de-complexité","content":" Prenons l'exemple du tri par sélection.  Pour trier un tableau de taille nnn, premièrement on parcourt le tableau pour trouver le plus petit élément, on va donc effectuer nnn comparaisons.  Ensuite, on va échanger cet élément avec le premier élément du tableau, on va donc effectuer 111 échange.  Ensuite on va recommencer l'opération, mais en ignorant le premier élément du tableau, car il est déjà trié.  On va donc effectuer n−1n-1n−1 comparaisons et 111 échange.  On va faire cela jusqu'à ce que le tableau soit trié, donc jusqu'à ce qu'il ne reste plus qu'un seul élément à trier.  Pour résumer, on va effectuer pour les différentes itérations:  nnn comparaisons et 111 échangen−1n-1n−1 comparaisons et 111 échangen−2n-2n−2 comparaisons et 111 échange...111 comparaison et 111 échange  On peut donc calculer le nombre total de comparaisons et d'échanges effectués par l'algorithme:  =(n+1)+((n−1)+1)+((n−2)+1)+...+(1+1)=(n+(n−1)+⋯+1)+(1+⋯+1)=n(n+1)2+n=n2+3n2\\begin{align*} = &amp; (n+1) + ((n-1)+1) + ((n-2)+1) + ... + (1+1) \\\\ = &amp; (n + (n-1) + \\dots + 1) + (1 + \\dots + 1) \\\\ = &amp; \\frac{n(n+1)}{2} + n \\\\ = &amp; \\frac{n^2 + 3n}{2} \\\\ \\end{align*}====​(n+1)+((n−1)+1)+((n−2)+1)+...+(1+1)(n+(n−1)+⋯+1)+(1+⋯+1)2n(n+1)​+n2n2+3n​​  Ici, j'ai compté de manière exacte le nombre d'opérations effectuées par l'algorithme, mais en général on s'intéresse à la complexité en fonction de la taille des données en entrée.  On va donc garder uniquement le terme de plus haut degré, ici n2n^2n2.  On dit que la complexité du tri par sélection est en O(n2)O(n^2)O(n2).  info On peut aussi évaluer cette complexité sans calcul exact, mais plutôt en estimant le nombre d'opérations effectuées par l'algorithme. On peut voir que l'algorithme doit à chaque itération parcourir le tableau, c'est ce qui va prendre le plus de temps et dépendra de la taille du tableau. Chaque itération va permettre de trier un élément du tableau, donc on va effectuer nnn itérations. On peut donc estimer que la complexité du tri par sélection est en O(n×n)=O(n2)O(n \\times n) = O(n^2)O(n×n)=O(n2).  ","version":"Next","tagName":"h3"},{"title":"Complexité dans le pire des cas​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-dans-le-pire-des-cas","content":" Le nombre d'opérations effectuées par un algorithme peut dépendre de la taille des données en entrée, mais aussi des données elles-mêmes.  Par exemple, dans le cadre d'un tri à bulles, si le tableau est déjà trié, on n'effectuera aucune opération d'échange, et seulement nnn comparaisons.  On peut donc dire que la complexité du tri à bulles est en O(n)O(n)O(n) dans le meilleur des cas.  Mais si le tableau est trié dans l'ordre inverse, on va effectuer nnn comparaisons et nnn échanges à chaque itération, et on va effectuer nnn itérations.  On peut donc dire que la complexité du tri à bulles est en O(n×n)=O(n2)O(n \\times n) = O(n^2)O(n×n)=O(n2) dans le pire des cas.  remarque C'est intéressant de considérer la complexité dans le pire des cas, car elle permet de savoir si l'algorithme est efficace pour toutes les données possibles. En général pour des données quelconques, c'est en général assez proche du comportement dans le pire des cas.  ","version":"Next","tagName":"h3"},{"title":"Complexité en moyenne​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-en-moyenne","content":" On peut aussi s'intéresser à la complexité en moyenne, c'est-à-dire la complexité sur toutes les données possibles.  Par exemple, pour le tri à bulles, la complexité en moyenne est en O(n2)O(n^2)O(n2).  Il existe des algorithmes qui ont une complexité en moyenne bien meilleure que leur complexité dans le pire des cas. Cela dépend du problème considéré et demande une analyse plus fine de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Complexité en mémoire​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité-en-mémoire","content":" On peut aussi s'intéresser à la complexité en mémoire d'un algorithme. Autrement dit, combien de mémoire va utiliser l'algorithme en fonction de la taille des données en entrée.  C'est aussi une mesure de la complexité pertinente.  Si par exemple on a besoin de trier un tableau de 1000 éléments, on peut se dire que la complexité en temps n'est pas très importante, car l'algorithme va s'exécuter très rapidement. Mais si l'algorithme utilise beaucoup de mémoire, cela peut poser problème, car il peut ne pas avoir assez de mémoire disponible pour exécuter l'algorithme.  Dans la plupart des cas, la complexité en mémoire est beaucoup plus simple à calculer que la complexité en temps.  Mais dans des problèmes plus compliqués, la complexité en mémoire et la complexité en temps peuvent être liées.  On peut par exemple choisir de sacrifier un peu de rapidité d'exécution pour utiliser moins de mémoire, ou au contraire d'augmenter la vitesse en augmentant la complexité en mémoire de notre algorithme, par exemple en stockant dans un tableau les résultats déjà calculés (c'est le principe de la mise en cache, appelée aussi memoization).  remarque De nos jours, la complexité en mémoire est moins importante qu'avant, car les ordinateurs ont beaucoup de mémoire disponible. Dans la majorité des cas, on va donc plutôt s'intéresser à la complexité en temps. Mais la complexité en mémoire reste importante dans certains cas avancés ou avec des données très volumineuses.  ","version":"Next","tagName":"h3"},{"title":"Limitation de la complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#limitation-de-la-complexité","content":" La complexité d'un algorithme est donc une mesure d'ordre de grandeur en fonction de la taille des données en entrée.  Cependant, il est important de garder à l'esprit que la complexité ne permet pas de savoir si un algorithme est rapide ou lent.  Même si un algorithme à une complexité plus faible qu'un autre, il peut être plus (beaucoup plus) lent à s'exécuter qu'un autre algorithme pour des tailles de données en entrée faibles.  ","version":"Next","tagName":"h3"},{"title":"Tri diviser pour régner (Divide-and-Conquer paradigm)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-diviser-pour-régner-divide-and-conquer-paradigm","content":" Il existe d'autres algorithmes de tri plus efficaces que les algorithmes de tri par comparaison. Ils sont basés sur le principe de diviser pour régner (divide and conquer en anglais). L'idée est de diviser le problème en sous-problèmes plus petits, de résoudre les sous-problèmes, puis de fusionner les solutions des sous-problèmes pour résoudre le problème initial.  ","version":"Next","tagName":"h2"},{"title":"Tri fusion (merge sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-fusion-merge-sort","content":" Le tri fusion est un algorithme de tri qui consiste à diviser le tableau en deux parties égales, trier les deux parties, puis fusionner les deux parties triées.  Le tri fusion est un algorithme efficace, car il a une complexité en O(n×log(n))O(n \\times log(n))O(n×log(n)).  C'est un algorithme &quot;récursif&quot;, c'est-à-dire qu'il s'appelle lui-même pour trier deux sous-tableaux et les fusionner pour trier le tableau complet.  Il y a donc deux &quot;phases&quot; dans cet algorithme:  la phase de division du tableau en deux parties égalesla phase de fusion des deux parties triées  Phase de division​  Il existe deux façons de procéder pour diviser le tableau en deux parties égales:  Créer des tableaux intermédiaires pour stocker les deux parties du tableau à trier, puis fusionner les deux tableaux triés.Utiliser des indices pour définir les parties du tableau à trier, et trier directement le tableau en place.  La première méthode est plus simple à comprendre, mais utilise plus de mémoire, car il faut créer des tableaux intermédiaires.  On privilégie donc la deuxième méthode, et c'est celle que je vais détailler ici.  Pour trier un tableau, on va donc utiliser deux indices, un indice de début et un indice de fin, qui vont définir la partie du tableau à trier.  Par exemple, pour le tableau [6, 2, 8, 1, 5, 3, 9], les indices 0 et 6 vont définir le tableau complet. On va calculer la taille de la partie du tableau à trier, ici 6 (indice de fin) - 0 (indice de début) + 1 (car on compte l'élément à l'indice de fin), soit 7.  On va ensuite diviser cette taille par deux, soit 3 (on peut arrondir à l'entier inférieur).  On va donc utiliser par récursion les indices 0 et 3 pour trier la première partie du tableau, et les indices 4 et 6 pour trier la deuxième partie du tableau.  Enfin la fusion des deux parties triées va permettre d'obtenir le tableau trié.  Phase de fusion​  C'est la phase de fusion qui est la plus intéressante, car c'est elle qui va permettre de trier le tableau.  Pour fusionner deux tableaux triés, on va utiliser deux (autres) indices, un indice pour chaque tableau, qui vont permettre de parcourir les deux tableaux.  On va comparer les éléments des deux tableaux, et ajouter le plus petit des deux dans le tableau final.  On va incrémenter l'indice du tableau dont on a ajouté l'élément, et on recommence l'opération jusqu'à ce qu'on ait parcouru les deux tableaux.  attention Il faut faire attention à ne pas dépasser la taille des sous-tableaux avec les indices, sinon on va avoir une erreur en essayant d'accéder à un élément qui n'existe pas. Il faut donc vérifier que les indices sont bien inférieurs à la taille des sous-tableaux. Si l'un des deux indices est égal à la taille du sous-tableau, cela veut dire qu'on a parcouru tout le sous-tableau, et qu'il ne reste plus qu'à ajouter les éléments du deuxième sous-tableau dans le tableau final.  On obtient ainsi un tableau trié.  info La condition d'arrêt de la récursion est quand la taille de la partie du tableau à trier est inférieure ou égale à 1, car un tableau de taille 1 est déjà trié (de même pour un tableau vide).  ","version":"Next","tagName":"h3"},{"title":"Tri rapide (quick sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-rapide-quick-sort","content":" Le tri rapide est un algorithme de tri qui consiste à choisir un élément du tableau, appelé pivot, et à placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.  On répète ensuite l'opération sur les deux sous-tableaux, jusqu'à ce que le tableau soit trié.  De la même manière que pour le tri fusion, c'est un algorithme récursif et on va donc utiliser des indices pour définir les parties du tableau à trier.  Il y a également deux phases dans cet algorithme:  la phase de division du tableau en deux parties en fonction du pivotla phase de tri des deux parties  Phase de division​  Choix du pivot​  Le choix du pivot est très important, car il va déterminer la complexité de l'algorithme.  Si on choisit un pivot qui est toujours le plus petit élément du tableau, on va avoir une complexité en O(n2)O(n^2)O(n2), car on va devoir parcourir tout le tableau à chaque itération (de même si on choisit le plus grand élément du tableau).  Il existe plusieurs méthodes pour choisir le pivot, la plus simple est de choisir le premier élément du tableau. Mais cela peut être problématique si le tableau est déjà trié car on va diviser le tableau en deux parties de tailles très différentes.  info L'idéal est de choisir un pivot qui est proche de la valeur médiane du tableau, c'est-à-dire qui va diviser le tableau en deux parties égales. Il existe plusieurs méthodes pour choisir un pivot proche de la valeur médiane du tableau, mais elles sont plus compliquées à mettre en oeuvre.  Nous allons préférer choisir un pivot aléatoire ou plus simplement l'élément au milieu du sous-tableau considéré pour minimiser les risques de cas défavorables.  Partitionnement​  Une fois le pivot choisi, on va parcourir le tableau et placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.  Il y a plusieurs approches pour gérer le pivot, dans notre cas, on va choisir de premièrement placer le pivot à la fin du tableau.  Pour cela, on va utiliser deux indices, un indice pour parcourir le tableau de gauche à droite, et un indice pour parcourir le tableau de droite à gauche.  On va incrémenter l'indice de gauche tant que l'élément est plus petit que le pivot, et on va décrémenter l'indice de droite tant que l'élément est plus grand que le pivot.  Si l'indice de gauche est inférieur à l'indice de droite, on va échanger les deux éléments et on recommence l'opération.  Une fois que les deux indices se sont croisés, on sait que tous les éléments plus petits que le pivot sont à gauche du pivot, et tous les éléments plus grands que le pivot sont à droite du pivot.  Enfin, on va échanger le pivot avec l'élément à l'indice de gauche (l'indice pointant sur le premier élément plus grand que le pivot) pour que le pivot soit à sa place définitive.  Récursion​  On obtient ainsi un tableau avec le pivot à sa place définitive, et tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot et on connaît l'indice du pivot.  On va donc pouvoir appeler récursivement l'algorithme sur les deux sous-tableaux, en ignorant le pivot.  ","version":"Next","tagName":"h3"},{"title":"Tri par dénombrement (counting sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-dénombrement-counting-sort","content":" IL existe encore d'autres algorithmes de tri, mais ils sont plus spécifiques et ne fonctionnent que dans certains cas. Je vais en présenter un simple ici pour vous donner une idée de ce qui existe.  Le tri par dénombrement (ou counting sort en anglais) est très efficace, car il va permettre de trier un tableau en complexité linéaire, c'est-à-dire en O(n)O(n)O(n). Il ne fonctionne cependant que pour des données entières car il ne se base pas sur des comparaisons mais va compter le nombre d'occurrences de chaque valeur (de plus pour simplifier, on va supposer que les valeurs sont positives).  Le prérequis pour utiliser cet algorithme est donc de connaître la valeur maximale des données à trier. Soit on connaît cette valeur à l'avance, soit on peut la calculer en parcourant le tableau une première fois.  L'algorithme consiste à compter le nombre d'occurrences de chaque valeur dans le tableau, puis à reconstruire le tableau en plaçant les valeurs dans l'ordre.  Par exemple, si on se fixe des valeurs entières entre 0 et 9, on peut trier le tableau suivant [1, 4, 1, 2, 7, 5, 2] en procédant ainsi:  On parcourt le tableau pour compter le nombre d'occurrences de chaque valeur.  valeur\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9nombre d'occurrences\t0\t2\t2\t0\t1\t1\t0\t1\t0\t0  On reconstruit le tableau en parcourant le tableau des occurrences et en ajoutant les valeurs dans l'ordre.  On ajoute 2 fois la valeur 1On ajoute 2 fois la valeur 2...  On obtient ainsi le tableau trié [1, 1, 2, 2, 4, 5, 7].  attention On remarque qu'il faut pouvoir stocker le nombre d'occurrences de chaque valeur, donc un tableau de taille 10 dans notre exemple. Il faut donc un tableau de taille kkk pour trier des données comprises entre 0 et k−1k-1k−1 ce qui augmente la complexité en mémoire de l'algorithme. C'est à prendre en compte si on veut utiliser cet algorithme car il peut être très efficace en temps, mais peut aussi utiliser beaucoup de mémoire si les valeurs sont très grandes. C'est un algorithme à utiliser seulement dans le cas où on connaît la valeur maximale des données à trier et que cette valeur est raisonnable.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin:​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Tri par dénombrement stable​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-dénombrement-stable","content":" Details On peut améliorer le tri par dénombrement en le rendant stable. Cela signifie que si deux éléments ont la même valeur, ils seront dans le même ordre dans le tableau trié que dans le tableau initial. Cela ne semble pas très important à première vue, mais cela permet de trier des données plus complexes en leur associant des valeurs entières sur lesquelles on va effectuer le tri. Pour faire cela il faut modifier légèrement l'algorithme de tri par dénombrement. Une fois qu'on a compté le nombre d'occurrences de chaque valeur, on va calculer la somme partielle des occurrences de chaque valeur. Cela va nous permettre de connaître la position de chaque valeur dans le tableau trié. Par exemple, avec le tableau suivant [1, 4, 1, 2, 7, 5, 2] contenant des valeurs entières entre 0 et 9: On compte le nombre d'occurrences de chaque valeur : [0, 2, 2, 0, 1, 1, 0, 1, 0, 0]On calcule la somme partielle des occurrences de chaque valeur : [0, 2, 4, 4, 5, 6, 6, 7, 7, 7] remarque On peut se resservir du tableau des occurrences pour stocker la somme partielle des occurrences de chaque valeur, ce qui permet de ne pas utiliser de tableau intermédiaire supplémentaire. On va construire un nouveau tableau de même taille que le tableau initial, en parcourant le tableau initial pour ajouter les valeurs dans le nouveau tableau. On va ajouter la valeur à la position indiquée par la somme partielle des occurrences de la valeur, puis on va décrémenter la somme partielle des occurrences de la valeur. Par exemple, pour la valeur 1, on va ajouter la valeur 1 à la position 2 du nouveau tableau, puis on va décrémenter la somme partielle des occurrences de la valeur 1 pour obtenir 1 (car il reste une occurrence de la valeur 1). On obtient ainsi le tableau trié [1, 1, 2, 2, 4, 5, 7]. L'inconvénient principal de cette méthode est qu'il faut un tableau intermédiaire pour stocker le tableau trié, ce qui augmente la complexité en mémoire de l'algorithme.  ","version":"Next","tagName":"h3"},{"title":"Tri par base (radix sort)​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-base-radix-sort","content":" Details Le tri par dénombrement permet de trier des données entières comprises entre 0 et k−1k-1k−1 en complexité linéaire. On va se servir de cet algorithme pour trier des données plus complexes, en associant à chaque donnée une valeur entière sur laquelle on va effectuer le tri (d'où l'intérêt de rendre le tri par dénombrement stable). On va considérer un tri de nombres entiers, mais cela peut s'appliquer à d'autres types de données. Un nombre entier peut être représenté en base 10, c'est-à-dire en utilisant les chiffres de 0 à 9. Par exemple, le nombre 123 peut être représenté en base 10 par la suite de chiffres 1, 2 et 3. On va donc pouvoir trier des nombres entiers en triant les chiffres de leur représentation en base 10. Par exemple, pour trier les nombres [123, 456, 324, 682, 789, 118, 321, 654, 987], on va trier les chiffres des nombres, en commençant par les unités, puis les dizaines, puis les centaines. Cela permet de trier les nombres en complexité linéaire grâce au tri par dénombrement. Dans notre exemple, le nombre le plus grand est 987, il a donc 3 chiffres, on va donc effectuer 3 itérations de tri par dénombrement pour trier les nombres. remarque Cette information peut être connue à l'avance, mais on peut aussi la calculer en parcourant le tableau une première fois. On trie les unités ce qui donne [321, 682, 123, 324, 654, 456, 987, 118, 789]On trie les dizaines ce qui donne [118, 321, 123, 324, 456, 654, 682, 987, 789]enfin, on trie les centaines ce qui donne [118, 123, 321, 324, 456, 654, 682, 789, 987]  ","version":"Next","tagName":"h3"},{"title":"Recherche dichotomique​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#recherche-dichotomique","content":" Avoir un tableau trié est très utile pour effectuer des recherches dans un tableau.  Par exemple, si on veut savoir si une valeur est présente dans un tableau, on peut le parcourir le tableau et comparer chaque élément avec la valeur recherchée.  Mais si le tableau est trié, on peut utiliser une méthode plus efficace: la recherche dichotomique.  La recherche dichotomique consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l'opération jusqu'à trouver la valeur ou jusqu'à ce qu'il ne reste plus qu'un seul élément dans le tableau.  Exemple simple avec le tableau suivant [1, 2, 2, 4, 5, 8, 12] (nombre d'éléments: 7) et la valeur recherchée 8:  On calcule l'indice du milieu du tableau, soit 3. On compare la valeur à l'indice 3 avec la valeur recherchée 8, comme 4 est plus petit que 8, on ne garde que la partie du tableau qui contient la valeur recherchée, c'est-à-dire la partie du tableau à partir de l'indice 4 (indice de début: 4, indice de fin: 6). On recommence l'opération avec la partie du tableau restante. Sous partie du tableau: [5, 8, 12] (nombre d'éléments: 3), indice du milieu: 5. On compare la valeur à l'indice 5 avec la valeur recherchée 8, comme 8 est égal à 8, on a trouvé la valeur recherchée. On peut donc s'arrêter et renvoyer l'indice 5.  ","version":"Next","tagName":"h2"},{"title":"Complexité​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexité","content":" La complexité de la recherche dichotomique est en O(log(n))O(log(n))O(log(n)).  (où logloglog est le logarithme en base 2 et pas lnlnln qui est le logarithme népérien)  En effet, à chaque itération, on divise le tableau en deux parties égales, ce qui permet de réduire la taille du tableau à chaque itération.  On peut donc calculer le nombre d'itérations nécessaires pour trouver la valeur recherchée en fonction de la taille du tableau.  Par exemple, pour un tableau de taille 8, on va effectuer au maximum 3 itérations pour trouver la valeur recherchée.  On divise le tableau en deux parties égales, on ne garde que la partie qui contient la valeur recherchée, soit 4 éléments.On divise le tableau en deux parties égales, on ne garde que la partie qui contient la valeur recherchée, soit 2 éléments.In reste 2 elements (dernière itération). On garde la valeur recherchée.  Ce qui fait un total de log2(8)=3log_2(8) = 3log2​(8)=3 itérations.  ","version":"Next","tagName":"h3"},{"title":"Résumé​","type":1,"pageTitle":"Algorithmes de tri, complexité et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#résumé","content":" Les algorithmes de tri sont très importants en informatique, car ils permettent de trier des données, ce qui est une opération très courante.La complexité d'un algorithme est une mesure de la quantité de ressources (temps, mémoire, etc) que celui-ci va utiliser pour s'exécuter.La complexité en temps permet de quantifier la relation entre les conditions de départ (nombre d'éléments du tableau, valeurs des éléments, etc) et le temps effectué par l'algorithme.La complexité permet de savoir quel algorithme est le plus efficace quand on a un très grand nombre de données, mais ne permet pas de savoir si un algorithme est rapide ou lent pour un petit nombre de données (un algorithme avec une complexité en O(n2)O(n^2)O(n2) peut être plus rapide qu'un algorithme avec une complexité en O(n×log(n))O(n \\times log(n))O(n×log(n)) pour un petit nombre de données).Nous avons vu les algorithmes de tri suivants: Tri par sélection (selection sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par recherche successive du plus petit élément du tableau. Tri à bulles (bubble sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par comparaison successive de deux éléments consécutifs du tableau. Tri fusion (merge sort): O(n×log(n))O(n \\times log(n))O(n×log(n)) C'est un algorithme qui fonctionne par récursion en divisant le tableau en deux parties égales, en triant les deux parties, puis en fusionnant les deux parties triées. Tri rapide (quick sort): O(n×log(n))O(n \\times log(n))O(n×log(n)) C'est un algorithme qui fonctionne par récursion en choisissant un pivot, en divisant le tableau en deux parties en fonction du pivot, puis en triant les deux parties. Tri par dénombrement (counting sort): O(n)O(n)O(n) C'est un algorithme qui fonctionne en comptant le nombre d'occurrences de chaque valeur, puis en reconstruisant le tableau en plaçant les valeurs dans l'ordre. C'est un algorithme qui ne fonctionne que pour des données entières et où la valeur maximale des données est connue à l'avance et relativement petite. La recherche dichotomique est une méthode de recherche dans un tableau trié qui consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l'opération jusqu'à trouver la valeur souhaitée. ","version":"Next","tagName":"h2"},{"title":"TD4 - Boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Loops","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (For)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-1-for","content":" Faire une boucle for qui affiche les nombres pairs inférieurs ou égal à un nombre entré par l'utilisateur de différentes façons:  en utilisant un condition et l'opérateur moduloen utilisant le mot clé continueen utilisant une boucle bien choisie (un nombre pair est un nombre qui peut s'écrire comme le double d'un nombre entier)  astuce Vous pourrez utiliser std::cin pour demander le nombre maximum à l'utilisateur (aucune gestion d'une éventuelle erreur de saisie n'est demandée ici).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (While)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-2-while","content":" Écrire une boucle while qui affichera les entiers entre 1 et 20.Écrire une boucle while qui affichera les 50 premiers multiples de 7, chacun sur une ligne de la forme: 5 fois 7 = 35.Refaire les deux questions précédentes en utilisant une boucle for.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Somme d'entiers positifs)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-3-somme-dentiers-positifs","content":" Écrire un programme qui demande à l’utilisateur de saisir des entiers positifs (s’arrête dès que l’utilisateur saisit un entier négatif)  Gérer l'entrée utilisateur (et son arrêt) à l'aide d'une boucle while ou do while.Afficher la somme des entiers positifs saisis par l’utilisateur.Modifier le programme pour qu'il affiche également la moyenne des entiers positifs saisis par l’utilisateur.  info Pour calculer la moyenne, il faut compter le nombre d'entiers positifs saisis par l'utilisateur. Vous n'avez pas à stocker les entiers saisis par l'utilisateur (vous découvrirez comment faire cela dans le prochain chapitre).  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (rendu de monnaie)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-4-rendu-de-monnaie","content":" Écrire un programme qui demande à l’utilisateur un montant en euros et affiche le nombre de billets et de pièces nécessaires pour rendre la monnaie avec le moins de billets et de pièces possible.  On suppose que l’on dispose de pièces de 1, 2, 5, 10, 20 et 50 centimes, de 1 et 2 euros ainsi que de billets de 5, 10, 20, 50, 100, 200 et 500 euros.  astuce Utilisez un tableau pour stocker le nombre de pièces et de billets à rendre. Utilisez un algorithme glouton qui consiste à regarder si on peut rendre la monnaie avec le plus gros billet ou pièce possible et à recommencer avec le billet ou la pièce suivante jusqu'à avoir rendu toute la monnaie.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (entrée utilisateur)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-5-entrée-utilisateur","content":" Écrire un programme qui demande à l'utilisateur un nombre et affiche la table de multiplication de ce nombre.  Vous devrez gérer le cas où l'utilisateur saisit une valeur incorrecte (un nombre négatif ou une lettre par exemple) et redemander à l'utilisateur de saisir un nombre tant qu'il n'a pas saisi une valeur correcte.  Je vous invite à retourner voir l'exercice 3 du TD2 sur les conditions pour vous aider.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (conjecture de Syracuse)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-6-conjecture-de-syracuse","content":" Écrire un programme qui, à partir d’un entier positif saisi par l’utilisateur, affiche le nombre de termes de la suite de Syracuse nécessaires pour atteindre 1 (on inclut le terme de départ dans le décompte).  La suite de Syracuse est une suite d'entiers dans laquelle chaque terme est obtenu en appliquant une fonction à son terme précédent. Cette fonction est définie comme suit:  si le terme est pair, le terme suivant est égal à la moitié du terme précédent. (x/2)si le terme est impair, le terme suivant est égal à 3 fois le terme précédent plus 1 (3x+1).  Par exemple, si le terme de départ est 7, la suite est :7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1, ...  Ici, la suite atteint la valeur 1 au bout de 17 termes (incluant le terme de départ).  Vous remarquez qu’à la fin, une fois qu’on est tombé sur 1, la suite finit par répéter indéfiniment le cycle 4, 2, 1.  Il est conjecturé que cette suite atteint toujours la valeur 1 quelque soit le terme de départ. Cela a d'ailleurs déjà été vérifiée numériquement jusqu’à 10^20 (par Tomas Oliveira e Silva).  ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (ASCII art)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-7-ascii-art","content":" Écrire un programme qui demande à l’utilisateur de saisir un entier positif et affiche un triangle rectangle de hauteur n comme dans l’exemple ci-dessous.  exemple d'exécution Entrez un entier positif : 5 * ** *** **** *****   Essayer d'afficher un sapin de noël, autrement dit un triangle rectangle isocèle de hauteur n et dont le sommet est composé d'une seule étoile.  exemple d'exécution Entrez un entier positif : 3 * *** *****   Essayer d'afficher les contours d'un carré de côté n comme dans l’exemple ci-dessous.  exemple d'exécution Entrez un entier positif : 5 ***** * * * * * * *****   ","version":"Next","tagName":"h2"},{"title":"Exercice 8 (Le juste prix)​","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-8-le-juste-prix","content":" Un nombre entier est tiré au hasard entre 1 et 100 (inclus).  Le joueur doit deviner ce nombre en un minimum de tentatives.  À chaque tentative, le programme indique au joueur si le nombre à deviner est plus grand ou plus petit que celui qu’il a proposé.  Le programme s’arrête lorsque le joueur a trouvé le nombre mystère.  info Pour générer un nombre aléatoire, vous pouvez utiliser la fonction rand() de la bibliothèque cstdlib. Elle retourne un nombre entier aléatoire entre 0 et RAND_MAX (une constante définie dans la bibliothèque cstdlib). Pour obtenir un nombre aléatoire entre 1 et 100, on peut utiliser l'opérateur modulo %: std::rand() % 100 + 1 Pour que le générateur de nombres aléatoires ne génère pas toujours la même séquence de nombres, il faut l’initialiser avec une valeur différente à chaque exécution du programme. C'est avec la fonction srand(). On peut utiliser la fonction time() de la bibliothèque ctime pour obtenir l'heure actuelle en secondes et l'utiliser comme valeur d'initialisation du générateur de nombres aléatoires. #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; int main() { // Initialisation du générateur de nombres aléatoires avec la fonction time() std::srand(std::time(nullptr)); int random_variable { std::rand()}; std::cout &lt;&lt; &quot;Random value between 0 and &quot;&lt;&lt; RAND_MAX &lt;&lt;&quot; : &quot; &lt;&lt; random_variable &lt;&lt; std::endl; } Il existe une façon plus moderne de générer des nombres aléatoires à partir de C++11, nous découvrirons cela au prochain semestre. ","version":"Next","tagName":"h2"},{"title":"TD9 - Mémoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Allocation dynamique)​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-1-allocation-dynamique","content":" Écrire un programme qui alloue dynamiquement une variable de type int avec le mot-clé new (sans initialisation).Demander à l'utilisateur de saisir une valeur pour cette variable et modifier la valeur de la variable avec cette saisie.Écrire une fonction qui prend en paramètre un pointeur sur un int et qui affiche la valeur de la variable pointée.Afficher la valeur de la variable avec la fonction précédente.Afficher l'adresse de la variable.Libérer cette variable avec le mot-clé delete.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-2","content":" Écrire un programme qui génère un tableau (std::vector) de 100 entiers aléatoires compris entre 0 et 100. info Vous pouvez utiliser la fonction rand() pour générer un nombre aléatoire. Je vous renvoie à l'Exercice 1 du TD5 pour plus d'informations. Écrire une fonction qui retourne un pointeur sur le plus grand élément du tableau. Écrire une fonction qui prend en paramètre un pointeur sur un emplacement mémoire contiguë d'entiers et sa taille et qui retourne la somme des éléments du tableau. Utiliser les fonctions précédentes pour afficher le plus grand élément du tableau et la somme des éléments du tableau. astuce On peut récupérer un pointeur sur le premier élément d'un std::vector avec la méthode data(). Sinon il est aussi possible d'utiliser l'opérateur &amp; sur le premier élément du std::vector. Completer la fonction sum suivante pour qu'elle retourne un pointeur sur la somme des éléments du tableau passé en paramètre. int* sum(std::vector&lt;int&gt; const&amp; v) { int sum {0}; // boucle for // TODO } Utiliser la fonction sum pour afficher la somme des éléments du tableau. En fonction du résultat obtenu, que pouvez-vous en déduire sur le fonctionnement de la fonction sum ? Si elle ne fonctionne pas, corriger la fonction sum pour qu'elle fonctionne correctement.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Split)​","type":1,"pageTitle":"TD9 - Mémoire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-3-split","content":" Dans cet exercice, on ne doit pas utiliser de std::vector.  Allouer dynamiquement un tableau de 100 flottants aléatoires compris entre 0 et 100 (utiliser l'allocation dynamique pour des emplacements mémoire contiguës). info Vous pouvez utiliser la fonction rand() pour générer un nombre aléatoire. Pour générer un nombre flottant aléatoire vous pouvez utiliser la fonction rand() et la diviser par RAND_MAX (qui est une constante définie dans la bibliothèque cstdlib) ce qui permet d'obtenir un nombre flottant aléatoire entre 0 et 1. Il ne vous reste plus qu'à multiplier ce nombre par 100 pour obtenir un nombre flottant aléatoire entre 0 et 100. Écrire une fonction qui prend en paramètre un tableau de flottants (sous la forme d'un pointeur sur le premier élément du tableau) et sa taille et qui retourne un pointeur sur le plus grand élément du tableau. On souhaite créer une fonction qui permet de créer un nouveau tableau composé des éléments du tableau passé en paramètre qui sont supérieurs à un certain seuil. Écrire une fonction thresholdFilter qui prend en paramètre un tableau de flottants, sa taille, un seuil et une référence sur un entier qui contiendra la taille du nouveau tableau et qui retourne un pointeur sur le premier élément du nouveau tableau. Voilà la signature de la fonction: float* thresholdFilter(float const* const array, size_t const size, float const threshold, size_t&amp; new_size); info Vous pouvez remarquer que j'ai écrit float const* const array au lieu de float* array. Le premier const signifie que l'on ne peut pas modifier les valeurs pointées par le pointeur array et le deuxième const signifie que l'on ne peut pas modifier l'adresse pointée par le pointeur array. ","version":"Next","tagName":"h2"},{"title":"TD4 - Déduction de type et bibliothèque standard","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Vector and Algorithm)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-1-vector-and-algorithm","content":" Remplir un std::vector avec des nombres entiers aléatoires compris entre 0 et 100.Utiliser les itérateurs et les méthodes begin et end pour afficher les valeurs du vecteur à l'aide d'une boucle for.Chercher si un nombre saisi par l'utilisateur est présent dans le vecteur à l'aide de la fonction std::find et afficher un message adapté.Utiliser la fonction std::count pour compter le nombre d'occurrences d'un autre nombre entier le vecteur. Vous pouvez trouver la documentation de la fonction std::count ici.Utiliser la fonction std::sort pour trier le vecteur.Utiliser la fonction std::accumulate pour calculer la somme des éléments du vecteur (par défaut, la fonction std::accumulate utilise l'opérateur + entre les éléments).  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (String)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-2-string","content":" Étant donnée une phrase composée de mots séparés par des espaces.  Nous avons utilisé dans le TD précédent une astuce avec les stream C++ qui permet de séparer les mots d'une phrase. L'idée est de coder une autre façon d'arriver au même résultat sans utiliser les stream.  Je vous donne la fonction lambda suivante qui permet de savoir si un caractère est un espace:  auto const is_space = [](char letter){ return letter == ' '; };   Le mot clé auto ici permet de &quot;stocker&quot; la fonction dans une variable pour la passé en paramètre. En réalité se cache derrière des pointeur de fonction ou le type std::function qui permet d'avoir une variable qui représente une fonction comme cela.  Cela va permettre d'utiliser les fonctions std::find_if_not et find_if (qui retourne des itérateurs) pour rechercher ou non des espaces dans une chaîne de caractère.  Écrire une fonction (à l'aide des fonctions std::find et std::distance) qui prendre en paramètre une référence constante sur une std::string et qui retourne le nombre de lettres du premier mot de la phrase.  info Vous allez avoir besoin de la fonction std::distance, qui retourne la distance entre deux itérateurs, sous forme d’un nombre entier.  Écrire une fonction qui permet de découper la phrase en mots et de les stocker dans un std::vector de std::string. Voilà le prototype de la fonction :  std::vector&lt;std::string&gt; split_string(std::string const&amp; str);   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Palindrome)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#exercice-3-palindrome","content":" Écrire une fonction qui prend en paramètre une référence constante sur une std::string et qui retourne true si la chaîne de caractères est un palindrome (qui peut se lire dans les deux sens), false sinon.  Utiliser la fonctions std::equal pour comparer les valeurs de deux itérateurs. Utiliser les fonctions std::begin, std::end et std::rbegin, std::rend pour obtenir les itérateurs de début et de fin d'une chaîne de caractères et de sa version inversée.  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin (lambda)​","type":1,"pageTitle":"TD4 - Déduction de type et bibliothèque standard","url":"/Learn--cpp_programming/TDs/S2/AutoAndAlgorithm#pour-aller-plus-loin-lambda","content":" Écrire une fonction qui prend en paramètre un std::vector et retourne la somme du carré de ses éléments. Vous devez utiliser la fonction std::accumulate et une fonction lambda.Écrire une fonction qui prend en paramètre un std::vector et retourne le produit de ses éléments pairs. Vous ne devez pas filtrer les éléments du vecteur, mais utiliser une fonction lambda pour déterminer si un élément est pair ou non et si oui, le prendre en compte dans le produit. Vous devez utiliser la fonction std::accumulate et une fonction lambda. ","version":"Next","tagName":"h2"},{"title":"TD1 - Mise en place","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Setup","content":"","keywords":"","version":"Next"},{"title":"Premier programme​","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#premier-programme","content":" Une fois que vous avez installé les outils, vous pouvez créer votre premier programme.  Je vous invite à regarder la page suivante pour avoir les instructions: Premier programme  ","version":"Next","tagName":"h2"},{"title":"Plusieurs exécutables​","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#plusieurs-exécutables","content":" Comme je l'ai expliqué, il ne doit y avoir qu'un seul point d'entrée dans un programme C++ et donc une seule fonction main.  Cependant, dans le cadre des TDs, il est parfois utile de pouvoir tester plusieurs fonctions main différentes, une par exercice par exemple.  Pour cela, nous allons utiliser une fonctionnalité de CMake qui permet de créer plusieurs targets ou exécutables.  Je vous invite à créer deux fichiers td01_ex01.cpp et td01_ex02.cpp dans un dossier src et à y mettre le contenu suivant:  src/td01_ex01.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 01&quot; &lt;&lt; std::endl; return 0; }   src/td01_ex02.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 02&quot; &lt;&lt; std::endl; return 0; }   Ensuite, nous allons créer un fichier CMakeLists.txt à la racine du projet avec le contenu suivant:  CMakeLists.txt cmake_minimum_required(VERSION 3.0) set(CMAKE_CXX_STANDARD 17) project(TD01) # On indique que l'on veut créer un exécutable &quot;ex01&quot; compilé à partir du fichier td01_ex01.cpp add_executable(ex01 src/td01_ex01.cpp) # On indique que l'on veut créer un exécutable &quot;ex02&quot; compilé à partir du fichier td01_ex02.cpp add_executable(ex02 src/td01_ex02.cpp)   Vous devriez avoir une arborescence de fichiers qui ressemble à ça:  td01 ├── CMakeLists.txt └── src ├── td01_ex01.cpp └── td01_ex02.cpp   Ouvrez ensuite le dossier td01 avec VSCode, il devrait vous proposer de configurer CMake comme pour le premier programme.  Vous devriez ensuite avoir deux targets dans la barre à droite du bouton &quot;Run&quot; en bas:    Cela vous permet de choisir quelle target vous voulez exécuter pour travailler sur plusieurs exécutables dans le même projet.  info C'est la même chose pour les tâches de compilation (à droite du bouton &quot;Build&quot;).  Bravo, Vous êtes maintenant prêt à faire du C++ sur vos propres machines ! :partying_face: ","version":"Next","tagName":"h2"},{"title":"TD7 - Structures","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Exercice 1​","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-1","content":" Vous êtes le pilote d'un sous-marin, vous avez reçu des ordres de mouvements sous la forme d'une instruction et d'une distance à parcourir. Vous devez écrire un programme qui permet de calculer la position du sous-marin après avoir effectué les mouvements reçus.  Votre position initiale est (0, 0) et vous pouvez vous déplacer dans les directions suivantes: Up, Down, Forward, Backward.  Écrire une structure Position qui permet de stocker les coordonnées du sous-marin. Écrire un enum Direction qui permet de stocker les directions possibles. Écrire une structure Move qui représente un mouvement sous la forme d'une direction et d'une distance à parcourir. Écrire une fonction moveSubmarine qui permet de déplacer le sous-marin en fonction d'un mouvement. La fonction ne doit rien retourner et doit modifier la position du sous-marin passée en paramètre. Écrire une fonction display qui permet d'afficher la position du sous-marin passée en paramètre.  Le but est d'indiquer la position du sous-marin après avoir effectué les mouvements suivants:  Forward 10Down 5Backward 3Up 2Forward 5Down 1Backward 2Forward 3Down 1Up 3Forward 1Down 5Backward 2Forward 6  Vous pouvez représenter les mouvements sous la forme d'un vecteur de Move:  std::vector&lt;Move&gt; moves = { {Direction::Forward, 10}, {Direction::Down, 5}, {Direction::Backward, 3}, {Direction::Up, 2}, {Direction::Forward, 5}, {Direction::Down, 1}, {Direction::Backward, 2}, {Direction::Forward, 3}, {Direction::Down, 1}, {Direction::Up, 3}, {Direction::Forward, 1}, {Direction::Down, 5}, {Direction::Backward, 2}, {Direction::Forward, 6} };   info Exercice inspiré de de l'édition 2021 de l'advent of code: https://adventofcode.com/2021/day/2 ","version":"Next","tagName":"h2"},{"title":"TD2 - Variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (opérations)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-1-opérations","content":" Créer une variable de type int et initialiser la avec une valeur de votre choix. Appliquer les opérations suivantes sur cette variable et afficher le résultat de chaque opération: Incrémenter la variable de 1 (avec la méthode de votre choix).Multiplier la variable par 3.Diviser la variable par 2.  astuce Utiliser la fonction std::cout pour afficher la valeur de la variable.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (entrée utilisateur)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-2-entrée-utilisateur","content":" Créer un programme qui demande à l'utilisateur de saisir trois valeurs flottantes (de type float).  Calculer la somme de ces trois valeurs et stocker le résultat dans une variable de type float.Calculer de même la moyenne de ces trois valeurs.Afficher le résultat de la somme et de la moyenne.  astuce Utiliser la fonction std::cin pour lire la valeur saisie par l'utilisateur.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (cast)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-3-cast","content":" Créer une variable entière (de type int) et l'initialiser avec la valeur 11. Afficher la valeur de cette variable. Afficher la valeur de cette variable divisée par 2.  Vous devriez obtenir une valeur de 5 et non 5.5. Pourquoi ?  Utiliser un cast pour convertir la variable en un type flottant. Afficher la valeur de la variable divisée par 2.0f  astuce static_cast&lt;type&gt;(variable) permet convertir une variable en un autre type.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-4","content":" Écrire un programme qui demande un nombre de jours à l'utilisateur et affiche le nombre d'années, de mois et de jours correspondant à ce nombre de jours.  L’aﬀichage se fera sous la forme : &quot;J jours correspondent à: xx siecle xx annee xx mois xx semaine xx jours&quot;  info Pour simplifier le problème, on considérera que tous les mois ont 30 jours et toutes les années 360 jours.  exemple d'exécution Entrez un nombre de jours : 4096 4096 jours correspondent à : 0 siecle 11 annee 4 mois 2 semaine 2 jours   ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (ASCII)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-5-ascii","content":" Demander à l'utilisateur de saisir un nombre entier entre 1 et 26 et afficher la lettre correspondante dans l'alphabet.  exemple d'exécution Entrez un nombre entre 1 et 26 : 5 La lettre correspondante est : E   info Le type char permet de stocker un caractère. Il est possible de faire des opérations sur les caractères comme si c'était des entiers. Le code ASCII associe les caractères à des entiers. Par exemple, le caractère 'A' est associé à l'entier 65, 'B' à 66, etc. En ce qui nous concerne, nous allons utiliser le fait que les lettres majuscules sont associées aux entiers de 65 à 90 et les lettres minuscules aux entiers de 97 à 122. Vous pouvez trouver la table de correspondance ASCII complète ici.  ","version":"Next","tagName":"h2"},{"title":"Exercice 6​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-6","content":" Un cuisinier doit aller au marché pour récupérer ses légumes. Il a besoin de sacs de pommes de terre, de carottes et de salades.  Vous avez les informations suivantes :  Un sac de pommes de terre pèse 2kg.Le prix d'un kg de pommes de terre est de 1.5€.Une carotte pèse 150g.Le prix d'un kg de carottes est de 2.5€.Une salade coûte 1.2€.  Écrire un programme qui demande à l'utilisateur de saisir le nombre de sacs de pommes de terre, de carottes et de salades qu'il souhaite acheter.  Le programme doit ensuite calculer le prix total de la commande et l'afficher.  exemple d'exécution Entrez le nombre de sacs de pommes de terre : 2 Entrez le nombre de carottes : 3 Entrez le nombre de salades : 1 Le prix total de la commande est de 8.325 €   Bonus En bonus, afficher le détail de la commande. ... Le prix total de la commande est de 8.325 € détails: - 2 sacs de pommes de terre : 6 € - 3 carottes : 1.125 € - 1 salade : 1.2 €   ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (problème de compilation)​","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-7-problème-de-compilation","content":" #include &lt;iotream&gt; int main() { const int a{5}; int b{8}; float c{pi*3}; // je veux le résultat de pi (environ 3.141592) fois 3 b += &quot;20&quot;; // je veux ajouter 20 à la valeur de b a = a * 15; // je veux le résultat de a fois 15 std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl std::cout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; std::endl; return 0; }   Vérifier que le code ne compile pas et essayez de corriger les erreurs.  info Pour pi vous pouvez utiliser la constante M_PI définie dans la bibliothèque cmath. Il faut ajouter #include &lt;cmath&gt; en haut du fichier pour pouvoir l'utiliser. ","version":"Next","tagName":"h2"},{"title":"TD3 - Structures de données","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/dataStructures","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Evaluation NPI)​","type":1,"pageTitle":"TD3 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-1-evaluation-npi","content":" La notation polonaise inversée (NPI) est une notation mathématique qui permet d'exprimer des expressions arithmétiques sans utiliser de parenthèses. Elle a été inventée par le mathématicien polonais Jan Lukasiewicz en 1924.  La notation polonaise inversée est une notation postfixe, c'est-à-dire que l'opérateur est placé après les deux opérandes. Par exemple, l'expression 3 + 4 s'écrit 3 4 + en NPI.  Ce qui permet ensuite d'interpréter l'expression de gauche à droite, en empilant les opérandes sur une pile, et en déclenchant l'opération lorsque l'on rencontre un opérateur.  Par exemple, l'expression 3 4 + s'interprète comme suit :  On empile 3On empile 4On rencontre +, on dépile 4 et 3, on calcule 3 + 4 = 7, et on empile le résultat 7On a terminé, le résultat est 7  On va donc pouvoir se servir d'une pile pour évaluer une expression en NPI.  info Il faut cependant faire attention aux opérateurs non commutatifs, comme - ou /. 3 4 / ne s'interprète pas comme 3 / 4, mais comme 4 / 3. Il faut donc écrire 3 4 / pour évaluer 3 / 4.  Le but de cet exercice est d'écrire un programme qui permet d'évaluer une expression en NPI sous forme d'une chaîne de caractères (les différents éléments de l'expression sont séparés par des espaces), et retourner le résultat de l'expression.  Écrire un programme qui permet de lire une entrée utilisateur (std::cin) sous la forme d'une chaines de caractères composée des différents éléments de l'expression (nombre, opérateur) espacés par des espaces en notation polonaise inversée (NPI).  remarque Par simplicité, on se limitera à des expressions contenant des nombres (flottants), et les opérateurs +, -, * et / (Dans une expression en NPI il y a plus de parenthèses (( et ) car l'order des opérations est déterminé par l'ordre des opérateurs dans l'expression).  Je vous donne le code suivant qui permet à l'aide d'une particularité des streams de séparer les éléments(mots) de la chaîne de caractères en utilisant les espaces comme séparateurs:  #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iterator&gt; std::vector&lt;std::string&gt; split_string(std::string const&amp; s) { std::istringstream in(s); return std::vector&lt;std::string&gt;(std::istream_iterator&lt;std::string&gt;(in), std::istream_iterator&lt;std::string&gt;()); }   Utilisez ce code pour séparer les éléments de l'expression en NPI entrée par l'utilisateur et créer un std::vector&lt;std::string&gt; qui représenterons les éléments (tokens) de l'expression en NPI.  Écrire une fonction qui prends une chaîne de caractères et permet de dire si celle-ci représente un nombre flottant ou non. On utilisera le prototype suivant:  bool is_floating(std::string const&amp; s);   astuce Pour y arriver il faut parcourir la chaîne de caractères et de tester si chaque caractère est un chiffre ou un point . (pour gérer les nombres flottants). Si c'est le cas, on continue, sinon on retourne false. Vous pouvez utiliser la fonction std::isdigit de la bibliothèque &lt;cctype&gt; qui permet de tester si un caractère représente un chiffre.  Cela va être utile pour distinguer si un token (sous forme d'une chaîne de caractère) est un nombre(opérandes) ou un opérateur dans l'expression en NPI.  solution C++17 Il existe une fonction plus récente qui permet de faire cela, la fonction std::from_chars de la bibliothèque &lt;charconv&gt;. Elle permet de convertir une chaîne de caractères en nombre, et de retourner un pointeur sur le premier caractère non converti, ainsi qu'un code d'erreur si la conversion a échoué. #include &lt;system_error&gt; #include &lt;charconv&gt; #include &lt;string&gt; bool is_floating(std::string const&amp; s) { float value; auto [p, ec] = std::from_chars(s.data(), s.data() + s.size(), value); return ec == std::errc() &amp;&amp; p == s.data() + s.size(); } Vous pouvez utiliser cette fonction si vous le souhaitez pour confirmer votre solution. Mais il est important de faire soit même l'implémentation de la fonction is_floating pour apprendre à manipuler les chaînes de caractères.  Écrire une fonction qui prend en paramètre un vecteur de chaînes de caractères représentant les tokens de l'expression en NPI, et qui retourne le résultat de l'expression.  On utilisera le prototype suivant:  float npi_evaluate(std::vector&lt;std::string&gt; const&amp; tokens);   Utilisez une pile (std::stack) pour évaluer l'expression comme dans l'exemple précédent.  astuce En utilisant la fonction is_floating de la question précédente, on peut déterminer si un élément de l'expression est un nombre ou un opérateur. Il faut ensuite utiliser la fonction std::stof de la bibliothèque &lt;string&gt; pour convertir la chaîne de caractères en nombre flottant si c'est le cas.  Enfin, utiliser les fonctions précédentes pour afficher le résultat d'une expression en NPI entrée par l'utilisateur.  Vous pouvez tester avec les expressions suivantes:  3 4 +3 4 2 * +3 4 2 * 1 5 - 6 ^ / +  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utiliser une structure et des énumérations)​","type":1,"pageTitle":"TD3 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-2-utiliser-une-structure-et-des-énumérations","content":" Le but est de réécrire le programme précédent en utilisant un enum pour représenter les différents opérateurs ainsi qu'une structure pour représenter un token (un élément de l'expression) avec un champ pour le type (opérateur ou opérande) et des champs pour les valeurs (opérateur ou opérande).  enum class Operator { ADD, SUB, MUL, DIV, OPEN_PAREN, CLOSE_PAREN}; enum class TokenType { OPERATOR, OPERAND }; struct Token { TokenType type; float value; Operator op; };   info Il existe des fonctionnalités plus avancés qui permettraient de faire ça plus proprement, et de se passer de l'enum TokenType dans la structure Token (les variantes). Vous pouvez vous renseigner ou me demander si vous voulez en savoir plus.  Créer deux fonctions (surchargées) qui permettent de construire la structure Token à partir d'un nombre flottant ou de la valeur de l’énumération Operator.  Token make_token(float value) Token make_token(Operator op);   Créer une fonction tokenize qui prends en paramètre un vecteur de chaîne de caractères (représentant les &quot;mots&quot; d'une phrase, nos anciens tokens) et retourne un vecteur de Token.  std::vector&lt;Token&gt; tokenize(std::vector&lt;std::string&gt; const&amp; words);   Créer une nouvelle fonction npi_evaluate qui utilise cette fois un vecteur de Token au lieu de manipuler directement des chaînes de caractères.  float npi_evaluate(std::vector&lt;Token&lt;float&gt;&gt; const&amp; tokens);   ","version":"Next","tagName":"h3"},{"title":"Pour aller plus loin​","type":1,"pageTitle":"TD3 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#pour-aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Conversion en NPI)​","type":1,"pageTitle":"TD3 - Structures de données","url":"/Learn--cpp_programming/TDs/S2/dataStructures#exercice-3-conversion-en-npi","content":" Nous avons précédemment vu comment évaluer une expression en NPI. Mais comment faire pour convertir une expression en notation infixe (c'est-à-dire de manière &quot;classique&quot; avec des parenthèses) en une expression en NPI ?  Pour cela, il existe un algorithme appelé Shunting-yard algorithm (littéralement &quot;algorithme de la cour de triage&quot;).  Son principe est d'utiliser également une pile pour stocker les opérateurs rencontrés, et de les dépiler lorsque l'on rencontre un opérateur de priorité supérieure.  Voilà comment il fonctionne :  On parcourt l'expression de gauche à droite Si on rencontre un nombre, on l'ajoute à la sortie Si on rencontre un opérateur: Si on rencontre une parenthèse ouvrante ((), on la met sur la pile des opérateursSi on rencontre une parenthèse fermante ()), on dépile les opérateurs jusqu'à ce qu'on rencontre une parenthèse ouvrante, et on ajoute les opérateurs défilés à la sortieTant qu'il y a un opérateur sur la pile des opérateurs de priorité supérieure ou égale à l'opérateur courant, on dépile les opérateurs et on les ajoute à la sortie. Puis on ajoute l'opérateur courant à la pile des opérateurs. Enfin, on dépile les opérateurs restants et on les ajoute à la sortie.  Voici un exemple d'application de l'algorithme avec l'expression 3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 :  Entrée\tSortie\tPile des opérateurs\tcommentaire3\t3 on ajoute 3 à la sortie +\t3\t+\ton ajoute + à la pile des opérateurs 4\t3 4\t+\ton ajoute 4 à la sortie ^\t3 4\t+ ^\ton ajoute ^ à la pile des opérateurs 2\t3 4 2\t+ ^\ton ajoute 2 à la sortie /\t3 4 2 ^\t+\ton dépile ^ et on l'ajoute à la sortie car / a une priorité inférieure à ^ (\t3 4 2 ^\t+ / (\ton ajoute ( à la pile des opérateurs 1\t3 4 2 ^ 1\t+ / (\ton ajoute 1 à la sortie -\t3 4 2 ^ 1\t+ / ( -\ton ajoute - à la pile des opérateurs 5\t3 4 2 ^ 1 5\t+ / ( -\ton ajoute 5 à la sortie )\t3 4 2 ^ 1 5 -\t+ /\ton dépile les opérateurs jusqu'à ( et on les ajoute à la sortie ^\t3 4 2 ^ 1 5 -\t+ / ^\ton ajoute ^ à la pile des opérateurs 6\t3 4 2 ^ 1 5 - 6\t+ / ^\ton ajoute 6 à la sortie 3 4 2 ^ 1 5 - 6 ^\t+ /\ton dépile le reste des opérateurs et on les ajoute à la sortie  Résultat final : 3 4 2 ^ 1 5 - 6 ^ / +  info La suite de l'exercice est présenté en utilisant les fonctions et structures de l'exercice précédent. Si vous n'avez pas fait l'exercice 2 vous pouvez tout aussi bien travailler avec un vecteur de chaînes de caractères sans utiliser la structure Token.  Écrire une fonction operator_precedence qui prends en paramètre un Operator et retour sous forme d'un nombre entier positif la priorité de cet opérateur.  size_t operator_precedence(Operator const op);   Écrire une fonction qui prend en paramètre une chaîne de caractères représentant une expression en notation infixe, qui retourne un tableau de Token représentant l'expression en NPI.  std::vector&lt;Token&gt; infix_to_npi_tokens(std::string const&amp; expression);   astuce On utilisera la même structure Token que dans l'exercice précédent et les fonctions tokenize et split_string pour récupérer dans un premier temps une représentation de l'expression en notation infixe sous forme d'une liste de Token (dont les parenthèses ici). C'est ici que parenthèses en tant qu'opérateur vont être utile mais elles ne devrons pas se retrouver dans la liste de Token en NPI.  Maintenant que nous savons évaluer une expression en NPI et que nous savons convertir une expression en notation infixe en NPI, nous pouvons réaliser une calculatrice. 3. Essayez de réaliser un programme qui permet de lire une expression en notation infixe, de la convertir en NPI, de l'évaluer et d'afficher le résultat. ","version":"Next","tagName":"h3"},{"title":"Exercice 1 (Run-length encoding)","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/encodingAndCompression","content":"Exercice 1 (Run-length encoding) Écrire une fonction qui prend en paramètre une chaîne de caractères composée uniquement de caractères alphabétiques et qui retourne une chaîne de caractères encodée en utilisant le run-length encoding. Par exemple, si la chaîne de caractères en entrée est AAAABBBCCDAA, la chaîne de caractères encodée est 4A3B2C1D2A. Écrire une fonction qui prend en paramètre une chaîne de caractères encodée en utilisant le run-length encoding et qui retourne la chaîne de caractères décodée. Améliorer la fonction précédente pour qu'elle puisse décoder une chaîne de caractères même si cette chaîne de caractères contient des nombres à plusieurs chiffres. Par exemple, si la chaîne de caractères en entrée est 12A3B2C1D2A, la chaîne de caractères décodée est AAAAAAAAAAAABBBCCDAA. Écrire une fonction qui permet d'encoder en utilisant un caractère spécial (caractère de contrôle) suivit d'un nombre pour indiquer le nombre de fois qu'un caractère doit être répété. Par exemple, en se donnant le caractère de contrôle *, si la chaîne de caractères en entrée est AAAABBBCCDAA, la chaîne de caractères encodée est *4A*3B*2C1D2A. Améliorer la fonction précédente pour rendre le caractère de contrôle paramétrable et retourner la chaîne de caractères originale si la longueur de la chaîne de caractères encodée est plus grande que la chaîne de caractères originale. Écrire une fonction qui permet de décoder une chaîne de caractères encodée en utilisant un caractère de contrôle. Exercice 2 (Huffman encoding) Écrire une fonction frequency qui prend en paramètre une chaîne de caractères et retourne un std::unordered_map&lt;char, size_t&gt; qui associe à chaque caractère le nombre d'occurrences de ce caractère dans la chaîne de caractères. Donnons nous la structure suivante pour la suite de l'exercice: struct Node { char character; size_t frequency; Node* left { nullptr }; Node* right { nullptr }; }; info on n'utilise pas de std::unique_ptr dans cet exercice pour simplifier l'écriture des fonctions. En effet, l'utilisation de std::unique_ptr impose de passer par des std::move pour déplacer les pointeurs et cela rendrait l'écriture des fonctions plus complexe. Cela nous forcerait même à créer notre propre file de priorité (priority_queue) pour pouvoir utiliser des std::unique_ptr dans la file de priorité. Ce n'est pas l'objet de cet exercice. Surcharger l'opérateur &lt; pour la structure Node de telle sorte que l'opérateur &lt; retourne true si la fréquence du nœud de gauche est inférieure à la fréquence du nœud de droite. Écrire une fonction createNode qui prend en paramètre un caractère et une fréquence et qui retourne un Node*. Écrire une fonction createSymbolNode qui prend en paramètre (par valeur) deux Node* et qui retourne un Node* dont le caractère est 0 et la fréquence est la somme des fréquences des deux nœuds passés en paramètre et les deux nœuds passés en paramètre sont les fils du nœud retourné. Cette fonction va être utilisée pour créer un nœud qui représente un &quot;symbole&quot; (un ensemble de caractères) et qui va être utilisé pour construire l'arbre de Huffman. Écrire une fonction build_huffman_tree qui prend en paramètre (référence constante) un std::unordered_map&lt;char, size_t&gt; et qui retourne un Node* qui représente l'arbre de Huffman. Cet arbre va être construit en utilisant une std::priority_queue qui va permettre de trier les nœuds (symboles) en fonction de leur fréquence. Pour construire l'arbre, on va retirer les deux nœuds de plus petite fréquence de la file de priorité, créer un nouveau nœud dont la fréquence est la somme des fréquences des deux nœuds retirés et dont les fils sont les deux nœuds retirés, et ajouter ce nouveau nœud à la file de priorité. Écrire une fonction build_encoding_table qui prend en paramètre le sommet de l'arbre de Huffman et qui retourne un std::unordered_map&lt;char, std::string&gt; qui associe à chaque caractère le code de Huffman correspondant. Pour construire le code de Huffman, on va parcourir l'arbre de Huffman en ajoutant un 0 à une chaîne de caractère à chaque fois qu'on descend à gauche et un 1 à chaque fois qu'on descend à droite. On va s'arrêter lorsqu'on arrive à une feuille et on va associer la chaîne de caractère obtenue à la feuille. Il faudra utiliser une fonction intermédiaire fill_encoding_table qui prend en paramètre un nœud, la chaîne de caractères associé avec représentation binaire du nœud et qui remplit ta table (std::unordered_map&lt;char, std::string&gt;) passé par référence. C'est cette fonction qui va être appelée récursivement pour parcourir l'arbre de Huffman et remplir la table. Voila les signatures des fonctions: void fill_encoding_table(Node const* node, std::unordered_map&lt;char, std::string&gt;&amp; table, std::string str); std::unordered_map&lt;char, std::string&gt; build_encoding_table(Node const* root); Écrire une fonction encode qui prend en paramètre une chaîne de caractères et un std::unordered_map&lt;char, std::string&gt; et qui retourne une chaîne de caractères représentant la chaîne de caractères encodée en utilisant le code de Huffman. std::string encode(std::string str, std::unordered_map&lt;char, std::string&gt; const&amp; table); Écrire une fonction decode qui prend en paramètre une chaîne de caractères encodée en utilisant le code de Huffman et le sommet de l'arbre de Huffman et qui retourne une chaîne de caractères représentant la chaîne de caractères décodée. std::string decode(std::string const&amp; str, Node const* huffman_tree_root); Écrire une fonction delete_huffman_tree qui prend en paramètre le sommet de l'arbre de Huffman et qui libère la mémoire allouée pour l'arbre. Culture - Aller plus loin: Dans la réalité, on ne souhaite pas encoder le caractères a par une chaîne de caractère (par exemple 110). Sinon on se retrouverait avec une chaîne de caractères plus grande que la chaîne de caractères originale. On va plutôt utiliser des bits. Par exemple, on va encoder le caractère a par les bits 110 (soit le nombre 6 en décimal). Pour faire cela il faut manipuler des bits. En C++, on peut manipuler des bits en utilisant les opérateurs &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite), | (ou binaire), &amp; (et binaire), ^ (ou exclusif binaire), ~ (non binaire). Pour ensuite pouvoir écrire en binaire dans un fichier on va utiliser des octets. Un octet est un ensemble de 8 bits. En C++, on peut manipuler des octets en utilisant le type unsigned char (ou uint8_t). Ensuite, au lieu de retourner une chaîne de caractères, on va retourner un std::vector&lt;uint8_t&gt; qui contient les octets composés des bits de chaque caractère mis bout à bout. C'est un jeu d'operation binaire et de décalage qui permet de mettre bout à bout les octets pour obtenir la représentation binaire de la chaîne de caractères encodée. On obtient ensuite un std::vector&lt;uint8_t&gt; qui contient la représentation binaire de la chaîne de caractères encodée. On peut ensuite écrire cet std::vector&lt;uint8_t&gt; dans un fichier. Si l'on souhaite faire un programme qui compresse de bout en bout une chaîne de caractères dans un fichier, il faut pouvoir écrire dans un fichier la représentation binaire de la chaîne de caractères encodée. Pour cela, on peut utiliser la classe std::ofstream qui permet d'écrire dans un fichier. Il suffira d'écrire octet par octet dans le fichier. Afin, de pouvoir décoder ce fichier, il faut pouvoir lire les octets du fichier et les transformer en une représentation binaire. Cela se fait en utilisant la classe std::ifstream qui permet de lire dans un fichier. Il suffira de lire octet par octet et de transformer chaque octet en une représentation binaire. Enfin, pour décoder totalement et retrouver la chaîne originale, il faut non seulement avoir la représentation binaire de la chaîne de caractères encodée, mais également avoir l'arbre de Huffman pour pouvoir décoder la représentation binaire en caractères et ainsi retrouver la chaîne de caractères originale. Il faudra donc ajouter à ce fichier la représentation de l'arbre de Huffman pour pouvoir décoder totalement la chaîne de caractères encodée. Je ne vous demande pas de faire cela, mais c'est pour vous donner une idée de ce à quoi cela peut servir en pratique et comment cela peut être utilisé.","keywords":"","version":"Next"},{"title":"TD5 - Hachage et tableaux associatifs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (fonction de hachage)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-1-fonction-de-hachage","content":" Écrire une fonction de hachage qui prend en paramètre une chaîne de caractères, fait la somme des valeurs ASCII des caractères et renvoie un entier compris entre 0 et un maximum donné nommé max (le type de retour du hash doit être size_t).  Nous utiliserons une simple somme des codes ASCII des caractères suivie d'un modulo pour obtenir un entier compris entre 0 et max.  size_t folding_string_hash(std::string const&amp; s, size_t max);   Ce que nous venons de faire s'appel la technique dite de folding (pliage en français). Cela consiste à découper notre donnée en plusieurs parties, calculer une valeur(hash) pour chacune de ces parties, sommer ces valeurs et enfin appliquer un modulo pour obtenir un entier compris entre 0 et max. Ici on traite une chaîne de caractère, on va donc faire la somme des valeurs de hachage de chaque caractère.  info On veux se ramener à un entier compris entre 0 et max car cette valeur hachée sert généralement d'index dans un tableau (table de hachage). Hors on souhaite un tableau de taille &quot;raisonnable&quot; en mémoire, donc on limite la taille de ce tableau à max. Le choix de max dépend du contexte d'utilisation de la table de hachage, généralement on choisit une valeur qui est une puissance de 2 (par exemple 1024, 2048, 4096, etc.).  Écrire une nouvelle fonction de hachage sur une chaîne de caractères pour laquelle l'ordre des caractères a de l'importance. Par exemple, les chaînes de caractères &quot;abc&quot; et &quot;cba&quot; ne doivent pas avoir la même valeur hachée. Ce qui est le cas avec la fonction de hachage précédente.  Utiliser par exemple la somme des codes ASCII des caractères multipliée par leur position dans la chaîne de caractères.  size_t folding_string_ordered_hash(std::string const&amp; s, size_t max);   Écrire une fonction de hachage sur une chaîne de caractères utilisant la technique de polynomial rolling hash.  Voila le prototype de la fonction à écrire:  size_t polynomial_rolling_hash(const std::string&amp; s, size_t p, size_t m);   Nous allons utiliser la technique dite de polynomial rolling hash. Cette technique consiste à calculer le hash d'une chaîne de caractères en fonction du hash de la chaîne de caractères précédente. Cela permet de prendre en compte l'ordre des caractères dans la chaîne de caractères. Pour cela, nous allons utiliser la formule suivante: hash(s)=∑i=0n−1(s[i]×pi)mod m\\text{hash}(s) = \\sum_{i=0}^{n-1} (s[i] \\times p^i) \\mod mhash(s)=i=0∑n−1​(s[i]×pi)modm Avec: sss la chaîne de caractèresnnn la taille de la chaîne de caractèress[i]s[i]s[i] le code ASCII du caractère à l'index iii dans la chaîne de caractèresppp un nombre (généralement un nombre premier)mmm un nombre (généralement une puissance de 2)  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Réparation de Robots)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-2-réparation-de-robots","content":" l'idée de cet exercice est d'utiliser une table associative pour résoudre un problème.  Nous avons des robots qui sont en panne. Chaque robot est identifié par son nom composé de 2 lettres majuscules. Je vous donne la liste des robots en panne et les différentes dépenses pour les réparer.  Voilà la fonction qui génère la liste des réparations effectuées en donnant sous forme de std::pair le nom du robot et le coût de la réparation:  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; std::string random_name(size_t size) { std::string name {&quot;&quot;}; // Optimisation pour que la chaîne de caractère ne réalloue pas de la mémoire à chaque caractère ajouté // https://cplusplus.com/reference/string/string/reserve/ name.reserve(size); for(size_t i {0}; i &lt; size; ++i) { name.push_back('A' + std::rand() % 26); } return name; } std::vector&lt;std::pair&lt;std::string, float&gt;&gt; get_robots_fix(size_t size) { std::vector&lt;std::pair&lt;std::string, float&gt;&gt; robots_fix {}; // Meme optimisation que dans random_name() // https://cplusplus.com/reference/vector/vector/reserve/ robots_fix.reserve(size); for (size_t i {0}; i &lt; size; ++i) { // random name std::string robotName { random_name(2) }; // random cost float cost {static_cast&lt;float&gt;(std::rand()) / RAND_MAX * 1000.0f}; robots_fix.push_back(std::make_pair(robotName, cost)); } return robots_fix; }   J'aimerai être capable de lister pour un robot donné l'ensemble des réparations effectuées pour ce robot. Par exemple, pour le robot &quot;AB&quot;, j'aimerai avoir la liste des réparations effectuées pour ce robot.  Pour cela, je vous demande d'écrire une fonction qui prend en paramètre la liste des réparations effectuées et qui retourne une table associative (std::unordered_map) qui associe à chaque nom de robot la liste des réparations effectuées pour ce robot (sous forme de std::vector&lt;float&gt;). Écrire une fonction qui prend en un std::vector&lt;float&gt; et qui retourne la somme des éléments de ce vecteur. Utiliser les deux fonctions précédentes pour afficher la somme des réparations effectuées pour chaque robot. (à partir de la liste des réparations effectuées obtenue avec la fonction get_robots_fix).  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (hash sur une structure)​","type":1,"pageTitle":"TD5 - Hachage et tableaux associatifs","url":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables#exercice-3-hash-sur-une-structure","content":" Donnons nous les enums et structures suivantes:  enum class CardKind { Heart, Diamond, Club, Spade, }; enum class CardValue { Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace, }; struct Card { CardKind kind; CardValue value; };   L'idée de cet exercice est de créer une fonction de hachage pour la structure Card pour que l'on puisse utiliser cette structure comme clé dans une table de hachage.  la bibliothèque standard C++ fournit une fonction de hachage pour les types de base (entiers, flottants, etc.) et les chaînes de caractères. Mais elle ne fournit pas de fonction de hachage pour nos structures.  De la même façon que l'on a surchargé les opérateurs pour nos structures, on va pouvoir surcharger la fonction de hachage de notre structure.  Il faut deux choses pour pouvoir utiliser une structure comme clé dans une table de hachage:  un opérateur == pour comparer deux structuresune fonction de hachage de cette structure  Surchargez l'opérateur == pour la structure Card (deux cartes sont égales si elles ont la même valeur et la même couleur). Écrire une méthode hash pour la structure Card qui retourne un entier.  Vous pouvez utiliser la méthode de hachage que vous souhaitez et qui vous semble la plus adaptée. Mais je vous donne un indice pour trouver une fonction de hachage parfaite pour notre structure Card dans la question suivante (vous pouvez donc passer à la question suivante si vous le souhaitez).  Trouvez un moyen simple (à l'aide d'une multiplication et de static_cast) d'améliorer la fonction de hachage de notre structure Card pour quelle soit parfaite.  astuce Trouver une bonne fonction de hachage de notre structure Card revient à trouver une façon de transformer une carte en un entier unique. Il y a de nombreuses façons de s'y prendre comme on l'a vu précédemment. Mais pour ce cas précis, il existe une fonction de hachage dite parfaite. On peut se rendre compte qu'il y a seulement 52 cartes différentes. On peut donc utiliser une fonction de hachage qui retourne un entier compris entre 0 et 51 avec un nombre différent pour chaque carte et donc sans collision.    Je vous donne ensuite le code suivant qui permet de faire en sorte que la bibliothèque standard utilise notre méthode hash pour la structure Card:  namespace std { template&lt;&gt; struct hash&lt;Card&gt; { size_t operator()(Card const&amp; card) const { return card.hash(); } }; }   Je ne vous demande pas de comprendre ce code, il y a des notions plus complexes que vous découvrirez l'année prochaine. Gardez simplement en tête que ce code permet de faire en sorte que la bibliothèque standard utilise notre méthode hash pour la structure Card. (Notamment les tables associatives ont besoin de ça pour indexer les objects).  Je vous donne également une fonction qui permet de générer une liste de cartes aléatoires:  #include &lt;vector&gt; std::vector&lt;Card&gt; get_cards(size_t const size) { std::vector&lt;Card&gt; cards; cards.reserve(size); for (size_t i {0}; i &lt; size; ++i) { cards.emplace_back(static_cast&lt;CardKind&gt;(rand() % 4), static_cast&lt;CardValue&gt;(rand() % 13)); } return cards; }   Utiliser la fonction get_cards pour générer une liste de 100 cartes aléatoires. Utiliser une table de hachage std::unordered_map pour compter le nombre de fois que chaque carte apparaît dans la liste et afficher le résultat.  Pour pouvoir afficher, je vous donne la fonction suivante qui permet d'obtenir une représentation sous forme de chaîne de caractères de notre structure Card:  std::string card_name(Card const&amp; card) { std::string name {}; unsigned int card_value {(static_cast&lt;unsigned int&gt;(card.value)+2) % 14}; if (card_value &lt; 10) { name += '0' + card_value; }else if (card_value == 10) { name += &quot;10&quot;; }else if (card_value == 11) { name += 'V'; }else if (card_value == 12) { name += 'Q'; }else if (card_value == 13) { name += 'K'; } name += &quot; of &quot;; if (card.kind == CardKind::Heart) { name += &quot;Heart&quot;; }else if (card.kind == CardKind::Diamond) { name += &quot;Diamond&quot;; }else if (card.kind == CardKind::Club) { name += &quot;Club&quot;; }else if (card.kind == CardKind::Spade) { name += &quot;Spade&quot;; } return name; }  ","version":"Next","tagName":"h2"},{"title":"Arbres binaires de recherche","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/binaryTree","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Implémentation)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-1-implémentation","content":" Donnons nous pour commencer la structure suivante pour représenter un nœud d'un arbre binaire.  struct Node { int value; Node* left { nullptr }; Node* right { nullptr }; };   astuce Je vous conseil de créer un fichier node.hpp et d'y mettre la structure Node ainsi que le prototype des fonctions et méthodes que vous allez écrire. Avec une organisation de fichier comme celle-ci: src/ L main.cpp L node.hpp L node.cpp CmakeLists.txt   Affichage dans la console Je vous fourni une fonction qui permet d'afficher une représentation ASCII dans la console d'un arbre binaire: void pretty_print_left_right(Node const&amp; node, std::string const&amp; prefix, bool is_left) { if (node.right) { pretty_print_left_right(*node.right, prefix + (is_left ? &quot;| &quot; : &quot; &quot;), false); } std::cout &lt;&lt; prefix &lt;&lt; (is_left ? &quot;+-- &quot; : &quot;+-- &quot;) &lt;&lt; node.value &lt;&lt; std::endl; if (node.left) { pretty_print_left_right(*node.left, prefix + (is_left ? &quot; &quot; : &quot;| &quot;), true); } } void pretty_print_left_right(Node const&amp; node) { pretty_print_left_right(node, &quot;&quot;, true); }   Écrire une fonction create_node qui prend en paramètre une valeur et permet de créer (sur la heap avec new) un nœud contenant cette valeur et dont les fils sont pointeur nuls.  Node* create_node(int value);   Écrire une méthode is_leaf sur la structure Node qui retourne vrai si le nœud est une feuille (c'est à dire si ses deux fils sont nuls).  bool is_leaf() const;   Écrire une méthode insert à la structure BinaryTree qui prend en paramètre une valeur et qui insère un nouveau nœud contenant cette valeur dans l'arbre binaire. On insérera le nœud à gauche si la valeur est inférieure à la valeur du nœud courant et à droite sinon.  void Node::insert(int value);   astuce On utilisera la fonction create_node pour créer le nouveau nœud.  Écrire une méthode height qui retourne la hauteur de l'arbre binaire (c'est à dire la longueur du plus long chemin entre la racine et une feuille).  int Node::height() const;   astuce On peut utiliser de la récursivité pour calculer la hauteur de l'arbre.  Écrire une fonction delete_childs sur la structure Node qui permet de supprimer les fils d'un nœud (et de libérer la mémoire).  void Node::delete_childs();   astuce On peut utiliser de la récursivité pour supprimer les nœuds de l'arbre.  On va se donner la convention qu'un arbre binaire contenant un seul nœud a une hauteur de 1.  Écrire une méthode display_infixe qui affiche les valeurs des nœuds parcourus dans l'ordre infixe.  void Node::display_infixe() const;   Écrire une méthode prefixe qui retourne un vecteur contenant des pointeurs vers les nœuds de l'arbre binaire parcourus en prefixe.  std::vector&lt;Node const*&gt; Node::prefixe() const;   astuce Pour le faire par récursivité on pourra utiliser la méthode insert du std::vector qui permet d’insérer plusieurs éléments à l'aide d’itérateurs. auto left_nodes {left-&gt;infixe()}; nodes.insert(nodes.end(), left_nodes.begin(), left_nodes.end()); Cela va permettre de concaténer dans un seul vecteur les nœuds des sous arbres gauche et droit.  De même, écrire une autre méthode postfixe qui retournent les nœuds parcourus dans l'ordre postfixe.  BONUS: Itératif si tu le souhaites, tu peux essayer de le faire de manière itérative (sans récursivité). Pour faire cela tu peux utiliser une pile (std::stack) pour stocker les nœuds à parcourir. L'idée est de parcourir l'arbre en commençant par la racine (premier élément de la pile). Puis, de déplier un nœud de la pile, s'il a un fils droit, on le met dans la pile et on recommence. Sinon, s'il a un fils gauche, on le met dans la pile et on recommence. enfin s'il n'a pas de fils, on le traite (on peut l'ajouter à un vecteur par exemple). Il faut aussi faire attention à conserver un pointeur vers le nœud précédent afin de savoir si on remonte ou si on descend dans l'arbre. Exemple: Si on a l'arbre suivant: 5 / \\ 3 7 / \\ / \\ on va commencer par mettre le nœud 5 dans la pile. (le nœud précédent est nul) On va lire le nœud 5 et se rendre compte qu'il a un fils gauche, on le met dans la pile et on recommence (le nœud précédent est 5). On va lire le nœud 3 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le nœud précédent est 3). On va lire de nouveau le nœud 5 mais comme on a déjà traité le fils gauche (on le sait car le nœud précédent est le nœud 3), on va mettre le fils droit dans la pile et recommencer. (le nœud précédent devient 5). On va lire le nœud 7 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le nœud précédent est 7). On va lire de nouveau le nœud 5 mais comme on a déjà traité le fils droit (on le sait car le nœud précédent est le nœud 7), on va enfin traiter le nœud 5 et le retirer de la pile. Ce qui nous donne l'ordre postfixe: 3, 7, 5. C'est un peu plus compliqué que la version récursive mais c'est un bon exercice pour comprendre le fonctionnement des arbres binaires et des mécanismes de pile. Voilà un bout de code pour vous aider à démarrer: std::vector&lt;Node const*&gt; Node::postfixe() const { std::vector&lt;Node const*&gt; nodes {}; std::stack&lt;Node const*&gt; to_process {}; Node* previous {nullptr}; to_process.push(this); while (!to_process.empty()) { Node const* current { to_process.top() }; // Si on est en train de descendre dans l'arbre if (previous == nullptr || (previous-&gt;left == current || previous-&gt;right == current)) { if(/* ? */) { to_process.push(current-&gt;left); } else if(/* ? */) { // todo } else { // on traite le nœud (ajouter au vecteur) et on le retire de la pile // todo } // Si l'on remonte dans l'arbre en venant de la gauche }else if (/* ? */) { if(/* ? */) { // todo } else { // todo } // Si l'on remonte dans l'arbre en venant de la droite } else if (/* ? */) { // todo } previous = current; } return nodes; }   Écrire une fonction most_left qui retourne une référence vers le pointeur du nœud le plus à gauche de l'arbre binaire.   Node*&amp; most_left(Node*&amp; node);   ⚠️ Pourquoi retourner une référence vers un pointeur(*&amp;) ? Car on va ensuite utiliser cette fonction dans la fonction removeNode pour supprimer une valeur (donc un nœud) de l'arbre binaire. Mais dans certains cas on va devoir modifier le pointeur du nœud parent pour qu'il ne pointe plus vers le nœud que l'on veut supprimer. la référence va permettre de modifier directement le pointeur du nœud parent.  Écrire une fonction remove qui permet de supprimer une valeur de l'arbre binaire dont le nœud racine est passé en paramètre. La fonction retourne vrai si la valeur a été supprimée et faux sinon.  bool remove(Node*&amp; node, int value);   Prendre en paramètre une référence vers un pointeur permet de modifier directement le pointeur du nœud parent si le nœud est supprimé. C'est important dans le cas par exemple où l'on supprime une feuille de l'arbre il faut pouvoir réassigner le pointeur du nœud parent vers un pointeur nul pour éviter d'avoir un pointeur qui pointe vers un nœud supprimé.  if (value == node-&gt;value &amp;&amp; node-&gt;is_leaf()) { // On supprime le nœud courant delete node; // Comme on a une référence sur le pointeur du nœud courant, on le met à jour avec nullptr // Ainsi le parent du nœud courant aura un pointeur vers nullptr node = nullptr; // on retourne true car la suppression a été effectuée return true; }   astuce Il existe trois cas de figure lorsqu'on supprime un nœud d'un arbre binaire: Le nœud n'a pas de fils: on peut le supprimer directement (exemple précédent).Le nœud a un seul fils: on peut le supprimer et le remplacer par son fils.Le nœud a deux fils: Il faut remplacer la valeur du nœud à supprimer par une valeur préserver l'ordre de l'arbre. Pour cela, on utilisera la fonction most_left qui permettent de trouver le nœud le plus à gauche d'un arbre binaire (autrement dit, le nœud de valeur minimale). Il faut ensuite remplacer la valeur du nœud à supprimer par la valeur du nœud trouvé précédemment et supprimer ce dit nœud pour ne pas avoir de doublon. (cela revient à intervertir les deux nœuds sans avoir à modifier les pointeurs puis à supprimer le nœud dont la valeur a été copiée). Ce troisième cas est le plus compliqué à gérer. N'hésitez pas à demander de l'aide et prendre le temps de faire des schémas pour comprendre le fonctionnement. Il faudra utiliser la fonction most_left pour trouver le nœud le plus à gauche de l'arbre binaire.  attention Il faut faire attention à bien libérer la mémoire des nœuds supprimés.  Écrire une fonction delete_tree qui permet de supprimer un arbre binaire (et de libérer la mémoire).  void delete_tree(Node* node);   (BONUS) Écrire des méthodes min et max qui retournent respectivement les valeurs minimales et maximales de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Utilisation)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-2-utilisation","content":" Testons maintenant notre implémentation en créant un programme qui permet de créer un arbre binaire et d'effectuer différentes opérations dessus.  Créer un arbre binaire et insérer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0. Afficher les valeurs des nœuds de l'arbre binaire dans l'ordre infixe. Afficher la valeur minimale et maximale de l'arbre. Afficher la somme des valeurs des nœuds de l'arbre binaire en utilisant la fonction postfixe qui retourne un vecteur contenant les nœuds parcourus dans l'ordre postfixe. Afficher la hauteur de l'arbre binaire.  ","version":"Next","tagName":"h2"},{"title":"Aller plus loin​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#aller-plus-loin","content":" ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Pointeurs intelligents)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-3-pointeurs-intelligents","content":" Nous allons maintenant améliorer et simplifier notre code en utilisant des pointeurs intelligents. En effet la partie la plus compliquée de notre code est la gestion de la mémoire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous débarrasser de cette gestion et de nous passer de la fonction delete_tree par exemple.  Copier coller votre fichier pour garder une version de votre code précédent et créer un nouveau fichier smartNode.hpp dans lequel vous allez réécrire votre code en utilisant des pointeurs intelligents. Renommer la structure Node en SmartNode pour pouvoir faire la différence entre les deux versions et remplacer les pointeurs &quot;bruts&quot; par des pointeurs intelligents std::unique_ptr dans la structure SmartNode.  Je vous donne le contenu du fichier smartNode.hpp:  #pragma once #include &lt;vector&gt; struct SmartNode { int value; std::unique_ptr&lt;SmartNode&gt; left { nullptr }; std::unique_ptr&lt;SmartNode&gt; right { nullptr }; bool is_leaf() const; void insert(int value); size_t height() const; int min() const; int max() const; }; std::unique_ptr&lt;SmartNode&gt; create_smart_node(int value); std::unique_ptr&lt;SmartNode&gt;&amp; SmartNode::most_left(std::unique_ptr&lt;SmartNode&gt;&amp; node); bool remove(std::unique_ptr&lt;SmartNode&gt;&amp; node, int value);   Modifier la fonction is_leaf pour utiliser le fait qu'un pointeur intelligent peut être converti implicitement en booléen (il vaut false si le pointeur est nul et true sinon).  std::unique_ptr&lt;float&gt; ptr {nullptr}; if (ptr) { // ptr est différent de nullptr } else { // ptr est égal à nullptr }   Renommer et modifier la fonction create_node (en create_smart_node) pour qu'elle retourne un pointeur intelligent std::unique_ptr au lieu d'un pointeur brut (on utilisera la fonction std::make_unique pour créer le pointeur).  Elle s'utilise de la manière suivante:  std::unique_ptr&lt;float&gt; ptr {std::make_unique&lt;float&gt;(3.14)};   Modifier la méthode most_left pour qu'elle retourne une référence vers un pointeur intelligent au lieu d'un pointeur brut. Modifier la méthode insert pour qu'elle utilise des pointeurs intelligents. Modifier la méthode remove pour qu'elle utilise des pointeurs intelligents.  astuce C'est un peu plus compliqué car il faut utiliser des références vers des pointeurs intelligents pour pouvoir les modifier. On peut utiliser les méthodes reset et release pour gérer la mémoire et les pointeurs intelligents. Ou utiliser un concept plus avancé std::move pour transférer la propriété d'un pointeur intelligent d'un objet à un autre. Si vous voulez essayer, n'hésitez pas à demander de l'aide.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Encapsulation)​","type":1,"pageTitle":"Arbres binaires de recherche","url":"/Learn--cpp_programming/TDs/S2/binaryTree#exercice-4-encapsulation","content":" Le but est de créer une structure BinaryTree qui encapsule la structure Node ou SmartNode et qui permet d'utiliser les même méthodes sans connaître la structure interne de l'arbre binaire. Cela permet aussi de gérer le cas où l'arbre binaire est vide (c'est à dire que la racine est un pointeur nul).  C'est moins pertinent dans notre cas pour ce TDs mais lorsque vous découvrirez la notion de visibilité vous comprendrez l'intérêt de cette encapsulation.  Voilà le contenu du fichier binaryTree.hpp:  #pragma once #include &lt;memory&gt; #include &quot;smartNode.hpp&quot; struct BinaryTree { std::unique_ptr&lt;SmartNode&gt; root { nullptr }; void insert(int value); bool remove(int value); void clear(); bool contains(int value) const; size_t height() const; }; bool contains(std::unique_ptr&lt;SmartNode&gt;&amp; node, int value);   Créer un fichier binaryTree.cpp et implémenter les méthodes de la structure BinaryTree.  info C'est grâce à cette encapsulation que l'on peut changer la structure interne de l'arbre binaire sans avoir à modifier le code qui l'utilise. Nous pourrions par exemple changer la structure SmartNode par une structure Node sans avoir à modifier le code qui utilise la structure BinaryTree. Ici avec l'utilisation des pointeurs intelligents, la mémoire va être gérée automatiquement à la destruction de l'objet BinaryTree et il n'y a plus besoin de la fonction delete_tree. C'est un grand avantage des pointeurs intelligents et permet d'éviter les erreurs de fuites mémoires. ","version":"Next","tagName":"h2"},{"title":"TD1 - Opérateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/operators","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (opérations)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-1-opérations","content":" Transformer les méthodes add, sub, mul et div en surcharge des opérateurs +, -, * et / pour pouvoir utiliser les opérateurs avec des fractions.  On peut appliquer une simplification sur les fractions retournées par les opérateurs pour éviter d'avoir des fractions non simplifiées.  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (affichage)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-2-affichage","content":" Transformer la fonction display en surcharge de l'opérateur &lt;&lt; pour pouvoir afficher une fraction avec std::cout.  ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (égalité)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-3-égalité","content":" Ajouter l'opérateur == pour comparer deux fractions.Ajouter l'opérateur != en se basant sur l'opérateur ==.  astuce Attention, cela ne fonctionnera pas si on compare deux fractions non simplifiées. (ex: 1/2 == 2/4) Une autre solution serait de simplifier les fractions dans l'opérateur avant de les comparer. Il existe une autre façon de faire en comparant les produits en croix des fractions. (ex: a/b == d/c &lt;=&gt; a * c == b * d)  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (comparaison)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-4-comparaison","content":" Ajouter l'opérateur &lt; pour comparer deux fractions.Ajouter les opérateurs &lt;=, &gt; et &gt;= en se basant sur l'opérateur &lt;.  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (opérations d'affectation)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-5-opérations-daffectation","content":" Transformer les méthodes add, sub, mul et div en surcharge des opérateurs d'affectation +=, -=, *= et /=Réécrire les opérateurs +, -, * et / en utilisant les opérateurs affectation afin d'éviter de dupliquer le code (deux-en-un).  ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (conversion)​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#exercice-6-conversion","content":" Définir et implémenter une méthode to_float qui retourne la valeur de la fraction sous forme de float.  Il est aussi possible de définir des opérateurs de conversion pour convertir une fraction en un autre type.  la syntaxe est la suivante:  operator type() const { // code de conversion }   Ajouter l'opérateur de conversion float pour pouvoir convertir une fraction en float en utilisant la méthode to_float.  le prototype de la méthode pour notre structure Fraction sera le suivant:  Fraction::operator float() const;   Grâce à cet opérateur, on pourra convertir une fraction en float de la manière suivante:  Fraction f1 {1, 2}; float d1 {static_cast&lt;float&gt;(f1)}; // conversion explicite avec static_cast   ","version":"Next","tagName":"h2"},{"title":"Aller plus loin​","type":1,"pageTitle":"TD1 - Opérateurs","url":"/Learn--cpp_programming/TDs/S2/operators#aller-plus-loin","content":" Ajouter des fonction libres pour les opérateurs +, -, * et / afin de pouvoir faire des opérations avec des fractions et des entiers. exemple: Fraction f1 {1, 2}; int i {2}; Fraction f2 {f1 + i}; Fraction operator+(Fraction const&amp; f, int const i); Fraction operator+(int const i, Fraction const&amp; f); astuce Pour que ce soit commutatif, il faut aussi définir la fonction avec l'entier en premier paramètre. Réutiliser la fonction précédente pour éviter de dupliquer le code. Ajouter des méthodes pour appliquer des opérations mathématiques sur les fractions. abs: valeur absolueceil: arrondi supérieurfloor: arrondi inférieurround: arrondi ","version":"Next","tagName":"h2"},{"title":"TD2 - Algorithmes de tri","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/sorting","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (tri itératif)​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-1-tri-itératif","content":" Dans cet exercice, vous devez écrire une fonction qui prend en paramètre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Vous avez le choix entre deux algorithmes de tri:  tri à bulletri par sélection  Voilà les prototypes des fonctions:  void bubble_sort(std::vector&lt;int&gt; &amp; vec); void selection_sort(std::vector&lt;int&gt; &amp; vec);   ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (tri récursif)​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-2-tri-récursif","content":" De nouveau, vous devez écrire une fonction qui prend en paramètre un tableau d'entiers (std::vector) et le trie par ordre croissant.  Cette fois-ci, vous devez utiliser un algorithme de tri récursif.  Vous avez le choix entre deux algorithmes de tri:  tri fusiontri rapide  Voilà les prototypes des fonctions à utiliser et implémenter:  size_t quick_sort_partition(std::vector&lt;float&gt; &amp; vec, size_t left, size_t right, size_t const pivot); void quick_sort(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const right); void quick_sort(std::vector&lt;float&gt; &amp; vec) { quick_sort(vec, 0, vec.size() - 1); } void merge_sort_merge(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const middle, size_t const right); void merge_sort(std::vector&lt;float&gt; &amp; vec, size_t const left, size_t const right); void merge_sort(std::vector&lt;float&gt; &amp; vec) { merge_sort(vec, 0, vec.size() - 1); }   Dans ces deux algorithmes, on va trier des plages du tableau par récursivité. C'est pour cela que les fonctions prennent en paramètre les indices de début et de fin de la plage à trier (left et right). De plus, dans les deux algorithmes, on va utiliser une fonction auxiliaire pour séparer le tableau en deux parties (quick_sort_partition) ou pour fusionner deux tableaux triés (merge_sort_merge).  astuce Pour l'étape de merge du merge sort (merge_sort_merge), il faudra copier les valeurs dans des vecteurs temporaires pour stocker les deux parties du tableau à fusionner. Il existe plusieurs façons de copier les valeurs d'un vecteur dans un autre. La plus simple est de donner à la construction du vecteur les itérateurs de début et de fin du vecteur à copier. Cela fonctionne de la manière suivante: std::vector&lt;int&gt; vec1 {1, 2, 3, 4, 5}; // copie de vec1 dans vec2 std::vector&lt;int&gt; vec2(vec1.begin(), vec1.end()); // copie des éléments de vec1 dans vec3 à partir de l'élément d'indice 2 std::vector&lt;int&gt; vec3(vec1.begin() + 2, vec1.end()); // copie des éléments de vec1 dans vec4 à partir de l'élément d'indice 1 jusqu'à l'élément d'indice 3 std::vector&lt;int&gt; vec4(vec1.begin() + 1, vec1.begin() + 4); // il est également possible de copier un vecteur dans un autre à l'aide de la fonction std::copy std::vector&lt;int&gt; vec5(vec1.size()); std::copy(vec1.begin(), vec1.end(), vec5.begin()); // il faut que le vecteur de destination ait la bonne taille pour pouvoir copier les valeurs // ou à l'aide de la méthode assign std::vector&lt;int&gt; vec6; vec6.assign(vec1.begin(), vec1.end());   ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Comparaison des algorithmes de tri)​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-3-comparaison-des-algorithmes-de-tri","content":" Une fois nos algorithmes de tri implémentés, nous allons les comparer en terme de complexité temporelle.  Je vous fournis une fonction qui permet de générer un tableau d'entiers aléatoires.  #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; std::vector&lt;int&gt; generate_random_vector(size_t const size, int const max = 100) { std::vector&lt;int&gt; vec(size); std::generate(vec.begin(), vec.end(), [&amp;max]() { return std::rand() % max;} ); return vec; }   Je vous fournis également une structure chronomètre, il suffit de télécharger le fichier ScopedTimer.hpp et le copier dans le dossier de votre projet et de l'inclure dans votre fichier source:  #include &quot;ScopedTimer.hpp&quot;   Elle fonctionne de la manière suivante:  { ScopedTimer timer(&quot;nom du chronomètre&quot;); // code à chronométrer }   Elle affichera le temps écoulé entre sa création et sa destruction(c'est à dire à la fin du bloc de code, c'est pourquoi il est déclaré dans un bloc entre accolades (Scope) dans l'exemple ci-dessus).  ","version":"Next","tagName":"h2"},{"title":"bibliothèque standard​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#bibliothèque-standard","content":" La bibliothèque standard de C++ fournit une fonction de tri std::sort qui permet de trier des conteneurs (incluse dans la bibliothèque &lt;algorithm&gt;)  Vous pouvez l'utiliser de la manière suivante:  std::vector&lt;int&gt; array {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::sort(array.begin(), array.end());   remarque begin et end sont des méthodes de std::vector qui permettent de récupérer des itérateurs sur le début et la fin du conteneur. Nous verrons les itérateurs plus tard dans le cours.  Avec cette fonction, vous pouvez comparer les temps d'exécution de vos algorithmes de tri avec celui de la bibliothèque standard.  Que constatez-vous ?Que pouvez-vous en dire ?  ","version":"Next","tagName":"h3"},{"title":"Exercice 4 (dichotomie)​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-4-dichotomie","content":" Écrire une fonction search qui prend en paramètre un tableau d'entiers (std::vector) trié par ordre croissant et une valeur entière et retourne l'indice de la valeur dans le tableau. Si la valeur n'est pas présente dans le tableau, la fonction retournera -1 (on pourrait utiliser quelques chose de plus propre comme std::optional que l'on découvrira dans le prochain cours pour éviter de retourner -1 pour indiquer que l'on ne trouve pas la valeur).  la fonction devra utiliser l'algorithme de recherche dichotomique.  astuce On utilisera deux indices pour définir la partie du tableau à traiter: left : indice du premier élément de la partie du tableau à traiterright : indice du dernier élément de la partie du tableau à traiter Exemple simple avec le tableau suivant [1, 2, 2, 3, 4, 8, 12] (nombre d'éléments: 7) et la valeur recherchée 8: left = 0 et right = 6 (indice du premier et dernier élément du tableau)middle = (left + right) / 2 = (0 + 6) / 2 = 3 (indice de l'élément au milieu du tableau) la valeur au milieu du tableau est 3 qui est inférieure à la valeur recherchée 8, on ne garde que la partie droite du tableau.left devient middle + 1 = 3 + 1 = 4 (indice du premier élément de la partie droite du tableau)left = 4 et right = 6middle = (left + right) / 2 = (4 + 6) / 2 = 5la valeur au milieu du tableau est 8 qui est égale à la valeur recherchée, on retourne l'indice 5 de la valeur dans le tableau.  tester la fonction search avec les tableaux suivants et afficher le résultat de la recherche: [1, 2, 2, 3, 4, 8, 12] (valeur recherchée: 8)[1, 2, 3, 3, 6, 14, 12, 15] (valeur recherchée: 15)[2, 2, 3, 4, 5, 8, 12, 15, 16] (valeur recherchée: 16)[5, 6, 7, 8, 9, 10, 11, 12, 13] (valeur recherchée: 6)[1, 2, 3, 4, 5, 6, 7, 8, 9] (valeur recherchée: 10)  ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin: Counting sort​","type":1,"pageTitle":"TD2 - Algorithmes de tri","url":"/Learn--cpp_programming/TDs/S2/sorting#pour-aller-plus-loin-counting-sort","content":" Le counting sort est un algorithme de tri qui permet de trier un tableau d'entiers en temps linéaire (c'est à dire en O(n)O(n)O(n)). Il est cependant limité par le fait qu'il ne peut trier que des entiers (&quot;positifs&quot; pour le cas le plus simple) et que la valeur maximale des entiers du tableau doit être connue (à calculer avant le tri ou connue en fonction du contexte).  Essaye d'implémenter cet algorithme de tri. Voilà le prototype de la fonction:  void counting_sort(std::vector&lt;int&gt; &amp; vec, int const max);  ","version":"Next","tagName":"h2"}],"options":{"languages":["fr"],"includeRoutes":["**/Lessons/**","**/TDs/**"],"id":"default"}}
import{G,A as L,$ as H,k as p,a0 as K,H as $,a1 as M,J as x,g as F,h as Q,L as U,B as X,a2 as Y,a3 as Z,a4 as nn,K as sn,N as en,t as A,p as R,O as tn,v as N,x as on}from"./_virtual_settings-W9jktp4-.js";function W(i,n,s){const t={arcLength:0,segments:[],minSin:1};if(i.length===0)return t;if(s){const a=i[0].add(i[i.length-1]).scale(.5);i=[a,...i,a]}let e=i[0];for(let a=2;a<i.length;a++){const l=i[a-2],r=i[a-1],c=i[a],P=l.sub(r),g=c.sub(r),h=P.normalized.safe,m=g.normalized.safe,q=Math.acos(G(-1,1,h.dot(m))),b=Math.tan(q/2),w=Math.sin(q/2),j=Math.min(n,b*P.magnitude*(a===2?1:.5),b*g.magnitude*(a===i.length-1?1:.5)),J=w===0?0:j/w,B=b===0?0:j/b,E=h.add(m).scale(1/2).normalized.safe.scale(J).add(r),S=h.perpendicular.dot(m)<0,v=new L(e,r.add(h.scale(B))),D=new H(E,j,h.perpendicular.scale(S?1:-1),m.perpendicular.scale(S?-1:1),S);v.arcLength>0&&(t.segments.push(v),t.arcLength+=v.arcLength),D.arcLength>0&&(t.segments.push(D),t.arcLength+=D.arcLength),t.minSin=Math.min(t.minSin,Math.abs(w)),e=r.add(m.scale(B))}const o=new L(e,i[i.length-1]);return o.arcLength>0&&(t.segments.push(o),t.arcLength+=o.arcLength),t}function an(i,n){for(let s=0;s<i.length-1;s++){const t=i[s];let e=i[s+1];for(;t.sub(e).magnitude>n;)e=p.lerp(t,e,.5),i.splice(s+1,0,e)}}function ln(i,n){const s=[];let t=null;for(const e of i.segments){if(!(e instanceof L))return null;s.push(e.from),t=e.to}return t&&s.push(t),!Number.isNaN(n)&&n>0&&an(s,n),s}function rn(i){return i.reduce((n,s,t)=>{const e=i[(t+1)%i.length];return n+(s.y*e.x-s.x*e.y)},0)/2}function cn(i,n){const s=[];let t=3;!Number.isNaN(n)&&n>0&&(t=Math.max(t,Math.ceil(i.arcLength/n)));for(let e=0;e<t;e+=1){const o=K(i,i.arcLength*(e/(t-1)));s.push(o.position)}return rn(s)>0&&s.reverse(),s}function C(i){if(i.segments.length===0)return[];let n={arcLength:0,minSin:0,segments:[],closed:!1},s=null;const t=[n];for(const e of i.segments){const o=e.getPoint(0).position;s&&!o.equals(s)&&(n={arcLength:0,minSin:0,segments:[],closed:!1},t.push(n)),n.segments.push(e),n.arcLength+=e.arcLength,s=e.getPoint(1).position}for(const e of t)e.closed=e.segments[0].getPoint(0).position.equals(e.segments[e.segments.length-1].getPoint(1).position);return t}function O(i,n){return{points:[...ln(i,n)||cn(i,n)],closed:i.closed}}function I(i){return i.reduce((n,s,t)=>t?n+i[t-1].sub(s).magnitude:0,0)}function k(i,n){const s=i.length+n,t=I(i)/n;let e=0,o=0,a=t/2;for(;i.length<s;){const l=i[e],r=i[(e+1)%i.length],c=l.sub(r).magnitude;a<=o+c?(i.splice(e+1,0,c?p.lerp(l,r,(a-o)/c):new p(l)),a+=t):(o+=c,e+=1)}}function d(i,n,s){const t=i.length;let e=0;for(let o=0;o<n.length;o+=1){const a=i[(s+o)%t],l=n[o];e+=a.sub(l).squaredMagnitude}return e}function _(i,n){const{points:s,closed:t}=i,e=s.length;if(t){let o=1/0,a=0;const l=s.pop();for(let r=0;r<e;r+=1){const c=d(s,n.points,r);c<o&&(o=c,a=r)}if(l&&s.push(l),a){s.pop();const r=s.splice(0,a);s.splice(s.length,0,...r),s.push(s[0])}}else{const o=d(s,n.points,0),a=[...s].reverse();d(a,n.points,0)<o&&(i.points=a)}}function T({points:i,...n},s){const t=10**s;return{points:i.map(e=>{const[o,a]=[e.x,e.y].map(l=>Math.round(l*t)/t);return new p(o,a)}),...n}}function hn(i,n,s,t){const e=s,o=O(i,e),a=O(n,e),l=o.points.length-a.points.length;return k(o.points,l<0?l*-1:0),k(a.points,l>0?l:0),!i.closed&&n.closed?_(a,o):_(o,a),{from:T(o,t),to:T(a,t)}}function z(i,n){for(let s=i.length;s<n.length;s++){const t=n[s].segments[0].getPoint(0).position;i.push({arcLength:0,closed:!1,minSin:0,segments:[new L(t,t)]})}}function pn(i,n,s,t){const e=C(i),o=C(n);return e.length<o.length?z(e,o):z(o,e),e.map((a,l)=>hn(a,o[l],s,t))}function un(i,n){const{segments:s,arcLength:t,minSin:e}=n;i.segments.push(...s),i.arcLength+=t,i.minSin=Math.min(i.minSin,e)}function V(i,n,s){const t=[];if(s===0)return[...i];if(s===1)return[...n];for(let e=0;e<i.length;e++){const o=i[e],a=n[e];t.push(p.lerp(o,a,s))}return t}function gn(i,n){const s=pn(i,n,5,4);return t=>{const e={segments:[],arcLength:0,minSin:1};for(const{from:o,to:a}of s){const l=V(o.points,a.points,t);un(e,W(l,0,!1))}return e}}var f=function(i,n,s,t){var e=arguments.length,o=e<3?n:t===null?t=Object.getOwnPropertyDescriptor(n,s):t,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(i,n,s,t);else for(var l=i.length-1;l>=0;l--)(a=i[l])&&(o=(e<3?a(o):e>3?a(n,s,o):a(n,s))||o);return e>3&&o&&Object.defineProperty(n,s,o),o},y;let u=y=class extends ${static rotatePoints(n,s,t){if(t){let e=1/0,o=0;for(let a=0;a<n.length;a+=1){const l=d(n,s,a);l<e&&(e=l,o=a)}if(o){const a=n.splice(0,o);n.splice(n.length,0,...a)}}else{const e=d(n,s,0),o=[...n].reverse();d(o,s,0)<e&&n.reverse()}}static distributePoints(n,s){if(n.length===0){for(let l=0;l<s;l++)n.push(p.zero);return}if(n.length===1){const l=n[0];for(let r=0;r<s;r++)n.push(l);return}const t=n.length+s,e=I(n);let o=e===0?0:s/e,a=0;for(;n.length<t;){const l=t-n.length;if(a+1>=n.length){o=e===0?0:l/e,a=0;continue}const r=n[a],c=n[a+1],P=r.sub(c).magnitude;let g=Math.min(Math.round(P*o),l)+1;e===0&&(g=2);for(let h=1;h<g;h++)n.splice(++a,0,p.lerp(r,c,h/g));a++}}*tweenPoints(n,s,t){const e=[...this.parsedPoints()],o=this.parsePoints(M(n)),a=this.closed(),l=e.length-o.length;y.distributePoints(l<0?e:o,Math.abs(l)),y.rotatePoints(o,e,a),this.tweenedPoints(e),yield*x(s,r=>{const c=t(r);this.tweenedPoints(V(e,o,c))},()=>{this.tweenedPoints(null),this.points(n)})}constructor(n){super(n),this.tweenedPoints=F(null),n.children===void 0&&n.points===void 0&&Q().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;</code></pre><p>Alternatively, you can define the points using the children:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;</code></pre><p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;</code></pre>`,inspect:this.key})}childrenBBox(){let n=this.tweenedPoints();if(!n){const s=this.points();n=s?s.map(t=>new p(M(t))):this.children().filter(t=>!(t instanceof U)||t.isLayoutRoot()).map(t=>t.position())}return X.fromPoints(...n)}parsedPoints(){return this.parsePoints(this.points())}profile(){return W(this.tweenedPoints()??this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const n=this.radius(),s=this.lineJoin();let t=super.lineWidthCoefficient();if(n===0&&s==="miter"){const{minSin:e}=this.profile();e>0&&(t=Math.max(t,.5/e))}return t}drawOverlay(n,s){const t=this.childrenBBox().transformCorners(s),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(s);n.fillStyle="white",n.strokeStyle="black",n.lineWidth=1;const a=new Path2D,l=(this.tweenedPoints()??this.parsedPoints()).map(r=>r.transformAsPoint(s));if(l.length>0){Y(a,l[0]);for(const r of l)Z(a,r),n.beginPath(),nn(n,r,4),n.closePath(),n.fill(),n.stroke()}n.strokeStyle="white",n.stroke(a),n.beginPath(),sn(n,o),n.stroke(),n.beginPath(),en(n,t),n.closePath(),n.stroke()}parsePoints(n){return n?n.map(s=>new p(M(s))):this.children().map(s=>s.position())}};f([A(0),R()],u.prototype,"radius",void 0);f([A(null),R()],u.prototype,"points",void 0);f([tn()],u.prototype,"tweenPoints",null);f([N()],u.prototype,"childrenBBox",null);f([N()],u.prototype,"parsedPoints",null);f([N()],u.prototype,"profile",null);u=y=f([on("Line")],u);export{u as L,gn as c};

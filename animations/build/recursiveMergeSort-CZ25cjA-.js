import{M as V,m as X,u as w,r as z,j as i,c as u,L as k,b as Y,R as G,a as L,w as R,G as D,V as q}from"./_virtual_settings-DUdUAYR1.js";import{u as P,C as n,T as A,t as C,s as S}from"./styles-1mPC6dPo.js";import{c as E,S as B,b,p as W}from"./motion-CfaMFuXj.js";import{r as H,s as J}from"./utils-B3L5ltZ6.js";let j;j??(j=new V("recursiveMergeSort",!1));j.loadData({version:0,timeEvents:[],seed:3180500438});const K=j,a={...B};a.boxWidth/=1.2;a.boxGap/=1.5;function N(t,c,f,x,l,s=4*a.outlineMargin,d=2*a.boxWidth,e=1){return[i(k,{ref:x,opacity:e,topLeft:t().bottomLeft().addX(-d/2).addY(s),width:c*b(a)-a.boxGap,height:()=>t().height()}),i(k,{ref:l,opacity:e,topRight:t().bottomRight().addX(d/2).addY(s),width:f*b(a)-a.boxGap,height:()=>t().height()})]}function*I(t,c,f,x,l,s,d=0,e=null){if(f<=1){yield l.stroke(n.green,.5),yield*R(.5);return}yield e==null?void 0:e.save(),yield e==null?void 0:e.stroke(e.stroke().alpha(.3),.3),yield l.stroke(n.blue,.3);let m=Math.floor(f/2);const o=u(),M=u(),y=u(),h=u();t.add(i(k,{layout:!0,direction:"column",alignItems:"start",topLeft:()=>t.topLeft().transformAsPoint(t.worldToLocal()).add(50),children:[i(k,{layout:!0,margin:10,children:[i(A,{text:"Sorted Array:",...C,marginRight:50}),i(G,{size:[200,60],fill:new D(n.green).alpha(.02),stroke:n.green,radius:10,lineWidth:6})]}),i(k,{layout:!0,margin:10,children:[i(A,{text:"Current Array:",...C,marginRight:20}),i(G,{size:[200,60],fill:new D(n.blue).alpha(.02),stroke:n.blue,radius:10,lineWidth:6})]})]})),t.add(N(x,m,f-m,o,y,4*a.outlineMargin,(Math.pow(c-d,2)+1)*a.outlineMargin)),t.add([E(o,M,n.surface,a.outlineMargin,0),E(y,h,n.surface,a.outlineMargin,0)]),o().y(o().y()+50),y().y(y().y()+50),yield*L(o().y(o().y()-50,.3),y().y(y().y()-50,.3),M().opacity(1,.3),h().opacity(1,.3)),yield*L(S(.1,...s.slice(0,m).map((r,p)=>r.topLeft(W(o,p,b(a)),.2))),S(.1,...s.slice(m).map((r,p)=>r.topLeft(W(y,p,b(a)),.2)))),yield*I(t,c,m,o,M(),s.slice(0,m),d+1,l),yield*R(.5),yield*I(t,c,f-m,y,h(),s.slice(m),d+1,l);const F=H(J(s.map(r=>parseInt(r.childAs(0).text(),10))));{const r=s.slice();F.forEach((p,T)=>s[p]=r[T])}yield*S(.2,...s.map((r,p)=>r.topLeft(W(x,p,b(a)),.3))),yield*L(M().opacity(0,.3),h().opacity(0,.3)),yield*R(.5),yield*l.stroke(n.green,.3),e&&(yield*e.restore(.3)),yield*R(.5),[o,y,M,h].forEach(r=>r().remove())}const g=X(function*(t){const c=w().variables.get("seed",42),f=w().variables.get("size",7)(),x=P(c());let l=z(f).map(o=>x.nextInt(1,99));const s=[],d=u(),e=u();t.fill(n.background),t.add([i(k,{ref:d,opacity:1,width:l.length*b(a)-a.boxGap,height:a.boxWidth,y:-200}),E(d,e,n.surface,a.outlineMargin,1)]),t.add(z(l.length).map(o=>i(G,{ref:Y(s,o),size:a.boxWidth,lineWidth:a.boxStrokeWidth,stroke:n.surface,fill:n.background,radius:a.boxRadius,topLeft:W(d,o,b(a)),alignItems:"center",justifyContent:"center",children:i(A,{text:l[o].toString(),...C})})));const m=Math.ceil(Math.log2(f));yield*I(t,m,f,d,e(),s),yield*L(e().stroke(n.surface,.3),S(.1,...s.map(o=>o.fill(n.green,.3)))),yield*R(1)});g.name="recursiveMergeSort";K.attach(g.meta);g.onReplaced??(g.onReplaced=new q(g.config));export{g as d};

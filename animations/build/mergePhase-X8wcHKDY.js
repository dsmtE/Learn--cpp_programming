import{g as xe,h as fe,C as je,i as ee,k as Le,l as le,t as We,n as ie,o as ze,L as B,B as Me,p as Ae,q as Se,v as ve,x as Re,y as De,z as we,A as ke,D as Te,E as de,F as Ce,M as qe,m as Be,u as ue,r as ce,j as s,c as y,G as b,b as Ee,R as W,S as Xe,a as k,w as se,V as Ye}from"./_virtual_settings-DUdUAYR1.js";import{u as Oe,C as l,T as f,t as u,s as O}from"./styles-1mPC6dPo.js";import{S as Ve,b as D,c as oe}from"./motion-CfaMFuXj.js";import{z as Ge,r as ge,s as me}from"./utils-B3L5ltZ6.js";import{C as x}from"./Circle-BvtK0xEw.js";function Ie(a,e,i){const r={arcLength:0,segments:[],minSin:1};if(a.length===0)return r;if(i){const n=a[0].add(a[a.length-1]).scale(.5);a=[n,...a,n]}let t=a[0];for(let n=2;n<a.length;n++){const d=a[n-2],m=a[n-1],z=a[n],T=d.sub(m),M=z.sub(m),_=T.normalized.safe,C=M.normalized.safe,F=Math.acos(xe(-1,1,_.dot(C))),E=Math.tan(F/2),A=Math.sin(F/2),S=Math.min(e,E*T.magnitude*(n===2?1:.5),E*M.magnitude*(n===a.length-1?1:.5)),te=A===0?0:S/A,Z=E===0?0:S/E,H=_.add(C).scale(1/2).normalized.safe.scale(te).add(m),v=_.perpendicular.dot(C)<0,R=new fe(t,m.add(_.scale(Z))),j=new je(H,S,_.perpendicular.scale(v?1:-1),C.perpendicular.scale(v?-1:1),v);R.arcLength>0&&(r.segments.push(R),r.arcLength+=R.arcLength),j.arcLength>0&&(r.segments.push(j),r.arcLength+=j.arcLength),r.minSin=Math.min(r.minSin,Math.abs(A)),t=m.add(C.scale(Z))}const o=new fe(t,a[a.length-1]);return o.arcLength>0&&(r.segments.push(o),r.arcLength+=o.arcLength),r}function Ne(a){return a.reduce((e,i,r)=>r?e+a[r-1].sub(i).magnitude:0,0)}function re(a,e,i){const r=a.length;let t=0;for(let o=0;o<e.length;o+=1){const n=a[(i+o)%r],d=e[o];t+=n.sub(d).squaredMagnitude}return t}function Fe(a,e,i){const r=[];if(i===0)return[...a];if(i===1)return[...e];for(let t=0;t<a.length;t++){const o=a[t],n=e[t];r.push(ee.lerp(o,n,i))}return r}var J=function(a,e,i,r){var t=arguments.length,o=t<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,i):r,n;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(a,e,i,r);else for(var d=a.length-1;d>=0;d--)(n=a[d])&&(o=(t<3?n(o):t>3?n(e,i,o):n(e,i))||o);return t>3&&o&&Object.defineProperty(e,i,o),o},ae;let P=ae=class extends Le{static rotatePoints(e,i,r){if(r){let t=1/0,o=0;for(let n=0;n<e.length;n+=1){const d=re(e,i,n);d<t&&(t=d,o=n)}if(o){const n=e.splice(0,o);e.splice(e.length,0,...n)}}else{const t=re(e,i,0),o=[...e].reverse();re(o,i,0)<t&&e.reverse()}}static distributePoints(e,i){if(e.length===0){for(let d=0;d<i;d++)e.push(ee.zero);return}if(e.length===1){const d=e[0];for(let m=0;m<i;m++)e.push(d);return}const r=e.length+i,t=Ne(e);let o=t===0?0:i/t,n=0;for(;e.length<r;){const d=r-e.length;if(n+1>=e.length){o=t===0?0:d/t,n=0;continue}const m=e[n],z=e[n+1],T=m.sub(z).magnitude;let M=Math.min(Math.round(T*o),d)+1;t===0&&(M=2);for(let _=1;_<M;_++)e.splice(++n,0,ee.lerp(m,z,_/M));n++}}*tweenPoints(e,i,r){const t=[...this.parsedPoints()],o=this.parsePoints(le(e)),n=this.closed(),d=t.length-o.length;ae.distributePoints(d<0?t:o,Math.abs(d)),ae.rotatePoints(o,t,n),this.tweenedPoints(t),yield*We(i,m=>{const z=r(m);this.tweenedPoints(Fe(t,o,z))},()=>{this.tweenedPoints(null),this.points(e)})}constructor(e){super(e),this.tweenedPoints=ie(null),e.children===void 0&&e.points===void 0&&ze().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;</code></pre><p>Alternatively, you can define the points using the children:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;</code></pre><p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;</code></pre>`,inspect:this.key})}childrenBBox(){let e=this.tweenedPoints();if(!e){const i=this.points();e=i?i.map(r=>new ee(le(r))):this.children().filter(r=>!(r instanceof B)||r.isLayoutRoot()).map(r=>r.position())}return Me.fromPoints(...e)}parsedPoints(){return this.parsePoints(this.points())}profile(){return Ie(this.tweenedPoints()??this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const e=this.radius(),i=this.lineJoin();let r=super.lineWidthCoefficient();if(e===0&&i==="miter"){const{minSin:t}=this.profile();t>0&&(r=Math.max(r,.5/t))}return r}drawOverlay(e,i){const r=this.childrenBBox().transformCorners(i),o=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(i);e.fillStyle="white",e.strokeStyle="black",e.lineWidth=1;const n=new Path2D,d=(this.tweenedPoints()??this.parsedPoints()).map(m=>m.transformAsPoint(i));if(d.length>0){Ae(n,d[0]);for(const m of d)Se(n,m),e.beginPath(),ve(e,m,4),e.closePath(),e.fill(),e.stroke()}e.strokeStyle="white",e.stroke(n),e.beginPath(),Re(e,o),e.stroke(),e.beginPath(),De(e,r),e.closePath(),e.stroke()}parsePoints(e){return e?e.map(i=>new ee(le(i))):this.children().map(i=>i.position())}};J([we(0),ke()],P.prototype,"radius",void 0);J([we(null),ke()],P.prototype,"points",void 0);J([Te()],P.prototype,"tweenPoints",null);J([de()],P.prototype,"childrenBBox",null);J([de()],P.prototype,"parsedPoints",null);J([de()],P.prototype,"profile",null);P=ae=J([Ce("Line")],P);let he;he??(he=new qe("mergePhase",!1));he.loadData({version:0,timeEvents:[],seed:2990217251});const Je=he,h={...Ve};h.boxWidth/=1.2;h.boxGap/=1.5;function Q(a,e,i){return()=>a().topLeft().addX(e*i)}function ye(a,e,i){return()=>a().bottomLeft().addX(e*i)}function He(a,e,i,r,t,o=4*h.outlineMargin,n=2*h.boxWidth,d=1){return[s(B,{ref:r,opacity:d,topLeft:()=>a().bottomLeft().addX(-n/2).addY(o),width:e*D(h)-h.boxGap,height:()=>a().height()}),s(B,{ref:t,opacity:d,topRight:()=>a().bottomRight().addX(n/2).addY(o),width:i*D(h)-h.boxGap,height:()=>a().height()})]}function be(a,e){return ce(a().children().length-1).map(i=>s(P,{points:[a().children()[i].right().transformAsPoint(a().localToParent()),a().children()[i+1].left().transformAsPoint(a().localToParent())],...e}))}const U=Be(function*(a){const e=ue().variables.get("seed",42),i=ue().variables.get("size",7)(),r=Oe(e()),t=Math.floor(i/2);let o=ce(i).map(c=>r.nextInt(1,99));const n=[],d=y(),m=y(),z=y(),T=y(),M=y(),_=y();a.fill(l.background),a.add(s(B,{ref:d,opacity:1,width:o.length*D(h)-h.boxGap,y:-a.height()/2+h.boxWidth+2*h.outlineMargin,height:h.boxWidth})),a.add(He(d,t,o.length-t,z,M)),a.add([oe(d,m,l.surface,h.outlineMargin,1),oe(z,T,l.cyan,h.outlineMargin,1),oe(M,_,l.yellow,h.outlineMargin,1)]),T().fill(new b(l.cyan).desaturate(.5).alpha(.1)),_().fill(new b(l.yellow).desaturate(.5).alpha(.1)),a.add(ce(o.length).map(c=>s(W,{ref:Ee(n,c),size:h.boxWidth,lineWidth:h.boxStrokeWidth,stroke:l.surface,fill:l.background,radius:h.boxRadius,topLeft:Q(d,c,D(h)),alignItems:"center",justifyContent:"center",children:s(f,{text:o[c].toString(),...u})})));const C=y(),F=y(),E=y();a.add(Array.from(Ge([C,F,E],[l.cyan,l.yellow,l.pink])).map(([c,p])=>s(x,{ref:c,fill:p,stroke:new b(p).darken(2),size:20,lineWidth:4,opacity:0})));const A=y(),S=y(),te=y(),Z=y(),H=y(),v=y(),R=y(),j=y(),V=y(),X={lineWidth:5,stroke:l.white,radius:10,padding:new Xe(5,15),layout:!0,alignItems:"center",justifyContent:"center"},G={lineWidth:5,stroke:l.white,lineDash:[5,5],radius:5};a.add(s(B,{ref:A,children:[s(W,{ref:S,...X,x:-600,y:200,children:[s(B,{ref:te,width:20,padding:[0,30]}),s(f,{ref:H,text:"<",...u,padding:[0,20],opacity:0}),s(B,{ref:Z,width:20,padding:[0,30]})]}),s(B,{ref:v,layout:!0,gap:40,left:()=>S().right().addX(100).addY(-70),children:[s(W,{...X,opacity:.5,children:[s(f,{text:"[",...u}),s(x,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:20,lineWidth:5}),s(f,{text:"] < [",...u}),s(x,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:20,lineWidth:5}),s(f,{text:"]",...u})]}),s(W,{...X,opacity:.5,children:[s(f,{text:"[",...u}),s(x,{fill:l.pink,stroke:new b(l.pink).darken(2),size:20,lineWidth:5}),s(f,{text:"] = [",...u}),s(x,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:20,lineWidth:5}),s(f,{text:"]",...u})]}),s(W,{...X,opacity:.5,children:[s(x,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:20,lineWidth:5}),s(f,{text:" + 1",...u,padding:[0,20]})]})]}),s(P,{points:[S().right(),v().left()],...G}),s(B,{ref:R,layout:!0,gap:40,left:()=>S().right().addX(100).addY(70),children:[s(W,{...X,opacity:.5,children:[s(f,{text:"[",...u}),s(x,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:20,lineWidth:5}),s(f,{text:"] > [",...u}),s(x,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:20,lineWidth:5}),s(f,{text:"]",...u})]}),s(W,{...X,opacity:.5,children:[s(f,{text:"[",...u}),s(x,{fill:l.pink,stroke:new b(l.pink).darken(2),size:20,lineWidth:5}),s(f,{text:"] = [",...u}),s(x,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:20,lineWidth:5}),s(f,{text:"]",...u})]}),s(W,{...X,opacity:.5,children:[s(x,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:20,lineWidth:5}),s(f,{text:" + 1",...u,padding:[0,20]})]})]}),s(P,{points:()=>[S().right(),R().left()],...G}),s(W,{ref:V,...X,opacity:.5,left:()=>v().right().addX(100).addY(70),children:[s(x,{fill:l.pink,stroke:new b(l.pink).darken(2),size:20,lineWidth:5}),s(f,{text:" + 1",...u,padding:[0,20]})]}),s(P,{...G,points:()=>[v().childAs(2).right().transformAsPoint(v().localToParent()),V().left()]}),s(P,{...G,points:()=>[R().childAs(2).right().transformAsPoint(R().localToParent()),V().left]}),s(B,{ref:j,opacity:.5,children:[s(W,{...X,position:R().bottom().addY(100),children:[s(f,{text:"While",...u,padding:[0,20]}),s(x,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:20,lineWidth:5}),s(f,{text:"< size(",...u,paddingLeft:20}),s(W,{fill:l.cyan,stroke:new b(l.cyan).darken(2),size:[60,30],radius:10,lineWidth:5}),s(f,{text:") &&",...u,paddingRight:20}),s(x,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:20,lineWidth:5}),s(f,{text:"< size(",...u,paddingLeft:20}),s(W,{fill:l.yellow,stroke:new b(l.yellow).darken(2),size:[60,30],radius:10,lineWidth:5}),s(f,{text:")",...u})]}),s(P,{...G,radius:200,points:()=>[V().bottom(),[V().bottom().x,j().childAs(0).right().y],j().childAs(0).right()]}),s(P,{...G,radius:200,endArrow:!0,points:()=>[j().childAs(0).left(),[S().bottom().x,j().childAs(0).left().y],S().bottom()]})]})]})),A().add(be(v,G)),A().add(be(R,G)),yield*k(O(.1,...n.slice(0,t).map(c=>c.stroke(l.cyan,.1))),O(.1,...n.slice(t).map(c=>c.stroke(l.yellow,.1)))),yield*k(O(.1,...n.slice(0,t).map((c,p)=>c.topLeft(Q(z,p,D(h)),.2))),O(.1,...n.slice(t).map((c,p)=>c.topLeft(Q(M,p,D(h)),.2))));{const c=ge([...me(o.slice(0,t)),...me(o.slice(t)).map(L=>L+t)]),p=n.map(L=>L.position());yield*k(...c.map((L,$)=>n[$].position(p[L],.2)));const I=[...n];c.forEach((L,$)=>n[L]=I[$]);const N=[...o];c.forEach((L,$)=>o[L]=N[$])}yield*k(O(.1,...n.slice(0,t).map(c=>c.stroke(l.surface,.1))),O(.1,...n.slice(t).map(c=>c.stroke(l.surface,.1)))),yield*k(...[T,_].map(c=>c().stroke(l.surface,.1)));const g=ie(0),w=ie(0),q=ie(0);C().position(()=>ye(z,Math.min(g(),t-1),D(h))().addX(h.boxWidth/2).addY(h.outlineMargin)),F().position(()=>ye(M,Math.min(w(),i-t-1),D(h))().addX(h.boxWidth/2).addY(h.outlineMargin)),E().position(()=>Q(d,Math.min(q(),i-1),D(h))().addX(h.boxWidth/2).addY(-h.outlineMargin)),yield*k(...[C,F,E].map(c=>c().opacity(1,.3)));let K=Array(i);for(;g()<t&&w()<i-t;){n[g()].save(),n[w()+t].save();const c=n[g()].childAs(0).clone(),p=n[w()+t].childAs(0).clone();c.position(n[g()].childAs(0).absolutePosition().transformAsPoint(a.worldToLocal())),p.position(n[w()+t].childAs(0).absolutePosition().transformAsPoint(a.worldToLocal())),a.add([c,p]),yield*k(n[g()].stroke(l.cyan,.3),n[w()+t].stroke(l.yellow,.3),c.absolutePosition(te().absolutePosition(),.3),c.fill(l.cyan,.3),p.absolutePosition(Z().absolutePosition(),.3),p.fill(l.yellow,.3));let I=o[g()]<o[w()+t];H().text(I?"<":">");const N=I?v:R;N().children().forEach(L=>L.save()),V().save(),yield*k(H().opacity(1,.3),N().children()[0].opacity(1,.3)),yield*se(.5),N().children()[1].save(),yield*N().children()[1].opacity(1,.3),yield*k(n[g()].restore(.3),n[w()+t].restore(.3),(I?n[g()]:n[w()+t]).topLeft(Q(d,q(),D(h)),.3)),yield*N().children()[2].opacity(1,.3),K[q()]=I?g():w()+t,yield*(I?g:w)((I?g:w)()+1,.3),yield*V().opacity(1,.3),q()<i-1&&(yield*q(q()+1,.3)),j().save(),yield*j().opacity(1,.3),g()<t&&w()<i-t||(yield*j().childAs(0).stroke(l.red,.3),yield*se(.5)),yield*k(H().opacity(0,.3),c.opacity(0,.3),p.opacity(0,.3),O(.1,...N().children().map(L=>L.restore(.3)),V().restore(.3),j().restore(.3))),c.remove(),p.remove(),yield*se(.5)}yield*k(A().opacity(0,.3),A().y(A().y()+50,.4)),A().remove();const Y=y();a.add(s(f,{...u,y:200,ref:Y,text:"Move remaining elements"})),Y().save(),Y().opacity(0),Y().y(Y().y()+50),yield*Y().restore(.3),yield*se(.5);const ne=g()<t?T:_;ne().save(),yield*ne().stroke(ne().stroke().brighten(4),.4),yield*ne().restore(.4);const pe=g()<t?n.slice(g(),t):n.slice(t+w());pe.forEach((c,p)=>K[q()+p]=g()<t?g()+p:t+w()+p),yield*k(O(.1,...pe.map((c,p)=>c.topLeft(Q(d,q()+p,D(h)),.4))),q(i,.2*(i-q())),g()<t?g(t,.2*(t-g())):w(i-t,.2*(i-t-w()))),yield*k(k(...[T,_].map(c=>c().opacity(0,.3))),k(...[C,F,E].map(c=>c().opacity(0,.3)))),yield*k(Y().opacity(0,.3),Y().y(Y().y()+50,.3),d().y(0,.3)),K=ge(K);const _e=[...n];K.forEach((c,p)=>n[c]=_e[p]);const Pe=[...o];K.forEach((c,p)=>o[c]=Pe[p]),yield*O(.1,...n.map(c=>c.fill(l.green,.3)))});U.name="mergePhase";Je.attach(U.meta);U.onReplaced??(U.onReplaced=new Ye(U.config));export{U as d};

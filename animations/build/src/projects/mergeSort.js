import{w as Y,i as Ge,g as qe,t as De,h as Ie,k as ze,C as Oe,l as ce,n as Be,o as ge,p as Fe,q as he,v as Ve,L as C,B as $e,x as Ne,y as Je,z as He,A as Ke,D as Qe,E as ve,F as Te,G as ke,H as Ue,M as ye,m as we,u as le,r as ee,j as a,b as xe,R as A,c as m,I as _,J as Ze,a as w,V as Pe,S as et,d as tt,f as nt,s as st}from"../../_virtual_settings-DVCYLlHS.js";import{u as Le,C as o,T as b,t as k,s as M}from"../../styles-DiP1wR1d.js";import{S as Ce,b as v,c as ae,p as fe}from"../../motion-DS7563LG.js";import{C as X}from"../../Circle-yd4S5mtU.js";function*Ee(e,t){yield*Y(e),Ge(t)?yield*t:t()}function it(e,t,a){const i={arcLength:0,segments:[],minSin:1};if(0===e.length)return i;if(a){const t=e[0].add(e[e.length-1]).scale(.5);e=[t,...e,t]}let n=e[0];for(let s=2;s<e.length;s++){const a=e[s-2],o=e[s-1],l=e[s],r=a.sub(o),d=l.sub(o),c=r.normalized.safe,p=d.normalized.safe,h=Math.acos(Ie(-1,1,c.dot(p))),y=Math.tan(h/2),f=Math.sin(h/2),u=Math.min(t,y*r.magnitude*(2===s?1:.5),y*d.magnitude*(s===e.length-1?1:.5)),g=0===f?0:u/f,m=0===y?0:u/y,w=c.add(p).scale(.5).normalized.safe.scale(g).add(o),b=c.perpendicular.dot(p)<0,k=new ze(n,o.add(c.scale(m))),x=new Oe(w,u,c.perpendicular.scale(b?1:-1),p.perpendicular.scale(b?-1:1),b);k.arcLength>0&&(i.segments.push(k),i.arcLength+=k.arcLength),x.arcLength>0&&(i.segments.push(x),i.arcLength+=x.arcLength),i.minSin=Math.min(i.minSin,Math.abs(f)),n=o.add(p.scale(m))}const o=new ze(n,e[e.length-1]);return o.arcLength>0&&(i.segments.push(o),i.arcLength+=o.arcLength),i}function at(e){return e.reduce(((t,a,i)=>i?t+e[i-1].sub(a).magnitude:0),0)}function me(e,t,a){const i=e.length;let n=0;for(let o=0;o<t.length;o+=1){const s=e[(a+o)%i],l=t[o];n+=s.sub(l).squaredMagnitude}return n}function ot(e,t,a){const i=[];if(0===a)return[...e];if(1===a)return[...t];for(let n=0;n<e.length;n++){const o=e[n],s=t[n];i.push(ce.lerp(o,s,a))}return i}qe(Ee,De());var ue,te=function(e,t,a,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,a):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,a,i);else for(var l=e.length-1;l>=0;l--)(n=e[l])&&(s=(o<3?n(s):o>3?n(t,a,s):n(t,a))||s);return o>3&&s&&Object.defineProperty(t,a,s),s};let _e,E=ue=class extends Be{static rotatePoints(e,t,a){if(a){let a=1/0,i=0;for(let n=0;n<e.length;n+=1){const o=me(e,t,n);o<a&&(a=o,i=n)}if(i){const t=e.splice(0,i);e.splice(e.length,0,...t)}}else{const a=me(e,t,0);me([...e].reverse(),t,0)<a&&e.reverse()}}static distributePoints(e,t){if(0===e.length){for(let a=0;a<t;a++)e.push(ce.zero);return}if(1===e.length){const a=e[0];for(let i=0;i<t;i++)e.push(a);return}const a=e.length+t,i=at(e);let n=0===i?0:t/i,o=0;for(;e.length<a;){const t=a-e.length;if(o+1>=e.length){n=0===i?0:t/i,o=0;continue}const s=e[o],l=e[o+1],r=s.sub(l).magnitude;let d=Math.min(Math.round(r*n),t)+1;0===i&&(d=2);for(let a=1;a<d;a++)e.splice(++o,0,ce.lerp(s,l,a/d));o++}}*tweenPoints(e,t,a){const i=[...this.parsedPoints()],n=this.parsePoints(ge(e)),o=this.closed(),s=i.length-n.length;ue.distributePoints(s<0?i:n,Math.abs(s)),ue.rotatePoints(n,i,o),this.tweenedPoints(i),yield*Fe(t,(e=>{const t=a(e);this.tweenedPoints(ot(i,n,t))}),(()=>{this.tweenedPoints(null),this.points(e)}))}constructor(e){super(e),this.tweenedPoints=he(null),void 0===e.children&&void 0===e.points&&Ve().warn({message:"No points specified for the line",remarks:'<p>The line won&#39;t be visible unless you specify at least two points:</p>\n<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>\n  stroke=<span class="hljs-string">&quot;#fff&quot;</span>\n  lineWidth={<span class="hljs-number">8</span>}\n  points={[\n    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],\n    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],\n  ]}\n/&gt;</code></pre><p>Alternatively, you can define the points using the children:</p>\n<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Line</span>&gt;</code></pre><p>If you did this intentionally, and want to disable this message, set the\n<code>points</code> property to <code>null</code>:</p>\n<pre class=""><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;</code></pre>',inspect:this.key})}childrenBBox(){let e=this.tweenedPoints();if(!e){const t=this.points();e=t?t.map((e=>new ce(ge(e)))):this.children().filter((e=>!(e instanceof C)||e.isLayoutRoot())).map((e=>e.position()))}return $e.fromPoints(...e)}parsedPoints(){return this.parsePoints(this.points())}profile(){return it(this.tweenedPoints()??this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const e=this.radius(),t=this.lineJoin();let a=super.lineWidthCoefficient();if(0===e&&"miter"===t){const{minSin:e}=this.profile();e>0&&(a=Math.max(a,.5/e))}return a}drawOverlay(e,t){const a=this.childrenBBox().transformCorners(t),i=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(t);e.fillStyle="white",e.strokeStyle="black",e.lineWidth=1;const n=new Path2D,o=(this.tweenedPoints()??this.parsedPoints()).map((e=>e.transformAsPoint(t)));if(o.length>0){Ne(n,o[0]);for(const t of o)Je(n,t),e.beginPath(),He(e,t,4),e.closePath(),e.fill(),e.stroke()}e.strokeStyle="white",e.stroke(n),e.beginPath(),Ke(e,i),e.stroke(),e.beginPath(),Qe(e,a),e.closePath(),e.stroke()}parsePoints(e){return e?e.map((e=>new ce(ge(e)))):this.children().map((e=>e.position()))}};te([ve(0),Te()],E.prototype,"radius",void 0),te([ve(null),Te()],E.prototype,"points",void 0),te([De()],E.prototype,"tweenPoints",null),te([ke()],E.prototype,"childrenBBox",null),te([ke()],E.prototype,"parsedPoints",null),te([ke()],E.prototype,"profile",null),E=ue=te([Ue("Line")],E),_e??(_e=new ye("mergeSort",!1)),_e.loadData({version:0,shared:{background:null,range:[0,null],size:{x:1920,y:1080},audioOffset:0},preview:{fps:30,resolutionScale:1},rendering:{fps:30,resolutionScale:.5,colorSpace:"srgb",exporter:{name:"@motion-canvas/core/image-sequence",options:{fileType:"image/png",quality:100,groupByScene:!1,fastStart:!0,includeAudio:!0}}}});const lt=_e;let We;We??(We=new ye("mergeSort_intro",!1)),We.loadData({version:0,timeEvents:[],seed:829095212});const rt=We;function oe(e){return e.map(((e,t)=>({value:e,index:t}))).sort(((e,t)=>e.value-t.value)).map((({index:e})=>e))}function de(e){let t=Array(e.length);for(let a=0;a<e.length;a++)t[e[a]]=a;return t}function*ct(...e){const t=e.map((e=>e[Symbol.iterator]()));for(;;){const e=t.map((e=>e.next()));if(e.some((({done:e})=>e)))break;yield e.map((({value:e})=>e))}}const Q=we((function*(e){const t=le().variables.get("seed",42),i=le().variables.get("size",7),n=Le(t()),s=ee(i()).map((e=>n.nextInt(1,70))),l=Math.floor(i()/2),r=[],d=m(),c=m(),p=m(),h=16,y=128,f=156;e.fill(o.background),e.add(ee(s.length).map((e=>a(A,{ref:xe(r,e),size:y,lineWidth:8,stroke:o.surface,fill:o.background,radius:4,x:-156*(s.length-1)/2+f*e,alignItems:"center",justifyContent:"center",children:a(b,{text:s[e].toString(),...k})})))),e.add(a(Ze,{children:[a(A,{ref:d,stroke:o.surface,lineWidth:6,radius:8,opacity:0,width:s.length*f-28+32,height:160}),a(A,{ref:c,stroke:o.cyan,lineWidth:6,radius:8,opacity:0,topLeft:()=>[d().left().x-y,d().bottomRight().y+32],width:l*f-28+32,height:160,fill:new _(o.cyan).desaturate(.5).alpha(.1)}),a(A,{ref:p,stroke:o.yellow,lineWidth:6,radius:8,opacity:0,topRight:()=>[d().right().x+y,d().bottomRight().y+32],width:(s.length-l)*f-28+32,height:160,fill:new _(o.yellow).desaturate(.5).alpha(.1)})]})),yield*Y(.5),yield*w(M(.1,...r.slice(0,l).map((e=>e.stroke(o.cyan,.1)))),M(.1,...r.slice(l).map((e=>e.stroke(o.yellow,.1))))),yield*Y(.5);yield*w(d().y(d().y()-96,.3),...r.map((e=>e.y(e.y()-96,.3))),d().opacity(1,.3),Ee(.1,w(c().opacity(1,.3),p().opacity(1,.3))));const u=r.map((e=>e.position()));yield*w(M(.3,...r.slice(0,l).map(((e,t)=>e.topLeft(c().topLeft().addY(h).addX(h+f*t),.4)))),M(.3,...r.slice(l).map(((e,t)=>e.topLeft(p().topLeft().addY(h).addX(h+f*t),.4)))));const g=r.map((e=>e.position())),x=de([...oe(s.slice(0,l)),...oe(s.slice(l)).map((e=>e+l))]);yield*M(.1,...x.map(((e,t)=>r[t].position(g[e],.3)))),yield*Y(.5);const P=[...r];x.forEach(((e,t)=>r[e]=P[t]));const v=[...s];x.forEach(((e,t)=>s[e]=v[t]));const W=de(oe(s));{const e=r.slice();W.forEach(((t,a)=>r[t]=e[a]))}yield*M(.2,...r.map(((e,t)=>e.position(u[t],.3)))),yield*Y(.5),yield*w(d().y(d().y()+96,.3),...r.map((e=>e.y(e.y()+96,.3))),d().opacity(0,.3),c().opacity(0,.3),p().opacity(0,.3),...r.map((e=>e.stroke(o.surface,.3)))),yield*w(c().opacity(0,.3),p().opacity(0,.3),d().opacity(0,.3)),yield*M(.1,...r.map((e=>e.fill(o.green,.3))))}));let je;Q.name="mergeSort_intro",rt.attach(Q.meta),Q.onReplaced??(Q.onReplaced=new Pe(Q.config)),je??(je=new ye("mergePhase",!1)),je.loadData({version:0,timeEvents:[],seed:2990217251});const dt=je,y={...Ce};function ie(e,t,a){return()=>e().topLeft().addX(t*a)}function Re(e,t,a){return()=>e().bottomLeft().addX(t*a)}function pt(e,t,i,n,o,s=4*y.outlineMargin,l=2*y.boxWidth,r=1){return[a(C,{ref:n,opacity:r,topLeft:()=>e().bottomLeft().addX(-l/2).addY(s),width:t*v(y)-y.boxGap,height:()=>e().height()}),a(C,{ref:o,opacity:r,topRight:()=>e().bottomRight().addX(l/2).addY(s),width:i*v(y)-y.boxGap,height:()=>e().height()})]}function Ae(e,t){return ee(e().children().length-1).map((i=>a(E,{points:[e().children()[i].right().transformAsPoint(e().localToParent()),e().children()[i+1].left().transformAsPoint(e().localToParent())],...t})))}y.boxWidth/=1.2,y.boxGap/=1.5;const U=we((function*(e){const t=le().variables.get("seed",42),i=le().variables.get("size",7)(),n=Le(t()),s=Math.floor(i/2);let l=ee(i).map((e=>n.nextInt(1,99)));const r=[],d=m(),c=m(),p=m(),h=m(),f=m(),u=m();e.fill(o.background),e.add(a(C,{ref:d,opacity:1,width:l.length*v(y)-y.boxGap,y:-e.height()/2+y.boxWidth+2*y.outlineMargin,height:y.boxWidth})),e.add(pt(d,s,l.length-s,p,f)),e.add([ae(d,c,o.surface,y.outlineMargin,1),ae(p,h,o.cyan,y.outlineMargin,1),ae(f,u,o.yellow,y.outlineMargin,1)]),h().fill(new _(o.cyan).desaturate(.5).alpha(.1)),u().fill(new _(o.yellow).desaturate(.5).alpha(.1)),e.add(ee(l.length).map((e=>a(A,{ref:xe(r,e),size:y.boxWidth,lineWidth:y.boxStrokeWidth,stroke:o.surface,fill:o.background,radius:y.boxRadius,topLeft:ie(d,e,v(y)),alignItems:"center",justifyContent:"center",children:a(b,{text:l[e].toString(),...k})}))));const g=m(),x=m(),P=m();e.add(Array.from(ct([g,x,P],[o.cyan,o.yellow,o.pink])).map((([e,t])=>a(X,{ref:e,fill:t,stroke:new _(t).darken(2),size:20,lineWidth:4,opacity:0}))));const W=m(),L=m(),j=m(),z=m(),S=m(),R=m(),D=m(),I=m(),T=m(),q={lineWidth:5,stroke:o.white,radius:10,padding:new et(5,15),layout:!0,alignItems:"center",justifyContent:"center"},G={lineWidth:5,stroke:o.white,lineDash:[5,5],radius:5};e.add(a(C,{ref:W,children:[a(A,{ref:L,...q,x:-600,y:200,children:[a(C,{ref:j,width:20,padding:[0,30]}),a(b,{ref:S,text:"<",...k,padding:[0,20],opacity:0}),a(C,{ref:z,width:20,padding:[0,30]})]}),a(C,{ref:R,layout:!0,gap:40,left:()=>L().right().addX(100).addY(-70),children:[a(A,{...q,opacity:.5,children:[a(b,{text:"[",...k}),a(X,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:20,lineWidth:5}),a(b,{text:"] < [",...k}),a(X,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:20,lineWidth:5}),a(b,{text:"]",...k})]}),a(A,{...q,opacity:.5,children:[a(b,{text:"[",...k}),a(X,{fill:o.pink,stroke:new _(o.pink).darken(2),size:20,lineWidth:5}),a(b,{text:"] = [",...k}),a(X,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:20,lineWidth:5}),a(b,{text:"]",...k})]}),a(A,{...q,opacity:.5,children:[a(X,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:20,lineWidth:5}),a(b,{text:" + 1",...k,padding:[0,20]})]})]}),a(E,{points:[L().right(),R().left()],...G}),a(C,{ref:D,layout:!0,gap:40,left:()=>L().right().addX(100).addY(70),children:[a(A,{...q,opacity:.5,children:[a(b,{text:"[",...k}),a(X,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:20,lineWidth:5}),a(b,{text:"] > [",...k}),a(X,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:20,lineWidth:5}),a(b,{text:"]",...k})]}),a(A,{...q,opacity:.5,children:[a(b,{text:"[",...k}),a(X,{fill:o.pink,stroke:new _(o.pink).darken(2),size:20,lineWidth:5}),a(b,{text:"] = [",...k}),a(X,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:20,lineWidth:5}),a(b,{text:"]",...k})]}),a(A,{...q,opacity:.5,children:[a(X,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:20,lineWidth:5}),a(b,{text:" + 1",...k,padding:[0,20]})]})]}),a(E,{points:()=>[L().right(),D().left()],...G}),a(A,{ref:T,...q,opacity:.5,left:()=>R().right().addX(100).addY(70),children:[a(X,{fill:o.pink,stroke:new _(o.pink).darken(2),size:20,lineWidth:5}),a(b,{text:" + 1",...k,padding:[0,20]})]}),a(E,{...G,points:()=>[R().childAs(2).right().transformAsPoint(R().localToParent()),T().left()]}),a(E,{...G,points:()=>[D().childAs(2).right().transformAsPoint(D().localToParent()),T().left]}),a(C,{ref:I,opacity:.5,children:[a(A,{...q,position:D().bottom().addY(100),children:[a(b,{text:"While",...k,padding:[0,20]}),a(X,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:20,lineWidth:5}),a(b,{text:"< size(",...k,paddingLeft:20}),a(A,{fill:o.cyan,stroke:new _(o.cyan).darken(2),size:[60,30],radius:10,lineWidth:5}),a(b,{text:") &&",...k,paddingRight:20}),a(X,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:20,lineWidth:5}),a(b,{text:"< size(",...k,paddingLeft:20}),a(A,{fill:o.yellow,stroke:new _(o.yellow).darken(2),size:[60,30],radius:10,lineWidth:5}),a(b,{text:")",...k})]}),a(E,{...G,radius:200,points:()=>[T().bottom(),[T().bottom().x,I().childAs(0).right().y],I().childAs(0).right()]}),a(E,{...G,radius:200,endArrow:!0,points:()=>[I().childAs(0).left(),[L().bottom().x,I().childAs(0).left().y],L().bottom()]})]})]})),W().add(Ae(R,G)),W().add(Ae(D,G)),yield*w(M(.1,...r.slice(0,s).map((e=>e.stroke(o.cyan,.1)))),M(.1,...r.slice(s).map((e=>e.stroke(o.yellow,.1))))),yield*w(M(.1,...r.slice(0,s).map(((e,t)=>e.topLeft(ie(p,t,v(y)),.2)))),M(.1,...r.slice(s).map(((e,t)=>e.topLeft(ie(f,t,v(y)),.2)))));{const e=de([...oe(l.slice(0,s)),...oe(l.slice(s)).map((e=>e+s))]),t=r.map((e=>e.position()));yield*w(...e.map(((e,a)=>r[a].position(t[e],.2))));const a=[...r];e.forEach(((e,t)=>r[e]=a[t]));const i=[...l];e.forEach(((e,t)=>l[e]=i[t]))}yield*w(M(.1,...r.slice(0,s).map((e=>e.stroke(o.surface,.1)))),M(.1,...r.slice(s).map((e=>e.stroke(o.surface,.1))))),yield*w(...[h,u].map((e=>e().stroke(o.surface,.1))));const B=he(0),U=he(0),Q=he(0);g().position((()=>Re(p,Math.min(B(),s-1),v(y))().addX(y.boxWidth/2).addY(y.outlineMargin))),x().position((()=>Re(f,Math.min(U(),i-s-1),v(y))().addX(y.boxWidth/2).addY(y.outlineMargin))),P().position((()=>ie(d,Math.min(Q(),i-1),v(y))().addX(y.boxWidth/2).addY(-y.outlineMargin))),yield*w(...[g,x,P].map((e=>e().opacity(1,.3))));let Z=Array(i);for(;B()<s&&U()<i-s;){r[B()].save(),r[U()+s].save();const t=r[B()].childAs(0).clone(),a=r[U()+s].childAs(0).clone();t.position(r[B()].childAs(0).absolutePosition().transformAsPoint(e.worldToLocal())),a.position(r[U()+s].childAs(0).absolutePosition().transformAsPoint(e.worldToLocal())),e.add([t,a]),yield*w(r[B()].stroke(o.cyan,.3),r[U()+s].stroke(o.yellow,.3),t.absolutePosition(j().absolutePosition(),.3),t.fill(o.cyan,.3),a.absolutePosition(z().absolutePosition(),.3),a.fill(o.yellow,.3));let n=l[B()]<l[U()+s];S().text(n?"<":">");const c=n?R:D;c().children().forEach((e=>e.save())),T().save(),yield*w(S().opacity(1,.3),c().children()[0].opacity(1,.3)),yield*Y(.5),c().children()[1].save(),yield*c().children()[1].opacity(1,.3),yield*w(r[B()].restore(.3),r[U()+s].restore(.3),(n?r[B()]:r[U()+s]).topLeft(ie(d,Q(),v(y)),.3)),yield*c().children()[2].opacity(1,.3),Z[Q()]=n?B():U()+s,yield*(n?B:U)((n?B:U)()+1,.3),yield*T().opacity(1,.3),Q()<i-1&&(yield*Q(Q()+1,.3)),I().save(),yield*I().opacity(1,.3),B()<s&&U()<i-s||(yield*I().childAs(0).stroke(o.red,.3),yield*Y(.5)),yield*w(S().opacity(0,.3),t.opacity(0,.3),a.opacity(0,.3),M(.1,...c().children().map((e=>e.restore(.3))),T().restore(.3),I().restore(.3))),t.remove(),a.remove(),yield*Y(.5)}yield*w(W().opacity(0,.3),W().y(W().y()+50,.4)),W().remove();const O=m();e.add(a(b,{...k,y:200,ref:O,text:"Move remaining elements"})),O().save(),O().opacity(0),O().y(O().y()+50),yield*O().restore(.3),yield*Y(.5);const N=B()<s?h:u;N().save(),yield*N().stroke(N().stroke().brighten(4),.4),yield*N().restore(.4);const H=B()<s?r.slice(B(),s):r.slice(s+U());H.forEach(((e,t)=>Z[Q()+t]=B()<s?B()+t:s+U()+t)),yield*w(M(.1,...H.map(((e,t)=>e.topLeft(ie(d,Q()+t,v(y)),.4)))),Q(i,.2*(i-Q())),B()<s?B(s,.2*(s-B())):U(i-s,.2*(i-s-U()))),yield*w(w(...[h,u].map((e=>e().opacity(0,.3)))),w(...[g,x,P].map((e=>e().opacity(0,.3))))),yield*w(O().opacity(0,.3),O().y(O().y()+50,.3),d().y(0,.3)),Z=de(Z);const J=[...r];Z.forEach(((e,t)=>r[e]=J[t]));const V=[...l];Z.forEach(((e,t)=>l[e]=V[t])),yield*M(.1,...r.map((e=>e.fill(o.green,.3))))}));let Se;U.name="mergePhase",dt.attach(U.meta),U.onReplaced??(U.onReplaced=new Pe(U.config)),Se??(Se=new ye("recursiveMergeSort",!1)),Se.loadData({version:0,timeEvents:[],seed:3180500438});const ht=Se,P={...Ce};function ft(e,t,i,n,o,s=4*P.outlineMargin,l=2*P.boxWidth,r=1){return[a(C,{ref:n,opacity:r,topLeft:e().bottomLeft().addX(-l/2).addY(s),width:t*v(P)-P.boxGap,height:()=>e().height()}),a(C,{ref:o,opacity:r,topRight:e().bottomRight().addX(l/2).addY(s),width:i*v(P)-P.boxGap,height:()=>e().height()})]}function*be(e,t,i,n,s,l,r=0,d=null){if(i<=1)return yield s.stroke(o.green,.5),void(yield*Y(.5));yield null==d?void 0:d.save(),yield null==d?void 0:d.stroke(d.stroke().alpha(.3),.3),yield s.stroke(o.blue,.3);let c=Math.floor(i/2);const p=m(),h=m(),y=m(),f=m();e.add(a(C,{layout:!0,direction:"column",alignItems:"start",topLeft:()=>e.topLeft().transformAsPoint(e.worldToLocal()).add(50),children:[a(C,{layout:!0,margin:10,children:[a(b,{text:"Sorted Array:",...k,marginRight:50}),a(A,{size:[200,60],fill:new _(o.green).alpha(.02),stroke:o.green,radius:10,lineWidth:6})]}),a(C,{layout:!0,margin:10,children:[a(b,{text:"Current Array:",...k,marginRight:20}),a(A,{size:[200,60],fill:new _(o.blue).alpha(.02),stroke:o.blue,radius:10,lineWidth:6})]})]})),e.add(ft(n,c,i-c,p,y,4*P.outlineMargin,(Math.pow(t-r,2)+1)*P.outlineMargin)),e.add([ae(p,h,o.surface,P.outlineMargin,0),ae(y,f,o.surface,P.outlineMargin,0)]),p().y(p().y()+50),y().y(y().y()+50),yield*w(p().y(p().y()-50,.3),y().y(y().y()-50,.3),h().opacity(1,.3),f().opacity(1,.3)),yield*w(M(.1,...l.slice(0,c).map(((e,t)=>e.topLeft(fe(p,t,v(P)),.2)))),M(.1,...l.slice(c).map(((e,t)=>e.topLeft(fe(y,t,v(P)),.2))))),yield*be(e,t,c,p,h(),l.slice(0,c),r+1,s),yield*Y(.5),yield*be(e,t,i-c,y,f(),l.slice(c),r+1,s);const u=de(oe(l.map((e=>parseInt(e.childAs(0).text(),10)))));{const e=l.slice();u.forEach(((t,a)=>l[t]=e[a]))}yield*M(.2,...l.map(((e,t)=>e.topLeft(fe(n,t,v(P)),.3)))),yield*w(h().opacity(0,.3),f().opacity(0,.3)),yield*Y(.5),yield*s.stroke(o.green,.3),d&&(yield*d.restore(.3)),yield*Y(.5),[p,y,h,f].forEach((e=>e().remove()))}P.boxWidth/=1.2,P.boxGap/=1.5;const Z=we((function*(e){const t=le().variables.get("seed",42),i=le().variables.get("size",7)(),n=Le(t());let s=ee(i).map((e=>n.nextInt(1,99)));const l=[],r=m(),d=m();e.fill(o.background),e.add([a(C,{ref:r,opacity:1,width:s.length*v(P)-P.boxGap,height:P.boxWidth,y:-200}),ae(r,d,o.surface,P.outlineMargin,1)]),e.add(ee(s.length).map((e=>a(A,{ref:xe(l,e),size:P.boxWidth,lineWidth:P.boxStrokeWidth,stroke:o.surface,fill:o.background,radius:P.boxRadius,topLeft:fe(r,e,v(P)),alignItems:"center",justifyContent:"center",children:a(b,{text:s[e].toString(),...k})}))));const c=Math.ceil(Math.log2(i));yield*be(e,c,i,r,d(),l),yield*w(d().stroke(o.surface,.3),M(.1,...l.map((e=>e.fill(o.green,.3))))),yield*Y(1)}));Z.name="recursiveMergeSort",ht.attach(Z.meta),Z.onReplaced??(Z.onReplaced=new Pe(Z.config));const ut=tt({scenes:[Q,U,Z]}),wt=nt("mergeSort",{core:"3.17.2",two:"3.17.2",ui:"3.17.2",vitePlugin:"3.17.2"},[],ut,lt,st);export{wt as default};
"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[1594],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),d=s(n),c=a,k=d["".concat(u,".").concat(c)]||d[c]||m[c]||i;return n?r.createElement(k,o(o({ref:t},l),{},{components:n})):r.createElement(k,o({ref:t},l))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var p={};for(var u in t)hasOwnProperty.call(t,u)&&(p[u]=t[u]);p.originalType=e,p[d]="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9848:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const i={title:"S\xe9mantique et op\xe9rateurs",tags:["C++"],sidebar_position:2},o=void 0,p={unversionedId:"Lessons/S2/Operators",id:"Lessons/S2/Operators",title:"S\xe9mantique et op\xe9rateurs",description:"Nous avons appris au semestre 1 \xe0 d\xe9finir des structures. Cela permet de regrouper des donn\xe9es qui ont un lien entre elles. Par exemple, on peut cr\xe9er une structure Point qui contient les coordonn\xe9es d'un point dans un plan.",source:"@site/content/Lessons/S2/Operators.md",sourceDirName:"Lessons/S2",slug:"/Lessons/S2/Operators",permalink:"/Learn--cpp_programming/Lessons/S2/Operators",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",sidebarPosition:2,frontMatter:{title:"S\xe9mantique et op\xe9rateurs",tags:["C++"],sidebar_position:2}},u={},s=[{value:"Op\xe9rateurs",id:"op\xe9rateurs",level:2},{value:"\xc9galit\xe9",id:"\xe9galit\xe9",level:2},{value:"Definition libre ou membre",id:"definition-libre-ou-membre",level:3},{value:"R\xe9utilisation des op\xe9rateurs",id:"r\xe9utilisation-des-op\xe9rateurs",level:2},{value:"default et C++ 20",id:"default-et-c-20",level:2},{value:"Op\xe9rateurs d&#39;assignation compos\xe9s",id:"op\xe9rateurs-dassignation-compos\xe9s",level:2},{value:"Deux en un",id:"deux-en-un",level:3},{value:"Op\xe9rateurs de flux",id:"op\xe9rateurs-de-flux",level:2},{value:"Op\xe9rateurs d&#39;affectation par copie",id:"op\xe9rateurs-daffectation-par-copie",level:2},{value:"Quelques bonnes pratiques",id:"quelques-bonnes-pratiques",level:2},{value:"D&#39;autres op\xe9rateurs",id:"dautres-op\xe9rateurs",level:2},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],l={toc:s},d="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Nous avons appris au semestre 1 \xe0 d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"structures"),". Cela permet de regrouper des donn\xe9es qui ont un lien entre elles. Par exemple, on peut cr\xe9er une structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui contient les coordonn\xe9es d'un point dans un plan."),(0,a.kt)("p",null,"Nous avons aussi vu comment d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thodes")," pour utiliser la structure. Par exemple, on peut d\xe9finir une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"add")," qui permet d'ajouter deux ",(0,a.kt)("strong",{parentName:"p"},"points")," entre eux (en faisant la somme de leurs coordonn\xe9es respectives)."),(0,a.kt)("p",null,"On s\u2019aper\xe7oit avec cet exemple de structure ",(0,a.kt)("inlineCode",{parentName:"p"},"point")," que les structures permettent de cr\xe9er de nouveaux ",(0,a.kt)("em",{parentName:"p"},"types fondamentaux"),". On aimerait donc pouvoir manipuler ces structures comme si c'\xe9tait des types de base. Par exemple, on aimerait pouvoir ajouter deux ",(0,a.kt)("strong",{parentName:"p"},"points")," entre eux avec l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," au lieu d'appeler la m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"add"),"."),(0,a.kt)("p",null,"Nous allons d\xe9couvrir dans ce cours comment d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"op\xe9rateurs")," pour manipuler nos structures comme si elles \xe9taient des types de base."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Ce n'est pas toujours pertinent de le faire comme avec une structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Personne")," par exemple. On ne peut pas vraiment d\xe9finir un op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," pour ajouter deux personnes entre elles. Qu'est-ce que cela voudrait dire ? Dans ce cas, il est pr\xe9f\xe9rable de d\xe9finir des m\xe9thodes explicites.")),(0,a.kt)("h2",{id:"op\xe9rateurs"},"Op\xe9rateurs"),(0,a.kt)("p",null,"Les op\xe9rateurs sont des symboles qui permettent de manipuler des donn\xe9es. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," permet d'additionner deux nombres entre eux."),(0,a.kt)("p",null,"En C++, il est possible de d\xe9finir des op\xe9rateurs pour nos structures, c'est ce que l'on appelle la ",(0,a.kt)("strong",{parentName:"p"},"surcharge d'op\xe9rateurs"),". Cela permet ensuite d'utiliser l'op\xe9rateur sur nos structures sans devoir passer par une m\xe9thode."),(0,a.kt)("p",null,"Pour d\xe9finir un op\xe9rateur, on utilise le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"operator")," suivi du symbole de l'op\xe9rateur. Par exemple, pour d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),", on utilise ",(0,a.kt)("inlineCode",{parentName:"p"},"operator+"),"."),(0,a.kt)("p",null,"Par exemple, on peut d\xe9finir un op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet op\xe9rateur sur nos structures comme si elles \xe9taient des nombres."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nPoint operator+(Point const a, Point const b) {\n    return {a.x + b.x, a.y + b.y};\n}\n\nint main() {\n    Point a {1, 2};\n    Point b {3, 4};\n    Point c { a + b}; // c = {4, 6}\n}\n")),(0,a.kt)("h2",{id:"\xe9galit\xe9"},"\xc9galit\xe9"),(0,a.kt)("p",null,"Ce qui fait g\xe9n\xe9ralement sens pour une structure, c'est de pouvoir ",(0,a.kt)("strong",{parentName:"p"},"comparer")," deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont ",(0,a.kt)("strong",{parentName:"p"},"\xe9gaux")," ou non."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"D\xe8s que cela vous semble pertinent de d\xe9finir l'\xe9galit\xe9, c'est un ",(0,a.kt)("strong",{parentName:"p"},"indicateur")," qui permet d'identifier que la structure va \xeatre utilis\xe9e comme un type de base et que la surcharge d'op\xe9rateurs est pertinente.\nEn opposition aux structures qui sont plut\xf4t utilis\xe9es pour structurer le code, hi\xe9rarchiser les donn\xe9es (game manager, etc.) et qui ne n\xe9cessitent pas de surcharge d'op\xe9rateurs mais plut\xf4t des m\xe9thodes explicites.")),(0,a.kt)("p",null,"Pour \xeatre en mesure de d\xe9finir l\u2019\xe9galit\xe9, on doit respecter les conditions suivantes."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"a == a")," doit \xeatre vrai, c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"r\xe9flexivit\xe9"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"b")," de m\xeame type, si ",(0,a.kt)("inlineCode",{parentName:"li"},"a == b")," est ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", alors ",(0,a.kt)("inlineCode",{parentName:"li"},"b == a")," doit \xeatre ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"sym\xe9trie")," et la ",(0,a.kt)("strong",{parentName:"li"},"commutativit\xe9"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"b")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"c")," de m\xeame type, si ",(0,a.kt)("inlineCode",{parentName:"li"},"a == b")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"b == c")," sont ",(0,a.kt)("strong",{parentName:"li"},"vrais"),", alors ",(0,a.kt)("inlineCode",{parentName:"li"},"a == c")," doit \xeatre ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"transitivit\xe9"),".")),(0,a.kt)("p",null,"Pour d\xe9finir l'op\xe9rateur d'\xe9galit\xe9, on utilise ",(0,a.kt)("inlineCode",{parentName:"p"},"operator=="),". On peut ensuite utiliser cet op\xe9rateur sur nos structures de la m\xeame fa\xe7on que pour les types de base."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nbool operator==(Point const a, Point const b) {\n    return a.x == b.x && a.y == b.y;\n}\n\nint main() {\n    Point a {1, 2};\n    Point b {1, 2};\n    bool c { a == b}; // c = true\n}\n")),(0,a.kt)("h3",{id:"definition-libre-ou-membre"},"Definition libre ou membre"),(0,a.kt)("p",null,"On peut d\xe9finir l'op\xe9rateur d'\xe9galit\xe9 comme une ",(0,a.kt)("strong",{parentName:"p"},"fonction libre")," (en dehors de la d\xe9finition de la structure) ou comme une ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thode")," membre."),(0,a.kt)("p",null,"La diff\xe9rence est que dans le cas d'une m\xe9thode membre, le premier param\xe8tre est implicite et correspond \xe0 l'instance sur laquelle on appelle la m\xe9thode."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n    \n    bool operator==(Point const b) {\n        return x == b.x && y == b.y;\n    }\n};\n")),(0,a.kt)("p",null,"Cela a une influence sur la fa\xe7on dont on utilise l'",(0,a.kt)("strong",{parentName:"p"},"op\xe9rateur"),"."),(0,a.kt)("p",null,"Par exemple si l'on souhaite multiplier un point par un nombre, on peut d\xe9finir l'op\xe9rateur comme une m\xe9thode membre."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n    \n    Point operator*(int const a) {\n        return {x * a, y * a};\n    }\n};\n\nint main() {\n    Point a {1, 2};\n    Point b { a * 2}; // b = {2, 4}\n}\n")),(0,a.kt)("p",null,"Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas d\xe9finir l'op\xe9rateur comme une m\xe9thode membre car le premier param\xe8tre est implicite et correspond \xe0 l'instance sur laquelle on appelle la m\xe9thode."),(0,a.kt)("p",null,"Il faut donc d\xe9finir l'op\xe9rateur comme une fonction libre."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nPoint operator*(int const a, Point const b) {\n    return {a * b.x, a * b.y};\n}\n\nint main() {\n    Point a {1, 2};\n    Point b { 2 * a}; // b = {2, 4}\n}\n")),(0,a.kt)("p",null,"Les deux syntaxes sont donc valables, mais il faut garder en t\xeate que la syntaxe avec une m\xe9thode membre implique que le premier param\xe8tre est implicite et correspond \xe0 l'instance sur laquelle on appelle la m\xe9thode. Il y a plusieurs \xe9coles, en g\xe9n\xe9ral on pr\xe9f\xe8re la syntaxe avec une ",(0,a.kt)("strong",{parentName:"p"},"fonction libre")," concernant les op\xe9rateurs binaires (qui prennent deux param\xe8tres). Cela permet par exemple, dans le cas d'op\xe9rateurs binaires commutatifs (dans lequel l'ordre des param\xe8tres n'a pas d'importance), de d\xe9finir les deux op\xe9rateurs en fonction l'un de l'autre."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nPoint operator*(int const a, Point const b) {\n    return {a * b.x, a * b.y};\n}\n\nPoint operator*(Point const b, int const a) {\n    return a * b;\n}\n\nint main() {\n    Point a {1, 2};\n    Point b {2 * a}; // b = {2, 4}\n    Point c {a * 3}; // b = {3, 6}\n}\n")),(0,a.kt)("h2",{id:"r\xe9utilisation-des-op\xe9rateurs"},"R\xe9utilisation des op\xe9rateurs"),(0,a.kt)("p",null,"Je vous ai d\xe9j\xe0 parl\xe9 de l\u2019int\xe9r\xeat de la ",(0,a.kt)("strong",{parentName:"p"},"r\xe9utilisation")," avec les fonctions. C'est aussi valable pour les op\xe9rateurs."),(0,a.kt)("p",null,"L\u2019habitude que beaucoup prennent est de d\xe9finir les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", puis de d\xe9finir les autres en fonction de ces deux-l\xe0."),(0,a.kt)("p",null,"On va donc d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},">")," en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nbool operator==(Point a, Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\nbool operator!=(Point a, Point b) {\n    return !(a == b);\n}\n\nbool operator<(Point a, Point b) {\n    return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nbool operator>(Point a, Point b) {\n    return b < a;\n}\n")),(0,a.kt)("h2",{id:"default-et-c-20"},"default et C++ 20"),(0,a.kt)("p",null,"Il est parfois possible de d\xe9finir automatiquement certains op\xe9rateurs. Dans le cas de structures simples, on peut d\xe9finir automatiquement les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," avec le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"default"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n\n    bool operator==(Point const&) const = default;\n    bool operator!=(Point const&) const = default;\n};\n")),(0,a.kt)("p",null,"Cela permet de d\xe9finir automatiquement les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," en fonction des op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," de chaque membre de la structure."),(0,a.kt)("p",null,"Depuis ",(0,a.kt)("strong",{parentName:"p"},"C++20"),", il est m\xeame possible de d\xe9finir automatiquement l'op\xe9rateur d'\xe9galit\xe9 et les op\xe9rateurs de comparaison (",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,a.kt)("inlineCode",{parentName:"p"},">"),", ",(0,a.kt)("inlineCode",{parentName:"p"},">="),") d'un coup avec l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<=>")," (appel\xe9 ",(0,a.kt)("strong",{parentName:"p"},"three-way comparison operator"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n    \n    auto operator<=>(Point const&) const = default;\n};\n")),(0,a.kt)("p",null,"l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<=>")," est un op\xe9rateur qui permet de donner un ",(0,a.kt)("strong",{parentName:"p"},"ordre")," \xe0 une structure. Avec le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"default"),", on d\xe9l\xe8gue la d\xe9finition de l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<=>")," \xe0 chaque membre de la structure.\nOn d\xe9fini donc automatiquement l'ordre de la structure en fonction de l'ordre de chaque membre (dans notre cas, on compare d'abord ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," puis ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),")."),(0,a.kt)("p",null,"C'est tr\xe8s pratique dans le cas o\xf9 nos structures sont compos\xe9es de types de base ou de structures qui ont d\xe9j\xe0 des op\xe9rateurs de comparaison d\xe9finis."),(0,a.kt)("p",null,"Dans le cadre de ce cours nous allons d\xe9finir les op\xe9rateurs manuellement pour bien comprendre le principe. Mais dans la pratique, il est pr\xe9f\xe9rable d'utiliser ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," ou ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," avec ",(0,a.kt)("inlineCode",{parentName:"p"},"<=>")," si possible."),(0,a.kt)("h2",{id:"op\xe9rateurs-dassignation-compos\xe9s"},"Op\xe9rateurs d'assignation compos\xe9s"),(0,a.kt)("p",null,"Les op\xe9rateurs d'assignation compos\xe9s permettent de combiner une op\xe9ration et une assignation. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," permet d'additionner une valeur \xe0 une variable et de stocker le r\xe9sultat dans la variable."),(0,a.kt)("p",null,"Il est aussi possible de d\xe9finir des op\xe9rateurs d'assignation compos\xe9s pour nos structures. Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'additionner un point \xe0 un autre point et de stocker le r\xe9sultat dans le premier point."),(0,a.kt)("p",null,"Cela fait sens dans ce cas de les d\xe9finir comme des m\xe9thodes membres."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n\n    Point& operator+=(Point p) {\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n};\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"L'expression ",(0,a.kt)("inlineCode",{parentName:"p"},"*this")," peut sembler \xe9trange. ",(0,a.kt)("inlineCode",{parentName:"p"},"this")," est un pointeur sur l'instance courante. ",(0,a.kt)("inlineCode",{parentName:"p"},"*this")," est donc une r\xe9f\xe9rence sur l'instance courante.\nOn retourne une r\xe9f\xe9rence sur l'instance courante pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("p",{parentName:"admonition"},"Par exemple, on peut \xe9crire ",(0,a.kt)("inlineCode",{parentName:"p"},"a += b += c")," qui est \xe9quivalent \xe0 ",(0,a.kt)("inlineCode",{parentName:"p"},"a += (b += c)"),"."),(0,a.kt)("p",{parentName:"admonition"},"Cela nous permet d\u2019avoir le m\xeame comportement pour notre structure que s\u2019il s\u2019agissait d\u2019un type natif comme ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),".")),(0,a.kt)("h3",{id:"deux-en-un"},"Deux en un"),(0,a.kt)("p",null,"Pour chaque op\xe9rateur d'assignation compos\xe9, il existe un op\xe9rateur binaire (prenant deux param\xe8tres) correspondant. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," a pour op\xe9rateur binaire correspondant ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),"."),(0,a.kt)("p",null,"Dans un souci de r\xe9utilisation, on peut d\xe9finir l'op\xe9rateur binaire en fonction de l'op\xe9rateur d'assignation compos\xe9."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n\n    Point& operator+=(Point b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n};\n\nPoint operator+(Point a, Point const& b) {\n    a += b;\n    return a;\n}\n")),(0,a.kt)("p",null,"Ici le principe de passage par ",(0,a.kt)("strong",{parentName:"p"},"copie")," (ou par valeur) est important. Puisque le premier param\xe8tre est ",(0,a.kt)("strong",{parentName:"p"},"copi\xe9"),", on peut le modifier avec l\u2019op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," sans risque modifier l'instance originale. On obtient donc l'op\xe9rateur binaire ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," en fonction de l'op\xe9rateur d'assignation compos\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"+="),"."),(0,a.kt)("p",null,"L'avantage est que si l'on doit modifier ou corriger le comportement de l'addition, on n'a pas besoin de modifier l'op\xe9rateur binaire ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," puisqu'il est d\xe9fini en fonction de l'op\xe9rateur d'assignation compos\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"+="),"."),(0,a.kt)("h2",{id:"op\xe9rateurs-de-flux"},"Op\xe9rateurs de flux"),(0,a.kt)("p",null,"Les op\xe9rateurs de flux permettent de d\xe9finir comment afficher une structure ou la lire depuis un flux (comme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::cout")," ou ",(0,a.kt)("inlineCode",{parentName:"p"},"std::cin"),"). Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'afficher un point dans un flux."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nstd::ostream& operator<<(std::ostream& os, Point const& p) {\n    return os << '(' << p.x << \", \" << p.y << ')';\n}\n")),(0,a.kt)("p",null,"L'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," prend en premier param\xe8tre un flux de sortie (",(0,a.kt)("inlineCode",{parentName:"p"},"std::ostream&"),") et en deuxi\xe8me param\xe8tre un point (",(0,a.kt)("inlineCode",{parentName:"p"},"Point const&"),"). Il retourne le flux de sortie pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("detail",null,(0,a.kt)("summary",null,"op\xe9rateur `>>`"),(0,a.kt)("p",null,"Il existe aussi l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},">>")," qui permet de lire depuis un flux pour construire une structure."),(0,a.kt)("p",null,"Il se d\xe9finit ainsi:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::istream& operator>>(std::istream& is, Point& p) {\n    // gestion de la lecture\n\n    is >> p.x >> p.y;\n\n    if( /* Erreur, impossible de construire notre structure */ )\n    {\n        is.setstate(std::ios::failbit);\n    }\n    return is;\n\n}\n")),(0,a.kt)("p",null,"notez que dans ce cas il faut signaler si l\u2019entr\xe9e est invalide en mettant le flux dans un \xe9tat invalide avec ",(0,a.kt)("inlineCode",{parentName:"p"},"std::ios::failbit"),", ce qui permet \xe0 l\u2019utilisateur de faire ",(0,a.kt)("inlineCode",{parentName:"p"},"if (std::cin.fail())"),".")),(0,a.kt)("p",null,"Ces op\xe9rateurs s\u2019\xe9crivent toujours sous la forme libre car leur premier argument est toujours un flux. "),(0,a.kt)("h2",{id:"op\xe9rateurs-daffectation-par-copie"},"Op\xe9rateurs d'affectation par copie"),(0,a.kt)("p",null,"Parfois, on a besoin de copier une structure. Pas seulement \xe0 l'initialisation (dans ce cas l\xe0 on peut utiliser la syntaxe d'initialisation ",(0,a.kt)("inlineCode",{parentName:"p"},"{}"),"), mais on a besoin d'affecter une nouvelle valeur \xe0 une structure d\xe9j\xe0 existante."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Point const point { 3, 4 };\nPoint copie { 1, 1 };\n\n// ...\ncopie = point;\n")),(0,a.kt)("p",null,"Pour faire cela il faut d\xe9finir l'op\xe9rateur d'affectation par copie ",(0,a.kt)("inlineCode",{parentName:"p"},"="),". Cet op\xe9rateur est appel\xe9 quand on affecte une valeur \xe0 une structure d\xe9j\xe0 existante."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\nstruct Point {\n    int x;\n    int y;\n\n    Point& operator=(Point const& b) {\n        x = b.x;\n        y = b.y;\n        return *this;\n    }\n};\n")),(0,a.kt)("h2",{id:"quelques-bonnes-pratiques"},"Quelques bonnes pratiques"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Il est important de garder en t\xeate que la surcharge d'op\xe9rateurs est une ",(0,a.kt)("strong",{parentName:"p"},"facilit\xe9")," et non une ",(0,a.kt)("strong",{parentName:"p"},"n\xe9cessit\xe9"),". Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Il est aussi important de respecter la ",(0,a.kt)("strong",{parentName:"p"},"s\xe9mantique")," des op\xe9rateurs. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," doit faire une addition et non une soustraction. Si un op\xe9rateur a une s\xe9mantique d\xe9j\xe0 d\xe9finie pour un ",(0,a.kt)("strong",{parentName:"p"},"domaine"),", tenez vous-y.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Si la signification de l'op\xe9rateur n'est pas \xe9vidente et indiscutable, il faut \xe9viter de le surcharger. Il est pr\xe9f\xe9rable de d\xe9finir une m\xe9thode explicite dans les cas o\xf9 la s\xe9mantique n'est pas \xe9vidente. Si pour une raison ou une autre, vous devez surcharger un op\xe9rateur qui n'a pas de s\xe9mantique \xe9vidente, il faut le commenter absolument.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Enfin, certains op\xe9rateurs sont li\xe9s entre eux. Par exemple, si vous surchargez l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"=="),", il est conseill\xe9 de surcharger l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," (en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," si possible). De m\xeame, si vous surchargez l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", les utilisateurs de votre structure s'attendront \xe0 ce que les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},">"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<=")," et ",(0,a.kt)("inlineCode",{parentName:"p"},">=")," soient d\xe9finis \xe9galement."))),(0,a.kt)("h2",{id:"dautres-op\xe9rateurs"},"D'autres op\xe9rateurs"),(0,a.kt)("p",null,"On peut aussi surcharger les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"()")," pour d\xe9finir un acc\xe8s \xe0 un \xe9l\xe9ment de notre structure ou les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"--")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," pour d\xe9finir un incr\xe9ment ou un d\xe9cr\xe9ment."),(0,a.kt)("p",null,"Il existe de nombreux op\xe9rateurs que l'on peut surcharger mais le principe reste le m\xeame."),(0,a.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"On peut d\xe9finir des op\xe9rateurs pour nos structures, c'est ce que l'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"surcharge d'op\xe9rateurs"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour d\xe9finir un op\xe9rateur, on utilise le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"li"},"operator")," suivi du symbole de l'op\xe9rateur. Par exemple, pour d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+"),", on utilise ",(0,a.kt)("inlineCode",{parentName:"li"},"operator+"),"."),(0,a.kt)("li",{parentName:"ul"},"Les op\xe9rateurs permettent de donner du ",(0,a.kt)("strong",{parentName:"li"},"sens")," \xe0 nos structures et de les manipuler comme si elles \xe9taient des types de base. Cela donne de la ",(0,a.kt)("strong",{parentName:"li"},"s\xe9mantique")," \xe0 nos structures."),(0,a.kt)("li",{parentName:"ul"},"C'est int\xe9ressant de r\xe9utiliser les op\xe9rateurs entre eux. Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+")," en fonction de l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+="),"."),(0,a.kt)("li",{parentName:"ul"},"L'expression ",(0,a.kt)("inlineCode",{parentName:"li"},"*this")," permet de retourner une r\xe9f\xe9rence sur l'instance courante pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("li",{parentName:"ul"},"Il est important de garder en t\xeate que la surcharge d'op\xe9rateurs est une ",(0,a.kt)("strong",{parentName:"li"},"facilit\xe9")," et non une ",(0,a.kt)("strong",{parentName:"li"},"n\xe9cessit\xe9"),". Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est pr\xe9f\xe9rable de d\xe9finir une ",(0,a.kt)("strong",{parentName:"li"},"m\xe9thode")," avec un nom explicite."),(0,a.kt)("li",{parentName:"ul"},"On peut surcharger les op\xe9rateurs de flux ",(0,a.kt)("inlineCode",{parentName:"li"},"<<")," et ",(0,a.kt)("inlineCode",{parentName:"li"},">>")," pour d\xe9finir comment afficher une structure ou la lire depuis un flux."),(0,a.kt)("li",{parentName:"ul"},"Vous trouverez la page de documentation sur la surcharge d'op\xe9rateurs ",(0,a.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/language/operators"},"ici"),".")))}m.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[4714],{3905:(e,r,n)=>{n.d(r,{Zo:()=>p,kt:()=>b});var t=n(7294);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function u(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?u(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):u(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function i(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},u=Object.keys(e);for(t=0;t<u.length;t++)n=u[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(e);for(t=0;t<u.length;t++)n=u[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=t.createContext({}),o=function(e){var r=t.useContext(l),n=r;return e&&(n="function"==typeof e?e(r):s(s({},r),e)),n},p=function(e){var r=o(e.components);return t.createElement(l.Provider,{value:r},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},m=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,u=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=o(n),m=a,b=d["".concat(l,".").concat(m)]||d[m]||c[m]||u;return n?t.createElement(b,s(s({ref:r},p),{},{components:n})):t.createElement(b,s({ref:r},p))}));function b(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var u=n.length,s=new Array(u);s[0]=m;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var o=2;o<u;o++)s[o]=n[o];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7698:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>u,metadata:()=>i,toc:()=>o});var t=n(7462),a=(n(7294),n(3905));const u={title:"Arbres binaires",tags:["C++"]},s=void 0,i={unversionedId:"Lessons/S2/BinaryTree",id:"Lessons/S2/BinaryTree",title:"Arbres binaires",description:"Dans ce chapitre nous allons d\xe9couvrir une nouvelle structure de donn\xe9es: les arbres binaires.",source:"@site/content/Lessons/S2/BinaryTree.md",sourceDirName:"Lessons/S2",slug:"/Lessons/S2/BinaryTree",permalink:"/Learn--cpp_programming/Lessons/S2/BinaryTree",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",frontMatter:{title:"Arbres binaires",tags:["C++"]}},l={},o=[{value:"Profondeur d&#39;un noeud",id:"profondeur-dun-noeud",level:3},{value:"Hauteur d&#39;un arbre",id:"hauteur-dun-arbre",level:3},{value:"Arbres binaires",id:"arbres-binaires",level:2},{value:"Repr\xe9sentation d&#39;un arbre binaire",id:"repr\xe9sentation-dun-arbre-binaire",level:2},{value:"Structure par r\xe9cursivit\xe9",id:"structure-par-r\xe9cursivit\xe9",level:3},{value:"Structure par tableau",id:"structure-par-tableau",level:3},{value:"Parcours d&#39;un arbre binaire",id:"parcours-dun-arbre-binaire",level:2},{value:"Parcours en largeur",id:"parcours-en-largeur",level:3},{value:"Parcours en profondeur",id:"parcours-en-profondeur",level:3},{value:"Arbres binaires de recherche",id:"arbres-binaires-de-recherche",level:2},{value:"Insertion",id:"insertion",level:3},{value:"Recherche",id:"recherche",level:3},{value:"Suppression",id:"suppression",level:3},{value:"Une multitude d&#39;arbres binaires",id:"une-multitude-darbres-binaires",level:2},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],p={toc:o},d="wrapper";function c(e){let{components:r,...n}=e;return(0,a.kt)(d,(0,t.Z)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Dans ce chapitre nous allons d\xe9couvrir une nouvelle structure de donn\xe9es: les arbres binaires."),(0,a.kt)("p",null,"La notion d'",(0,a.kt)("strong",{parentName:"p"},"arbre")," est une notion tr\xe8s importante en informatique.\nUn arbre est une ",(0,a.kt)("strong",{parentName:"p"},"structure de donn\xe9es")," qui permet de repr\xe9senter des donn\xe9es ",(0,a.kt)("strong",{parentName:"p"},"hi\xe9rarchiques")," comme par exemple des dossiers et des fichiers dans un syst\xe8me de fichiers."),(0,a.kt)("p",null,"Un arbre est compos\xe9 de ",(0,a.kt)("strong",{parentName:"p"},"noeuds"),". Chaque noeud peut avoir un nombre quelconque de ",(0,a.kt)("strong",{parentName:"p"},"fils"),". Un noeud qui n'a pas de fils est appel\xe9 une ",(0,a.kt)("strong",{parentName:"p"},"feuille"),"."),(0,a.kt)("p",null,"Un arbre est compos\xe9 d'un ",(0,a.kt)("strong",{parentName:"p"},"noeud racine")," qui est le noeud de d\xe9part de l'arbre. Il est possible d'acc\xe9der \xe0 tous les autres noeuds de l'arbre \xe0 partir du noeud racine."),(0,a.kt)("mermaid",{value:"graph LR\n    A[Noeud A] --\x3e B[Noeud B]\n    A --\x3e C[Noeud C]\n    A --\x3e D[Noeud D]\n    B --\x3e E[Noeud E]\n    B --\x3e F[Noeud F]\n    C --\x3e G[Noeud G]\n    C --\x3e H[Noeud H]\n    C --\x3e I[Noeud I]\n    D --\x3e J[Noeud J]\n    D --\x3e K[Noeud K]\n    D --\x3e L[Noeud L]"}),(0,a.kt)("h3",{id:"profondeur-dun-noeud"},"Profondeur d'un noeud"),(0,a.kt)("p",null,"La ",(0,a.kt)("strong",{parentName:"p"},"profondeur")," d'un noeud est le nombre de noeuds qui le s\xe9parent du noeud racine. En consid\xe9rant que la profondeur du noeud racine est 1."),(0,a.kt)("p",null,"Dans notre exemple, la profondeur du noeud racine ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," est 1. La profondeur du noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," est 2. La profondeur du noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"E")," est 3. etc.."),(0,a.kt)("h3",{id:"hauteur-dun-arbre"},"Hauteur d'un arbre"),(0,a.kt)("p",null,"La ",(0,a.kt)("strong",{parentName:"p"},"hauteur")," d'un arbre est la profondeur maximale de ses noeuds. C'est \xe0 dire la profondeur du noeud le plus profond."),(0,a.kt)("h2",{id:"arbres-binaires"},"Arbres binaires"),(0,a.kt)("p",null,"Il existe plusieurs types d'arbres qui ont des propri\xe9t\xe9s diff\xe9rentes. On peut par exemple se limiter \xe0 un nombre maximum de fils par noeud, imposer un ordre sur les fils d'un noeud, ou encore imposer que chaque noeud ait un nombre fixe de fils."),(0,a.kt)("p",null,"C'est le cas des ",(0,a.kt)("strong",{parentName:"p"},"arbres binaires"),". Un ",(0,a.kt)("strong",{parentName:"p"},"arbre binaire")," est un arbre dont chaque noeud a au maximum deux fils. Un fils gauche et un fils droit."),(0,a.kt)("p",null,"C'est une structure de donn\xe9es tr\xe8s utilis\xe9e en informatique et c'est ce que nous allons \xe9tudier."),(0,a.kt)("h2",{id:"repr\xe9sentation-dun-arbre-binaire"},"Repr\xe9sentation d'un arbre binaire"),(0,a.kt)("h3",{id:"structure-par-r\xe9cursivit\xe9"},"Structure par r\xe9cursivit\xe9"),(0,a.kt)("p",null,"Pour repr\xe9senter un arbre binaire une solution qui peut sembler naturelle est d'utiliser une structure r\xe9cursive. C'est \xe0 dire une structure qui contient des \xe9l\xe9ments de son propre type."),(0,a.kt)("p",null,"En effet, n'importe quel noeud de l'arbre, peut \xeatre vu comme un sous arbre binaire dont la racine est ce noeud. Ce jeu de l'esprit permet de comprendre qu'un noeud ",(0,a.kt)("strong",{parentName:"p"},"pointe")," vers deux autres noeuds qui sont les fils gauche et droit de ce noeud."),(0,a.kt)("p",null,"Il peut ne pointer vers aucun noeud, dans ce cas il est une feuille. Sinon, ce noeud repr\xe9sente un embranchement de l'arbre."),(0,a.kt)("p",null,"Mais on peut se demander comment repr\xe9senter ce lien (qui peut ne pas exister dans le cas d'une feuille) entre un noeud et ses fils."),(0,a.kt)("p",null,"C'est l\xe0 qu'interviennent les ",(0,a.kt)("strong",{parentName:"p"},"pointeurs"),". On peut repr\xe9senter ce lien en utilisant des pointeurs vers les noeuds fils."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"On ne peut pas utiliser des ",(0,a.kt)("strong",{parentName:"p"},"r\xe9f\xe9rences")," car elles doivent \xeatre une ",(0,a.kt)("strong",{parentName:"p"},"r\xe9f\xe9rence vers")," un ",(0,a.kt)("strong",{parentName:"p"},"objet existant"),". Or, dans le cas d'une feuille, il n'y a pas de noeud fils.")),(0,a.kt)("p",null,"Le pointeur lui peut \xeatre nul, c'est \xe0 dire qu'il ne pointe vers aucun objet. C'est cette particularit\xe9 qui permet de repr\xe9senter le cas d'une feuille."),(0,a.kt)("p",null,"Voil\xe0 \xe0 quoi ressemble la ",(0,a.kt)("strong",{parentName:"p"},"structure")," que l'on va utiliser pour repr\xe9senter un ",(0,a.kt)("strong",{parentName:"p"},"arbre binaire"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Node {\n    int value;\n    Node* left;\n    Node* right;\n};\n")),(0,a.kt)("p",null,"Elle est compos\xe9e d'un entier qui repr\xe9sente la valeur du noeud (cela peut \xeatre n'importe quel type de donn\xe9e), et de deux pointeurs vers des noeuds qui repr\xe9sentent les fils gauche et droit."),(0,a.kt)("p",null,"C'est pratique mais cela s'accompagne des ",(0,a.kt)("strong",{parentName:"p"},"inconv\xe9nients des pointeurs"),". Il faut faire attention \xe0 ne pas avoir de fuites m\xe9moires (g\xe9rer l'allocation et la d\xe9sallocation de la m\xe9moire) et il faut faire attention \xe0 ne pas utiliser un pointeur qui ne pointe vers rien (pointeur nul)."),(0,a.kt)("p",null,"Exemple d'utilisation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Node* root { new Node {1, nullptr, nullptr}};\nroot->left = { new Node {2, nullptr, nullptr}};\nroot->right = { new Node {3, nullptr, nullptr}};\n\nroot->left->left = { new Node {4, nullptr, nullptr}};\n\ndelete root->left->left;\ndelete root->left;\ndelete root->right;\ndelete root;\n")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"\u26a0\ufe0f Il faut faire attention \xe0 d\xe9sallouer la m\xe9moire dans le bon ordre ! Si on d\xe9salloue le noeud racine avant ses fils, on ne pourra plus acc\xe9der aux fils pour les d\xe9sallouer. Cela provoque une ",(0,a.kt)("strong",{parentName:"p"},"fuite de m\xe9moire"),".")),(0,a.kt)("hr",null),(0,a.kt)("p",null,"On pourrait se limiter seulement \xe0 cette structure de ",(0,a.kt)("strong",{parentName:"p"},"noeud")," pour repr\xe9senter un ",(0,a.kt)("strong",{parentName:"p"},"arbre binaire"),". Mais cela peut \xeatre pratique d'avoir une structure d\xe9di\xe9e \xe0 l'arbre binaire qui contient un pointeur vers le noeud racine."),(0,a.kt)("p",null,"Cela permet de ne pas avoir \xe0 passer le noeud racine en param\xe8tre \xe0 chaque fois que l'on veut utiliser l'arbre. Cela permet aussi de mieux s\xe9parer les responsabilit\xe9s. La structure de l'arbre s'occupe de g\xe9rer ses noeuds (dont le noeud racine), et la structure du noeud n'est qu'une structure pour aider \xe0 repr\xe9senter l'arbre."),(0,a.kt)("p",null,"Par exemple on pourrait vouloir ajouter une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"insert")," \xe0 la structure d'arbre qui permet d'ajouter une ",(0,a.kt)("strong",{parentName:"p"},"valeur"),". Cette m\xe9thode va s'occuper de trouver le bon endroit pour ins\xe9rer le noeud dans l'arbre \xe0 partir du noeud racine. Cela permet aussi de g\xe9rer le cas o\xf9 l'on souhaite repr\xe9senter un arbre vide (qui n'a pas encore de noeud racine)."),(0,a.kt)("p",null,"Cela permet aussi de cacher la structure interne de l'arbre. On peut par exemple changer la structure interne ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")," (la structure de ",(0,a.kt)("strong",{parentName:"p"},"noeud"),") sans avoir \xe0 modifier le code qui l'utilise (la m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"insert")," par exemple). L'utilisateur de l'arbre n'a pas besoin de savoir comment est repr\xe9sent\xe9 l'arbre en interne, il n'est pas cens\xe9 manipuler directement les noeuds."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct BinaryTree {\n    Node* root;\n};\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null," Pointeurs intelligents "),(0,a.kt)("p",null,"Il existe des ",(0,a.kt)("strong",{parentName:"p"},"pointeurs intelligents")," qui permettent de g\xe9rer automatiquement la m\xe9moire. Ils sont d\xe9finis dans la biblioth\xe8que ",(0,a.kt)("inlineCode",{parentName:"p"},"<memory>"),"."),(0,a.kt)("p",null,"On pourrait se servir dans notre cas du pointeur intelligent ",(0,a.kt)("inlineCode",{parentName:"p"},"std::unique_ptr")," qui permet de g\xe9rer automatiquement la m\xe9moire d'un objet allou\xe9 dynamiquement."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Node {\n    int value;\n    std::unique_ptr<Node> left;\n    std::unique_ptr<Node> right;\n};\n")),(0,a.kt)("p",null,"On peut alors utiliser la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"std::make_unique")," pour cr\xe9er un objet allou\xe9 dynamiquement et initialiser les pointeurs intelligents."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::unique_ptr<Node> root { std::make_unique<Node>(1, nullptr, nullptr)};\nroot->left = std::make_unique<Node>(2, nullptr, nullptr);\nroot->right = std::make_unique<Node>(3, nullptr, nullptr);\n")),(0,a.kt)("p",null,"Cela permet de ne pas avoir \xe0 g\xe9rer la d\xe9sallocation de la m\xe9moire. La structure est automatiquement d\xe9sallou\xe9e lorsque le pointeur intelligent est d\xe9truit. Cela va se faire dans le bon ordre naturellement car pour d\xe9truire une structure, il faut d'abord d\xe9truire ses membres. Ses enfants seront donc d\xe9truits avant le noeud parent.")),(0,a.kt)("h3",{id:"structure-par-tableau"},"Structure par tableau"),(0,a.kt)("p",null,"Une autre fa\xe7on de repr\xe9senter un arbre binaire est d'utiliser un tableau. Cela peut sembler \xe9trange mais c'est possible."),(0,a.kt)("p",null,"On peut repr\xe9senter un arbre binaire en utilisant un tableau en utilisant la relation entre les indices du tableau et les noeuds de l'arbre."),(0,a.kt)("p",null,"On commence par num\xe9roter le noeud racine avec l'indice 0. Ensuite, on d\xe9finit une relation entre les indices des noeuds et les indices de leurs fils."),(0,a.kt)("p",null,"On d\xe9finit que le fils gauche d'un noeud d'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"i")," est le noeud d'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*i + 1"),". Et que le fils droit d'un noeud d'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"i")," est le noeud d'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*i + 2"),"."),(0,a.kt)("p",null,"Un exemple avec l'arbre suivant:"),(0,a.kt)("mermaid",{value:"graph LR\n    A --\x3e B\n    A --\x3e C\n    B --\x3e D\n    B --\x3e E\n    C --\x3e F\n    C --\x3e G"}),(0,a.kt)("p",null,"On peut repr\xe9senter cet arbre avec le tableau suivant:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"[A, B, C, D, E, F, G]\n")),(0,a.kt)("p",null,"En effet, le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," est \xe0 l'indice 0. Son fils gauche est le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," qui est \xe0 l'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*0 + 1 = 1"),". Son fils droit est le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"C")," qui est \xe0 l'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*0 + 2 = 2"),". Pour le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),"(d'indice 1) , son fils gauche est le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"D")," qui est \xe0 l'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*1 + 1 = 3"),". Son fils droit est le noeud ",(0,a.kt)("inlineCode",{parentName:"p"},"E")," qui est \xe0 l'indice ",(0,a.kt)("inlineCode",{parentName:"p"},"2*1 + 2 = 4"),". Etc..."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"On peut remarquer qu'il faut un tableau de taille ",(0,a.kt)("inlineCode",{parentName:"p"},"2^n - 1")," pour repr\xe9senter un arbre binaire complet de hauteur ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". C'est \xe0 dire un arbre binaire dont tous les niveaux sont remplis sauf \xe9ventuellement le dernier niveau qui peut ne pas \xeatre rempli.")),(0,a.kt)("p",null,"Dans le cas o\xf9 l'arbre n'est pas ",(0,a.kt)("strong",{parentName:"p"},"complet")," (c'est \xe0 dire que tous les noeuds n'ont pas forc\xe9ment deux fils), on peut avoir des trous dans le tableau. C'est \xe0 dire des cases du tableau qui ne sont pas utilis\xe9es."),(0,a.kt)("p",null,"Par exemple, pour l'arbre suivant:"),(0,a.kt)("mermaid",{value:"graph LR\n    A --\x3e B\n    A --\x3e C\n    C --\x3e D\n    C --\x3e E\n    E --\x3e F\n    D --\x3e H"}),(0,a.kt)("p",null,"On peut repr\xe9senter cet arbre avec le tableau suivant:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"[A, B, C, _, _, D, E, _, _, _, _, H, _, F, _]\n")),(0,a.kt)("p",null,"Cette repr\xe9sentation est int\xe9ressante car elle permet de repr\xe9senter un arbre binaire sans avoir \xe0 utiliser de pointeurs. Mais elle a aussi l'inconv\xe9nient de ne pas \xeatre tr\xe8s efficace quand l'arbre n'est compl\xe8tement rempli. En effet, on peut avoir beaucoup de trous dans le tableau. Cela peut \xeatre probl\xe9matique si l'arbre a une hauteur importante."),(0,a.kt)("p",null,"De plus il faut un moyen de repr\xe9senter les trous dans le tableau. On peut par exemple utiliser une valeur sp\xe9ciale qui ne peut pas \xeatre une valeur valide pour un noeud. Par exemple, on peut utiliser la valeur ",(0,a.kt)("inlineCode",{parentName:"p"},"-1")," pour repr\xe9senter un trou dans le tableau. Ou alors on peut utiliser ",(0,a.kt)("inlineCode",{parentName:"p"},"std::optional")," pour repr\xe9senter un noeud qui n'existe pas."),(0,a.kt)("h2",{id:"parcours-dun-arbre-binaire"},"Parcours d'un arbre binaire"),(0,a.kt)("p",null,"Il existe plusieurs fa\xe7ons de parcourir les diff\xe9rents noeuds d'un arbre binaire. On peut par exemple parcourir l'arbre en largeur ou en profondeur."),(0,a.kt)("p",null,"Donnons nous l'arbre suivant:"),(0,a.kt)("mermaid",{value:"graph LR\n    A --\x3e B\n    A --\x3e C\n    B --\x3e D\n    B --\x3e E\n    C --\x3e F\n    C --\x3e G"}),(0,a.kt)("h3",{id:"parcours-en-largeur"},"Parcours en largeur"),(0,a.kt)("p",null,"Le parcours en largeur consiste \xe0 parcourir l'arbre en commen\xe7ant par le noeud racine puis en parcourant les noeuds de ",(0,a.kt)("strong",{parentName:"p"},"chaque niveau")," de profondeur de l'arbre de gauche \xe0 droite."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Cela correspond \xe0 l'ordre dans lequel sont rang\xe9es les donn\xe9es lorsque l'on repr\xe9sente un arbre binaire par un tableau.")),(0,a.kt)("h3",{id:"parcours-en-profondeur"},"Parcours en profondeur"),(0,a.kt)("p",null,"Le parcours en profondeur consiste \xe0 parcourir l'arbre de la racine vers les feuilles par r\xe9cursion dans les ",(0,a.kt)("strong",{parentName:"p"},"sous-arbres")," gauche et droite. On peut parcourir l'arbre en profondeur de diff\xe9rentes fa\xe7ons:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"pr\xe9fixe")," (ou ",(0,a.kt)("strong",{parentName:"li"},"pr\xe9-ordre"),"): on parcourt d'abord le noeud racine, puis le sous-arbre gauche et enfin le sous-arbre droit."),(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"infixe")," (ou ",(0,a.kt)("strong",{parentName:"li"},"sym\xe9trique"),"): on parcourt d'abord le sous-arbre gauche, puis le noeud racine et enfin le sous-arbre droit."),(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"postfixe")," (ou ",(0,a.kt)("strong",{parentName:"li"},"post-ordre"),"): on parcourt d'abord le sous-arbre gauche, puis le sous-arbre droit et enfin le noeud racine.")),(0,a.kt)("p",null,"Exemple de parcours Pour l'arbre suivant:"),(0,a.kt)("mermaid",{value:"graph LR\n    A --\x3e B\n    A --\x3e C\n    B --\x3e D\n    B --\x3e E\n    C --\x3e F\n    C --\x3e G"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Parcours en ",(0,a.kt)("strong",{parentName:"li"},"largeur"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"A B C D E F G")),(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"pr\xe9fixe"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"A B D E C F G")),(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"infixe"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"D B E A F C G")),(0,a.kt)("li",{parentName:"ul"},"Parcours en profondeur ",(0,a.kt)("strong",{parentName:"li"},"postfixe"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"D E B F G C A"))),(0,a.kt)("h2",{id:"arbres-binaires-de-recherche"},"Arbres binaires de recherche"),(0,a.kt)("p",null,"Une fois que l'on a vu comment repr\xe9senter un arbre binaire, on peut se demander \xe0 quoi cela peut servir. On peut par exemple se demander comment faire une recherche efficace dans un arbre binaire."),(0,a.kt)("p",null,"Un ",(0,a.kt)("strong",{parentName:"p"},"arbre binaire de recherche")," est un ",(0,a.kt)("strong",{parentName:"p"},"arbre binaire")," qui \xe0 la particularit\xe9 d'\xeatre ",(0,a.kt)("strong",{parentName:"p"},"ordonn\xe9"),". On va imposer un ordre sur les valeurs des noeuds de l'arbre."),(0,a.kt)("p",null,"Dans notre cas on va imposer que pour chaque noeud, toutes les valeurs des noeuds du ",(0,a.kt)("strong",{parentName:"p"},"sous-arbre gauche")," sont ",(0,a.kt)("strong",{parentName:"p"},"inf\xe9rieures")," \xe0 la valeur du noeud et toutes les valeurs des noeuds du ",(0,a.kt)("strong",{parentName:"p"},"sous-arbre droit")," sont ",(0,a.kt)("strong",{parentName:"p"},"sup\xe9rieures")," \xe0 la valeur du noeud."),(0,a.kt)("p",null,"Le premier \xe9l\xe9ment ins\xe9r\xe9 dans l'arbre devient la racine. Ensuite, il suffit de mettre \xe0 gauche les \xe9l\xe9ments plus petits et \xe0 droite les \xe9l\xe9ments plus grands. C'est cette particularit\xe9 qui rend les arbres binaires de recherche int\xe9ressants."),(0,a.kt)("p",null,"Cela permet de faire des recherches efficaces dans l'arbre. Gr\xe2ce \xe0 la relation d'ordre entre les noeuds, on peut savoir dans quel sous-arbre se trouve la valeur recherch\xe9e et effectuer une recherche rappelant le fonctionnement de la recherche dichotomique."),(0,a.kt)("h3",{id:"insertion"},"Insertion"),(0,a.kt)("p",null,"L'insertion dans un arbre binaire de recherche est assez simple. Il suffit de trouver le bon endroit pour ins\xe9rer le nouveau noeud en respectant la relation d'ordre entre les noeuds."),(0,a.kt)("p",null,"On commence par comparer la valeur du nouveau noeud avec la valeur du noeud racine. Si la valeur du nouveau noeud est inf\xe9rieure \xe0 la valeur du noeud racine, on ins\xe8re le nouveau noeud dans le sous-arbre gauche. Sinon, on ins\xe8re le nouveau noeud dans le sous-arbre droit."),(0,a.kt)("p",null,"On r\xe9p\xe8te cette op\xe9ration jusqu'\xe0 trouver un noeud qui n'a pas de fils dans la direction o\xf9 l'on souhaite ins\xe9rer le nouveau noeud. On ins\xe8re alors le nouveau noeud \xe0 cet endroit."),(0,a.kt)("h3",{id:"recherche"},"Recherche"),(0,a.kt)("p",null,"La recherche dans un arbre binaire de recherche est similaire \xe0 la recherche dichotomique. Pour commencer, on compare la valeur recherch\xe9e avec la valeur du noeud racine. Si la valeur recherch\xe9e est inf\xe9rieure \xe0 la valeur du noeud racine, on effectue la recherche dans le sous-arbre gauche. Sinon, on effectue la recherche dans le sous-arbre droit."),(0,a.kt)("p",null,"On r\xe9p\xe8te cette op\xe9ration jusqu'\xe0 trouver la valeur recherch\xe9e ou jusqu'\xe0 arriver \xe0 un noeud qui n'a pas de fils dans la direction o\xf9 l'on souhaite continuer la recherche. Dans ce cas, on peut conclure que la valeur recherch\xe9e n'est pas dans l'arbre."),(0,a.kt)("h3",{id:"suppression"},"Suppression"),(0,a.kt)("p",null,"La suppression dans un arbre binaire de recherche est plus complexe que l'insertion et la recherche. Il faut faire attention \xe0 ne pas casser la relation d'ordre entre les noeuds."),(0,a.kt)("p",null,"Il existe trois cas de figure:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Le noeud \xe0 supprimer est une feuille: il suffit de supprimer le noeud."),(0,a.kt)("li",{parentName:"ol"},"Le noeud \xe0 supprimer a un seul fils: il suffit de supprimer le noeud et de le remplacer par son fils."),(0,a.kt)("li",{parentName:"ol"},"Le noeud \xe0 supprimer a deux fils: il faut trouver le noeud qui va remplacer le noeud \xe0 supprimer tout en conservant la relation d'ordre entre les noeuds.")),(0,a.kt)("p",null,"Dans le cas 3, il faut faire attention \xe0 ne pas casser la relation d'ordre entre les noeuds. Je rappelle que pour chaque noeud, toutes les valeurs des noeuds du sous-arbre gauche sont inf\xe9rieures \xe0 la valeur du noeud et toutes les valeurs des noeuds du sous-arbre droit sont sup\xe9rieures \xe0 la valeur du noeud. Pour conserver cette relation d'ordre, il faut alors que le noeud qui remplace le noeud \xe0 supprimer soit plus grand que tous les noeuds du sous-arbre gauche ou plus petit que tous les noeuds du sous-arbre droit."),(0,a.kt)("p",null,"On va donc par exemple chercher le noeud le plus \xe0 gauche du sous-arbre droit. Ce noeud est le plus petit noeud du sous-arbre droit. Il est donc plus grand que tous les noeuds du sous-arbre gauche et plus petit que tous les noeuds du sous-arbre droit. Il peut donc remplacer le noeud \xe0 supprimer tout en conservant la relation d'ordre entre les noeuds."),(0,a.kt)("h2",{id:"une-multitude-darbres-binaires"},"Une multitude d'arbres binaires"),(0,a.kt)("p",null,"Il existe une multitude d'arbres binaires diff\xe9rents qui ont des propri\xe9t\xe9s diff\xe9rentes. Cela permet de s'adapter \xe0 diff\xe9rents cas d'utilisation."),(0,a.kt)("p",null,"Par exemple, dans le cadre d'une recherche, on peut vouloir que l'arbre soit le plus \xe9quilibr\xe9 possible (c'est \xe0 dire que la hauteur de l'arbre soit la plus petite possible). Cela permet de r\xe9duire le nombre de comparaisons n\xe9cessaires pour trouver un \xe9l\xe9ment dans l'arbre. C'est le cas des arbres binaires de recherche ",(0,a.kt)("strong",{parentName:"p"},"AVL"),". Cela nous force \xe0 impl\xe9menter des algorithmes d'insertion et de suppression plus complexes pour maintenir l'\xe9quilibre de l'arbre."),(0,a.kt)("p",null,"Dans d'autres cas, on peut vouloir privil\xe9gier la rapidit\xe9 d'insertion et de suppression. C'est le cas des arbres binaires de recherche ",(0,a.kt)("strong",{parentName:"p"},"Rouge-Noir"),". C'est un autre type d'arbre binaire de recherche qui permet de maintenir un arbre \xe9quilibr\xe9 mais qui ne garantit pas \xe0 tout moment que l'arbre soit le plus \xe9quilibr\xe9 possible. Cela permet de simplifier les algorithmes d'insertion et de suppression tout en restant efficace la majorit\xe9 du temps."),(0,a.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Un ",(0,a.kt)("strong",{parentName:"li"},"arbre")," est une ",(0,a.kt)("strong",{parentName:"li"},"structure de donn\xe9es")," qui permet de repr\xe9senter des donn\xe9es hi\xe9rarchiques."),(0,a.kt)("li",{parentName:"ul"},"Un arbre est compos\xe9 de ",(0,a.kt)("strong",{parentName:"li"},"noeuds"),". Chaque noeud peut avoir un nombre quelconque de fils. Un noeud qui n'a pas de fils est appel\xe9 une feuille."),(0,a.kt)("li",{parentName:"ul"},"Un arbre est compos\xe9 d'un ",(0,a.kt)("strong",{parentName:"li"},"noeud racine")," qui est le noeud de d\xe9part de l'arbre. Il est possible d'acc\xe9der \xe0 tous les autres noeuds de l'arbre \xe0 partir du noeud racine."),(0,a.kt)("li",{parentName:"ul"},"La ",(0,a.kt)("strong",{parentName:"li"},"profondeur")," d'un noeud est le nombre de noeuds qui le s\xe9parent du noeud racine."),(0,a.kt)("li",{parentName:"ul"},"La ",(0,a.kt)("strong",{parentName:"li"},"hauteur")," d'un arbre est la profondeur maximale de ses noeuds. C'est \xe0 dire la profondeur du noeud le plus profond."),(0,a.kt)("li",{parentName:"ul"},"Un ",(0,a.kt)("strong",{parentName:"li"},"arbre binaire")," est un arbre dont chaque noeud a au ",(0,a.kt)("strong",{parentName:"li"},"maximum deux fils"),". Un fils ",(0,a.kt)("strong",{parentName:"li"},"gauche")," et un fils ",(0,a.kt)("strong",{parentName:"li"},"droit"),"."),(0,a.kt)("li",{parentName:"ul"},"Un ",(0,a.kt)("strong",{parentName:"li"},"arbre binaire")," peut \xeatre repr\xe9sent\xe9 par une ",(0,a.kt)("strong",{parentName:"li"},"structure r\xe9cursive")," (C'est \xe0 dire une structure qui contient des \xe9l\xe9ments de son propre type) ou par un tableau."),(0,a.kt)("li",{parentName:"ul"},"Un ",(0,a.kt)("strong",{parentName:"li"},"arbre binaire de recherche")," est un arbre binaire qui a la particularit\xe9 d'\xeatre ",(0,a.kt)("strong",{parentName:"li"},"ordonn\xe9"),". On va imposer un ordre sur les valeurs des noeuds de l'arbre. Cela va permettre de faire des recherches efficaces dans l'arbre."),(0,a.kt)("li",{parentName:"ul"},"Il existe une multitude d'arbres binaires diff\xe9rents qui ont des propri\xe9t\xe9s diff\xe9rentes. Cela permet de s'adapter \xe0 diff\xe9rents cas d'utilisation (pour optimiser la recherche, l'insertion, la suppression, etc...)")))}c.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[325],{6712:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var r=t(5893),i=t(1151);const s={},o="Correction",c={id:"Annals/IMAC2026/S1/correction",title:"Correction",description:"Exercice 1",source:"@site/content/Annals/IMAC2026/S1/correction.md",sourceDirName:"Annals/IMAC2026/S1",slug:"/Annals/IMAC2026/S1/correction",permalink:"/Learn--cpp_programming/Annals/IMAC2026/S1/correction",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"Annals",previous:{title:"sujet",permalink:"/Learn--cpp_programming/Annals/IMAC2026/S1/sujet"},next:{title:"Retours G\xe9n\xe9raux",permalink:"/Learn--cpp_programming/Annals/IMAC2026/S1/feedbacks"}},a={},l=[];function d(n){const e={a:"a",code:"code",h1:"h1",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components},{Details:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"correction",children:"Correction"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Exercice 1"}),(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Quelle est la diff\xe9rence entre un tableau ",(0,r.jsx)(e.strong,{children:"statique"})," et un tableau ",(0,r.jsx)(e.strong,{children:"dynamique"})," ?"]}),"\n"]}),(0,r.jsxs)(e.p,{children:["Un tableau ",(0,r.jsx)(e.strong,{children:"statique"})," est un tableau dont la taille est connue \xe0 la compilation, c'est \xe0 dire que la taille du tableau est fixe et ne peut pas \xeatre modifi\xe9e pendant l'ex\xe9cution du programme (",(0,r.jsx)(e.code,{children:"std::array"})," en ",(0,r.jsx)(e.strong,{children:"C++"}),").\nUn tableau ",(0,r.jsx)(e.strong,{children:"dynamique"})," est un tableau dont la taille peut varier pendant l'ex\xe9cution du programme (",(0,r.jsx)(e.code,{children:"std::vector"})," en ",(0,r.jsx)(e.strong,{children:"C++"}),"). Pour cela, il faut utiliser de l\u2019allocation dynamique de m\xe9moire."]}),(0,r.jsx)(e.hr,{}),(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:["Quelle est la diff\xe9rence entre l'op\xe9rateur ",(0,r.jsx)(e.code,{children:"="})," et l'op\xe9rateur ",(0,r.jsx)(e.code,{children:"=="})," ?"]}),"\n"]}),(0,r.jsxs)(e.p,{children:["L'op\xe9rateur ",(0,r.jsx)(e.code,{children:"="})," permet d'",(0,r.jsx)(e.strong,{children:"affecter"})," une valeur \xe0 une variable."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"int a {1};\nint b {2};\na = b; // a vaut maintenant 2\n"})}),(0,r.jsxs)(e.p,{children:["L'op\xe9rateur ",(0,r.jsx)(e.code,{children:"=="})," permet de ",(0,r.jsx)(e.strong,{children:"comparer"})," deux valeurs et retourne un ",(0,r.jsx)(e.strong,{children:"bool\xe9en"}),"."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"int a {1};\nint b {2};\nbool c {a == b}; // c vaut false\n"})}),(0,r.jsx)(e.hr,{}),(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsxs)(e.li,{children:["Qu\u2019entendez-vous par passage par ",(0,r.jsx)(e.strong,{children:"copie"})," et passage par ",(0,r.jsx)(e.strong,{children:"r\xe9f\xe9rence"}),"(",(0,r.jsx)(e.code,{children:"&"}),") ?"]}),"\n"]}),(0,r.jsxs)(e.p,{children:["Le passage par ",(0,r.jsx)(e.strong,{children:"copie"})," consiste \xe0 passer une ",(0,r.jsx)(e.strong,{children:"copie"})," de la variable en param\xe8tre de la fonction. C'est \xe0 dire que la variable en param\xe8tre de la fonction est une ",(0,r.jsx)(e.strong,{children:"copie"})," de la variable pass\xe9e en param\xe8tre lors de l'appel de la fonction."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"void addOne(int x) {\n    // Ici x est une variable locale \xe0 la fonction addOne\n    // x est une copie de la variable pass\xe9e en param\xe8tre lors de l'appel de la fonction\n    x += 1;\n}\n\nint main() {\n    int a {1};\n    addOne(a);\n    // a vaut toujours 1\n}\n"})}),(0,r.jsxs)(e.p,{children:["Le passage par ",(0,r.jsx)(e.strong,{children:"r\xe9f\xe9rence"})," consiste \xe0 passer une ",(0,r.jsx)(e.strong,{children:"r\xe9f\xe9rence"})," de la variable en param\xe8tre de la fonction. C'est \xe0 dire que la variable en param\xe8tre de la fonction utilise le ",(0,r.jsx)(e.strong,{children:"m\xeame espace m\xe9moire"})," que la variable pass\xe9e en param\xe8tre lors de l'appel de la fonction. Cela permet de modifier et manipuler directement la variable pass\xe9e en param\xe8tre lors de l'appel de la fonction."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"void addOne(int& x) {\n    // Ici x est un r\xe9f\xe9rence \xe0 la variable pass\xe9e en param\xe8tre lors de l'appel de la fonction\n    x += 1;\n}\n\nint main() {\n    int a {1};\n    addOne(a);\n    // a vaut maintenant 2\n}\n"})}),(0,r.jsx)(e.hr,{}),(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsxs)(e.li,{children:["A quoi servent les mots cl\xe9s ",(0,r.jsx)(e.code,{children:"const"})," et ",(0,r.jsx)(e.code,{children:"unsigned"})," ? Quand et pourquoi les utiliser ?"]}),"\n"]}),(0,r.jsxs)(e.p,{children:["Le mot cl\xe9 ",(0,r.jsx)(e.code,{children:"const"})," permet de d\xe9clarer une variable ",(0,r.jsx)(e.strong,{children:"constante"}),". C'est \xe0 dire que la variable ne peut pas \xeatre modifi\xe9e apr\xe8s son initialisation."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"int main() {\n    const int a {1};\n    a = 2; // Erreur: a est une variable constante\n}\n"})}),(0,r.jsxs)(e.p,{children:["Cela permet de s'assurer que la variable ne sera pas modifi\xe9e par erreur et rajoute de la ",(0,r.jsx)(e.strong,{children:"s\xe9curit\xe9"})," au programme."]}),(0,r.jsxs)(e.p,{children:["On peut \xe9galement pr\xe9ciser qu'une m\xe9thode ne modifie pas l'objet sur lequel elle est appel\xe9e en utilisant le mot cl\xe9 ",(0,r.jsx)(e.code,{children:"const"})," apr\xe8s la d\xe9claration de la m\xe9thode."]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"struct Point {\n    // ...\n    void display() const;\n};\n"})}),(0,r.jsx)(e.p,{children:"Cela permet de pouvoir utiliser la m\xe9thode sur un objet constant (sinon ce n'est pas possible)."}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"int main() {\n    Point const p {1, 2};\n    p.display(); // OK\n}\n"})}),(0,r.jsx)(e.hr,{}),(0,r.jsxs)(e.p,{children:["Le mot cl\xe9 ",(0,r.jsx)(e.code,{children:"unsigned"})," permet de d\xe9clarer une variable ",(0,r.jsx)(e.strong,{children:"non sign\xe9e"}),". C'est \xe0 dire que la variable ne peut pas prendre de valeur n\xe9gative."]}),(0,r.jsx)(e.p,{children:"Cela permet de s'assurer que la variable ne sera pas n\xe9gative lors de son utilisation. Cela a aussi l\u2019avantage de doubler la valeur maximale que peut prendre la variable (comme il n'y a plus de valeur n\xe9gative \xe0 stocker)."}),(0,r.jsxs)(e.p,{children:["En ",(0,r.jsx)(e.strong,{children:"C++"}),", ",(0,r.jsx)(e.code,{children:"size_t"})," est un alias pour ",(0,r.jsx)(e.code,{children:"unsigned long long int"})," (un entier ",(0,r.jsx)(e.strong,{children:"non sign\xe9e"}),") et est souvent utilis\xe9 dans les boucles ou pour repr\xe9senter la taille d'un tableau ou d'un conteneur (c'est la taille maximale que peut prendre un tableau ou un conteneur)."]})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Exercice 2"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"#include <iostream>\n#include <vector>\n\n// Par r\xe9f\xe9rence constante pour \xe9viter de faire une copie du vecteur et pour pouvoir utiliser la fonction sur un vecteur constant\nint max(std::vector<int> const& vec) {\n    int max {vec[0]};\n    // Ici je commence \xe0 l'index 1 car j'ai d\xe9j\xe0 initialis\xe9 max avec la premi\xe8re valeur du tableau\n    for (size_t i {1}; i < vec.size(); ++i)\n    {\n        if (vec[i] > max)\n        {\n            max = vec[i];\n        }\n    }\n\n    return max;\n}\n\n// Version alternative avec un \"Range-based for loop\"\n// int max(std::vector<int> const& vec) {\n//     int max = vec[0];\n//     for (int value: vec) \n//     {\n//         if (value > max)\n//         {\n//             max = value;\n//         }\n//     }\n//     return max;\n// }\n\nint main() {\n    std::vector<int> v1 {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    std::cout << max(v1) << std::endl;\n    std::vector<int> const v2 {9, 8, 7, 6, 5, 4, 3, 2, 1};\n    std::cout << max(v2) << std::endl;\n    // Aussi par valeur comme on a bien une r\xe9f\xe9rence constante\n    std::cout << max({9, 8, 7, 6, 5, 4, 3, 2, 1})  << std::endl;\n}\n"})}),(0,r.jsxs)(e.p,{children:['D\xe9tail du "Range-based for loop" ',(0,r.jsx)(e.a,{href:"/Lessons/S1/Arrays#range-based-for-loop",children:"ici"})]})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Exercice 3"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <cctype>\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == \'a\' ||  c == \'e\' || c == \'i\' || c == \'o\' || c == \'u\' || c == \'y\';\n}\n\n// version alternative avec un tableau (cha\xeene de caract\xe8res) contenant les voyelles\n// bool isVowel(char c) {\n//     c = std::tolower(c);\n//     std::string const vowels {"aeiouy"};\n//     for (char vowel: vowels)\n//     {\n//         if (c == vowel)\n//         {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n\n// Il existe aussi d\'autres fa\xe7on de faire comme avec la m\xe9thode find de la classe std::string\n\nsize_t countVowels(std::string const& str) {\n    size_t count {0};\n    for(char c: str)\n    {\n        if(isVowel(c))\n        {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::string helloWorldStr {"Hello World!"};\n    std::cout << "\\"" << helloWorldStr << "\\"" << ": " << countVowels(helloWorldStr) << std::endl;\n    std::string testStr {"Ceci est un test"};\n    std::cout << "\\"" << testStr  << "\\"" << ": " << countVowels(testStr) << std::endl;\n    // Aussi possible par valeur comme on a bien une r\xe9f\xe9rence constante\n    std::cout << "\\"Je suis une phrase avec des voyelles\\" : " << countVowels("Je suis une phrase avec des voyelles") << std::endl;\n}\n'})})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Exercice 4"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x {0f};\n    float y {0f};\n};\n\nfloat distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p1.x - p2.x, 2) + std::pow(p1.y - p2.y, 2));\n}\n\n// sans utiliser la fonction pow\n// float distance(Point const& p1, Point const& p2) {\n//     float diff_x {p1.x - p2.x};\n//     float diff_y {p1.y - p2.y};\n//     return std::sqrt(diff_x*diff_x + diff_y*diff_y);\n// }\n\nbool isInCircle(Point const& p, Point const& center, float radius) {\n    return distance(p, center) < radius;\n}\n\nbool isCirclesIntersect(Point const& c1, float r1, Point const& c2, float r2) {\n    return distance(c1, c2) < (r1 + r2);\n}\n\n// BONUS\nstruct Circle {\n    Point center;\n    float radius;\n};\n\nbool isInCircle(Point const& p, Circle const& circle) {\n    return distance(p, circle.center) < circle.radius;\n}\n\nbool isCirclesIntersect(Circle const& c1, Circle const& c2) {\n    return distance(c1.center, c2.center) < (c1.radius + c2.radius);\n}\n\nint main() {\n    Point circle_center {0, 1};\n    float circle_radius {2.4f};\n    \n    // Optionnel: Permet d\'afficher les bool\xe9ens sous forme de true/false (et pas 0/1)\n    std::cout << std::boolalpha;\n    std::cout << "(0, 0) isInCircle ((0, 1), 2.4f): " << isInCircle({0, 0}, circle_center, circle_radius) << std::endl;\n    std::cout << "(1, 1) isInCircle ((0, 1), 2.4f): " << isInCircle({1, 1}, circle_center, circle_radius) << std::endl;\n    std::cout << "(3, 4) isInCircle ((0, 1), 2.4f): " << isInCircle({3, 4}, circle_center, circle_radius) << std::endl;\n\n    // BONUS\n    Circle c1 { p1, 1.2f};\n    Circle c2 { p2, 1.f};\n    std::cout << "c1 intersect c2 :" << isCirclesIntersect(c1, c2) << std::endl;\n\n    return 0;\n}\n'})})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" Robot "}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/direction.hpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"#pragma once\n\n#include <string>\n\nenum class Direction {\n    north,\n    east,\n    south,\n    west\n};\n\nstd::string to_string(Direction direction);\n"})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/direction.cpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include "direction.hpp"\n\nstd::string to_string(Direction direction) {\n    switch (direction) {\n        case Direction::north:\n            return "north";\n            // break pas n\xe9cessaire ici car on utilise le mot cl\xe9 return qui permet de sortir imm\xe9diatement de la fonction\n        case Direction::east:\n            return "east";\n        case Direction::south:\n            return "south";\n        case Direction::west:\n            return "west";\n    }\n}\n'})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/point.hpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#pragma once\n\n// J\'ai besoin de la d\xe9claration de Direction pour pouvoir d\xe9clarer la m\xe9thode move\n#include "direction.hpp"\n\nstruct Point {\n    int x {0};\n    int y {0};\n\n    // BONUS: Ici la m\xe9thode peut \xeatre d\xe9clar\xe9e comme const car elle ne modifie pas la structure\n    void display() const;\n    void move(Direction const d, unsigned int const n);\n};\n'})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/point.cpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"#include \"point.hpp\"\n#include <iostream>\n\n// Ici je n'ai pas afficher de retour \xe0 la ligne afin de pouvoir r\xe9utiliser la m\xe9thode ensuite dans robot.cpp\nvoid Point::display() const {\n    std::cout << '(' << x << \", \" << y << ')';\n}\n\nvoid Point::move(Direction const d, unsigned int const n) {\n    switch (d) {\n        case Direction::north:\n            y += n;\n            break;\n        case Direction::east:\n            x += n;\n            break;\n        case Direction::south:\n            y -= n;\n            break;\n        case Direction::west:\n            x -= n;\n            break;\n    }\n}\n"})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/robot.hpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#pragma once\n\n#include <string>\n#include "direction.hpp"\n#include "point.hpp"\n\nstruct Robot {\n    std::string name;\n    Point position;\n    Direction direction;\n\n    void display() const;\n    void turnLeft();\n    void turnRight();\n    void move(unsigned int const n);\n};\n\nstd::string createRobotName();\n\nRobot createRobot(Point position, Direction direction);\n'})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/robot.cpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"#include \"robot.hpp\"\n\n#include <cstdlib>\n#include <iostream>\n\nvoid Robot::display() const {\n    std::cout << name << '(';\n    position.display();\n    std::cout << \", \" << to_string(direction) << ')';\n}\n\nvoid Robot::turnLeft() {\n    switch (direction) {\n        case Direction::north:\n            direction = Direction::west;\n            break;\n        case Direction::east:\n            direction = Direction::north;\n            break;\n        case Direction::south:\n            direction = Direction::east;\n            break;\n        case Direction::west:\n            direction = Direction::south;\n            break;\n    }\n}\n\nvoid Robot::turnRight() {\n    switch (direction) {\n        case Direction::north:\n            direction = Direction::east;\n            break;\n        case Direction::east:\n            direction = Direction::south;\n            break;\n        case Direction::south:\n            direction = Direction::west;\n            break;\n        case Direction::west:\n            direction = Direction::north;\n            break;\n    }\n}\nvoid Robot::move(unsigned int const n) {\n    position.move(direction, n);\n}\n\nstd::string createRobotName() {\n    std::string name {\"\"};\n\n    for(size_t i {0}; i < 2; ++i)\n    {\n        name += 'A' + (std::rand() % (25+1));\n    }\n    for(size_t i {0}; i < 3; ++i)\n    {\n        name += '0' + (std::rand() % (9+1));\n    }\n\n    return name;\n}\n\nRobot createRobot(Point position, Direction direction) {\n    return Robot { createRobotName(), position, direction };\n}\n"})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" src/main.cpp "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <ctime>\n\n#include "direction.hpp"\n#include "point.hpp"\n#include "robot.hpp"\n\nint main() {\n\n    // Initialisation du g\xe9n\xe9rateur de nombre al\xe9atoire\n    std::srand(std::time(nullptr));\n\n    // Test direction\n    Direction direction_test {Direction::north};\n    std::cout << to_string(direction_test) << std::endl;\n\n    // Test point\n    Point p1 {1, 2};\n    p1.display();\n    std::cout << std::endl;\n    p1.move(Direction::east, 3);\n    p1.display();\n    std::cout << std::endl;\n\n    Robot robot {createRobot(Point{0, 0}, Direction::north)};\n\n    std::count << "Robot start value: ";\n    robot.display();\n    std::cout << std::endl;\n\n    robot.turnLeft();\n    robot.move(3);\n    robot.turnRight();\n    robot.move(5);\n    robot.move(2);\n    robot.turnLeft();\n    robot.move(1);\n    robot.turnRight();\n    robot.move(2);\n\n    std::count << "Robot end value: ";\n    robot.display();\n    std::cout << std::endl;\n\n    // Version alternative avec boucle sur une cha\xeene de caract\xe8re pour indiquer les actions \xe0 effectuer\n    robot = createRobot(Point{0, 0}, Direction::north);\n\n    for (char action : "L3R52L1R2") {\n        // number test \n        if (action >= 48 && action <= 57) {\n            robot.move(static_cast<int>(action - \'0\'));\n        }\n        else if (action == \'R\')\n        {\n            robot.turnRight();\n        }\n        else if(action == \'L\')\n        {\n            robot.turnLeft();\n        }\n        else \n        {\n            if (action != \'\\0\') {\n                std::cout << "unknown action :" << action;\n            }\n        }\n        \n        robot.display();\n        std::cout << std::endl;\n    }\n}\n'})})]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:" CMakeLists.txt "}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cmake",children:'# la version de cmake \xe0 utiliser\ncmake_minimum_required(VERSION 3.0)\n\n# La version du C++ que l\'on souhaite utiliser (dans notre cas C++17)\nset(CMAKE_CXX_STANDARD 17)\n\n# On souhaite placer l\'ex\xe9cutable dans un sous-dossier "bin" au lieu de le mettre dans le dossier build\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n\n# Le nom du projet\nproject(Robot)\n\n# Obtenir la liste des fichiers sources dans le dossier src\nfile(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS "src/*.cpp")\n\n# Optionnel : afficher la liste des fichiers sources\n# message(STATUS "Found source files:")\n# foreach(SRC_FILE ${SRC_FILES})\n#     message(STATUS " - ${SRC_FILE}")\n# endforeach()\n\n# On indique que l\'on souhaite faire un ex\xe9cutable avec nos fichiers sources\nadd_executable(robot ${SRC_FILES})\n\n# le dossier contenant les fichiers d\'en-t\xeate pour notre executable\ntarget_include_directories(robot PUBLIC "src/")\n'})})]})]})]})}function u(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},1151:(n,e,t)=>{t.d(e,{Z:()=>c,a:()=>o});var r=t(7294);const i={},s=r.createContext(i);function o(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);
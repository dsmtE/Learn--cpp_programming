"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[9853],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),s=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(o.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=s(n),c=a,k=m["".concat(o,".").concat(c)]||m[c]||d[c]||l;return n?r.createElement(k,i(i({ref:t},u),{},{components:n})):r.createElement(k,i({ref:t},u))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=c;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[m]="string"==typeof e?e:a,i[1]=p;for(var s=2;s<l;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7893:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const l={title:"TD3 - Structures de donn\xe9es"},i=void 0,p={unversionedId:"TDs/S2/dataStructures",id:"TDs/S2/dataStructures",title:"TD3 - Structures de donn\xe9es",description:"Evaluation NPI",source:"@site/content/TDs/S2/03_dataStructures.md",sourceDirName:"TDs/S2",slug:"/TDs/S2/dataStructures",permalink:"/Learn--cpp_programming/TDs/S2/dataStructures",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"TD3 - Structures de donn\xe9es"},sidebar:"TDs",previous:{title:"TD2 - Algorithmes de tri",permalink:"/Learn--cpp_programming/TDs/S2/sorting"},next:{title:"TD5 - Hachage et tableaux associatifs",permalink:"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables"}},o={},s=[{value:"Evaluation NPI",id:"evaluation-npi",level:2},{value:"Pour aller plus loin",id:"pour-aller-plus-loin",level:2},{value:"Conversion en NPI",id:"conversion-en-npi",level:3},{value:"R\xe9aliser un calculatrice",id:"r\xe9aliser-un-calculatrice",level:3}],u={toc:s},m="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"evaluation-npi"},"Evaluation NPI"),(0,a.kt)("p",null,"La notation polonaise invers\xe9e (",(0,a.kt)("strong",{parentName:"p"},"NPI"),") est une notation math\xe9matique qui permet d'exprimer des expressions arithm\xe9tiques sans utiliser de parenth\xe8ses. Elle a \xe9t\xe9 invent\xe9e par le math\xe9maticien polonais Jan Lukasiewicz en 1924."),(0,a.kt)("p",null,"La notation polonaise invers\xe9e est une notation postfixe, c'est-\xe0-dire que l'op\xe9rateur est plac\xe9 apr\xe8s les deux op\xe9randes. Par exemple, l'expression ",(0,a.kt)("inlineCode",{parentName:"p"},"3 + 4")," s'\xe9crit ",(0,a.kt)("inlineCode",{parentName:"p"},"3 4 +")," en NPI."),(0,a.kt)("p",null,"Ce qui permet ensuite d'interpr\xe9ter l'expression de gauche \xe0 droite, en empilant les op\xe9randes sur une pile, et en d\xe9clenchant l'op\xe9ration lorsque l'on rencontre un op\xe9rateur."),(0,a.kt)("p",null,"Par exemple, l'expression ",(0,a.kt)("inlineCode",{parentName:"p"},"3 4 +")," s'interpr\xe8te comme suit :"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"On empile ",(0,a.kt)("inlineCode",{parentName:"li"},"3")),(0,a.kt)("li",{parentName:"ul"},"On empile ",(0,a.kt)("inlineCode",{parentName:"li"},"4")),(0,a.kt)("li",{parentName:"ul"},"On rencontre ",(0,a.kt)("inlineCode",{parentName:"li"},"+"),", on d\xe9pile ",(0,a.kt)("inlineCode",{parentName:"li"},"4")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"3"),", on calcule ",(0,a.kt)("inlineCode",{parentName:"li"},"3 + 4 = 7"),", et on empile le r\xe9sultat ",(0,a.kt)("inlineCode",{parentName:"li"},"7")),(0,a.kt)("li",{parentName:"ul"},"On a termin\xe9, le r\xe9sultat est ",(0,a.kt)("inlineCode",{parentName:"li"},"7"))),(0,a.kt)("p",null,"On va donc pouvoir se servir d'une ",(0,a.kt)("strong",{parentName:"p"},"pile")," pour \xe9valuer une expression en NPI."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Il faut cependant faire attention au op\xe9rateur non commutatifs, comme ",(0,a.kt)("inlineCode",{parentName:"p"},"-")," ou ",(0,a.kt)("inlineCode",{parentName:"p"},"/"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"3 4 /")," ne s'interpr\xe8te pas comme ",(0,a.kt)("inlineCode",{parentName:"p"},"3 / 4"),", mais comme ",(0,a.kt)("inlineCode",{parentName:"p"},"4 / 3"),". Il faut donc \xe9crire ",(0,a.kt)("inlineCode",{parentName:"p"},"3 4 /")," pour \xe9valuer ",(0,a.kt)("inlineCode",{parentName:"p"},"3 / 4"),".")),(0,a.kt)("p",null,"Le but de cet exercice est d'\xe9crire une fonction qui prend en param\xe8tre une expression en NPI sous forme d'une cha\xeene de caract\xe8res (les diff\xe9rents \xe9l\xe9ments de l'expression sont s\xe9par\xe9s par des espaces), et qui retourne le r\xe9sultat de l'expression."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire un programme qui permet de lire une entr\xe9e utilisateur sous la forme d'une chaines de caract\xe8res avec des espaces entre les diff\xe9rents \xe9l\xe9ments de l'expression (nombre, op\xe9rateur, parenth\xe8ses)."),(0,a.kt)("admonition",{parentName:"li",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Par simplicit\xe9, on se limitera \xe0 des expressions contenant des ",(0,a.kt)("strong",{parentName:"p"},"chiffres")," entiers positifs compris entre ",(0,a.kt)("strong",{parentName:"p"},"0")," et ",(0,a.kt)("strong",{parentName:"p"},"9"),", et des op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"/")," ainsi que des ",(0,a.kt)("strong",{parentName:"p"},"parenth\xe8ses")," (",(0,a.kt)("inlineCode",{parentName:"p"},"(")," et ",(0,a.kt)("inlineCode",{parentName:"p"},")"),")."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une fonction qui prend en param\xe8tre une ",(0,a.kt)("strong",{parentName:"p"},"cha\xeene de caract\xe8res")," repr\xe9sentant l'expression en NPI et qui retourne le r\xe9sultat de l'expression.\nUtilisez une ",(0,a.kt)("strong",{parentName:"p"},"pile")," (",(0,a.kt)("inlineCode",{parentName:"p"},"std::stack"),") pour \xe9valuer l'expression comme dans l'exemple pr\xe9c\xe9dent."),(0,a.kt)("admonition",{parentName:"li",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"On pourra faire la distinction entre les op\xe9rateurs et les op\xe9randes en utilisant la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"std::isdigit")," de la biblioth\xe8que ",(0,a.kt)("inlineCode",{parentName:"p"},"<cctype>"),".\nOn pourra utiliser la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"std::stoi")," de la biblioth\xe8que ",(0,a.kt)("inlineCode",{parentName:"p"},"<string>")," pour convertir une cha\xeene de caract\xe8res en entier.")),(0,a.kt)("p",{parentName:"li"},"Je vous fourni le code suivant pour vous aider:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <string>\n#include <cctype>\n#include <algorithm>\n#include <iostream>\n\nbool is_digits(std::string const& str)\n{\n  return std::all_of(str.begin(), str.end(), [](unsigned char ch){ return std::isdigit(ch); });\n}\n\nvoid main() {\n  std::string s { "42" };\n  if (is_digits(s))\n  {\n    int i { std::stoi(s) };\n    std::cout << i << std::endl;\n  }\n  else\n  {\n    // opertor\n    std::cout << "not a number" << std::endl;\n  }\n}\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Utiliser les fonctions pr\xe9c\xe9dentes pour afficher le r\xe9sultat d'une expression en NPI entr\xe9e par l'utilisateur.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Pour aller plus loin:"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"G\xe9rer les nombres (\xe0 plusieurs chiffres) (il va falloir ajouter un espace entre chaque \xe9l\xe9ments de l'expression et ajouter une \xe9tape de traitement pour s\xe9parer l'expression en plusieurs nombres et op\xe9rateurs (appel\xe9s ",(0,a.kt)("strong",{parentName:"p"},"tokens"),") en fonction des espaces).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"R\xe9\xe9crire le programme pr\xe9c\xe9dent en utilisant un ",(0,a.kt)("strong",{parentName:"p"},"enum")," pour repr\xe9senter les diff\xe9rents ",(0,a.kt)("strong",{parentName:"p"},"op\xe9rateurs")," (les parenth\xe8ses sont des op\xe9rateurs) ainsi qu'une structure pour repr\xe9senter un ",(0,a.kt)("strong",{parentName:"p"},"token")," (un \xe9l\xe9ment de l'expression) avec un champ pour le type (op\xe9rateur ou op\xe9rande) et des champs pour les valeurs (op\xe9rateur ou op\xe9rande)."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"enum class Operator { ADD, SUB, MUL, DIV, OPEN_PARENTHESIS, CLOSE_PARENTHESIS };\nenum class TokenType { OPERATOR, OPERAND };\nstruct Token {\n  TokenType type;\n  int value;\n  Operator op;\n};\n")),(0,a.kt)("admonition",{parentName:"li",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Il existe des fonctionnalit\xe9s plus avanc\xe9s qui permettraient de faire \xe7a plus proprement, et de se passer de la structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Token")," (les ",(0,a.kt)("strong",{parentName:"p"},"unions")," ou les ",(0,a.kt)("strong",{parentName:"p"},"variantes"),"). Vous pouvez vous renseigner ou me demander si vous voulez en savoir plus.")))),(0,a.kt)("h2",{id:"pour-aller-plus-loin"},"Pour aller plus loin"),(0,a.kt)("h3",{id:"conversion-en-npi"},"Conversion en NPI"),(0,a.kt)("p",null,'Nuus avons pr\xe9c\xe9demment vu comment \xe9valuer une expression en NPI. Mais comment faire pour convertir une expression en notation infixe (c\'est-\xe0-dire de mani\xe8re "classique" avec des parenth\xe8ses) en une expression en NPI ?'),(0,a.kt)("p",null,"Pour cela, il existe un algorithme appel\xe9 ",(0,a.kt)("strong",{parentName:"p"},"Shunting-yard algorithm"),' (litt\xe9ralement "algorithme de la cour de triage").'),(0,a.kt)("p",null,"Son principe est d'utiliser une ",(0,a.kt)("strong",{parentName:"p"},"pile")," pour stocker les op\xe9rateurs rencontr\xe9s, et de les d\xe9piler lorsque l'on rencontre un op\xe9rateur de priorit\xe9 sup\xe9rieure."),(0,a.kt)("p",null,"Voil\xe0 comment il fonctionne :"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"On parcourt l'expression de gauche \xe0 droite")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Si on rencontre un nombre, on l'ajoute \xe0 la sortie")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Si on rencontre un op\xe9rateur:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Si on rencontre une parenth\xe8se ouvrante (",(0,a.kt)("inlineCode",{parentName:"li"},"("),"), on la met sur la pile des op\xe9rateurs"),(0,a.kt)("li",{parentName:"ul"},"Si on rencontre une parenth\xe8se fermante (",(0,a.kt)("inlineCode",{parentName:"li"},")"),"), on d\xe9pile les op\xe9rateurs jusqu'\xe0 ce qu'on rencontre une parenth\xe8se ouvrante, et on ajoute les op\xe9rateurs d\xe9fil\xe9s \xe0 la sortie"),(0,a.kt)("li",{parentName:"ul"},"Tant qu'il y a un op\xe9rateur sur la pile des op\xe9rateurs de priorit\xe9 sup\xe9rieure ou \xe9gale \xe0 l'op\xe9rateur courant, on d\xe9pile les op\xe9rateurs et on les ajoute \xe0 la sortie. Puis on ajoute l'op\xe9rateur courant \xe0 la pile des op\xe9rateurs."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Enfin, on d\xe9pile les op\xe9rateurs restants et on les ajoute \xe0 la sortie."))),(0,a.kt)("p",null,"Voici un exemple d'application de l'algorithme  avec l'expression ",(0,a.kt)("inlineCode",{parentName:"p"},"3 + 4 ^ 2 / ( 1 - 5 ) ^ 6 ")," :"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Entr\xe9e"),(0,a.kt)("th",{parentName:"tr",align:null},"Sortie"),(0,a.kt)("th",{parentName:"tr",align:null},"Pile des op\xe9rateurs"),(0,a.kt)("th",{parentName:"tr",align:null},"commentaire"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"3"),(0,a.kt)("td",{parentName:"tr",align:null},"3"),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 3 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"3"),(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute + \xe0 la pile des op\xe9rateurs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"4"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4"),(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 4 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"^"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ^"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute ^ \xe0 la pile des op\xe9rateurs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"2"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ^"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 2 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"/"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^"),(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"on d\xe9pile ^ et on l'ajoute \xe0 la sortie car / a une priorit\xe9 inf\xe9rieure \xe0 ^")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"("),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ("),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute ( \xe0 la pile des op\xe9rateurs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"1"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ("),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 1 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"-"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ( -"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute - \xe0 la pile des op\xe9rateurs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"5"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1 5"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ( -"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 5 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},")"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1 5 -"),(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"on d\xe9pile les op\xe9rateurs jusqu'\xe0 ( et on les ajoute \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"^"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1 5 -"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ^"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute ^ \xe0 la pile des op\xe9rateurs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"6"),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1 5 - 6"),(0,a.kt)("td",{parentName:"tr",align:null},"+ ^"),(0,a.kt)("td",{parentName:"tr",align:null},"on ajoute 6 \xe0 la sortie")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null},"3 4 2 ^ 1 5 - 6 ^"),(0,a.kt)("td",{parentName:"tr",align:null},"+"),(0,a.kt)("td",{parentName:"tr",align:null},"on d\xe9pile le reste des op\xe9rateurs et on les ajoute \xe0 la sortie")))),(0,a.kt)("p",null,"\xc9crire une fonction qui prend en param\xe8tre une cha\xeene de caract\xe8res repr\xe9sentant une expression en notation infixe, qui retourne un tableau de ",(0,a.kt)("inlineCode",{parentName:"p"},"Token")," repr\xe9sentant l'expression en NPI."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"On utilisera la m\xeame structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Token")," que dans l'exercice pr\xe9c\xe9dent.\nOn utilisera une ",(0,a.kt)("inlineCode",{parentName:"p"},"std::stack")," pour repr\xe9senter la pile des op\xe9rateurs.")),(0,a.kt)("h3",{id:"r\xe9aliser-un-calculatrice"},"R\xe9aliser un calculatrice"),(0,a.kt)("p",null,"Maintenant que nous savons \xe9valuer une expression en NPI et que nous savons convertir une expression en notation infixe en NPI, nous pouvons r\xe9aliser une ",(0,a.kt)("strong",{parentName:"p"},"calculatrice"),"."),(0,a.kt)("p",null,"Essayez de r\xe9aliser un programme qui permet de lire une expression en notation infixe, de la convertir en NPI, de l'\xe9valuer et d'afficher le r\xe9sultat."))}d.isMDXComponent=!0}}]);
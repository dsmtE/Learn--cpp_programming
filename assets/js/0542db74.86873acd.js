"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[355],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,k=m["".concat(o,".").concat(c)]||m[c]||d[c]||l;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[m]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5587:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={title:"Allouer et manipuler la m\xe9moire",tags:["C++"],sidebar_position:9},i="Introduction",s={unversionedId:"Lessons/MemoryAllocation",id:"Lessons/MemoryAllocation",title:"Allouer et manipuler la m\xe9moire",description:"Jusque l\xe0 nous avons manipul\xe9 des variables et tableaux sans nous soucier vraiment de ce qu'il se passe sous le capot. Il est grand temps de comprendre un peu plus dans le d\xe9tail ce qu'il se passe et comment est allou\xe9e la m\xe9moire en C++.",source:"@site/content/Lessons/MemoryAllocation.md",sourceDirName:"Lessons",slug:"/Lessons/MemoryAllocation",permalink:"/Learn--cpp_programming/Lessons/MemoryAllocation",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",sidebarPosition:9,frontMatter:{title:"Allouer et manipuler la m\xe9moire",tags:["C++"],sidebar_position:9},sidebar:"sidebar",previous:{title:"Compilation et Headers: S\xe9parer en plusieurs fichiers",permalink:"/Learn--cpp_programming/Lessons/Headers"}},o={},p=[{value:"Mode d&#39;allocation",id:"mode-dallocation",level:2},{value:"Allocation statique",id:"allocation-statique",level:3},{value:"Allocation sur la <strong>Stack</strong>",id:"allocation-sur-la-stack",level:3},{value:"Allocation sur la <strong>Heap</strong>",id:"allocation-sur-la-heap",level:3},{value:"Adresse et pointeurs",id:"adresse-et-pointeurs",level:2},{value:"D\xe9r\xe9f\xe9rencement",id:"d\xe9r\xe9f\xe9rencement",level:3},{value:"Null pointer",id:"null-pointer",level:3},{value:"Allocation dynamique en pratique: New &amp; delete",id:"allocation-dynamique-en-pratique-new--delete",level:2},{value:"Tableaux",id:"tableaux",level:2},{value:"std::vector: explications",id:"stdvector-explications",level:2},{value:"Structure et This",id:"structure-et-this",level:2},{value:"Les r\xe9f\xe9rences dans tout \xe7a",id:"les-r\xe9f\xe9rences-dans-tout-\xe7a",level:2},{value:"Pointeurs intelligents",id:"pointeurs-intelligents",level:2},{value:"unique_ptr",id:"unique_ptr",level:3},{value:"shared_ptr",id:"shared_ptr",level:3},{value:"weak_ptr",id:"weak_ptr",level:3},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Jusque l\xe0 nous avons manipul\xe9 des variables et tableaux sans nous soucier vraiment de ce qu'il se passe sous le capot. Il est grand temps de comprendre un peu plus dans le d\xe9tail ce qu'il se passe et comment est allou\xe9e la ",(0,r.kt)("strong",{parentName:"p"},"m\xe9moire")," en C++."),(0,r.kt)("h2",{id:"mode-dallocation"},"Mode d'allocation"),(0,r.kt)("p",null,"Il existe trois principaux modes d\u2019allocation de la m\xe9moire:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"l\u2019allocation ",(0,r.kt)("strong",{parentName:"li"},"statique")),(0,r.kt)("li",{parentName:"ul"},"l\u2019allocation sur la ",(0,r.kt)("strong",{parentName:"li"},"Stack")),(0,r.kt)("li",{parentName:"ul"},"l\u2019allocation sur la ",(0,r.kt)("strong",{parentName:"li"},"Heap"))),(0,r.kt)("h3",{id:"allocation-statique"},"Allocation statique"),(0,r.kt)("p",null,"Lorsque le programme s\u2019initialise, il demande une quantit\xe9 de m\xe9moire sp\xe9cifi\xe9e dans le code source du programme, laquelle ne pourra ",(0,r.kt)("strong",{parentName:"p"},"pas changer")," par la suite."),(0,r.kt)("p",null,"Nous n'avons pas rencontr\xe9 ce type d'allocation pour l'instant mais sachez que \xe7a existe."),(0,r.kt)("h3",{id:"allocation-sur-la-stack"},"Allocation sur la ",(0,r.kt)("strong",{parentName:"h3"},"Stack")),(0,r.kt)("p",null,"Jusqu'a pr\xe9sent, nous avons principalement rencontr\xe9 des allocations de m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"p"},"Stack"),". C'est le cas de toutes nos variables locales (dans des fonctions, y compris dans la fonction ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),")."),(0,r.kt)("p",null,"La ",(0,r.kt)("strong",{parentName:"p"},"Stack")," (ou ",(0,r.kt)("strong",{parentName:"p"},"pile")," en fran\xe7ais) est une zone m\xe9moire qui sert d\u2019espace de stockage aux ",(0,r.kt)("strong",{parentName:"p"},"variables")," d\xe9clar\xe9es par les fonctions et permet aussi de garder une trace des appels de fonctions."),(0,r.kt)("p",null,"Elle tient son nom de son mode de fonctionnement, semblable \xe0 une ",(0,r.kt)("strong",{parentName:"p"},"pile")," de dossiers. Il s\u2019agit d\u2019une ",(0,r.kt)("strong",{parentName:"p"},"structure de donn\xe9es")," fond\xe9e sur le principe \u201cdernier pos\xe9 sur le dessus de la pile, premier \xe0 sortir\u201d. Cet ordonnancement s\u2019appelle ",(0,r.kt)("strong",{parentName:"p"},"LIFO")," (Last In, First Out). La ",(0,r.kt)("strong",{parentName:"p"},"Stack")," poss\xe8de donc deux actions principales : ",(0,r.kt)("strong",{parentName:"p"},"push"),", pour ajouter un \xe9l\xe9ment, et ",(0,r.kt)("strong",{parentName:"p"},"pop")," pour retirer et r\xe9cup\xe9rer cet \xe9l\xe9ment. Cela rend tr\xe8s simple le suivi de la pile pour lib\xe9rer ou demander de la m\xe9moire."),(0,r.kt)("p",null,"Comme les acc\xe8s \xe0 la Stack sont ",(0,r.kt)("strong",{parentName:"p"},"contigu\xebs")," et que les m\xeames adresses m\xe9moire tendent \xe0 \xeatre r\xe9utilis\xe9es, les lectures et \xe9critures dans la ",(0,r.kt)("strong",{parentName:"p"},"Stack")," sont tr\xe8s ",(0,r.kt)("strong",{parentName:"p"},"performantes"),'. Cependant cela manque de souplesse car son allocation doit \xeatre "',(0,r.kt)("strong",{parentName:"p"},"pr\xe9vue"),'" lors de l\u2019\xe9criture du programme (Pour des variables de taille d\xe9j\xe0 connue \xe0 la compilation).'),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"La ",(0,r.kt)("strong",{parentName:"p"},"Stack")," a une ",(0,r.kt)("strong",{parentName:"p"},"taille fix\xe9e")," (qui d\xe9pend des machines et syst\xe8mes d'exploitation(OS)).\nPour garder une trace de l\u2019emplacement m\xe9moire actuel, il existe un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," appel\xe9 ",(0,r.kt)("strong",{parentName:"p"},"Stack Pointer"),". Chaque fois que quelque chose doit \xeatre \xe9crit ou retir\xe9 dans la ",(0,r.kt)("strong",{parentName:"p"},"Stack"),", on d\xe9place simplement ce pointeur. Le pointeur ne peut pas aller au del\xe0 des limites de la Stack, cela risque de provoquer un crash du programme appel\xe9 ",(0,r.kt)("strong",{parentName:"p"},"Stack overflow"),". Cela peut se produire avec une fonction ",(0,r.kt)("strong",{parentName:"p"},"r\xe9cursive")," avec de nombreux appels r\xe9cursifs ou sans condition d'arr\xeat par exemple.")),(0,r.kt)("p",null,"La syntaxe pour allouer de la m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"p"},"Stack")," est la suivante:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int x {};\n")),(0,r.kt)("p",null,"Vous connaissez d\xe9j\xe0 cette syntaxe, c'est simplement la d\xe9claration d'une variable locale."),(0,r.kt)("h3",{id:"allocation-sur-la-heap"},"Allocation sur la ",(0,r.kt)("strong",{parentName:"h3"},"Heap")),(0,r.kt)("p",null,"L\u2019allocation sur la ",(0,r.kt)("strong",{parentName:"p"},"Heap")," se fait de mani\xe8re ",(0,r.kt)("strong",{parentName:"p"},"dynamique")," pendant l\u2019ex\xe9cution d\u2019un programme. L\u2019espace n\xe9cessaire n\u2019a pas besoin d'\xeatre d\xe9fini en amont dans le code. Le programme effectue la ",(0,r.kt)("strong",{parentName:"p"},"demande")," d\u2019allocation d\u2019espace \xe0 l\u2019OS au cours de son ex\xe9cution."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Il y a g\xe9n\xe9ralement un abus de langage et ce que l'on qualifie d'allocation ",(0,r.kt)("strong",{parentName:"p"},"dynamique")," d\xe9signe ce type d'allocation sur la ",(0,r.kt)("strong",{parentName:"p"},"Heap"),".\nL'allocation sur la Stack est \xe9galement ",(0,r.kt)("em",{parentName:"p"},"dynamique")," dans le sens o\xf9 elle se produit ",(0,r.kt)("strong",{parentName:"p"},"pendant")," l'ex\xe9cution du programme en fonction des variables d\xe9clar\xe9es.")),(0,r.kt)("p",null,"La ",(0,r.kt)("strong",{parentName:"p"},"Heap")," permet donc le contr\xf4le compl\xe8tement ",(0,r.kt)("strong",{parentName:"p"},"arbitraire")," de l\u2019allocation et de la lib\xe9ration. Lorsque le processus n\xe9cessite plus de m\xe9moire, il en fait simplement la demande \xe0 l\u2019OS (dans la limite o\xf9 il est en mesure de fournir un tel emplacement m\xe9moire). C'est donc aussi ce type d'allocation que l'on privil\xe9gie dans le cas de gros volumes de donn\xe9es."),(0,r.kt)("p",null,"Cependant, cela demande de maintenir des ",(0,r.kt)("strong",{parentName:"p"},"pointeurs")," pour chacune des valeurs stock\xe9es, afin de savoir o\xf9 se trouve la m\xe9moire demand\xe9e pour pouvoir la manipuler mais aussi la ",(0,r.kt)("strong",{parentName:"p"},"lib\xe9rer"),'. Cette gestion de la m\xe9moire \xe9tant plus "complexe", les performances n\u2019en sont g\xe9n\xe9ralement pas aussi bonnes, mais parfois on n\'a tout simplement pas le choix.'),(0,r.kt)("p",null,"La syntaxe pour allouer de la m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"p"},"Heap")," est la suivante:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int* x { new int };\n")),(0,r.kt)("p",null,"Je vous expliquerai plus en d\xe9tail ce que cela signifie dans la suite de ce chapitre."),(0,r.kt)("h2",{id:"adresse-et-pointeurs"},"Adresse et pointeurs"),(0,r.kt)("p",null,"J'ai \xe9voqu\xe9 le terme de ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," mais qu'est ce que c'est ?"),(0,r.kt)("p",null,"Une variable est localis\xe9e quelque part dans notre m\xe9moire.\nOn peut voir la m\xe9moire de notre ordinateur comme une grande \xe9tag\xe8re \xe0 livres dans laquelle chaque emplacement est num\xe9rot\xe9.\nChaque variable a une ",(0,r.kt)("strong",{parentName:"p"},"adresse")," (un num\xe9ro) qui permet de savoir ",(0,r.kt)("strong",{parentName:"p"},"o\xf9")," elle se trouve en m\xe9moire."),(0,r.kt)("p",null,"Cette adresse est simplement un nombre (g\xe9n\xe9ralement repr\xe9sent\xe9 sous forme ",(0,r.kt)("em",{parentName:"p"},"hexad\xe9cimale"),")."),(0,r.kt)("p",null,"On peut r\xe9cup\xe9rer l'adresse d'une variable en ajoutant le symbole \"esperluette\" ",(0,r.kt)("kbd",null,"&")," devant le nom de la variable en question."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Essayons:"',title:'"Essayons:"'},"#include <iostream>\n\nint main()\n{\n    int integer {4};\n\n    std::cout << &integer << std::endl; \n    return 0;\n}\n")),(0,r.kt)("p",null,"qui nous donne un truc qui ressemble \xe0 \xe7a:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"0x7ffe08bf5854\n")),(0,r.kt)("p",null,"Ce nombre indique o\xf9 est stock\xe9e la valeur de notre variable en m\xe9moire (que ce soit la ",(0,r.kt)("strong",{parentName:"p"},"heap")," ou la ",(0,r.kt)("strong",{parentName:"p"},"stack"),")."),(0,r.kt)("p",null,"Maintenant que nous savons ",(0,r.kt)("strong",{parentName:"p"},"o\xf9")," se trouve notre variable on va pouvoir stocker cette ",(0,r.kt)("strong",{parentName:"p"},"adresse"),"."),(0,r.kt)("p",null,"C'est justement le r\xf4le du ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," de stocker l'",(0,r.kt)("strong",{parentName:"p"},"adresse")," d'une variable."),(0,r.kt)("p",null,"On indique que l'on souhaite manipuler un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," en ajoutant le symbole ",(0,r.kt)("kbd",null,"*")," apr\xe8s le type de la variable. Cela indique donc que l'on stocke une ",(0,r.kt)("strong",{parentName:"p"},"adresse")," vers une variable du type indiqu\xe9 et non une valeur."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nint main()\n{\n    int integer {4};\n    int* integer_pointer {&integer};\n\n    std::cout << integer << std::endl;\n    std::cout << "address: " << integer_pointer << std::endl;\n\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"d\xe9r\xe9f\xe9rencement"},"D\xe9r\xe9f\xe9rencement"),(0,r.kt)("p",null,"Avec ce pointeur, il est possible de faire ce qu'on appelle un ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," et aller ",(0,r.kt)("em",{parentName:"p"},"voir")," le contenu de l'emplacement situ\xe9 \xe0 l'",(0,r.kt)("strong",{parentName:"p"},"adresse")," stock\xe9e. C'est-\xe0-dire, la valeur de la variable point\xe9e."),(0,r.kt)("p",null,"Pour faire un ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," on utilise \xe9galement le symbole ",(0,r.kt)("kbd",null,"*")," devant le nom de notre pointeur comme cela:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nint main()\n{\n    int integer {4};\n    int* integer_pointer {&integer};\n    \n    std::cout << integer << std::endl;\n    std::cout << "address: " << integer_pointer << std::endl;\n    std::cout << "value of integer: " << *integer_pointer << std::endl;\n\n    // On peut m\xeame modifier la valeur de notre variable par ce biais\n\n    *integer_pointer = 18;\n    std::cout << "value of integer: " << integer << std::endl;\n\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"null-pointer"},"Null pointer"),(0,r.kt)("p",null,"Il est possible d'indiquer qu'un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," ne pointe actuellement sur ",(0,r.kt)("strong",{parentName:"p"},"rien")," en lui attribuant une valeur nulle avec le mot-cl\xe9 ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr"),": "),(0,r.kt)("p",null,"Il s'agit alors d'un pointeur nul (ou ",(0,r.kt)("strong",{parentName:"p"},"null pointer")," en anglais).\nLe ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," d'un pointeur nul provoque une erreur:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nvoid displayPointer(int const* ptr)\n{\n    if (ptr != nullptr)\n    {\n        std::cout << *ptr << std::endl;\n    }\n    else\n    {\n        std::cout << "null" << std::endl;\n    }\n}\n\nint main()\n{\n    float* float_pointer {nullptr};\n    \n    displayPointer(float_pointer); // null\n\n    return 0;\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Il existe \xe9galement le mot-cl\xe9 ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," qui vient du ",(0,r.kt)("strong",{parentName:"p"},"C")," pour indiquer un pointeur nul. Il a cependant des inconv\xe9nients et je vous demande d'utiliser ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr")," en ",(0,r.kt)("strong",{parentName:"p"},"C++")," qui est plus s\xfbr.")),(0,r.kt)("h2",{id:"allocation-dynamique-en-pratique-new--delete"},"Allocation dynamique en pratique: New & delete"),(0,r.kt)("p",null,"Comme je l'ai \xe9voqu\xe9 pr\xe9c\xe9demment avec l\u2019allocation ",(0,r.kt)("strong",{parentName:"p"},"dynamique")," dans la ",(0,r.kt)("strong",{parentName:"p"},"Heap")," on va donc demander un emplacement m\xe9moire et le lib\xe9rer plus tard. Cela se fait avec les mots-cl\xe9s ",(0,r.kt)("strong",{parentName:"p"},"new")," et ",(0,r.kt)("strong",{parentName:"p"},"delete"),". Cette demande de m\xe9moire va retourner un ",(0,r.kt)("strong",{parentName:"p"},"pointeur"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main()\n{\n    // je demande un emplacement m\xe9moire pour un entier\n    int* integer_ptr {new int};\n\n    // je peux aussi demander et initialiser un entier\n    int* number_ptr {new int{5}};\n\n    std::cout << number_ptr << std::endl;\n    std::cout << *number_ptr << std::endl;\n\n    // Une fois que l'on en a plus besoin, on lib\xe8re les zones m\xe9moire demand\xe9es\n    delete number_ptr;\n    delete integer_ptr;\n\n    return 0;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="qui nous donne:"',title:'"qui',nous:!0,'donne:"':!0},"0x557590f93eb0\n5\n")),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},'Le pointeur est toujours "',(0,r.kt)("em",{parentName:"p"},"existant"),"\" apr\xe8s avoir \xe9t\xe9 lib\xe9r\xe9. Le pointeur n'est rien d'autre qu'un nombre repr\xe9sentant l'",(0,r.kt)("strong",{parentName:"p"},"adresse")," m\xe9moire. Cela ne veut pas dire que nous avons le ",(0,r.kt)("strong",{parentName:"p"},"droit")," de manipuler cette m\xe9moire. Si l'espace m\xe9moire point\xe9 par le ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," est lib\xe9r\xe9, il ne faut ",(0,r.kt)("strong",{parentName:"p"},"pas")," l'utiliser car cet emplacement m\xe9moire ne nous appartient plus."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main()\n{\n    int* number_ptr {new int{2}};\n    delete number_ptr;\n\n    // Ici l'adresse \xe9tant un nombre, elle est toujours valide\n    std::cout << number_ptr << std::endl;\n    // Mais la valeur contenue \xe0 cette adresse peut prendre n'importe quelle valeur en fonction de l'usage nouveau de cet emplacement m\xe9moire\n    std::cout << *number_ptr << std::endl;\n\n    return 0;\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"Il est donc recommand\xe9 d'assigner au pointeur la valeur ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr")," une fois lib\xe9r\xe9 pour \xe9viter tout probl\xe8me."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int* number_ptr {new int{2}};\ndelete number_ptr;\nnumber_ptr = nullptr;\n// ...\n"))),(0,r.kt)("h2",{id:"tableaux"},"Tableaux"),(0,r.kt)("p",null,"Il est \xe9galement possible de demander plusieurs emplacements m\xe9moire contigu\xebs (autrement dit un tableau) d'un coup en pr\xe9cisant entre ",(0,r.kt)("strong",{parentName:"p"},"crochets")," la taille du tableau ",(0,r.kt)("kbd",null," ","[ ]"," "),".\nLe ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," va contenir alors l'adresse du ",(0,r.kt)("strong",{parentName:"p"},"premier")," \xe9l\xe9ment du tableau."),(0,r.kt)("p",null,"L'adresse stock\xe9e par le pointeur \xe9tant un nombre (repr\xe9sent\xe9 en ",(0,r.kt)("strong",{parentName:"p"},"hexad\xe9cimal"),") il est possible de faire des op\xe9rations dessus comme l'addition ou la soustraction. Cela permet de se positionner sur un emplacement m\xe9moire pr\xe9cis du tableau."),(0,r.kt)("p",null,"Pour lib\xe9rer un tableau allou\xe9 dynamiquement, il faut utiliser le mot-cl\xe9 ",(0,r.kt)("strong",{parentName:"p"},"delete")," suivi de ",(0,r.kt)("strong",{parentName:"p"},"crochets")," ",(0,r.kt)("kbd",null," ","[ ]"," "),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int main()\n{\n    // attention ici les valeurs ne sont pas initialis\xe9es\n    int* array_ptr {new int[5]};\n\n    // Je me positionne sur le 3\xe8me \xe9l\xe9ment du tableau et j'utilise le d\xe9r\xe9f\xe9rencement pour modifier sa valeur\n    *(array_ptr + 2) = 42;\n\n    // On peut aussi utiliser la notation avec les crochets qui est \xe9quivalente\n    array_ptr[2] = 42;\n\n    // Je lib\xe8re l'espace m\xe9moire allou\xe9\n    delete[] array_ptr;\n\n    return 0;\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Si la taille est connue \xe0 l'avance (\xe0 la ",(0,r.kt)("strong",{parentName:"p"},"compilation"),"), il est aussi possible de d\xe9clarer un tableau sur la ",(0,r.kt)("strong",{parentName:"p"},"Stack")," avec la taille entre ",(0,r.kt)("strong",{parentName:"p"},"crochets")," ",(0,r.kt)("kbd",null,"[ ]"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int main()\n{\n    int array[5];\n\n    // Je peux acc\xe9der aux valeurs du tableau avec les crochets\n    array[0] = 42;\n\n    return 0;\n}\n"))),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Il est important de noter que le ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," ne contient pas la taille du tableau. Il est donc important de la conserver quelque part pour ne pas d\xe9passer la taille du tableau."),(0,r.kt)("p",{parentName:"admonition"},"Si vous d\xe9passez, vous risquez de modifier des valeurs qui ne vous appartiennent pas et donc de causer des erreurs."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int main()\n{\n    int* array_ptr {new int[5]};\n\n    // Ici je d\xe9passe la taille du tableau et j'essaie de modifier une valeur qui ne m'appartient pas\n    array_ptr[5] = 42;\n\n    return 0;\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"Il s'agit d'une erreur tr\xe8s courante appel\xe9e \"",(0,r.kt)("strong",{parentName:"p"},"erreur de segmentation"),"\". Elle se produit lorsque votre programme essaie de lire ou d'\xe9crire dans une zone m\xe9moire qui ne lui a pas \xe9t\xe9 attribu\xe9e (ou ne l'est plus).")),(0,r.kt)("p",null,"C'est la fa\xe7on de g\xe9rer les tableaux en ",(0,r.kt)("strong",{parentName:"p"},"C"),". Cependant, en ",(0,r.kt)("strong",{parentName:"p"},"C++")," il existe des ",(0,r.kt)("strong",{parentName:"p"},"structures de donn\xe9es")," plus adapt\xe9es pour g\xe9rer les tableaux comme ",(0,r.kt)("inlineCode",{parentName:"p"},"std::array")," ou ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," que nous avons vu pr\xe9c\xe9demment."),(0,r.kt)("h2",{id:"stdvector-explications"},"std::vector: explications"),(0,r.kt)("p",null,"Justement, parlons un peu de ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector"),".\nComme dit pr\xe9c\xe9demment, l'allocation dynamique (sur la ",(0,r.kt)("strong",{parentName:"p"},"Heap"),") est particuli\xe8rement int\xe9ressante lorsque l\u2019on ne sait pas \xe0 l\u2019avance la taille dont on va avoir besoin. C'est exactement le cas d'utilisation du ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector"),"."),(0,r.kt)("p",null,"En effet, ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," n'est rien d'autre qu'une ",(0,r.kt)("strong",{parentName:"p"},"structure de donn\xe9e")," qui g\xe8re en interne un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," vers une zone m\xe9moire contigu\xeb. Lorsque celui-ci est trop petit et que l'on souhaite tout de m\xeame ajouter une valeur, la structure demande un nouvel espace m\xe9moire plus grand, copie les donn\xe9es dans ce nouvel espace m\xe9moire et enfin lib\xe8re l'ancien espace m\xe9moire qui n'est donc plus utilis\xe9."),(0,r.kt)("p",null,"Ce changement (allocation, copie, lib\xe9ration de m\xe9moire) a un co\xfbt c'est pourquoi ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," pr\xe9voit un espace plus grand que n\xe9cessaire lors d'une allocation pour anticiper de futurs ajouts dans le tableau dynamique."),(0,r.kt)("p",null,"Il est possible de conna\xeetre la taille de l'espace de stockage allou\xe9 pour le ",(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," avec sa m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"capacity()")," qui retourne cette taille exprim\xe9e en nombre d'\xe9l\xe9ments. C'est diff\xe9rent de la taille actuellement utilis\xe9e qui s'obtient avec la m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"size()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null," Une impl\xe9mentation simplifi\xe9e "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct IntegerVector\n{\n    size_t size {0};\n    size_t capacity {0};\n    int* pointer {nullptr};\n\n    void reserve(size_t const newCapacity)\n    {\n        if (newCapacity <= capacity)\n        {\n            return;\n        }\n\n        // Je demande un nouvel espace m\xe9moire\n        int* newPointer {new int[newCapacity]};\n\n        // Si j'avais d\xe9j\xe0 un espace m\xe9moire\n        if (pointer != nullptr)\n        {\n            // Je copie les donn\xe9es de l'ancien espace m\xe9moire vers le nouveau\n            std::copy(pointer, pointer + size, newPointer);\n\n            // Je lib\xe8re l'ancien espace m\xe9moire\n            delete [ ] pointer;\n        }\n\n        // Je met \xe0 jour les informations de la structure\n        capacity = newCapacity;\n        pointer = newPointer;\n    }\n\n    void push_back(int const value)\n    {\n        // Si je n'ai plus de place dans mon tableau, j'en demande plus\n        if( size == capacity )\n        {\n            reserve( 2 * capacity + 1 );\n        }\n        // J'ajoute la valeur \xe0 la fin du tableau\n        objects[size] = value;\n        size++;\n        // objects[size++] = value;\n    }\n\n    void pop_back()\n    {\n        if (size > 0)\n        {\n            size--;\n        }\n    }\n\n    int & at(size_t const index)\n    {\n        // Si l'index est en dehors du tableau, je l\xe8ve une exception (erreur)\n        // Nous n'avons pas encore vu les exceptions, mais c'est un m\xe9canisme qui permet de g\xe9rer les erreurs\n        if (index >= size)\n        {\n            throw std::out_of_range(\"Index out of range\");\n        }\n        // Je retourne la valeur \xe0 l'index demand\xe9\n        return pointer[index];\n    }\n    //...\n};\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," est bien s\xfbr plus complexe que cela et a \xe9t\xe9 fait par des experts du ",(0,r.kt)("strong",{parentName:"p"},"C++")," mais cela permet de comprendre le principe qui se cache derri\xe8re cette structure de donn\xe9e.")),(0,r.kt)("h2",{id:"structure-et-this"},"Structure et This"),(0,r.kt)("p",null,"Vous vous souvenez de l'utilisation du mot-cl\xe9 ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," dans les m\xe9thodes de nos ",(0,r.kt)("strong",{parentName:"p"},"structures")," ?"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"this")," est en fait un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," vers la structure elle m\xeame !"),(0,r.kt)("p",null,"On peut donc faire un ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," et avoir acc\xe8s \xe0 la structure pour la modifier."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Product\n{\n    std::string name;\n    float price;\n    unsigned int quantity;\n\n    void ChangePrice(float const price)\n    {\n        (*this).price = price;\n        // this->price = price;\n    }\n};\n")),(0,r.kt)("p",null,"C'est ce qui permet ici de faire la diff\xe9rence entre ",(0,r.kt)("inlineCode",{parentName:"p"},"price")," qui est un param\xe8tre de la m\xe9thode et ",(0,r.kt)("inlineCode",{parentName:"p"},"this->price")," qui est le membre de la structure."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"La syntaxe ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," est en r\xe9alit\xe9 un raccourci de syntaxe qui permet de faire un ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," puis d'acc\xe9der \xe0 un membre ou une m\xe9thode de la structure:"),(0,r.kt)("p",{parentName:"admonition"},"Ces deux \xe9critures sont donc \xe9quivalentes: ",(0,r.kt)("inlineCode",{parentName:"p"},"this->member")," ",(0,r.kt)("inlineCode",{parentName:"p"},"(*this).member"),".")),(0,r.kt)("h2",{id:"les-r\xe9f\xe9rences-dans-tout-\xe7a"},"Les r\xe9f\xe9rences dans tout \xe7a"),(0,r.kt)("p",null,"Vous avez remarqu\xe9 des ressemblances entre les ",(0,r.kt)("strong",{parentName:"p"},"pointeurs")," et les ",(0,r.kt)("strong",{parentName:"p"},"r\xe9f\xe9rences")," ?\nC'est normal c'est le m\xeame m\xe9canisme sous-jacent.\nLa r\xe9f\xe9rence utilise l'adresse m\xe9moire de la variable cibl\xe9e."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Cependant, une r\xe9f\xe9rence ne peut pas \xeatre nulle comme avec ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr")," pour les pointeurs. Une r\xe9f\xe9rence est forc\xe9ment associ\xe9e \xe0 une variable.")),(0,r.kt)("p",null,"Une r\xe9f\xe9rence peut \xeatre consid\xe9r\xe9e comme un pointeur avec ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement automatique"),", c'est-\xe0-dire que le compilateur applique en quelque sorte l'op\xe9rateur ",(0,r.kt)("kbd",null,"*")," pour vous."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="comparaison"',title:'"comparaison"'},"#include <iostream>\n\nvoid addOneUsingPtr(int * a)\n{\n    *a += 1;\n}\n\nvoid addOneUsingRef(int & a)\n{\n    a += 1;\n}\n\nvoid constDisplayUsingRef(int const & a)\n{\n    std::cout << a << std::endl;\n}\n\nvoid constDisplayUsingPtr(int const * a)\n{\n    std::cout << *a << std::endl;\n}\n")),(0,r.kt)("p",null,"La r\xe9f\xe9rence a donc l'avantage d'\xeatre plus lisible et simple \xe0 utiliser."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Utiliser les ",(0,r.kt)("strong",{parentName:"p"},"pointeurs")," directement est plut\xf4t r\xe9serv\xe9 \xe0 des cas sp\xe9cifiques.\nComme par exemple dans le cas o\xf9 on souhaite une ",(0,r.kt)("strong",{parentName:"p"},'"r\xe9f\xe9rence" optionnelle')," (qui peut \xeatre nulle) ou alors ",(0,r.kt)("strong",{parentName:"p"},"r\xe9assigner la r\xe9f\xe9rence")," \xe0 une autre variable."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nvoid displayPointer(int const* ptr)\n{\n    if (ptr != nullptr)\n    {\n        std::cout << *ptr << std::endl;\n    }\n    else\n    {\n        std::cout << "null" << std::endl;\n    }\n}\n\nint main()\n{\n    int a {42};\n    int b {24};\n\n    int& ref {a};\n    ref = b; // a = b\n\n    int* ptr {&a};\n\n    *ptr = 12; // a = 12\n\n    ptr = &b; // ptr pointe sur b\n\n    *ptr = 36; // b = 36\n\n    displayPointer(ptr); // 36\n\n    ptr = nullptr;\n\n    displayPointer(ptr); // null\n\n    return 0;\n}\n'))),(0,r.kt)("h2",{id:"pointeurs-intelligents"},"Pointeurs intelligents"),(0,r.kt)("p",null,"Pendant l\u2019ex\xe9cution d'un programme, le syst\xe8me ne peut pas \xe9craser ce que les d\xe9veloppeurs ont demand\xe9. C\u2019est \xe0 nous, humains, de le g\xe9rer avec le mot-cl\xe9 ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," sinon cela provoque une ",(0,r.kt)("strong",{parentName:"p"},"fuite de m\xe9moire"),"."),(0,r.kt)("p",null,"Une ",(0,r.kt)("strong",{parentName:"p"},"fuite de m\xe9moire")," est la m\xe9moire qui a \xe9t\xe9 demand\xe9e par l\u2019utilisateur et qui n\u2019a ",(0,r.kt)("strong",{parentName:"p"},"jamais \xe9t\xe9 lib\xe9r\xe9e"),", lorsque le programme s\u2019est termin\xe9 ou que des pointeurs vers son emplacement ont \xe9t\xe9 perdus. Pour \xe9viter cela, chaque fois que nous n\u2019avons plus besoin d\u2019un \xe9l\xe9ment de la ",(0,r.kt)("strong",{parentName:"p"},"Heap")," allou\xe9, nous ",(0,r.kt)("strong",{parentName:"p"},"devons")," absolument le lib\xe9rer."),(0,r.kt)("p",null,"L'accumulation de fuites de m\xe9moire risque de provoquer un ",(0,r.kt)("strong",{parentName:"p"},"crash")," du programme ou de ralentir le syst\xe8me d'exploitation ou m\xeame dans le pire des cas faire planter l'ordinateur."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Pour \xe9viter ce probl\xe8me, et nous aider \xe0 g\xe9rer la m\xe9moire le ",(0,r.kt)("strong",{parentName:"p"},"C++11")," a introduit des pointeurs dits intelligents (",(0,r.kt)("strong",{parentName:"p"},"smart pointer")," en anglais) dans la ",(0,r.kt)("strong",{parentName:"p"},"biblioth\xe8que standard"),"."),(0,r.kt)("p",null,"Lorsque le ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," est d\xe9truit, la m\xe9moire allou\xe9e pr\xe9c\xe9demment est \xe9galement lib\xe9r\xe9e. Il n'est donc pas n\xe9cessaire de lib\xe9rer la m\xe9moire explicitement avec ",(0,r.kt)("inlineCode",{parentName:"p"},"delete"),", c'est le pointeur intelligent qui s'en charge."),(0,r.kt)("p",null,"Un pointeur intelligent est en quelque sorte une structure enveloppant un pointeur et permettant de s'assurer que la m\xe9moire est lib\xe9r\xe9e une fois que le pointeur n'est plus utilis\xe9."),(0,r.kt)("h3",{id:"unique_ptr"},"unique_ptr"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::unique_ptr")," est un pointeur intelligent qui g\xe8re une zone m\xe9moire allou\xe9e dynamiquement. Il est, comme son l'indique, l'unique responsable de cette zone m\xe9moire. Elle sera d\xe9truite d\xe8s que le pointeur est d\xe9truit."),(0,r.kt)("p",null,"Il ne peut pas \xeatre copi\xe9, c'est \xe0 dire que l'on ne peut pas avoir deux ",(0,r.kt)("inlineCode",{parentName:"p"},"std::unique_ptr")," pointant vers le m\xeame objet. Sinon, lors de la destruction des deux pointeurs, l'objet serait d\xe9truit deux fois."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <memory>\n\nint main()\n{\n    std::unique_ptr<int> ptr {new int{42}};\n\n    // On ne peut pas copier un unique_ptr\n    // std::unique_ptr<int> ptr2 {ptr};\n\n    // A la fin du bloc (de la fonction main ici), ptr est d\xe9truit et l'espace m\xe9moire est lib\xe9r\xe9\n}\n")),(0,r.kt)("h3",{id:"shared_ptr"},"shared_ptr"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr")," est un pointeur intelligent qui g\xe8re une zone m\xe9moire allou\xe9e dynamiquement. La responsabilit\xe9 de cette zone m\xe9moire peut-\xeatre partag\xe9e entre plusieurs ",(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr"),", et elle ne sera d\xe9truite que quand tous les ",(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr")," responsables auront \xe9t\xe9 d\xe9truits.\nIl est possible de copier un ",(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr")," pour partager la responsabilit\xe9 de la zone m\xe9moire. Il utilise un ",(0,r.kt)("strong",{parentName:"p"},"compteur")," interne pour savoir combien de ",(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr")," pointent vers la zone m\xe9moire. Lorsque ce compteur tombe \xe0 z\xe9ro, la zone m\xe9moire est lib\xe9r\xe9e."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <memory>\n\nint main()\n{\n    std::shared_ptr<int> ptr1 {new int{42}};\n\n    {\n        // On peut copier un shared_ptr\n        std::shared_ptr<int> ptr2 {ptr1};\n\n        // Changer la valeur de ptr1\n        *ptr1 = 24;\n\n        // ptr1 et ptr2 pointent vers la m\xeame zone m\xe9moire\n        std::cout << "ptr1 value:" << *ptr1 << std::endl; // 24\n        std::cout << "ptr2 value:" << *ptr2 << std::endl; // 24\n\n        *ptr2 = 12;\n\n        std::cout << "ptr1 value:" << *ptr1 << std::endl; // 12\n        std::cout << "ptr2 value:" << *ptr2 << std::endl; // 12\n        // Ici ptr2 est d\xe9truit mais la zone m\xe9moire n\'est pas lib\xe9r\xe9e car ptr1 pointe toujours vers cette zone m\xe9moire\n    }\n\n    std::cout << "ptr1 value:" << *ptr1 << std::endl; // 12\n\n    // A la fin du bloc (de la fonction main ici), ptr1 est d\xe9truit et l\'espace m\xe9moire est lib\xe9r\xe9\n    return 0;\n}\n')),(0,r.kt)("p",null,"C'est utile lorsque l'on souhaite partager un objet entre plusieurs parties du code."),(0,r.kt)("h3",{id:"weak_ptr"},"weak_ptr"),(0,r.kt)("p",null,"Il existe \xe9galement un pointeur intelligent ",(0,r.kt)("inlineCode",{parentName:"p"},"std::weak_ptr")," qui est un pointeur qui permet de pointer vers un objet g\xe9rer par un ",(0,r.kt)("inlineCode",{parentName:"p"},"std::shared_ptr")," sans augmenter le compteur de r\xe9f\xe9rences. C'est utile pour \xe9viter des r\xe9f\xe9rences circulaires et mieux g\xe9rer le cycle de vie des objets mais nous n'irons pas plus loin dans ce cours."),(0,r.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Il existe plusieurs types d'allocation de m\xe9moire:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"L'allocation de m\xe9moire ",(0,r.kt)("strong",{parentName:"li"},"statique")," est effectu\xe9e \xe0 la compilation. Elle est donc tr\xe8s rapide mais ne permet pas de modifier la taille de la m\xe9moire allou\xe9e."),(0,r.kt)("li",{parentName:"ul"},"L'allocation de m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"li"},"stack")," est effectu\xe9e \xe0 l'ex\xe9cution. Elle est utilis\xe9e pour allouer nos variables locales et est \xe0 privil\xe9gier car elle est rapide."),(0,r.kt)("li",{parentName:"ul"},"L'allocation de m\xe9moire ",(0,r.kt)("strong",{parentName:"li"},"dynamique")," sur la ",(0,r.kt)("strong",{parentName:"li"},"heap")," est effectu\xe9e \xe0 l'ex\xe9cution. Elle est utilis\xe9e si on ne conna\xeet pas la taille de la m\xe9moire \xe0 allouer \xe0 la compilation ou si on veut modifier la taille de la m\xe9moire allou\xe9e. Cela permet de g\xe9rer plus finement la m\xe9moire mais est plus lente que l'allocation de m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"li"},"stack"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," est une variable qui contient une ",(0,r.kt)("strong",{parentName:"p"},"adresse")," m\xe9moire (un nombre repr\xe9sent\xe9 en ",(0,r.kt)("em",{parentName:"p"},"hexad\xe9cimal"),"). C'est un type de variable \xe0 part enti\xe8re qu'on diff\xe9rencie avec le symbole ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," apr\xe8s le type de la variable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"On utilise les mots-cl\xe9s ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," pour ",(0,r.kt)("strong",{parentName:"p"},"allouer")," et ",(0,r.kt)("strong",{parentName:"p"},"d\xe9sallouer")," de la m\xe9moire sur la ",(0,r.kt)("strong",{parentName:"p"},"heap"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Le ",(0,r.kt)("strong",{parentName:"p"},"d\xe9r\xe9f\xe9rencement")," d'un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," permet d'acc\xe9der \xe0 la valeur de la variable point\xe9e. Cela s'effectue avec l'op\xe9rateur ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," devant le nom du ",(0,r.kt)("strong",{parentName:"p"},"pointeur"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Il est possible d'attribuer \xe0 un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," la valeur ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr")," qui repr\xe9sente un pointeur nul. Cela permet d'indiquer qu'un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," ne pointe sur rien. On l'utilise pour v\xe9rifier qu'un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," est valide avant de l'utiliser.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"std::vector")," est un ",(0,r.kt)("strong",{parentName:"p"},"conteneur")," qui permet de g\xe9rer les allocations dynamiques de tableaux \xe0 notre place.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"le mot-cl\xe9 ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," est un ",(0,r.kt)("strong",{parentName:"p"},"pointeur")," vers la ",(0,r.kt)("strong",{parentName:"p"},"structure")," elle m\xeame. Cela permet de faire la diff\xe9rence entre un param\xe8tre de m\xe9thode et un membre de la structure.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Il existe des ",(0,r.kt)("strong",{parentName:"p"},"pointeurs intelligents")," (smart pointer) qui permettent de g\xe9rer la m\xe9moire \xe0 notre place. Ils sont tr\xe8s pratiques car ils permettent d'\xe9viter les fuites m\xe9moires et les erreurs de d\xe9sallocation de m\xe9moire."))))}d.isMDXComponent=!0}}]);
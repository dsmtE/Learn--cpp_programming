"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[944],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>k});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(t),m=i,k=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(k,o(o({ref:n},p),{},{components:t})):a.createElement(k,o({ref:n},p))}));function k(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2044:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(7462),i=(t(7294),t(3905));const r={title:"Des boucles pour gagner du temps",tags:["C++"],sidebar_position:4},o="Introduction",l={unversionedId:"Lessons/Loops",id:"Lessons/Loops",title:"Des boucles pour gagner du temps",description:"Nous avons maintenant la capacit\xe9 d'ex\xe9cuter des codes diff\xe9rents en fonction de conditions.",source:"@site/content/Lessons/Loops.md",sourceDirName:"Lessons",slug:"/Lessons/Loops",permalink:"/Learn--cpp_programming/Lessons/Loops",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",sidebarPosition:4,frontMatter:{title:"Des boucles pour gagner du temps",tags:["C++"],sidebar_position:4},sidebar:"sidebar",previous:{title:"Un peu de logique avec les conditions",permalink:"/Learn--cpp_programming/Lessons/Conditions"}},s={},u=[{value:"While - &quot;Tant que ...&quot;",id:"while---tant-que-",level:2},{value:"Do while",id:"do-while",level:2},{value:"For",id:"for",level:2},{value:"Contr\xf4ler l&#39;ex\xe9cution",id:"contr\xf4ler-lex\xe9cution",level:2},{value:"Break",id:"break",level:3},{value:"Continue",id:"continue",level:3},{value:"Switch",id:"switch",level:2},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],p={toc:u},c="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(c,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Nous avons maintenant la capacit\xe9 d'ex\xe9cuter des codes diff\xe9rents en fonction de ",(0,i.kt)("strong",{parentName:"p"},"conditions"),".\nCependant, notre programme reste essentiellement lin\xe9aire, car nous ex\xe9cutons les instructions de haut en bas, l'un \xe0 la suite des autres."),(0,i.kt)("p",null,"Nous allons maintenant explorer de nouvelles structures de contr\xf4le: les ",(0,i.kt)("strong",{parentName:"p"},"boucles"),".\nElles vont nous permettre de r\xe9p\xe9ter plusieurs fois une s\xe9rie d'instructions, selon nos besoins."),(0,i.kt)("h2",{id:"while---tant-que-"},'While - "Tant que ..."'),(0,i.kt)("p",null,"La premi\xe8re est la boucle ",(0,i.kt)("strong",{parentName:"p"},"while"),", de l'anglais qui signifie \"tant que\".\nElle ex\xe9cute une s\xe9rie d\u2019instructions tant qu'une condition est vraie.\nUne fois que la condition devient fausse la boucle s\u2019arr\xeate et passe \xe0 la suite."),(0,i.kt)("mermaid",{value:"graph\nA(Start)\nB{Condition}\nC{Instructions}\nD(End)\n\nA --\x3e B\nB -- Condition is true --\x3e C\nC --\x3e B\nB -- Condition is false --\x3e D"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="un petit exemple"',title:'"un',petit:!0,'exemple"':!0},'#include <iostream>\nint main()\n{\n    int count { 10 };\n\n    while (count > 0)\n    {\n        std::cout << count << std::endl;\n        count--; // \xe9quivalent \xe0 "count -= 1;" ou encore "count = count - 1;"\n    }\n\n    return 0;\n}\n')),(0,i.kt)("p",null,"Le code \xe9value la condition avant d'effectuer quoi que ce soit. Dans notre cas si le ",(0,i.kt)("strong",{parentName:"p"},"compte est sup\xe9rieur \xe0 0")," alors on va afficher le nombre et le d\xe9cr\xe9menter.\nQuand finalement count vaut 0, la condition devient fausse, on passe \xe0 la suite du code. (",(0,i.kt)("strong",{parentName:"p"},"on ne va donc pas afficher la valeur 0"),")"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Attention aux ",(0,i.kt)("strong",{parentName:"p"},"boucles infinies")," !"),(0,i.kt)("p",{parentName:"admonition"},"Lorsque vous cr\xe9ez une boucle, assurez-vous qu'elle puisse s'arr\xeater \xe0 un moment ! Si la condition est toujours vraie, votre programme ne s'arr\xeatera jamais !")),(0,i.kt)("h2",{id:"do-while"},"Do while"),(0,i.kt)("p",null,"De mani\xe8re tr\xe8s similaire il existe la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"Do... while"),', qui signifie "fait .. tant que..."'),(0,i.kt)("p",null,"Ce type de boucle est moins utilis\xe9. La seule chose qui change par rapport \xe0 une boucle while, c'est la position de la condition : au lieu d'\xeatre au d\xe9but de la boucle, la condition est \xe0 la fin."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"La boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," peut tr\xe8s bien ne ",(0,i.kt)("strong",{parentName:"p"},"jamais")," \xeatre ex\xe9cut\xe9e si la ",(0,i.kt)("strong",{parentName:"p"},"condition est fausse d\xe8s le d\xe9part"),".\nDans mon exemple pr\xe9c\xe9dent, si on avait initialis\xe9 le count \xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", la condition aurait \xe9t\xe9 fausse d\xe8s le d\xe9but, et on ne serait jamais rentr\xe9 dans la boucle.")),(0,i.kt)("p",null,"Pour la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"Do... while"),", on rentre ",(0,i.kt)("strong",{parentName:"p"},"au moins une fois")," \xe0 l'int\xe9rieur. Le test se fait \xe0 la fin."),(0,i.kt)("p",null,"Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\nint main()\n{\n    int sum {0};\n    int number;\n    \n    do {\n        std::cout << "Entre un nombre: ";\n\n        std::cin >> number;\n\n        sum += number;\n\n    } while (number != 0);\n\n    std::cout << "La somme vaut " << sum << std::endl;\n\n    return 0;\n}\n')),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},'Il y a une petite sp\xe9cificit\xe9 suppl\xe9mentaire ici, il faut ajouter un "',(0,i.kt)("strong",{parentName:"p"},";"),'" \xe0 la fin de la ligne contenant la condition while.')),(0,i.kt)("h2",{id:"for"},"For"),(0,i.kt)("p",null,"Un des cas les plus fr\xe9quents avec les boucles est d'avoir un compteur et un nombre d'it\xe9rations pr\xe9d\xe9fini."),(0,i.kt)("p",null,"On pourrait tr\xe8s bien le faire avec la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"while"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// initialisation (d'un compteur ou autre chose li\xe9 \xe0 la boucle)\nwhile (/* condition */)\n{\n    // Instructions\n    // It\xe9ration (mise \xe0 jour du compteur g\xe9n\xe9ralement)\n}\n")),(0,i.kt)("p",null,"Mais il existe une boucle d\xe9di\xe9e \xe0 cela qui permet de s\xe9parer le reste de notre code de ce qui est li\xe9 \xe0 la boucle. Cela rend le code plus clair et plus compr\xe9hensible surtout dans le cas ou l'on connait \xe0 l'avance le nombre d'it\xe9rations."),(0,i.kt)("p",null,"C'est la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),' ("',(0,i.kt)("strong",{parentName:"p"},"pour"),"\" en anglais) et elle s'utilise selon le sch\xe9ma suivant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"for (/*initialisation*/ ; /*condition*/ ; /*It\xe9ration*/)\n{\n    // Instructions\n}\n")),(0,i.kt)("p",null,"Voil\xe0 le m\xeame exemple qu'avec la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," mais ici avec la boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    for (int count { 10 }; count > 0 ; count--)\n    {\n        std::cout << count << std::endl;\n    }\n\n    return 0;\n}\n")),(0,i.kt)("p",null,"L'avantage ici est que le d\xe9tail de ce que fait la boucle est concentr\xe9 sur la m\xeame ligne."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Un autre gros avantage est que la ",(0,i.kt)("strong",{parentName:"p"},"port\xe9e de la variable")," (",(0,i.kt)("strong",{parentName:"p"},"scope"),") est ",(0,i.kt)("strong",{parentName:"p"},"limit\xe9e")," \xe0 la boucle et donc rend notre code plus s\xfbr et propre."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    for (int count { 10 }; count > 0 ; count--)\n    {\n        std::cout << count << std::endl;\n    }\n    \n    std::cout << count << std::endl;\n\n    return 0;\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"La variable ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," ici est uniquement n\xe9cessaire pour la boucle en question et n'a donc pas lieu d'\xeatre partag\xe9e ensuite avec le reste du code pour \xe9viter des erreurs.\nSi on essaye de le faire le compilateur nous donne l'erreur suivante:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Compilation failed due to following error(s)"',title:'"Compilation',failed:!0,due:!0,to:!0,following:!0,'error(s)"':!0},"main.cpp: In function \u2018int main()\u2019:\nmain.cpp:17:18: error: \u2018count\u2019 was not declared in this scope\n   17 |     std::cout << count << std::endl;\n      |                  ^~~~~\n"))),(0,i.kt)("p",null,"Mais alors quand choisir une boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," ou une boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," ?"),(0,i.kt)("p",null,"C'est une question l\xe9gitime et il n'y a pas de bonne r\xe9ponse, vous \xeates libre.\nEn g\xe9n\xe9ral on utilise une boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," dans le cas o\xf9 l'on connait le nombre d'it\xe9rations \xe0 l'avance (un compteur, un nombre de niveaux ou de joueurs dans un jeu, etc...).\nLa boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"while"),", quant \xe0 elle, est g\xe9n\xe9ralement utilis\xe9e pour effectuer des actions sans savoir \xe0 l'avance le nombre d'it\xe9rations que l'on va effectuer (par exemple la gestion de l'entr\xe9e utilisateur ou dans un jeu faire bouger un ennemi ",(0,i.kt)("strong",{parentName:"p"},"tant qu"),"'il n'a pas atteint sa cible)"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'Plus simplement, essayez de dire ce que vous voulez faire et si votre phrase contient "',(0,i.kt)("strong",{parentName:"p"},"pour"),'" ou "',(0,i.kt)("strong",{parentName:"p"},"pour chaque ... faire ..."),"\" il est pr\xe9f\xe9rable d'utiliser une boucle ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),'. Et si vous vous d\xeetes "',(0,i.kt)("strong",{parentName:"p"},"Tant que ... faire ..."),'" alors vous devriez utiliser une boucle ',(0,i.kt)("inlineCode",{parentName:"p"},"while"),".")),(0,i.kt)("h2",{id:"contr\xf4ler-lex\xe9cution"},"Contr\xf4ler l'ex\xe9cution"),(0,i.kt)("p",null,"Les boucles sont tr\xe8s utiles, mais parfois on aimerait pouvoir contr\xf4ler plus finement les instructions \xe0 l\u2019int\xe9rieur des accolades et pouvoir s'arr\xeater plus t\xf4t ou ne pas ex\xe9cuter les instructions pour un cas particulier."),(0,i.kt)("p",null,"Il existe en ",(0,i.kt)("strong",{parentName:"p"},"C++")," deux mots-cl\xe9s: ",(0,i.kt)("strong",{parentName:"p"},"break")," et ",(0,i.kt)("strong",{parentName:"p"},"continue")),(0,i.kt)("h3",{id:"break"},"Break"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Break"),' (de anglais "casser"/"interrompre") permet d\'interrompre une boucle et mettre fin \xe0 l\u2019ex\xe9cution de celle-ci peu importe o\xf9 on en est.'),(0,i.kt)("p",null,'Voyons un exemple plus "complexe" ensemble:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'for (int i { 0 }; i < 5; ++i)\n    {\n        std::cout << "i : " << i << std::endl;\n        \n        for (int j { 0 }; j < i; ++j)\n        {\n            if (j == 2)\n            {\n                std::cout << "break j == 2" << std::endl;\n                break;\n            }\n    \n            std::cout << "j : " << j << std::endl;\n        }\n        std::cout << std::endl;\n        \n    }\n')),(0,i.kt)("p",null,"qui nous donne le r\xe9sultat suivant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"i: 0\n\ni: 1\nj: 0\n\ni: 2\nj: 0\nj: 1\n\ni: 3\nj: 0\nj: 1\nbreak j == 2\n\ni: 4\nj: 0\nj: 1\nbreak j == 2\n")),(0,i.kt)("p",null,"Ici il y a plusieurs choses qui se passent:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"il y a d\xe9j\xe0 deux boucles imbriqu\xe9es, et oui rien ne nous emp\xeache de faire cela en C++"),(0,i.kt)("li",{parentName:"ul"},"la deuxi\xe8me boucle (sur la variable ",(0,i.kt)("strong",{parentName:"li"},"j"),") d\xe9pend de la variable ",(0,i.kt)("strong",{parentName:"li"},"i")," de la premi\xe8re (c'est parfois utile de le faire et je vous montre donc un petit exemple)"),(0,i.kt)("li",{parentName:"ul"},"ici le mot cl\xe9 ",(0,i.kt)("inlineCode",{parentName:"li"},"break")," permet d'interrompre la boucle de la variable j si la valeur de j est \xe9gale \xe0 2.")),(0,i.kt)("p",null,"Une petite analyse des it\xe9rations s'impose:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"la premi\xe8re fois i est \xe9gal \xe0 0 et donc la condition ",(0,i.kt)("inlineCode",{parentName:"li"},"j < i")," est directement fausse vu que j aussi est \xe9gal \xe0 0.\nensuite"),(0,i.kt)("li",{parentName:"ul"},"ensuite i est \xe9gal \xe0 1 et donc on passe une fois seulement dans la boucle du j car \xe0 la seconde it\xe9ration j devient \xe9gal \xe0 i et invalide la condition ",(0,i.kt)("inlineCode",{parentName:"li"},"j < i"),"."),(0,i.kt)("li",{parentName:"ul"},"la troisi\xe8me fois c'est le ",(0,i.kt)("inlineCode",{parentName:"li"},"break")," qui entre en jeu et permet d'interrompre la boucle quand j est \xe9gal \xe0 2 (\xe0 noter que la condition de la boucle aurait aussi invalid\xe9 la condition ",(0,i.kt)("inlineCode",{parentName:"li"},"j < i"),")"),(0,i.kt)("li",{parentName:"ul"},"enfin ici le ",(0,i.kt)("inlineCode",{parentName:"li"},"break")," prend tout son sens car s'il n'\xe9tait pas l\xe0, on aurait encore continu\xe9 un tour car j \xe9tant \xe9gal \xe0 3, la condition (",(0,i.kt)("inlineCode",{parentName:"li"},"j < i"),") serait valide car i est \xe9gal \xe0 4 et que ",(0,i.kt)("inlineCode",{parentName:"li"},"3 < 4"),".")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Comme nous venons de le voir, dans le cas de boucles imbriqu\xe9es cela arr\xeate seulement la boucle du niveau au dessus et pas toutes les boucles.")),(0,i.kt)("h3",{id:"continue"},"Continue"),(0,i.kt)("p",null,"L\u2019autre mot-cl\xe9, ",(0,i.kt)("inlineCode",{parentName:"p"},"continue"),", permet de sauter l\u2019it\xe9ration courante."),(0,i.kt)("p",null,"Toutes les instructions du bloc sont ignor\xe9es et la boucle continue au tour suivant."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'for (int i { 0 }; i < 5; ++i)\n{\n    if( i == 3)\n    {\n        continue;\n    }\n    std::cout << "i : " << i << std::endl;\n}\n')),(0,i.kt)("p",null,"Ce qui nous donne:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"i : 0\ni : 1\ni : 2\ni : 4\n")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Comme cela interrompt la totalit\xe9 des instructions suivantes de la boucle cela peut \xeatre dangereux dans le cas d'une boucle ",(0,i.kt)("strong",{parentName:"p"},"while"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    int count { 10 };\n\n    while (count > 0)\n    {\n        std::cout << count << std::endl;\n\n        if (count == 5)\n        {\n            continue;\n        }\n        count--;\n    }\n\n    return 0;\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Ici, l'instruction de ",(0,i.kt)("inlineCode",{parentName:"p"},"count--;")," ne sera donc jamais appel\xe9e une fois que ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," devient \xe9gal \xe0 5.\n",(0,i.kt)("inlineCode",{parentName:"p"},"count")," restera donc \xe9gal \xe0 5 ind\xe9finiment: C'est une ",(0,i.kt)("strong",{parentName:"p"},"boucle infinie"),".")),(0,i.kt)("h2",{id:"switch"},"Switch"),(0,i.kt)("p",null,"Mainteant que nous avons toutes les cartes en main revenons bri\xe8vement au ",(0,i.kt)("strong",{parentName:"p"},"switch")," dont je vous parlais au chapitre pr\xe9c\xe9dent sur les conditions."),(0,i.kt)("p",null,"Tr\xe8s souvent on veut tester la valeur d'une variable et effectuer telle ou telle action en fonction. On pourrait tr\xe8s bien \xe9crire cela avec des ",(0,i.kt)("inlineCode",{parentName:"p"},"else if"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    int value { 42 };\n    if ( value == 12 )\n    {\n        // ...\n    }\n    else if ( value == 33 )\n    {\n        // ...\n    }\n    else  if ( value == 52)\n    {\n        //...\n    }\n    else {\n        //...  \n    }\n    return 0;\n}\n")),(0,i.kt)("p",null,"C'est avec le mot cl\xe9 ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," que l'on va pouvoir faire cela de fa\xe7on plus lisible:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    int value { 42 };\n    switch (value)\n    {\n        case 12:\n            // ...\n            break; // permet de quitter le bloc switch\n        case 33:\n            // ...\n            break;\n        case 52:\n            // ...\n            break;\n        default:\n            // ...\n            break;\n    }\n\n    return 0;\n}\n")),(0,i.kt)("p",null,"Lorsque l'expression test\xe9e est \xe9gale \xe0 une des valeurs list\xe9es avec les mots-cl\xe9s ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," la ",(0,i.kt)("strong",{parentName:"p"},"totalit\xe9")," des instructions qui suivent sont ex\xe9cut\xe9es.\nLe mot cl\xe9 ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," indique la sortie de la structure de contr\xf4le.\nLe mot cl\xe9 ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," indique quelles instructions ex\xe9cuter si l'expression n'est jamais \xe9gale \xe0 une des valeurs."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"De mani\xe8re g\xe9n\xe9rale, n'oubliez pas d'ins\xe9rer des instructions ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," entre chaque test, ce genre d'oubli est difficile \xe0 d\xe9tecter car aucune erreur n'est signal\xe9e...\nEn effet la ",(0,i.kt)("strong",{parentName:"p"},"totalit\xe9")," des instructions suivant le ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," sont ex\xe9cut\xe9es et donc on pourrait se retrouver \xe0 ex\xe9cuter des instructions de mani\xe8re involontaire."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\nint main()\n{\n    int value { 33 };\n    switch (value)\n    {\n        case 12:\n            std::cout << "value est \xe9gale \xe0 12" << std::endl;\n        case 33:\n            std::cout << "value est \xe9gale \xe0 33" << std::endl;\n        default:\n            std::cout << "value est diff\xe9rent de 12 ou 33" << std::endl;\n    }\n\n    return 0;\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"qui nous donne:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"value est \xe9gale \xe0 33\nvalue est diff\xe9rent de 12 ou 33\n")),(0,i.kt)("p",{parentName:"admonition"},"Cela peut \xeatre parfois voulu mais ici on se rend bien compte qu'il y a un probl\xe8me et il ne faut donc pas oublier le mot cl\xe9 ",(0,i.kt)("inlineCode",{parentName:"p"},"break"),"."),(0,i.kt)("p",{parentName:"admonition"},"Voici un exemple o\xf9 cela peut \xeatre utile:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\nint main()\n{\n    char letter { 'e' };\n    switch(letter)\n    {\n        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n        case 'y':\n            std::cout << \"You entered a vowel.\" << std::endl;\n            break;\n        default:\n            std::cout << \"You entered a consonant.\" << std::endl;\n            break;\n    }\n\n    return 0;\n}\n"))),(0,i.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Il existe trois types de boucle:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"la boucle ",(0,i.kt)("inlineCode",{parentName:"li"},"while")," qui permet d'ex\xe9cuter des instructions tant qu'une condition est v\xe9rifi\xe9e."),(0,i.kt)("li",{parentName:"ul"},"la boucle ",(0,i.kt)("inlineCode",{parentName:"li"},"Do while")," qui permet de faire la m\xeame chose que la boucle ",(0,i.kt)("inlineCode",{parentName:"li"},"while")," mais en faisant le test seulement \xe0 la fin et permettant d'ex\xe9cuter les instructions ",(0,i.kt)("strong",{parentName:"li"},"au moins une fois"),"."),(0,i.kt)("li",{parentName:"ul"},"la boucle ",(0,i.kt)("inlineCode",{parentName:"li"},"for")," plus utile en pratique quand l'on connait \xe0 l'avance le nombre d'it\xe9rations \xe0 effectuer. Elle permet aussi de mieux \"scoper\" les variables et ",(0,i.kt)("strong",{parentName:"li"},"limiter leur port\xe9e"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Il existe deux mots-cl\xe9s ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," et ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," qui permettent de contr\xf4ler plus finemment les boucles.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"La structure de contr\xf4le ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," est une alternative au ",(0,i.kt)("inlineCode",{parentName:"p"},"else if"),"."))))}d.isMDXComponent=!0}}]);
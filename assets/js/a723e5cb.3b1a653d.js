"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[96],{3905:(e,r,n)=>{n.d(r,{Zo:()=>s,kt:()=>N});var t=n(7294);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function l(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=t.createContext({}),u=function(e){var r=t.useContext(p),n=r;return e&&(n="function"==typeof e?e(r):o(o({},r),e)),n},s=function(e){var r=u(e.components);return t.createElement(p.Provider,{value:r},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},c=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(n),c=a,N=d["".concat(p,".").concat(c)]||d[c]||m[c]||i;return n?t.createElement(N,o(o({ref:r},s),{},{components:n})):t.createElement(N,o({ref:r},s))}));function N(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var p in r)hasOwnProperty.call(r,p)&&(l[p]=r[p]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4182:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var t=n(7462),a=(n(7294),n(3905));const i={title:"TD6 - Arbres binaires"},o="Arbres binaires de recherche",l={unversionedId:"TDs/S2/binaryTree",id:"TDs/S2/binaryTree",title:"TD6 - Arbres binaires",description:"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche.",source:"@site/content/TDs/S2/06_binaryTree.md",sourceDirName:"TDs/S2",slug:"/TDs/S2/binaryTree",permalink:"/Learn--cpp_programming/TDs/S2/binaryTree",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"TD6 - Arbres binaires"},sidebar:"TDs",previous:{title:"TD5 - Hachage et tableaux associatifs",permalink:"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables"}},p={},u=[],s={toc:u},d="wrapper";function m(e){let{components:r,...n}=e;return(0,a.kt)(d,(0,t.Z)({},s,n,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"arbres-binaires-de-recherche"},"Arbres binaires de recherche"),(0,a.kt)("p",null,"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche."),(0,a.kt)("h1",{id:"impl\xe9mentation"},"Impl\xe9mentation"),(0,a.kt)("p",null,"Donnons nous pour commencer la structure suivante pour repr\xe9senter un noeud d'un arbre binaire."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Node {\n    int value;\n    Node* left = nullptr;\n    Node* right = nullptr;\n};\n")),(0,a.kt)("p",null,"et \xe9galement la structure suivante pour repr\xe9senter un arbre binaire qui n'est rien d'autre qu'un pointeur vers son noeud racine."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct BinaryTree {\n    Node* root = nullptr;\n};\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"On pourrait se passer de cette seconde structure et utiliser directement un pointeur vers le noeud racine. Cependant, cela nous permettra de d\xe9finir des fonctions et m\xe9thodes qui font plus de sens et permet de mieux structurer notre code.\nCela permet au passage de g\xe9rer plus facilement le cas particulier d'un arbre vide qui est repr\xe9sent\xe9 par un pointeur nul.")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\xc9crire une fonction ",(0,a.kt)("inlineCode",{parentName:"li"},"createNode")," qui prend en param\xe8tre une valeur et permet de cr\xe9er (sur la heap avec ",(0,a.kt)("strong",{parentName:"li"},"new"),") un noeud contenant cette valeur et dont les fils sont pointeur nuls.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Node* createNode(int value);\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"li"},"insert")," \xe0 la structure ",(0,a.kt)("inlineCode",{parentName:"li"},"BinaryTree")," qui prend en param\xe8tre une valeur et qui ins\xe8re un nouveau noeud contenant cette valeur dans l'arbre binaire. On ins\xe9rera le noeud \xe0 gauche si la valeur est inf\xe9rieure \xe0 la valeur du noeud courant et \xe0 droite sinon.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void BinaryTree::insert(int value);\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"infixe")," sur la structure sur la structure BinaryTree qui retourne un vecteur contenant les pointeurs vers les noeuds de l'arbre binaire parcourus en ",(0,a.kt)("strong",{parentName:"p"},"infixe"),"."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<Node const*> BinaryTree::infixe() const;\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"De m\xeame, \xe9crire deux autres m\xe9thodes ",(0,a.kt)("inlineCode",{parentName:"p"},"prefixe")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"postfixe")," qui retournent les noeuds parcourus dans l'ordre ",(0,a.kt)("strong",{parentName:"p"},"pr\xe9fixe")," et ",(0,a.kt)("strong",{parentName:"p"},"postfixe")," respectivement.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"displayNodeValues")," qui prends en param\xe8tre un vecteur de pointeurs vers des noeuds et qui affiche les valeurs de ces noeuds, s\xe9par\xe9es par un s\xe9parateur pass\xe9 en param\xe8tre."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'void displayNodeValues(std::vector<Node const*> const& nodes, std::string separator = ", ");\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"mostLeftNodeFrom")," qui prend en param\xe8tre un pointeur vers un noeud et qui retourne un pointeur vers le noeud le plus \xe0 gauche de l'arbre binaire dont ce noeud est la racine."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Node* mostLeftNodeFrom(Node* node);\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"De la m\xeame mani\xe8re, \xe9crire la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"mostRightNodeFrom"),"."))),(0,a.kt)("ol",{start:8},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," sur la structure ",(0,a.kt)("inlineCode",{parentName:"p"},"BinaryTree")," qui prend en param\xe8tre une valeur et qui retourne un pointeur vers le noeud contenant cette valeur dans l'arbre binaire. Si la valeur n'est pas pr\xe9sente dans l'arbre, on retourne un pointeur nul."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Node* BinaryTree::find(int value);\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire la m\xeame m\xe9thode find mais qui retourne un pointeur constant vers le noeud. On ne pourra donc pas modifier la valeur du noeud retourn\xe9 et on pourra utiliser cette m\xe9thode sur un arbre binaire constant."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Node const* BinaryTree::find(int value) const;\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"remove")," qui permet de supprimer une valeur de l'arbre binaire. On supprimera le noeud contenant cette valeur et on r\xe9organisera l'arbre pour que les noeuds restants soient toujours dans un ordre valide."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void BinaryTree::remove(int value);\n")),(0,a.kt)("admonition",{parentName:"li",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Il existe trois cas de figure lorsqu'on supprime un noeud d'un arbre binaire:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Le noeud n'a pas de fils: on peut le supprimer directement."),(0,a.kt)("li",{parentName:"ul"},"Le noeud a un seul fils: on peut le supprimer et le remplacer par son fils."),(0,a.kt)("li",{parentName:"ul"},"Le noeud a deux fils:\nIl faut remplacer la valeur du noeud \xe0 supprimer par une valeur pr\xe9server l'ordre de l'arbre. Pour cela, on utilisera les fonctions ",(0,a.kt)("inlineCode",{parentName:"li"},"mostLeftNodeFrom")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"mostRightNodeFrom")," qui permettent de trouver le noeud le plus \xe0 gauche ou le plus \xe0 droite d'un arbre binaire (autrement dit, le plus petit ou le plus grand noeud de l'arbre).\nIl faut ensuite remplacer la valeur du noeud \xe0 supprimer par la valeur du noeud trouv\xe9 pr\xe9c\xe9demment et supprimer ce  dit noeud pour ne pas avoir de doublon. (cela revient \xe0 intervertir les deux noeuds ans avoir \xe0 modifier les pointeurs puis \xe0 supprimer le noeud dont la valeur a \xe9t\xe9 copi\xe9e)."))),(0,a.kt)("admonition",{parentName:"li",type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Il faut faire attention \xe0 bien lib\xe9rer la m\xe9moire des noeuds supprim\xe9s."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"deleteTree")," qui prend en param\xe8tre un pointeur vers un noeud et qui supprime l'arbre binaire dont ce noeud est la racine (en prenant soin de lib\xe9rer la m\xe9moire des noeuds dans le bon ordre)"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void deleteTree(Node* node);\n")),(0,a.kt)("admonition",{parentName:"li",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"On peut utiliser de la r\xe9cursivit\xe9 pour supprimer les noeuds de l'arbre."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"clear")," sur la structure ",(0,a.kt)("inlineCode",{parentName:"p"},"BinaryTree")," qui permet de supprimer tous les noeuds de l'arbre binaire (et de lib\xe9rer la m\xe9moire)"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void BinaryTree::clear();\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\xc9crire une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"height")," sur la structure ",(0,a.kt)("inlineCode",{parentName:"p"},"BinaryTree")," qui retourne la hauteur de l'arbre binaire (c'est \xe0 dire la longueur du plus long chemin entre la racine et une feuille)."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int BinaryTree::height() const;\n")),(0,a.kt)("admonition",{parentName:"li",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"On peut utiliser de la r\xe9cursivit\xe9 pour calculer la hauteur de l'arbre.")))),(0,a.kt)("h1",{id:"pointeurs-intelligents"},"Pointeurs intelligents"),(0,a.kt)("p",null,"Nous allons maintenant am\xe9liorer et simplifier notre code en utilisant des pointeurs intelligents. En effet la partie la plus compliqu\xe9e de notre code est la gestion de la m\xe9moire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous d\xe9barrasser de cette gestion."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Copier coller votre fichier pour garder une version de votre code pr\xe9c\xe9dent.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Remplacer les pointeurs bruts par des pointeurs intelligents ",(0,a.kt)("inlineCode",{parentName:"p"},"std::unique_ptr")," dans la structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Node"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Modifier la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"createNode")," pour qu'elle retourne un pointeur intelligent ",(0,a.kt)("inlineCode",{parentName:"p"},"std::unique_ptr")," au lieu d'un pointeur brut (on utilisera la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"std::make_unique")," pour cr\xe9er le pointeur).")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Modifier la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"clear")," pour qu'elle utilise des pointeurs intelligents. (il n'y a plus besoin de la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"deleteTree"),")"))),(0,a.kt)("h1",{id:"utilisation"},"Utilisation"),(0,a.kt)("p",null,"Testons maintenant notre impl\xe9mentation en cr\xe9ant un programme qui permet de cr\xe9er un arbre binaire et d'effectuer diff\xe9rentes op\xe9rations dessus."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Cr\xe9er un arbre binaire et ins\xe9rer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Afficher les valeurs des noeuds de l'arbre binaire dans l'ordre ",(0,a.kt)("strong",{parentName:"p"},"infixe"),", ",(0,a.kt)("strong",{parentName:"p"},"pr\xe9fixe")," et ",(0,a.kt)("strong",{parentName:"p"},"postfixe"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Afficher la hauteur de l'arbre binaire."))))}m.isMDXComponent=!0}}]);
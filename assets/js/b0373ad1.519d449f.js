"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[8564],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),o=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=o(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=o(n),m=r,k=d["".concat(p,".").concat(m)]||d[m]||c[m]||s;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var o=2;o<s;o++)i[o]=n[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var a=n(7462),r=(n(7294),n(3905));const s={title:"Structures de donn\xe9es",tags:["C++"],sidebar_position:1},i=void 0,l={unversionedId:"Lessons/S2/dataStructures",id:"Lessons/S2/dataStructures",title:"Structures de donn\xe9es",description:"Piles et files (LIFO, FIFO)",source:"@site/content/Lessons/S2/dataStructures.md",sourceDirName:"Lessons/S2",slug:"/Lessons/S2/dataStructures",permalink:"/Learn--cpp_programming/Lessons/S2/dataStructures",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",sidebarPosition:1,frontMatter:{title:"Structures de donn\xe9es",tags:["C++"],sidebar_position:1}},p={},o=[{value:"Piles et files (LIFO, FIFO)",id:"piles-et-files-lifo-fifo",level:2},{value:"std::stack \u2014 Une pile",id:"stdstack--une-pile",level:3},{value:"std::queue \u2014 Une file",id:"stdqueue--une-file",level:3},{value:"std::pair \u2014 Un conteneur de paires d&#39;\xe9l\xe9ments",id:"stdpair--un-conteneur-de-paires-d\xe9l\xe9ments",level:2},{value:"D\xe9finition d&#39;une paire",id:"d\xe9finition-dune-paire",level:3},{value:"Comparaison de paires",id:"comparaison-de-paires",level:3},{value:"Utilisation de std::pair",id:"utilisation-de-stdpair",level:3},{value:"std::tuple \u2014 Un conteneur de donn\xe9es h\xe9t\xe9rog\xe8nes",id:"stdtuple--un-conteneur-de-donn\xe9es-h\xe9t\xe9rog\xe8nes",level:2},{value:"Pour aller plus loin",id:"pour-aller-plus-loin",level:2},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],u={toc:o},d="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"piles-et-files-lifo-fifo"},"Piles et files (LIFO, FIFO)"),(0,r.kt)("p",null,"Une ",(0,r.kt)("strong",{parentName:"p"},"pile")," est une structure de donn\xe9es qui permet de stocker des \xe9l\xe9ments de fa\xe7on \xe0 ce que le ",(0,r.kt)("strong",{parentName:"p"},"dernier")," \xe9l\xe9ment ajout\xe9 soit le ",(0,r.kt)("strong",{parentName:"p"},"premier")," \xe0 \xeatre retir\xe9. On parle de structure de donn\xe9es ",(0,r.kt)("strong",{parentName:"p"},"LIFO")," (Last In First Out)."),(0,r.kt)("p",null,"Une ",(0,r.kt)("strong",{parentName:"p"},"file")," est une structure de donn\xe9es qui permet de stocker des \xe9l\xe9ments de fa\xe7on \xe0 ce que le ",(0,r.kt)("strong",{parentName:"p"},"premier")," \xe9l\xe9ment ajout\xe9 soit le ",(0,r.kt)("strong",{parentName:"p"},"premier")," \xe0 \xeatre retir\xe9. On parle de structure de donn\xe9es ",(0,r.kt)("strong",{parentName:"p"},"FIFO")," (First In First Out)."),(0,r.kt)("h3",{id:"stdstack--une-pile"},"std::stack \u2014 Une pile"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/container/stack"},(0,r.kt)("inlineCode",{parentName:"a"},"std::stack"))," permet de repr\xe9senter une ",(0,r.kt)("strong",{parentName:"p"},"pile"),". Elle est d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<stack>"),"."),(0,r.kt)("p",null,"On utilise la m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," pour ajouter un \xe9l\xe9ment au sommet de la pile et la m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"pop")," pour retirer l'\xe9l\xe9ment au sommet de la pile."),(0,r.kt)("p",null,"Elle s'utilise de la m\xeame fa\xe7on que d'autres conteneurs de la biblioth\xe8que standard."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <stack>\n#include <iostream>\n\nint main() {\n    std::stack<int> stack;\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    std::cout << stack.top() << std::endl; // Affiche 3\n    stack.pop();\n    std::cout << stack.top() << std::endl; // Affiche 2\n    stack.pop();\n    std::cout << stack.top() << std::endl; // Affiche 1\n    stack.pop();\n}\n")),(0,r.kt)("h3",{id:"stdqueue--une-file"},"std::queue \u2014 Une file"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/container/queue"},(0,r.kt)("inlineCode",{parentName:"a"},"std::queue"))," permet de repr\xe9senter une ",(0,r.kt)("strong",{parentName:"p"},"file"),". Elle est d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<queue>"),"."),(0,r.kt)("p",null,"On utilise la m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," pour ajouter un \xe9l\xe9ment \xe0 la fin de la file et la m\xe9thode ",(0,r.kt)("inlineCode",{parentName:"p"},"pop")," pour retirer l'\xe9l\xe9ment au d\xe9but de la file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <queue>\n#include <iostream>\n\nint main() {\n    std::queue<int> queue;\n    queue.push(1);\n    queue.push(2);\n    queue.push(3);\n    std::cout << queue.front() << std::endl; // Affiche 1\n    queue.pop();\n    std::cout << queue.front() << std::endl; // Affiche 2\n    queue.pop();\n    std::cout << queue.front() << std::endl; // Affiche 3\n    queue.pop();\n}\n")),(0,r.kt)("h2",{id:"stdpair--un-conteneur-de-paires-d\xe9l\xe9ments"},"std::pair \u2014 Un conteneur de paires d'\xe9l\xe9ments"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/utility/pair"},(0,r.kt)("inlineCode",{parentName:"a"},"std::pair"))," (d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<utility>"),") permet de repr\xe9senter une paire d'\xe9l\xe9ments de types diff\xe9rents."),(0,r.kt)("p",null,"On peut acc\xe9der aux \xe9l\xe9ments de la paire avec les attributs ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"second"),"."),(0,r.kt)("h3",{id:"d\xe9finition-dune-paire"},"D\xe9finition d'une paire"),(0,r.kt)("p",null,"Pour d\xe9finir une paire, on peut utiliser la fonction ",(0,r.kt)("inlineCode",{parentName:"p"},"std::make_pair")," ou assigner les valeurs directement aux attributs ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"second"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <utility>\n#include <iostream>\n\nint main() {\n    std::pair<int, int> p1 {1, 2};\n    std::pair<int, int> p2 = std::make_pair(3, 4);\n    std::pair<int, int> p3 {};\n    p3.first = 5;\n    p3.second = 6;\n    std::cout << p1.first << " " << p1.second << std::endl; // Affiche 1 2\n    std::cout << p2.first << " " << p2.second << std::endl; // Affiche 3 4\n    std::cout << p3.first << " " << p3.second << std::endl; // Affiche 5 6\n}\n')),(0,r.kt)("p",null,"Si rien n'est sp\xe9cifi\xe9, les attributs ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"second")," sont initialis\xe9s avec des valeurs par d\xe9faut."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"La fonction ",(0,r.kt)("inlineCode",{parentName:"p"},"std::make_pair")," permet d'expliciter le type de la paire. C'est utile dans certains cas o\xf9 le type de la paire ne peut pas \xeatre d\xe9duit automatiquement.")),(0,r.kt)("h3",{id:"comparaison-de-paires"},"Comparaison de paires"),(0,r.kt)("p",null,"La ",(0,r.kt)("strong",{parentName:"p"},"paire")," int\xe8gre \xe9galement un op\xe9rateur de comparaison qui compare les \xe9l\xe9ments de la paire dans l'ordre ",(0,r.kt)("strong",{parentName:"p"},"lexicographique"),"."),(0,r.kt)("admonition",{title:"Ordre lexicographique",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"L'ordre ",(0,r.kt)("strong",{parentName:"p"},"lexicographique")," est comparable \xe0 l'ordre alphab\xe9tique. Si l'on, se limite aux mots et lettres c'est l'ordre utilis\xe9 pour comparer les mots dans un dictionnaire. On compare les premi\xe8res lettres des mots. Si les premi\xe8res lettres sont \xe9gales, on compare les secondes lettres, etc.\nCela peux \xeatre \xe9tendu \xe0 des \xe9l\xe9ments plus complexes comme des nombres. On compare les premiers \xe9l\xe9ments. Si les premiers \xe9l\xe9ments sont \xe9gaux, on compare les seconds \xe9l\xe9ments, etc.")),(0,r.kt)("p",null,"Dans le cas des paires, on compare les premiers \xe9l\xe9ments. Si les premiers \xe9l\xe9ments sont \xe9gaux, on compare les seconds \xe9l\xe9ments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <utility>\n#include <iostream>\n\nint main() {\n    std::pair<int, int> p1 {1, 2};\n    std::pair<int, int> p2 {1, 3};\n    std::pair<int, int> p3 {2, 1};\n    std::pair<int, int> p4 {1, 2};\n    std::cout << (p1 < p2) << std::endl; // Affiche 1\n    std::cout << (p1 < p3) << std::endl; // Affiche 1\n    std::cout << (p1 < p4) << std::endl; // Affiche 0\n}\n")),(0,r.kt)("h3",{id:"utilisation-de-stdpair"},"Utilisation de std::pair"),(0,r.kt)("p",null,"On peut se servir de la classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::pair")," et de son ordre lexicographique pour trier des \xe9l\xe9ments dans un tableau."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <utility>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<std::pair<int, int>> pairs {\n        {1, 2},\n        {3, 4},\n        {1, 3},\n        {2, 1},\n        {1, 1}\n    };\n    std::sort(pairs.begin(), pairs.end());\n    for (auto const& pair : pairs) {\n        std::cout << pair.first << " " << pair.second << std::endl;\n    }\n}\n')),(0,r.kt)("p",null,"Dans cet exemple, on trie les paires dans l'ordre lexicographique sur les premiers \xe9l\xe9ments. Si les premiers \xe9l\xe9ments sont \xe9gaux, on trie les paires dans l'ordre lexicographique sur les seconds \xe9l\xe9ments."),(0,r.kt)("p",null,"Ce qui donne le r\xe9sultat suivant :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"1 1\n1 2\n1 3\n2 1\n3 4\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Cela peut aussi \xeatre utile pour retourner plusieurs valeurs dans une fonction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <utility>\n#include <vector>\n\nstd::pair<float, float> minMax(std::vector<float> const& array) {\n    float min {array[0]};\n    float max {array[0]};\n    for (float const& value: array) {\n        if (value < min) {\n            min = value;\n        }\n        if (value > max) {\n            max = value;\n        }\n    }\n    return std::make_pair(min, max);\n}\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::pair")," est \xe9galement utilis\xe9e par d'autres conteneurs de la biblioth\xe8que standard comme ",(0,r.kt)("inlineCode",{parentName:"p"},"std::map")," que nous verrons plus tard.")),(0,r.kt)("h2",{id:"stdtuple--un-conteneur-de-donn\xe9es-h\xe9t\xe9rog\xe8nes"},"std::tuple \u2014 Un conteneur de donn\xe9es h\xe9t\xe9rog\xe8nes"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/utility/tuple"},(0,r.kt)("inlineCode",{parentName:"a"},"std::tuple"))," (d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<tuple>"),") permet de repr\xe9senter un ensemble de donn\xe9es h\xe9t\xe9rog\xe8nes"),(0,r.kt)("p",null,"C'est similaire \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"std::pair")," mais on peut stocker ",(0,r.kt)("strong",{parentName:"p"},"plus de deux \xe9l\xe9ments"),"."),(0,r.kt)("p",null,"On peut acc\xe9der aux \xe9l\xe9ments de la paire avec la fonction ",(0,r.kt)("inlineCode",{parentName:"p"},"std::get"),"."),(0,r.kt)("p",null,"Exemple :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'\n#include <tuple>\n#include <iostream>\n\nint main() {\n    std::tuple<int, float, std::string> t {1, 3.14f, "Hello"};\n    std::cout << std::get<0>(t) << std::endl; // Affiche 1\n    std::cout << std::get<1>(t) << std::endl; // Affiche 3.14\n    std::cout << std::get<2>(t) << std::endl; // Affiche Hello\n}\n')),(0,r.kt)("h2",{id:"pour-aller-plus-loin"},"Pour aller plus loin"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"std::variant"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant")," (d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<variant>"),") permet de stocker un \xe9l\xe9ment parmi un ensemble d'\xe9l\xe9ments possibles. Similaires aux aux enums, mais avec des types diff\xe9rents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <variant>\n#include <iostream>\n#include <string>\n\nstd::variant<int, float, std::string> v;\n\nv = 42; // v contient un int\nv = 3.14f; // v contient un float\nv = "Hello"; // v contient une std::string\n\nif (std::holds_alternative<int>(v)) {\n    std::cout << "v contient un int dont la valeur est " << std::get<int>(v) << std::endl;\n} else if (std::holds_alternative<float>(v)) {\n    std::cout << "v contient un float dont la valeur est " << std::get<float>(v) << std::endl;\n} else if (std::holds_alternative<std::string>(v)) {\n    std::cout << "v contient une std::string dont la valeur est " << std::get<std::string>(v) << std::endl;\n}\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"std::optional"),(0,r.kt)("p",null,"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::optional")," (d\xe9finie dans la biblioth\xe8que ",(0,r.kt)("inlineCode",{parentName:"p"},"<optional>"),") permet de stocker un \xe9l\xe9ment optionnel. C'est-\xe0-dire un \xe9l\xe9ment qui peut \xeatre pr\xe9sent ou non."),(0,r.kt)("p",null,"Pour repr\xe9senter un \xe9l\xe9ment optionnel qui ne contient rien, on peut utiliser la valeur ",(0,r.kt)("inlineCode",{parentName:"p"},"std::nullopt"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <optional>\n#include <iostream>\n#include <string>\n\nstd::optional<int> o;\n\no = 42; // o contient un int\n\nif (o.has_value()) {\n    std::cout << "o contient un int dont la valeur est " << o.value() << std::endl;\n} else {\n    std::cout << "o ne contient rien" << std::endl;\n}\n')),(0,r.kt)("p",null,"C'est un objet qui peut \xeatre utile pour repr\xe9senter des valeurs optionnelles, comme par exemple le r\xe9sultat d'une recherche dans un tableau ou une param\xe8tre optionnel d'une fonction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <optional>\n#include <iostream>\n#include <string>\n\n// Recherche la valeur dans le tableau et retourne son index si elle est trouv\xe9e sous forme d\'un std::optional\nstd::optional<size_t> find(std::vector<int> const& array, int value) {\n    for (size_t i {0}; i < array.size(); ++i) {\n        if (array[i] == value) {\n            return i;\n        }\n    }\n    return std::nullopt;\n}\n\nint main() {\n    std::vector<int> array {1, 2, 3, 4, 5};\n    std::optional<size_t> index {find(array, 3)};\n    if (index.has_value()) {\n        std::cout << "3 se trouve \xe0 l\'index " << index.value() << std::endl;\n    } else {\n        std::cout << "3 ne se trouve pas dans le tableau" << std::endl;\n    }\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Cela permet de ne pas avoir \xe0 utiliser des valeurs ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"sp\xe9ciales"))," pour repr\xe9senter l'absence de valeur comme par exemple ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," pour un index comme on retrouve souvent en ",(0,r.kt)("strong",{parentName:"p"},"C"),"."))),(0,r.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Les ",(0,r.kt)("strong",{parentName:"p"},"piles")," et les ",(0,r.kt)("strong",{parentName:"p"},"files")," sont des structures de donn\xe9es qui permettent de stocker des \xe9l\xe9ments de fa\xe7on \xe0 ce que le dernier \xe9l\xe9ment ajout\xe9 soit le premier \xe0 \xeatre retir\xe9 (",(0,r.kt)("strong",{parentName:"p"},"LIFO"),") ou le premier \xe9l\xe9ment ajout\xe9 soit le premier \xe0 \xeatre retir\xe9 (",(0,r.kt)("strong",{parentName:"p"},"FIFO"),"). On utilise les classes ",(0,r.kt)("inlineCode",{parentName:"p"},"std::stack")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"std::queue")," pour les repr\xe9senter dans la biblioth\xe8que standard de C++.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::pair")," (",(0,r.kt)("inlineCode",{parentName:"p"},"<utility>"),") permet de repr\xe9senter une paire d'\xe9l\xe9ments de types diff\xe9rents. C'est une classe qui est utilis\xe9e par d'autres ",(0,r.kt)("strong",{parentName:"p"},"conteneurs")," de la biblioth\xe8que standard comme ",(0,r.kt)("inlineCode",{parentName:"p"},"std::map"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::tuple")," (",(0,r.kt)("inlineCode",{parentName:"p"},"<tuple>"),") permet de repr\xe9senter un ensemble de donn\xe9es h\xe9t\xe9rog\xe8nes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("details",null,(0,r.kt)("summary",null,"std::optional"),(0,r.kt)("p",{parentName:"li"},"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::optional")," (",(0,r.kt)("inlineCode",{parentName:"p"},"<optional>"),") permet de stocker un \xe9l\xe9ment optionnel. C'est utile pour \xe9viter d'avoir recours \xe0 des valeurs ",(0,r.kt)("em",{parentName:"p"},"sp\xe9ciales")," pour repr\xe9senter l'absence de valeur."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("details",null,(0,r.kt)("summary",null,"std::variant"),(0,r.kt)("p",{parentName:"li"},"La classe ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant")," (",(0,r.kt)("inlineCode",{parentName:"p"},"<variant>"),") permet de stocker un \xe9l\xe9ment parmi un ensemble d'\xe9l\xe9ments possibles. C'est comparable aux enums, mais permet de stocker des types diff\xe9rents.")))))}c.isMDXComponent=!0}}]);
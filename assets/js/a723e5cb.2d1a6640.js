"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[9095],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},92416:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>a,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"TDs/S2/binaryTree","title":"TD6 - Arbres binaires","description":"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche.","source":"@site/content/TDs/S2/06_binaryTree.md","sourceDirName":"TDs/S2","slug":"/TDs/S2/binaryTree","permalink":"/Learn--cpp_programming/TDs/S2/binaryTree","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"TD6 - Arbres binaires"},"sidebar":"TDs","previous":{"title":"TD5 - Hachage et tableaux associatifs","permalink":"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables"},"next":{"title":"TD7 - Graphes","permalink":"/Learn--cpp_programming/TDs/S2/graphs"}}');var s=r(74848),t=r(28453);const l={title:"TD6 - Arbres binaires"},o="Arbres binaires de recherche",d={},c=[{value:"Exercice 1 (Impl\xe9mentation)",id:"exercice-1-impl\xe9mentation",level:2},{value:"Exercice 2 (Utilisation)",id:"exercice-2-utilisation",level:2},{value:"Aller plus loin",id:"aller-plus-loin",level:2},{value:"Exercice 3 (Pointeurs intelligents) (Bonus)",id:"exercice-3-pointeurs-intelligents-bonus",level:3},{value:"Exercice 4 (Encapsulation) (Bonus)",id:"exercice-4-encapsulation-bonus",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"arbres-binaires-de-recherche",children:"Arbres binaires de recherche"})}),"\n",(0,s.jsx)(n.p,{children:"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche."}),"\n",(0,s.jsx)(n.h2,{id:"exercice-1-impl\xe9mentation",children:"Exercice 1 (Impl\xe9mentation)"}),"\n",(0,s.jsx)(n.p,{children:"Donnons nous pour commencer la structure suivante pour repr\xe9senter un n\u0153ud d'un arbre binaire :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Node {\n    int value;\n    Node* left { nullptr };\n    Node* right { nullptr };\n};\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Je vous conseil de cr\xe9er un fichier ",(0,s.jsx)(n.code,{children:"node.hpp"})," et d'y mettre la structure ",(0,s.jsx)(n.code,{children:"Node"})," ainsi que le prototype des fonctions et m\xe9thodes que vous allez \xe9crire."]}),(0,s.jsx)(n.p,{children:"Avec une organisation de fichier comme celle-ci:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/\n    L main.cpp\n    L node.hpp\n    L node.cpp\nCMakeLists.txt\n"})})]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Affichage dans la console"}),(0,s.jsx)(n.p,{children:"Je vous fourni une fonction qui permet d'afficher une repr\xe9sentation ASCII dans la console d'un arbre binaire:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'void pretty_print_left_right(Node const& node, std::string const& prefix, bool is_left) {\n    if (node.right) {\n        pretty_print_left_right(*node.right, prefix + (is_left ? "|   " : "    "), false);\n    }\n    std::cout << prefix << (is_left ? "+-- " : "+-- ") << node.value << std::endl;\n    if (node.left) {\n        pretty_print_left_right(*node.left, prefix + (is_left ? "    " : "|   "), true);\n    }\n}\n\nvoid pretty_print_left_right(Node const& node) {\n    pretty_print_left_right(node, "", true);\n}\n'})})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"fonction"})," ",(0,s.jsx)(n.code,{children:"create_node"})," qui prend en param\xe8tre une valeur et permet de cr\xe9er (sur la heap avec ",(0,s.jsx)(n.strong,{children:"new"}),") un n\u0153ud contenant cette valeur et dont les fils sont pointeur nuls."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Node* create_node(int value);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,s.jsx)(n.code,{children:"is_leaf"})," sur la structure ",(0,s.jsx)(n.code,{children:"Node"})," qui retourne vrai si le n\u0153ud est une feuille (c'est \xe0 dire si ses deux fils sont nuls)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool is_leaf() const;\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,s.jsx)(n.code,{children:"insert"})," \xe0 la structure ",(0,s.jsx)(n.code,{children:"Node"})," qui prend en param\xe8tre une valeur et qui ins\xe8re un nouveau n\u0153ud contenant cette valeur dans l'arbre binaire. On ins\xe9rera le n\u0153ud \xe0 gauche si la valeur est inf\xe9rieure \xe0 la valeur du n\u0153ud courant et \xe0 droite sinon."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void Node::insert(int value);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["On utilisera la fonction ",(0,s.jsx)(n.code,{children:"create_node"})," pour cr\xe9er le nouveau n\u0153ud."]})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une m\xe9thode ",(0,s.jsx)(n.code,{children:"height"})," qui retourne la hauteur de l'arbre binaire (c'est \xe0 dire la longueur du plus long chemin entre la racine et une feuille) (On va se donner la convention qu'un arbre binaire contenant un seul n\u0153ud a une hauteur de 1)"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int Node::height() const;\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"On peut utiliser de la r\xe9cursivit\xe9 pour calculer la hauteur de l'arbre."})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,s.jsx)(n.code,{children:"delete_children"})," sur la structure ",(0,s.jsx)(n.code,{children:"Node"})," qui permet de supprimer les fils d'un n\u0153ud (et de lib\xe9rer la m\xe9moire)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void Node::delete_children();\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"On peut utiliser de la r\xe9cursivit\xe9 pour supprimer les n\u0153uds de l'arbre."})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,s.jsx)(n.code,{children:"display_infix"})," qui affiche les valeurs des n\u0153uds parcourus dans l'ordre ",(0,s.jsx)(n.a,{href:"/Lessons/S2/BinaryTree/#parcours-en-profondeur",children:(0,s.jsx)(n.strong,{children:"infixe"})}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void Node::display_infix() const;\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"7",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,s.jsx)(n.code,{children:"prefix"})," qui retourne un vecteur contenant des pointeurs vers les n\u0153uds de l'arbre binaire parcourus en ",(0,s.jsx)(n.a,{href:"/Lessons/S2/BinaryTree/#parcours-en-profondeur",children:(0,s.jsx)(n.strong,{children:"prefixe"})}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::vector<Node const*> Node::prefix() const;\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Pour le faire par ",(0,s.jsx)(n.strong,{children:"r\xe9cursivit\xe9"})," on pourra utiliser la m\xe9thode ",(0,s.jsx)(n.code,{children:"insert"})," du ",(0,s.jsx)(n.code,{children:"std::vector"})," qui permet d\u2019ins\xe9rer plusieurs \xe9l\xe9ments \xe0 l'aide d\u2019it\xe9rateurs."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto left_nodes {left->prefix()};\nnodes.insert(nodes.end(), left_nodes.begin(), left_nodes.end());\n"})}),(0,s.jsx)(n.p,{children:"Cela va permettre de concat\xe9ner dans un seul vecteur les n\u0153uds des sous arbres gauche et droit."})]}),"\n",(0,s.jsxs)(n.ol,{start:"8",children:["\n",(0,s.jsxs)(n.li,{children:["(",(0,s.jsx)(n.strong,{children:"BONUS"}),") De m\xeame, \xe9crire une autre m\xe9thode ",(0,s.jsx)(n.code,{children:"postfix"})," qui retournent les n\u0153uds parcourus dans l'ordre ",(0,s.jsx)(n.a,{href:"/Lessons/S2/BinaryTree/#parcours-en-profondeur",children:(0,s.jsx)(n.strong,{children:"postfixe"})}),"."]}),"\n"]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"BONUS: It\xe9ratif"}),(0,s.jsx)(n.p,{children:"Si tu le souhaites, tu peux essayer de le faire de mani\xe8re it\xe9rative (sans r\xe9cursivit\xe9)."}),(0,s.jsxs)(n.p,{children:["Pour faire cela tu peux utiliser une pile (",(0,s.jsx)(n.code,{children:"std::stack"}),") pour stocker les n\u0153uds \xe0 parcourir. L'id\xe9e est de parcourir l'arbre en commen\xe7ant par la racine (premier \xe9l\xe9ment de la pile). Puis, de d\xe9piler un n\u0153ud de la pile, s'il a un fils droit, on le met dans la pile et on recommence. Sinon, s'il a un fils gauche, on le met dans la pile et on recommence. Enfin s'il n'a pas de fils, on le traite (on peut l'ajouter \xe0 un vecteur par exemple). Il faut aussi faire attention \xe0 conserver un pointeur vers le n\u0153ud pr\xe9c\xe9dent afin de savoir si on remonte ou si on descend dans l'arbre."]}),(0,s.jsx)(n.p,{children:"Exemple:\nSi on a l'arbre suivant:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    5\n   / \\\n  3   7\n / \\ / \\\n"})}),(0,s.jsx)(n.p,{children:"on va commencer par mettre le n\u0153ud 5 dans la pile. (le n\u0153ud pr\xe9c\xe9dent est nul)\nOn va lire le n\u0153ud 5 et se rendre compte qu'il a un fils gauche, on le met dans la pile et on recommence (le n\u0153ud pr\xe9c\xe9dent est 5).\nOn va lire le n\u0153ud 3 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le n\u0153ud pr\xe9c\xe9dent est 3).\nOn va lire de nouveau le n\u0153ud 5 mais comme on a d\xe9j\xe0 trait\xe9 le fils gauche (on le sait car le n\u0153ud pr\xe9c\xe9dent est le n\u0153ud 3), on va mettre le fils droit dans la pile et recommencer. (le n\u0153ud pr\xe9c\xe9dent devient 5).\nOn va lire le n\u0153ud 7 et se rendre compte qu'il n'a pas de fils, on le traite et on le retire de la pile. (le n\u0153ud pr\xe9c\xe9dent est 7).\nOn va lire de nouveau le n\u0153ud 5 mais comme on a d\xe9j\xe0 trait\xe9 le fils droit (on le sait car le n\u0153ud pr\xe9c\xe9dent est le n\u0153ud 7), on va enfin traiter le n\u0153ud 5 et le retirer de la pile."}),(0,s.jsx)(n.p,{children:"Ce qui nous donne l'ordre postfixe: 3, 7, 5."}),(0,s.jsx)(n.p,{children:"C'est un peu plus compliqu\xe9 que la version r\xe9cursive mais c'est un bon exercice pour comprendre le fonctionnement des arbres binaires et des m\xe9canismes de pile."}),(0,s.jsx)(n.p,{children:"Voil\xe0 un bout de code pour vous aider \xe0 d\xe9marrer:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"\nstd::vector<Node const*> Node::postfix() const {\n    std::vector<Node const*> nodes {};\n    std::stack<Node const*> to_process {};\n    Node const* previous {nullptr};\n    to_process.push(this);\n\n    while (!to_process.empty()) {\n        Node const* current { to_process.top() };\n\n        // Si on est en train de descendre dans l'arbre\n        if (previous == nullptr || (previous->left == current || previous->right == current)) {\n            if(/* ? */) {\n                to_process.push(current->left);\n            }\n            else if(/* ? */) {\n                // todo\n            } else {\n                // on traite le n\u0153ud (ajouter au vecteur) et on le retire de la pile\n                // todo\n            }\n\n        // Si l'on remonte dans l'arbre en venant de la gauche\n        }else if (/* ? */) {\n            if(/* ? */) {\n                // todo\n            } else {\n                // todo\n            }\n\n        // Si l'on remonte dans l'arbre en venant de la droite\n        } else if (/* ? */) {\n            // todo\n        }\n\n        previous = current;\n\n    }\n    return nodes;\n}\n"})})]}),"\n",(0,s.jsxs)(n.ol,{start:"9",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"fonction"})," ",(0,s.jsx)(n.code,{children:"most_left"})," qui retourne une r\xe9f\xe9rence vers le pointeur du n\u0153ud le plus \xe0 gauche de l'arbre binaire."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"    Node*& most_left(Node*& node);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["\u26a0\ufe0f"," Pourquoi retourner une ",(0,s.jsx)(n.strong,{children:"r\xe9f\xe9rence"})," vers un ",(0,s.jsx)(n.strong,{children:"pointeur"}),"(",(0,s.jsx)(n.code,{children:"*&"}),") ? Car on va ensuite utiliser cette fonction dans la fonction ",(0,s.jsx)(n.code,{children:"removeNode"})," pour supprimer une valeur (donc un n\u0153ud) de l'arbre binaire. Mais dans certains cas on va devoir modifier le pointeur du n\u0153ud parent pour qu'il ne pointe plus vers le n\u0153ud que l'on veut supprimer. la r\xe9f\xe9rence va permettre de modifier directement le pointeur du n\u0153ud parent."]}),"\n",(0,s.jsxs)(n.ol,{start:"10",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"fonction"})," ",(0,s.jsx)(n.code,{children:"remove"})," qui permet de supprimer une valeur de l'arbre binaire dont le n\u0153ud racine est pass\xe9 en param\xe8tre. La fonction retourne vrai si la valeur a \xe9t\xe9 supprim\xe9e et faux sinon."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool remove(Node*& node, int value);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Prendre en param\xe8tre une ",(0,s.jsx)(n.strong,{children:"r\xe9f\xe9rence vers un pointeur"})," permet de modifier directement le pointeur du n\u0153ud parent si le n\u0153ud est supprim\xe9. C'est important dans le cas par exemple o\xf9 l'on supprime une feuille de l'arbre il faut pouvoir r\xe9assigner le pointeur du n\u0153ud parent vers un pointeur nul pour \xe9viter d'avoir un pointeur qui pointe vers un n\u0153ud supprim\xe9."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (value == node->value && node->is_leaf()) {\n        // On supprime le n\u0153ud courant\n        delete node;\n        // Comme on a une r\xe9f\xe9rence sur le pointeur du n\u0153ud courant, on le met \xe0 jour avec nullptr\n        // Ainsi le parent du n\u0153ud courant aura un pointeur vers nullptr\n        node = nullptr;\n        // on retourne true car la suppression a \xe9t\xe9 effectu\xe9e\n        return true;\n    }\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"Il existe trois cas de figure lorsqu'on supprime un n\u0153ud d'un arbre binaire:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Le n\u0153ud n'a pas de fils: on peut le supprimer directement (exemple pr\xe9c\xe9dent)."}),"\n",(0,s.jsx)(n.li,{children:"Le n\u0153ud a un seul fils: on peut le supprimer et le remplacer par son fils."}),"\n",(0,s.jsxs)(n.li,{children:["Le n\u0153ud a deux fils:\nIl faut remplacer la valeur du n\u0153ud \xe0 supprimer par une valeur pour pr\xe9server l'ordre de l'arbre. Pour cela, on utilisera la fonction ",(0,s.jsx)(n.code,{children:"most_left"})," qui permettent de trouver le n\u0153ud le plus \xe0 gauche d'un arbre binaire (autrement dit, le n\u0153ud de valeur minimale).\nIl faut ensuite remplacer la valeur du n\u0153ud \xe0 supprimer par la valeur du n\u0153ud trouv\xe9 pr\xe9c\xe9demment et supprimer ce dit n\u0153ud pour ne pas avoir de doublon. (cela revient \xe0 intervertir les deux n\u0153uds sans avoir \xe0 modifier les pointeurs puis \xe0 supprimer le n\u0153ud dont la valeur a \xe9t\xe9 copi\xe9e)."]}),"\n"]}),(0,s.jsxs)(n.p,{children:["Ce troisi\xe8me cas est le plus compliqu\xe9 \xe0 g\xe9rer. N'h\xe9sitez pas \xe0 demander de l'aide et prendre le temps de faire des sch\xe9mas pour comprendre le fonctionnement.\nIl faudra utiliser la fonction ",(0,s.jsx)(n.code,{children:"most_left"})," pour trouver le n\u0153ud le plus \xe0 gauche de l'arbre binaire."]})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Il faut faire attention \xe0 bien lib\xe9rer la m\xe9moire des n\u0153uds supprim\xe9s, avec ",(0,s.jsx)(n.code,{children:"delete"}),"."]})}),"\n",(0,s.jsxs)(n.ol,{start:"11",children:["\n",(0,s.jsxs)(n.li,{children:["\xc9crire une ",(0,s.jsx)(n.strong,{children:"fonction"})," ",(0,s.jsx)(n.code,{children:"delete_tree"})," qui permet de supprimer un arbre binaire (et de lib\xe9rer la m\xe9moire)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void delete_tree(Node* node);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"12",children:["\n",(0,s.jsxs)(n.li,{children:["(",(0,s.jsx)(n.strong,{children:"BONUS"}),") \xc9crire des m\xe9thodes ",(0,s.jsx)(n.code,{children:"min"})," et ",(0,s.jsx)(n.code,{children:"max"})," qui retournent respectivement les valeurs minimales et maximales de l'arbre binaire."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercice-2-utilisation",children:"Exercice 2 (Utilisation)"}),"\n",(0,s.jsx)(n.p,{children:"Testons maintenant notre impl\xe9mentation en cr\xe9ant un programme qui permet de cr\xe9er un arbre binaire et d'effectuer diff\xe9rentes op\xe9rations dessus."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Cr\xe9er un arbre binaire et ins\xe9rer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Afficher les valeurs des n\u0153uds de l'arbre binaire dans l'ordre ",(0,s.jsx)(n.strong,{children:"infixe"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["(",(0,s.jsx)(n.strong,{children:"BONUS"}),") Afficher la valeur minimale et maximale de l'arbre."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Afficher la somme des valeurs des n\u0153uds de l'arbre binaire en utilisant la fonction ",(0,s.jsx)(n.code,{children:"prefix"})," qui retourne un vecteur contenant les n\u0153uds parcourus dans l'ordre ",(0,s.jsx)(n.strong,{children:"prefixe"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Afficher la hauteur de l'arbre binaire."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"aller-plus-loin",children:"Aller plus loin"}),"\n",(0,s.jsx)(n.h3,{id:"exercice-3-pointeurs-intelligents-bonus",children:"Exercice 3 (Pointeurs intelligents) (Bonus)"}),"\n",(0,s.jsxs)(n.p,{children:["Nous allons maintenant am\xe9liorer et simplifier notre code en utilisant des ",(0,s.jsx)(n.a,{href:"/Lessons/S1/MemoryAllocation",children:(0,s.jsx)(n.strong,{children:"pointeurs intelligents"})}),". En effet la partie la plus compliqu\xe9e de notre code est la gestion de la m\xe9moire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous d\xe9barrasser de cette gestion et de nous passer de la fonction ",(0,s.jsx)(n.code,{children:"delete_tree"})," par exemple."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Copier-coller votre fichier pour garder une version de votre code pr\xe9c\xe9dent et cr\xe9er un nouveau fichier ",(0,s.jsx)(n.code,{children:"smartNode.hpp"})," dans lequel vous allez r\xe9\xe9crire votre code en utilisant des ",(0,s.jsx)(n.strong,{children:"pointeurs intelligents"}),".\nRenommer la structure ",(0,s.jsx)(n.code,{children:"Node"})," en ",(0,s.jsx)(n.code,{children:"SmartNode"}),' pour pouvoir faire la diff\xe9rence entre les deux versions et remplacer les pointeurs "bruts" par des ',(0,s.jsx)(n.strong,{children:"pointeurs intelligents"})," ",(0,s.jsx)(n.code,{children:"std::unique_ptr"})," dans la structure ",(0,s.jsx)(n.code,{children:"SmartNode"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Je vous donne le contenu du fichier ",(0,s.jsx)(n.code,{children:"smartNode.hpp"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#pragma once\n\n#include <vector>\n\nstruct SmartNode {\n    int value;\n    std::unique_ptr<SmartNode> left { nullptr };\n    std::unique_ptr<SmartNode> right { nullptr };\n\n    bool is_leaf() const;\n    void insert(int value);\n\n    size_t height() const;\n\n    int min() const;\n    int max() const;\n};\n\nstd::unique_ptr<SmartNode> create_smart_node(int value);\nstd::unique_ptr<SmartNode>& SmartNode::most_left(std::unique_ptr<SmartNode>& node);\nbool remove(std::unique_ptr<SmartNode>& node, int value);\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Modifier la fonction ",(0,s.jsx)(n.code,{children:"is_leaf"})," pour utiliser le fait qu'un pointeur intelligent peut \xeatre converti implicitement en ",(0,s.jsx)(n.a,{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr/operator_bool",children:"bool\xe9en"})," (il vaut ",(0,s.jsx)(n.code,{children:"false"})," si le pointeur est nul et ",(0,s.jsx)(n.code,{children:"true"})," sinon)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::unique_ptr<float> ptr {nullptr};\nif (ptr) {\n    // ptr est diff\xe9rent de nullptr\n} else {\n    // ptr est \xe9gal \xe0 nullptr\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Renommer et modifier la fonction ",(0,s.jsx)(n.code,{children:"create_node"})," (en ",(0,s.jsx)(n.code,{children:"create_smart_node"}),") pour qu'elle retourne un pointeur intelligent ",(0,s.jsx)(n.code,{children:"std::unique_ptr"})," au lieu d'un pointeur brut (on utilisera la fonction ",(0,s.jsx)(n.code,{children:"std::make_unique"})," pour cr\xe9er le pointeur)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Elle s'utilise de la mani\xe8re suivante:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::unique_ptr<float> ptr {std::make_unique<float>(3.14f)};\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Modifier la m\xe9thode ",(0,s.jsx)(n.code,{children:"most_left"})," pour qu'elle retourne une r\xe9f\xe9rence vers un pointeur intelligent au lieu d'un pointeur brut."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Modifier la m\xe9thode ",(0,s.jsx)(n.code,{children:"insert"})," pour qu'elle utilise des pointeurs intelligents."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Modifier la m\xe9thode ",(0,s.jsx)(n.code,{children:"remove"})," pour qu'elle utilise des pointeurs intelligents."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["C'est un peu plus compliqu\xe9 car il faut utiliser des r\xe9f\xe9rences vers des pointeurs intelligents pour pouvoir les modifier. On peut utiliser les m\xe9thodes ",(0,s.jsx)(n.code,{children:"reset"})," et ",(0,s.jsx)(n.code,{children:"release"})," (allez lire la documentation pour voir la diff\xe9rence entre les deux !) pour g\xe9rer la m\xe9moire et les pointeurs intelligents. Ou utiliser un concept plus avanc\xe9 ",(0,s.jsx)(n.code,{children:"std::move"})," pour transf\xe9rer la propri\xe9t\xe9 d'un pointeur intelligent d'un objet \xe0 un autre.\nSi vous voulez essayer, n'h\xe9sitez pas \xe0 demander de l'aide."]})}),"\n",(0,s.jsx)(n.h3,{id:"exercice-4-encapsulation-bonus",children:"Exercice 4 (Encapsulation) (Bonus)"}),"\n",(0,s.jsxs)(n.p,{children:["Le but est de cr\xe9er une structure ",(0,s.jsx)(n.code,{children:"BinaryTree"})," qui encapsule la structure ",(0,s.jsx)(n.code,{children:"Node"})," ou ",(0,s.jsx)(n.code,{children:"SmartNode"})," et qui permet d'utiliser les m\xeame m\xe9thodes sans conna\xeetre la structure interne de l'arbre binaire. Cela permet aussi de g\xe9rer le cas o\xf9 l'arbre binaire est vide (c'est \xe0 dire que la racine est un pointeur nul)."]}),"\n",(0,s.jsxs)(n.p,{children:["C'est moins pertinent dans notre cas pour ce TD mais lorsque vous d\xe9couvrirez la notion de ",(0,s.jsx)(n.strong,{children:"visibilit\xe9"})," (public / priv\xe9) vous comprendrez l'int\xe9r\xeat de cette encapsulation."]}),"\n",(0,s.jsxs)(n.p,{children:["Voil\xe0 le contenu du fichier ",(0,s.jsx)(n.code,{children:"binaryTree.hpp"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n\n#include <memory>\n\n#include "smartNode.hpp"\n\nstruct BinaryTree {\n    std::unique_ptr<SmartNode> root { nullptr };\n\n    void insert(int value);\n    bool remove(int value);\n    void clear();\n    size_t height() const;\n};\n'})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Cr\xe9er un fichier ",(0,s.jsx)(n.code,{children:"binaryTree.cpp"})," et impl\xe9menter les m\xe9thodes de la structure ",(0,s.jsx)(n.code,{children:"BinaryTree"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["C'est gr\xe2ce \xe0 cette encapsulation que l'on peut changer la structure interne de l'arbre binaire sans avoir \xe0 modifier le code qui l'utilise. Nous pourrions par exemple changer la structure ",(0,s.jsx)(n.code,{children:"SmartNode"})," par une structure ",(0,s.jsx)(n.code,{children:"Node"})," sans avoir \xe0 modifier le code qui utilise la structure ",(0,s.jsx)(n.code,{children:"BinaryTree"}),"."]}),(0,s.jsxs)(n.p,{children:["Ici avec l'utilisation des pointeurs intelligents, la m\xe9moire va \xeatre g\xe9r\xe9e automatiquement \xe0 la destruction de l'objet ",(0,s.jsx)(n.code,{children:"BinaryTree"})," et il n'y a plus besoin de la fonction ",(0,s.jsx)(n.code,{children:"delete_tree"}),". C'est un grand avantage des pointeurs intelligents et permet d'\xe9viter les erreurs de fuites m\xe9moires."]})]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);
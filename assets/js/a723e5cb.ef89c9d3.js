"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[96],{1937:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var i=r(5893),s=r(1151);const t={title:"TD6 - Arbres binaires"},l="Arbres binaires de recherche",o={id:"TDs/S2/binaryTree",title:"TD6 - Arbres binaires",description:"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche.",source:"@site/content/TDs/S2/06_binaryTree.md",sourceDirName:"TDs/S2",slug:"/TDs/S2/binaryTree",permalink:"/Learn--cpp_programming/TDs/S2/binaryTree",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"TD6 - Arbres binaires"},sidebar:"TDs",previous:{title:"TD5 - Hachage et tableaux associatifs",permalink:"/Learn--cpp_programming/TDs/S2/hashAndAssociativeTables"}},d={},c=[{value:"Impl\xe9mentation",id:"impl\xe9mentation",level:2},{value:"Pointeurs intelligents",id:"pointeurs-intelligents",level:2},{value:"Utilisation",id:"utilisation",level:2},{value:"Aller plus loin: Encapsulation",id:"aller-plus-loin-encapsulation",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"arbres-binaires-de-recherche",children:"Arbres binaires de recherche"}),"\n",(0,i.jsx)(n.p,{children:"Dans ce TD, nous allons voir comment impl\xe9menter un arbre binaire de recherche."}),"\n",(0,i.jsx)(n.h2,{id:"impl\xe9mentation",children:"Impl\xe9mentation"}),"\n",(0,i.jsx)(n.p,{children:"Donnons nous pour commencer la structure suivante pour repr\xe9senter un noeud d'un arbre binaire."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Node {\n    int value;\n    Node* left = nullptr;\n    Node* right = nullptr;\n};\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["Je vous conseil de cr\xe9er un fichier ",(0,i.jsx)(n.code,{children:"node.hpp"})," et d'y mettre la structure ",(0,i.jsx)(n.code,{children:"Node"})," ainsi que le prototype des fonctions et m\xe9thodes que vous allez \xe9crire."]}),(0,i.jsx)(n.p,{children:"Avec une organisation de fichier comme celle-ci:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"src/\n    L main.cpp\n    L node.hpp\n    L node.cpp\nCmakeLists.txt\n"})})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"fonction"})," ",(0,i.jsx)(n.code,{children:"createNode"})," qui prend en param\xe8tre une valeur et permet de cr\xe9er (sur la heap avec ",(0,i.jsx)(n.strong,{children:"new"}),") un noeud contenant cette valeur et dont les fils sont pointeur nuls."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Node* createNode(int value);\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"isLeaf"})," sur la structure ",(0,i.jsx)(n.code,{children:"Node"})," qui retourne vrai si le noeud est une feuille (c'est \xe0 dire si ses deux fils sont nuls)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool isLeaf() const;\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"insert"})," \xe0 la structure ",(0,i.jsx)(n.code,{children:"BinaryTree"})," qui prend en param\xe8tre une valeur et qui ins\xe8re un nouveau noeud contenant cette valeur dans l'arbre binaire. On ins\xe9rera le noeud \xe0 gauche si la valeur est inf\xe9rieure \xe0 la valeur du noeud courant et \xe0 droite sinon."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void Node::insert(int value);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["On utilisera la fonction ",(0,i.jsx)(n.code,{children:"createNode"})," pour cr\xe9er le nouveau noeud."]})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"infixe"})," qui retourne un vecteur contenant les pointeurs vers les noeuds de l'arbre binaire parcourus en ",(0,i.jsx)(n.strong,{children:"infixe"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"std::vector<Node const*> Node::infixe() const;\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["Pour le faire par ",(0,i.jsx)(n.strong,{children:"r\xe9cursivit\xe9"})," on pourra utiliser la m\xe9thode ",(0,i.jsx)(n.code,{children:"insert"})," du ",(0,i.jsx)(n.code,{children:"std::vector"})," qui permet d\u2019ins\xe9rer plusieurs \xe9l\xe9ments \xe0 l'aide d\u2019it\xe9rateurs."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto left_nodes {left->infixe()};\nnodes.insert(nodes.end(), left_nodes.begin(), left_nodes.end());\n"})})]}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsxs)(n.li,{children:["De m\xeame, \xe9crire deux autres m\xe9thodes ",(0,i.jsx)(n.code,{children:"prefixe"})," et ",(0,i.jsx)(n.code,{children:"postfixe"})," qui retournent les noeuds parcourus dans l'ordre ",(0,i.jsx)(n.strong,{children:"pr\xe9fixe"})," et ",(0,i.jsx)(n.strong,{children:"postfixe"})," respectivement."]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"mostLeft"})," qui retourne un pointeur vers le noeud le plus \xe0 gauche de l'arbre binaire dont ce noeud est la racine."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    Node* Node::mostLeft();\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"7",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"find"})," qui prend en param\xe8tre une valeur et qui retourne un pointeur vers le noeud contenant cette valeur dans l'arbre binaire. Si la valeur n'est pas pr\xe9sente dans l'arbre, on retourne un pointeur nul."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Node* Node::find(int value);\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"8",children:["\n",(0,i.jsxs)(n.li,{children:["(",(0,i.jsx)(n.strong,{children:"BONUS"}),") \xc9crire la m\xeame ",(0,i.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,i.jsx)(n.code,{children:"find"})," mais qui retourne un pointeur constant vers le noeud. On ne pourra donc pas modifier la valeur du noeud retourn\xe9. L'avanatage de cette m\xe9thode est qu'on pourra l'utiliser sur un ",(0,i.jsx)(n.code,{children:"Node"})," constant."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Node const* Node::find(int value) const;\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"9",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"fonction"})," ",(0,i.jsx)(n.code,{children:"removeNode"})," qui permet de supprimer une valeur de l'arbre binaire dont le noeud pass\xe9 en param\xe8tre est la racine. La fonction retourne un pointeur vers le nouveau noeud racine de l'arbre binaire."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Node* removeNode(Node* node, int value);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Retourner un pointeur vers le nouveau noeud racine permet de r\xe9assigner le pointeur du node parent si le noeud est supprim\xe9. C'est important dans le cas par exemple o\xf9 l'on supprime une feuille de l'arbre il faut pouvoir r\xe9assigner le pointeur du noeud parent vers un pointeur nul pour \xe9viter d'avoir un pointeur qui pointe vers un noeud supprim\xe9."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"if (value == node->value && node->isLeaf()) {\n        // On supprime le noeud courant\n        delete node;\n        // on retourne nullptr pour mettre \xe0 jour le pointeur du parent vers le noeud courant\n        return nullptr;\n    }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["le parent doit alors appeler par r\xe9cursivit\xe9 la fonction ",(0,i.jsx)(n.code,{children:"removeNode"})," pour mettre \xe0 jour son pointeur vers le noeud fils correspondant."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"if (value < node->value) {\n    node->left = removeNode(node->left, value);\n}\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"Il existe trois cas de figure lorsqu'on supprime un noeud d'un arbre binaire:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Le noeud n'a pas de fils: on peut le supprimer directement."}),"\n",(0,i.jsx)(n.li,{children:"Le noeud a un seul fils: on peut le supprimer et le remplacer par son fils."}),"\n",(0,i.jsxs)(n.li,{children:["Le noeud a deux fils:\nIl faut remplacer la valeur du noeud \xe0 supprimer par une valeur pr\xe9server l'ordre de l'arbre. Pour cela, on utilisera la fonction ",(0,i.jsx)(n.code,{children:"mostLeft"})," qui permettent de trouver le noeud le plus \xe0 gauche d'un arbre binaire (autrement dit, le noeud de valeur minimale).\nIl faut ensuite remplacer la valeur du noeud \xe0 supprimer par la valeur du noeud trouv\xe9 pr\xe9c\xe9demment et supprimer ce dit noeud pour ne pas avoir de doublon. (cela revient \xe0 intervertir les deux noeuds sans avoir \xe0 modifier les pointeurs puis \xe0 supprimer le noeud dont la valeur a \xe9t\xe9 copi\xe9e)."]}),"\n"]})]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Il faut faire attention \xe0 bien lib\xe9rer la m\xe9moire des noeuds supprim\xe9s."})}),"\n",(0,i.jsxs)(n.ol,{start:"10",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,i.jsx)(n.code,{children:"deleteChilds"})," sur la structure ",(0,i.jsx)(n.code,{children:"Node"})," qui permet de supprimer les fils d'un noeud (et de lib\xe9rer la m\xe9moire)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void Node::deleteChilds();\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"On peut utiliser de la r\xe9cursivit\xe9 pour supprimer les noeuds de l'arbre."})}),"\n",(0,i.jsxs)(n.ol,{start:"11",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une m\xe9thode ",(0,i.jsx)(n.code,{children:"height"})," qui retourne la hauteur de l'arbre binaire (c'est \xe0 dire la longueur du plus long chemin entre la racine et une feuille)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int Node::height() const;\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"On peut utiliser de la r\xe9cursivit\xe9 pour calculer la hauteur de l'arbre."})}),"\n",(0,i.jsxs)(n.ol,{start:"12",children:["\n",(0,i.jsxs)(n.li,{children:["\xc9crire une ",(0,i.jsx)(n.strong,{children:"fonction"})," ",(0,i.jsx)(n.code,{children:"deleteTree"})," qui permet de supprimer un arbre binaire (et de lib\xe9rer la m\xe9moire)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void deleteTree(Node* node);\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"13",children:["\n",(0,i.jsxs)(n.li,{children:["(",(0,i.jsx)(n.strong,{children:"BONUS"}),") \xc9crire des m\xe9thodes ",(0,i.jsx)(n.code,{children:"min"})," et ",(0,i.jsx)(n.code,{children:"max"})," qui retournent respectivement les valeurs minimales et maximales de l'arbre binaire."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pointeurs-intelligents",children:"Pointeurs intelligents"}),"\n",(0,i.jsxs)(n.p,{children:["Nous allons maintenant am\xe9liorer et simplifier notre code en utilisant des pointeurs intelligents. En effet la partie la plus compliqu\xe9e de notre code est la gestion de la m\xe9moire et des pointeurs. Les pointeurs intelligents vont nous permettre de nous d\xe9barrasser de cette gestion et de nous passer de la fonction ",(0,i.jsx)(n.code,{children:"deleteTree"})," par exemple."]}),"\n",(0,i.jsxs)(n.ol,{start:"14",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Copier coller votre fichier pour garder une version de votre code pr\xe9c\xe9dent et cr\xe9er un nouveau fichier ",(0,i.jsx)(n.code,{children:"smartNode.hpp"})," dans lequel vous allez r\xe9\xe9crire votre code en utilisant des ",(0,i.jsx)(n.strong,{children:"pointeurs intelligents"}),".\nRenommer la structure ",(0,i.jsx)(n.code,{children:"Node"})," en ",(0,i.jsx)(n.code,{children:"SmartNode"})," pour pouvoir faire la diff\xe9rence entre les deux versions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:['Remplacer les pointeurs "bruts" par des pointeurs intelligents ',(0,i.jsx)(n.code,{children:"std::unique_ptr"})," dans la structure ",(0,i.jsx)(n.code,{children:"SmartNode"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Modifier la fonction ",(0,i.jsx)(n.code,{children:"isLeaf"})," pour utiliser le fait qu'un pointeur intelligent peut \xeatre converti implicitement en ",(0,i.jsx)(n.a,{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr/operator_bool",children:"bool\xe9en"})," (il vaut ",(0,i.jsx)(n.code,{children:"false"})," si le pointeur est nul et ",(0,i.jsx)(n.code,{children:"true"})," sinon)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Renommer et modifier la fonction ",(0,i.jsx)(n.code,{children:"createNode"})," (en ",(0,i.jsx)(n.code,{children:"createSmartNode"}),") pour qu'elle retourne un pointeur intelligent ",(0,i.jsx)(n.code,{children:"std::unique_ptr"})," au lieu d'un pointeur brut (on utilisera la fonction ",(0,i.jsx)(n.code,{children:"std::make_unique"})," pour cr\xe9er le pointeur)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Modifier la m\xe9thode ",(0,i.jsx)(n.code,{children:"mostLeft"})," pour qu'elle retourne une r\xe9f\xe9rence vers la structure ",(0,i.jsx)(n.code,{children:"SmartNode"})," au lieu d'un pointeur brut (une r\xe9f\xe9rence car cet \xe9l\xe9ment est toujours pr\xe9sent dans l'arbre)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Modifier les m\xe9thodes ",(0,i.jsx)(n.code,{children:"insert"}),", ",(0,i.jsx)(n.code,{children:"find"})," pour qu'elles fonctionnent avec des pointeurs intelligents."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["(",(0,i.jsx)(n.strong,{children:"BONUS"}),") Renommer et modifier la m\xe9thode ",(0,i.jsx)(n.code,{children:"removeNode"})," (en ",(0,i.jsx)(n.code,{children:"removeSmartNode"}),") \xe9galement."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"utilisation",children:"Utilisation"}),"\n",(0,i.jsx)(n.p,{children:"Testons maintenant notre impl\xe9mentation en cr\xe9ant un programme qui permet de cr\xe9er un arbre binaire et d'effectuer diff\xe9rentes op\xe9rations dessus."}),"\n",(0,i.jsxs)(n.ol,{start:"21",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Cr\xe9er un arbre binaire et ins\xe9rer les valeurs suivantes: 5, 3, 7, 2, 4, 6, 8, 1, 9, 0."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Afficher les valeurs des noeuds de l'arbre binaire dans l'ordre ",(0,i.jsx)(n.strong,{children:"infixe"}),", ",(0,i.jsx)(n.strong,{children:"pr\xe9fixe"})," et ",(0,i.jsx)(n.strong,{children:"postfixe"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Afficher la hauteur de l'arbre binaire."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"aller-plus-loin-encapsulation",children:"Aller plus loin: Encapsulation"}),"\n",(0,i.jsxs)(n.p,{children:["Le but est de cr\xe9er une structure ",(0,i.jsx)(n.code,{children:"BinaryTree"})," qui encapsule la structure ",(0,i.jsx)(n.code,{children:"Node"})," ou ",(0,i.jsx)(n.code,{children:"SmartNode"})," et qui permet d'utiliser les m\xeame m\xe9thodes sans conna\xeetre la structure interne de l'arbre binaire. Cela permet aussi de g\xe9rer le cas o\xf9 l'arbre binaire est vide (c'est \xe0 dire que la racine est un pointeur nul)."]}),"\n",(0,i.jsxs)(n.p,{children:["C'est moins pertinent dans notre cas pour ce TDs mais lorsque vous d\xe9couvrirez la notion de ",(0,i.jsx)(n.strong,{children:"visibilit\xe9"})," vous comprendrez l'int\xe9r\xeat de cette encapsulation."]}),"\n",(0,i.jsxs)(n.p,{children:["Voil\xe0 le contenu du fichier ",(0,i.jsx)(n.code,{children:"binaryTree.hpp"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n\n#include <vector>\n\n#include "smartNode.hpp"\n\nstruct BinaryTree {\n    std::unique_ptr<SmartNode>{} root = std::unique_ptr<SmartNode>{};\n\n    void insert(int value);\n    void remove(int value);\n    void clear();\n    SmartNode* find(int value);\n    SmartNode const* find(int value) const;\n    int height() const;\n    std::vector<Node const*> infixe() const;\n    std::vector<Node const*> postfixe() const;\n    std::vector<Node const*> prefixe() const;\n};\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>l});var i=r(7294);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);
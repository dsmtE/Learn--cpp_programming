"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[3642],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>v});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),o=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=o(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),d=o(n),c=a,v=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return n?r.createElement(v,l(l({ref:t},p),{},{components:n})):r.createElement(v,l({ref:t},p))}));function v(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u[d]="string"==typeof e?e:a,l[1]=u;for(var o=2;o<i;o++)l[o]=n[o];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8376:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>u,toc:()=>o});var r=n(7462),a=(n(7294),n(3905));const i={title:"D\xe9duction de type et biblioth\xe8que standard",tags:["C++","STL"]},l=void 0,u={unversionedId:"Lessons/S2/AutoAndAlgorithm",id:"Lessons/S2/AutoAndAlgorithm",title:"D\xe9duction de type et biblioth\xe8que standard",description:"La STL (Standard Template Library) est une biblioth\xe8que standard de la norme C++ qui fournit de nombreuses fonctionnalit\xe9s d\xe9j\xe0 impl\xe9ment\xe9es pour faciliter le d\xe9veloppement. Vous pouvez retrouver la documentation de la STL sur le site cppreference.com.",source:"@site/content/Lessons/S2/AutoAndAlgorithm.md",sourceDirName:"Lessons/S2",slug:"/Lessons/S2/AutoAndAlgorithm",permalink:"/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"},{label:"STL",permalink:"/Learn--cpp_programming/tags/stl"}],version:"current",frontMatter:{title:"D\xe9duction de type et biblioth\xe8que standard",tags:["C++","STL"]}},s={},o=[{value:"It\xe9rateurs",id:"it\xe9rateurs",level:2},{value:"Begin et end",id:"begin-et-end",level:3},{value:"Utilisation des it\xe9rateurs",id:"utilisation-des-it\xe9rateurs",level:3},{value:"D\xe9duction de type",id:"d\xe9duction-de-type",level:2},{value:"Exemples et algorithmes",id:"exemples-et-algorithmes",level:2},{value:"Find",id:"find",level:3},{value:"Sort",id:"sort",level:3},{value:"Remove et Erase",id:"remove-et-erase",level:3},{value:"Pour aller plus loin",id:"pour-aller-plus-loin",level:2},{value:"Les fonctions lambda",id:"les-fonctions-lambda",level:3},{value:"Transform",id:"transform",level:3},{value:"Accumulate et reduce",id:"accumulate-et-reduce",level:3},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],p={toc:o},d="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"La ",(0,a.kt)("strong",{parentName:"p"},"STL")," (Standard Template Library) est une biblioth\xe8que standard de la norme ",(0,a.kt)("strong",{parentName:"p"},"C++")," qui fournit de nombreuses fonctionnalit\xe9s d\xe9j\xe0 impl\xe9ment\xe9es pour faciliter le d\xe9veloppement. Vous pouvez retrouver la documentation de la ",(0,a.kt)("strong",{parentName:"p"},"STL")," sur le site ",(0,a.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/header"},"cppreference.com"),"."),(0,a.kt)("p",null,"Nous avons d\xe9j\xe0 utilis\xe9 des conteneurs de la ",(0,a.kt)("strong",{parentName:"p"},"STL")," comme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector")," ou ",(0,a.kt)("inlineCode",{parentName:"p"},"std::array")," mais aussi la ",(0,a.kt)("inlineCode",{parentName:"p"},"std::string")," qui est une ",(0,a.kt)("strong",{parentName:"p"},"classe")," qui permet de manipuler des cha\xeenes de caract\xe8res."),(0,a.kt)("admonition",{title:"Classes",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Je n'ai pas encore abord\xe9 le terme de ",(0,a.kt)("strong",{parentName:"p"},"classe")," mais je vais clarifier ce terme car je vais l'utiliser dans la suite du cours.\nUne ",(0,a.kt)("strong",{parentName:"p"},"classe")," est un type de donn\xe9es qui permet de regrouper des donn\xe9es et des fonctions qui agissent sur ces donn\xe9es de la m\xeame mani\xe8re que les ",(0,a.kt)("strong",{parentName:"p"},"structures"),". Pour faire simple, une ",(0,a.kt)("strong",{parentName:"p"},"classe")," est une ",(0,a.kt)("strong",{parentName:"p"},"structure"),". Il y a cependant des diff\xe9rences entre les deux (visibilit\xe9 des donn\xe9es, h\xe9ritage, ...) mais vous d\xe9couvrirez cela en deuxi\xe8me ann\xe9e.")),(0,a.kt)("p",null,"La ",(0,a.kt)("strong",{parentName:"p"},"STL")," fournit aussi des ",(0,a.kt)("strong",{parentName:"p"},"algorithmes")," et des fonctions qui permettent de simplifier la manipulation des conteneurs."),(0,a.kt)("p",null,"Pour que ces fonctionnalit\xe9s soient utilisables par le plus grand nombre de conteneurs possibles, la ",(0,a.kt)("strong",{parentName:"p"},"STL")," utilise le concept d'",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateurs")," qui permettent de parcourir les conteneurs de mani\xe8re g\xe9n\xe9rique."),(0,a.kt)("h2",{id:"it\xe9rateurs"},"It\xe9rateurs"),(0,a.kt)("p",null,"Les ",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateurs")," sont des objets propres \xe0 la ",(0,a.kt)("strong",{parentName:"p"},"STL")," qui permettent de parcourir les conteneurs et structures de donn\xe9es sans se soucier de la mani\xe8re dont ils sont impl\xe9ment\xe9s. Cela permet d'abstraire le conteneur utilis\xe9 et de pouvoir utiliser des algorithmes de mani\xe8re g\xe9n\xe9rique."),(0,a.kt)("p",null,"Les ",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateurs")," sont des objets qui se comportent un peu comme des pointeurs. Ils permettent de cibler un \xe9l\xe9ment dans un conteneur, de le manipuler et permettent de passer d'un \xe9l\xe9ment \xe0 l'autre."),(0,a.kt)("p",null,"Pour un ",(0,a.kt)("strong",{parentName:"p"},"tableau")," (comme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::array")," ou ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),") le passage d'un \xe9l\xe9ment \xe0 l'autre se fait g\xe9n\xe9ralement en incr\xe9mentant un compteur mais pour d'autres conteneurs, le passage d'un \xe9l\xe9ment \xe0 l'autre est plus complexe. Gr\xe2ce aux ",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateurs"),", nous n'avons pas \xe0 nous soucier de la mani\xe8re dont le conteneur est impl\xe9ment\xe9."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Il existe plusieurs types d'it\xe9rateurs qui permettent de parcourir les conteneurs de diff\xe9rentes mani\xe8res (parcours en lecture seule, parcours en lecture et \xe9criture, parcours seulement dans un sens, ...). Nous allons pas rentrer dans les d\xe9tails des diff\xe9rents types d'it\xe9rateurs mais sachez qu'il existe plusieurs types d'it\xe9rateurs qui permettent de parcourir les conteneurs de diff\xe9rentes mani\xe8res.")),(0,a.kt)("p",null,"Les ",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateurs")," on des ",(0,a.kt)("strong",{parentName:"p"},"op\xe9rateurs")," et ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thodes")," qui permettent de les manipuler comme avec l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," pour d\xe9r\xe9f\xe9rencer et acc\xe9der \xe0 la valeur point\xe9e par l'it\xe9rateur et l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," pour passer \xe0 l'\xe9l\xe9ment suivant."),(0,a.kt)("h3",{id:"begin-et-end"},"Begin et end"),(0,a.kt)("p",null,"Il existe principalement deux ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thodes")," sur les conteneurs qui permettent de r\xe9cup\xe9rer un it\xe9rateur sur le ",(0,a.kt)("strong",{parentName:"p"},"premier \xe9l\xe9ment")," du conteneur et un it\xe9rateur sur le ",(0,a.kt)("strong",{parentName:"p"},"dernier \xe9l\xe9ment")," du conteneur."),(0,a.kt)("p",null,"Voici un exemple avec un vecteur (",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),") :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> v = {1, 2, 3, 4, 5};\n\n// D\xe9claration d'un it\xe9rateur sur le vecteur v\nstd::vector<int>::iterator begin_iterator { v.begin() };\n\n// D\xe9claration d'un it\xe9rateur sur le dernier \xe9l\xe9ment du vecteur v\nstd::vector<int>::iterator end_iterator { v.end() };\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Ici, nous utilisons l'",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateur")," ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector<int>::iterator")," qui permet de parcourir un vecteur. Il existe aussi l'",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateur")," ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector<int>::const_iterator")," qui permet de parcourir un vecteur en lecture seule (",(0,a.kt)("inlineCode",{parentName:"p"},"const"),") (on peut obtenir des it\xe9rateurs constants avec les m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"cbegin")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"cend"),").")),(0,a.kt)("h3",{id:"utilisation-des-it\xe9rateurs"},"Utilisation des it\xe9rateurs"),(0,a.kt)("p",null,"Pour illustrer le fonctionnement des it\xe9rateurs, reprenons l'exemple pr\xe9c\xe9dent avec un vecteur pour utiliser l'it\xe9rateur pour parcourir le vecteur."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> v {1, 2, 3, 4, 5};\n\n// D\xe9claration d'un it\xe9rateur sur le dernier \xe9l\xe9ment du vecteur v\nstd::vector<int>::iterator end_iterator { v.end() };\n\n// Parcours du vecteur avec l'it\xe9rateur\nfor (std::vector<int>::iterator it { v.begin() }; it != end_iterator; ++it) {\n    std::cout << *it << std::endl;\n}\n")),(0,a.kt)("p",null,"Quelques explications sur ce code :\nNous d\xe9clarons un it\xe9rateur sur le premier \xe9l\xe9ment du vecteur ",(0,a.kt)("inlineCode",{parentName:"p"},"v")," et un it\xe9rateur sur le dernier \xe9l\xe9ment du vecteur ",(0,a.kt)("inlineCode",{parentName:"p"},"v"),". Ensuite, nous parcourons le vecteur avec une boucle ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," en incr\xe9mentant l'",(0,a.kt)("strong",{parentName:"p"},"it\xe9rateur")," (pour passer \xe0 l'\xe9l\xe9ment suivant). Nous utilisons l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," pour comparer l'it\xe9rateur avec l'it\xe9rateur sur le dernier \xe9l\xe9ment du vecteur afin de savoir quand nous avons parcouru tout le vecteur. L'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," permet de r\xe9cup\xe9rer la valeur point\xe9e par l'it\xe9rateur (\xe0 l'instar du d\xe9r\xe9f\xe9rencement d'un pointeur)."),(0,a.kt)("admonition",{title:"for range based loop",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Il existe une syntaxe plus simple pour parcourir un conteneur avec un it\xe9rateur. Il s'agit de la boucle ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," avec la syntaxe ",(0,a.kt)("inlineCode",{parentName:"p"},"for (element : container)"),". Nous avons d\xe9j\xe0 vu cette syntaxe avec les tableaux. Cette syntaxe est aussi valable pour les autres conteneurs de la ",(0,a.kt)("strong",{parentName:"p"},"STL")," et utilise en fait les it\xe9rateurs."),(0,a.kt)("p",{parentName:"admonition"},"Voil\xe0 le m\xeame exemple que pr\xe9c\xe9demment avec la boucle ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," et la syntaxe ",(0,a.kt)("inlineCode",{parentName:"p"},"for (element : container)")," :"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> v {1, 2, 3, 4, 5};\n\n// Parcours du vecteur avec l'it\xe9rateur\nfor (int element : v) {\n    std::cout << element << std::endl;\n}\n")),(0,a.kt)("p",{parentName:"admonition"},"C'est cette syntaxe que nous privil\xe9gierons en pratique pour parcourir les conteneurs.")),(0,a.kt)("h2",{id:"d\xe9duction-de-type"},"D\xe9duction de type"),(0,a.kt)("p",null,"Jusqu'\xe0 pr\xe9sent, nous avons toujours d\xe9clar\xe9 nos variables en pr\xe9cisant leur ",(0,a.kt)("strong",{parentName:"p"},"type"),". Cependant, il existe une syntaxe qui permet de d\xe9duire le type d'une variable \xe0 partir de son initialisation. Nous avons vu avec les it\xe9rateurs que le type de l'it\xe9rateur d\xe9pend du conteneur sur lequel il est utilis\xe9 (par exemple ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector<int>::iterator")," pour un vecteur de ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector<float>::iterator")," pour un vecteur de ",(0,a.kt)("inlineCode",{parentName:"p"},"float"),")"),(0,a.kt)("p",null,"Il est donc impossible de d\xe9clarer un it\xe9rateur sans conna\xeetre le type du conteneur. De plus, le type de l'it\xe9rateur est g\xe9n\xe9ralement tr\xe8s long et compliqu\xe9 \xe0 \xe9crire."),(0,a.kt)("p",null,"Dans ce cas, nous pouvons utiliser la ",(0,a.kt)("strong",{parentName:"p"},"d\xe9duction de type")," pour d\xe9clarer notre it\xe9rateur. Cela se fait avec le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"auto")," \xe0 la place du type de la variable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> v {1, 2, 3, 4, 5};\n\n// D\xe9claration d'un it\xe9rateur sur le vecteur v\nauto it { v.begin() };\n")),(0,a.kt)("p",null,"Pourquoi ne pas utiliser la d\xe9duction de type pour toutes les variables ? C'est une question de lisibilit\xe9 du code. Il est plus facile de comprendre le code si les types sont pr\xe9cis\xe9s. De plus, la d\xe9duction de type ne fonctionne que si la variable est initialis\xe9 et que le type peut \xeatre d\xe9duit. Cela peut \xeatre probl\xe9matique dans certains cas o\xf9 le type ne peut pas \xeatre d\xe9duit ou conduit \xe0 des erreurs (par exemple avec ",(0,a.kt)("inlineCode",{parentName:"p"},"{1, 2, 3, 4, 5}")," qui peut \xeatre un ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector")," ou un ",(0,a.kt)("inlineCode",{parentName:"p"},"std::array"),")."),(0,a.kt)("p",null,"Finalement, la d\xe9duction de type est une fonctionnalit\xe9 tr\xe8s utile mais qui doit \xeatre utilis\xe9e avec parcimonie quand cela est pertinent. Il est pr\xe9f\xe9rable de pr\xe9ciser le type des variables pour rendre le code plus lisible quand cela est possible."),(0,a.kt)("p",null,"On pr\xe9f\xe9rera donc \xe9crire ",(0,a.kt)("inlineCode",{parentName:"p"},"float")," plut\xf4t que ",(0,a.kt)("inlineCode",{parentName:"p"},"auto")," pour d\xe9clarer une variable de type ",(0,a.kt)("inlineCode",{parentName:"p"},"float"),". Mais on pr\xe9f\xe9rera utiliser la d\xe9duction de type pour d\xe9clarer un it\xe9rateur sur un conteneur."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"C'est g\xe9n\xe9ralement consid\xe9r\xe9 comme une mauvaise pratique de ne pas pr\xe9ciser le type des variables (comme c'est le cas en ",(0,a.kt)("strong",{parentName:"p"},"Python")," ou en ",(0,a.kt)("strong",{parentName:"p"},"JavaScript"),"). Il existe pour ces langages des surcouches qui permettent de v\xe9rifier le type des variables (comme ",(0,a.kt)("strong",{parentName:"p"},"TypeScript")," pour ",(0,a.kt)("strong",{parentName:"p"},"JavaScript")," et le module ",(0,a.kt)("inlineCode",{parentName:"p"},"typing")," pour ",(0,a.kt)("strong",{parentName:"p"},"Python"),"). Le ",(0,a.kt)("strong",{parentName:"p"},"C++")," est un langage ",(0,a.kt)("strong",{parentName:"p"},"fortement typ\xe9")," et nous impose de pr\xe9ciser le type des variables mais c'est pour une bonne raison et la ",(0,a.kt)("strong",{parentName:"p"},"d\xe9duction de type")," (",(0,a.kt)("inlineCode",{parentName:"p"},"auto"),") est une fonctionnalit\xe9 qui permet de simplifier le code dans certains cas et n'a pas pour but de remplacer la d\xe9claration de type.")),(0,a.kt)("h2",{id:"exemples-et-algorithmes"},"Exemples et algorithmes"),(0,a.kt)("p",null,"L'int\xe9r\xeat de l'it\xe9rateur pour boucler sur un conteneur est limit\xe9. En effet, il est plus simple d'utiliser la boucle ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," avec la syntaxe ",(0,a.kt)("inlineCode",{parentName:"p"},"for (element : container)")," pour parcourir un conteneur."),(0,a.kt)("p",null,"L'int\xe9r\xeat des it\xe9rateurs est de pouvoir utiliser des algorithmes de la ",(0,a.kt)("strong",{parentName:"p"},"STL")," qui permettent de manipuler les conteneurs de mani\xe8re g\xe9n\xe9rique."),(0,a.kt)("p",null,"Toutes ces fonctions sont d\xe9finies dans le fichier d'en-t\xeate ",(0,a.kt)("inlineCode",{parentName:"p"},"algorithm")," de la ",(0,a.kt)("strong",{parentName:"p"},"STL"),". Vous pouvez retrouver la documentation de ce fichier d'en-t\xeate sur le site ",(0,a.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/algorithm"},"cppreference.com")," (attention, la documentation est en anglais)."),(0,a.kt)("p",null,"Nous allons voir quelques exemples d'algorithmes les plus courants de la ",(0,a.kt)("strong",{parentName:"p"},"STL"),"."),(0,a.kt)("h3",{id:"find"},"Find"),(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::find")," permet de ",(0,a.kt)("strong",{parentName:"p"},"rechercher")," un \xe9l\xe9ment dans un conteneur. Il prend en param\xe8tre un it\xe9rateur sur le premier \xe9l\xe9ment du conteneur, un it\xe9rateur sur le dernier \xe9l\xe9ment du conteneur et la valeur \xe0 rechercher."),(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::find")," renvoie un it\xe9rateur sur l'\xe9l\xe9ment trouv\xe9 ou un it\xe9rateur sur le dernier \xe9l\xe9ment du conteneur si l'\xe9l\xe9ment n'est pas trouv\xe9."),(0,a.kt)("p",null,"Voici un exemple avec un vecteur (",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),") :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n\n    // Recherche de l'\xe9l\xe9ment 3 dans le vecteur v\n    auto it { std::find(v.begin(), v.end(), 3) };\n\n    // On compare l'it\xe9rateur avec l'it\xe9rateur sur le dernier \xe9l\xe9ment du vecteur\n    if (it != v.end())\n    {\n        std::cout << *it << std::endl;\n    }\n    else\n    {\n        std::cout << \"Element not found\" << std::endl;\n    }\n}\n")),(0,a.kt)("h3",{id:"sort"},"Sort"),(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::sort")," permet de trier un conteneur. Il prend en param\xe8tre un it\xe9rateur sur le premier \xe9l\xe9ment du conteneur et un it\xe9rateur sur le dernier \xe9l\xe9ment du conteneur."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {5, 2, 3, 1, 4};\n\n    // Tri du vecteur v\n    std::sort(v.begin(), v.end());\n\n    // Parcours du vecteur avec l'it\xe9rateur\n    for (int element : v)\n    {\n        std::cout << element << std::endl;\n    }\n}\n")),(0,a.kt)("h3",{id:"remove-et-erase"},"Remove et Erase"),(0,a.kt)("p",null,"Pour le ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),", il existe une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"std::erase")," qui permet de supprimer un \xe9l\xe9ment du vecteur. Cependant, cette m\xe9thode n'existe pas pour tous les conteneurs. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n\n    // Suppression de l'\xe9l\xe9ment 3 du vecteur v\n    std::erase(v, 3);\n}\n")),(0,a.kt)("p",null,"Cette fonction propre au ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector")," ne permet pas de supprimer un \xe9l\xe9ment d'un conteneur g\xe9n\xe9rique. Pour cela, il existe l'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::remove")," qui permet de supprimer un \xe9l\xe9ment d'un conteneur. Il prend en param\xe8tre un it\xe9rateur sur le premier \xe9l\xe9ment du conteneur, un it\xe9rateur sur le dernier \xe9l\xe9ment du conteneur et la valeur \xe0 supprimer. C'est ce qu'utilise la m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"std::erase")," pour supprimer un \xe9l\xe9ment du ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),"."),(0,a.kt)("h2",{id:"pour-aller-plus-loin"},"Pour aller plus loin"),(0,a.kt)("h3",{id:"les-fonctions-lambda"},"Les fonctions lambda"),(0,a.kt)("details",null,(0,a.kt)("p",null,"Il existe de nombreux autres algorithmes dans la ",(0,a.kt)("strong",{parentName:"p"},"STL"),". Il est impossible de tous les pr\xe9senter dans ce cours. Je vous invite \xe0 consulter la documentation de la ",(0,a.kt)("strong",{parentName:"p"},"STL")," sur le site ",(0,a.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/algorithm"},"cppreference.com")," pour d\xe9couvrir les autres algorithmes."),(0,a.kt)("p",null,"Certains utilisent des ",(0,a.kt)("strong",{parentName:"p"},"fonctions lambda")," pour permettre de personnaliser le comportement de l'algorithme. C'est le cas de l'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::transform")," qui permet d'appliquer une fonction \xe0 tous les \xe9l\xe9ments d'un conteneur."),(0,a.kt)("p",null,"Je ne vais pas rentrer dans les d\xe9tails des ",(0,a.kt)("strong",{parentName:"p"},"fonctions lambda")," mais sachez que c'est une ",(0,a.kt)("strong",{parentName:"p"},"syntaxe")," qui permet de d\xe9finir une fonction ",(0,a.kt)("strong",{parentName:"p"},"anonyme")," (g\xe9n\xe9ralement petite) et permet de passer une fonction en param\xe8tre d'une autre fonction. C'est quelque chose de tr\xe8s utilis\xe9 avec la ",(0,a.kt)("strong",{parentName:"p"},"STL"),"."),(0,a.kt)("p",null,"Cela reste une notion avanc\xe9e et je ne vais pas rentrer dans les d\xe9tails des ",(0,a.kt)("strong",{parentName:"p"},"fonctions lambda")," dans ce cours. Vous pouvez seulement retenir deux choses :"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"La syntaxe est la suivante : ",(0,a.kt)("inlineCode",{parentName:"li"},"[] (param\xe8tres) { instructions }"),". "),(0,a.kt)("li",{parentName:"ul"},"Si l'on souhaite acc\xe9der \xe0 une variable d\xe9finie en dehors de la fonction lambda (sans que ce soit un param\xe8tre),  il faut ajouter le symbole ",(0,a.kt)("inlineCode",{parentName:"li"},"&")," entre les crochets et les param\xe8tres de la fonction lambda (",(0,a.kt)("inlineCode",{parentName:"li"},"[&] (param\xe8tres) { instructions }"),") (c'est ce que l'on appelle une ",(0,a.kt)("strong",{parentName:"li"},"capture"),").")),(0,a.kt)("p",null,"Je vais pr\xe9senter quelques algorithmes qui utilisent des fonctions lambda pour vous montrer comment cela fonctionne.")),(0,a.kt)("h3",{id:"transform"},"Transform"),(0,a.kt)("details",null,(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::transform")," permet d'appliquer une fonction \xe0 tous les \xe9l\xe9ments d'un conteneur. Il prend en param\xe8tre un it\xe9rateur sur le premier et le dernier \xe9l\xe9ment du conteneur, un it\xe9rateur sur le premier \xe9l\xe9ment du conteneur de destination et la fonction \xe0 appliquer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n    std::vector<int> v2 {0, 0, 0, 0, 0};\n\n    // Application de la fonction lambda \xe0 tous les \xe9l\xe9ments du vecteur v\n    std::transform(v.begin(), v.end(), v2.begin(), [](int element) { return element * 2; });\n\n    // Parcours du vecteur avec l'it\xe9rateur\n    for (int const element : v2)\n    {\n        std::cout << element << std::endl;\n    }\n}\n")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Il faut faire attention \xe0 la taille du conteneur de destination. Si le conteneur de destination est trop petit, il y aura un d\xe9passement et soit le programme plantera soit il y aura des r\xe9sultats inattendus (le vecteur de destination ne sera pas rempli, etc...)."),(0,a.kt)("p",{parentName:"admonition"},"Avec des conteneurs pour lesquels on peut ajouter des \xe9l\xe9ments \xe0 la fin (comme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::vector"),"), il est possible d'utiliser la fonction ",(0,a.kt)("inlineCode",{parentName:"p"},"std::back_inserter")," pour ajouter des \xe9l\xe9ments \xe0 la fin du conteneur de destination. Cela permet de ne pas avoir \xe0 se soucier de la taille du conteneur de destination."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n    std::vector<int> v2 {};\n\n    // Application de la fonction lambda \xe0 tous les \xe9l\xe9ments du vecteur v\n    std::transform(v.begin(), v.end(), std::back_inserter(v2), [](int element) { return element * 2; });\n    // Parcours du vecteur avec l'it\xe9rateur\n    for (int const element : v2)\n    {\n        std::cout << element << std::endl;\n    }\n}\n")))),(0,a.kt)("h3",{id:"accumulate-et-reduce"},"Accumulate et reduce"),(0,a.kt)("details",null,(0,a.kt)("p",null,"Lorsque l'on souhaite agr\xe9ger les \xe9l\xe9ments d'un conteneur pour en extraire une valeur, il existe deux algorithmes qui permettent de faire cela : ",(0,a.kt)("inlineCode",{parentName:"p"},"std::accumulate")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"std::reduce"),"."),(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::accumulate")," permet d\u2019accumuler les \xe9l\xe9ments d'un conteneur selon une op\xe9ration. Pour en faire la somme par exemple. Il prend en param\xe8tre un it\xe9rateur sur le premier et le dernier \xe9l\xe9ment du conteneur, la valeur initiale et l'op\xe9ration \xe0 appliquer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n\n    // Somme des \xe9l\xe9ments du vecteur v\n    int sum { std::accumulate(v.begin(), v.end(), 0, [](int acc, int current_element) { return acc + current_element; }) };\n    std::cout << sum << std::endl;\n}\n")),(0,a.kt)("p",null,"A chaque it\xe9ration, l'op\xe9ration est appliqu\xe9e entre la valeur accumul\xe9e et l'\xe9l\xe9ment courant du conteneur. La valeur accumul\xe9e est initialis\xe9e avec la valeur initiale. Les valeurs sont parcourues ",(0,a.kt)("strong",{parentName:"p"},"dans l'ordre")," du conteneur."),(0,a.kt)("p",null,"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"p"},"std::reduce")," fonctionne de la m\xeame mani\xe8re que ",(0,a.kt)("inlineCode",{parentName:"p"},"std::accumulate")," mais il n'y a pas de valeur initiale. Les valeurs sont parcourues ",(0,a.kt)("strong",{parentName:"p"},"dans n'importe quel ordre"),". C''est utile quand l'op\xe9ration est ",(0,a.kt)("strong",{parentName:"p"},"commutative")," (l'ordre des op\xe9randes n'a pas d'importance)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Somme"',title:'"Somme"'},"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v {1, 2, 3, 4, 5};\n\n    // Somme des \xe9l\xe9ments du vecteur v\n    int sum { std::reduce(v.begin(), v.end(), [](int a, int b) { return a + b; }) };\n    // Ou en utilisant std::plus pour faire la somme (une fonction somme d\xe9j\xe0 impl\xe9ment\xe9e dans la STL dans l'ent\xeate <functional>)\n    // int sum { std::reduce(v.begin(), v.end(), std::plus<int>()) };\n    std::cout << sum << std::endl;\n}\n"))),(0,a.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"La ",(0,a.kt)("strong",{parentName:"li"},"STL")," fournit des ",(0,a.kt)("strong",{parentName:"li"},"algorithmes")," et des fonctions qui permettent de simplifier la manipulation des conteneurs."),(0,a.kt)("li",{parentName:"ul"},"La ",(0,a.kt)("strong",{parentName:"li"},"STL")," fournit des ",(0,a.kt)("strong",{parentName:"li"},"it\xe9rateurs")," qui permettent de parcourir les conteneurs de mani\xe8re g\xe9n\xe9rique."),(0,a.kt)("li",{parentName:"ul"},"Un ",(0,a.kt)("strong",{parentName:"li"},"it\xe9rateur")," est un objet qui se comporte un peu comme un pointeur et permet de cibler un \xe9l\xe9ment dans un conteneur, de le manipuler et permet de passer d'un \xe9l\xe9ment \xe0 l'autre."),(0,a.kt)("li",{parentName:"ul"},"Il existe deux m\xe9thodes sur les conteneurs qui permettent de r\xe9cup\xe9rer un it\xe9rateur sur le ",(0,a.kt)("strong",{parentName:"li"},"premier \xe9l\xe9ment")," du conteneur et un it\xe9rateur sur le ",(0,a.kt)("strong",{parentName:"li"},"dernier \xe9l\xe9ment")," du conteneur : ",(0,a.kt)("inlineCode",{parentName:"li"},"begin")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"end"),"."),(0,a.kt)("li",{parentName:"ul"},"La syntaxe ",(0,a.kt)("inlineCode",{parentName:"li"},"for (element : container)")," utilise les it\xe9rateurs pour parcourir un conteneur."),(0,a.kt)("li",{parentName:"ul"},"La ",(0,a.kt)("strong",{parentName:"li"},"d\xe9duction de type")," permet de d\xe9duire le type d'une variable \xe0 partir de son initialisation. Cela se fait avec le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"li"},"auto")," \xe0 la place du type de la variable."),(0,a.kt)("li",{parentName:"ul"},"La d\xe9duction de type est une fonctionnalit\xe9 tr\xe8s utile mais qui doit \xeatre utilis\xe9e avec parcimonie quand cela est pertinent. Il est pr\xe9f\xe9rable de pr\xe9ciser le type des variables pour rendre le code plus lisible quand cela est possible."),(0,a.kt)("li",{parentName:"ul"},"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"li"},"std::find")," permet de ",(0,a.kt)("strong",{parentName:"li"},"rechercher")," un \xe9l\xe9ment dans un conteneur."),(0,a.kt)("li",{parentName:"ul"},"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"li"},"std::sort")," permet de ",(0,a.kt)("strong",{parentName:"li"},"trier")," un conteneur."),(0,a.kt)("li",{parentName:"ul"},"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"li"},"std::erase")," permet de ",(0,a.kt)("strong",{parentName:"li"},"supprimer")," un \xe9l\xe9ment d'un ",(0,a.kt)("inlineCode",{parentName:"li"},"std::vector"),"."),(0,a.kt)("li",{parentName:"ul"},"Les fonctions lambda permettent de d\xe9finir une fonction ",(0,a.kt)("strong",{parentName:"li"},"anonyme")," (g\xe9n\xe9ralement petite) pour personnaliser le comportement d'un algorithme."),(0,a.kt)("li",{parentName:"ul"},"L'algorithme ",(0,a.kt)("inlineCode",{parentName:"li"},"std::transform")," permet d'",(0,a.kt)("strong",{parentName:"li"},"appliquer une fonction")," \xe0 tous les \xe9l\xe9ments d'un conteneur."),(0,a.kt)("li",{parentName:"ul"},"Les algorithmes ",(0,a.kt)("inlineCode",{parentName:"li"},"std::accumulate")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"std::reduce")," permettent d'",(0,a.kt)("strong",{parentName:"li"},"agr\xe9ger")," les \xe9l\xe9ments d'un conteneur pour en extraire une valeur.")))}m.isMDXComponent=!0}}]);
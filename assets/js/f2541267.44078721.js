"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[1594],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>k});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),d=s(t),c=a,k=d["".concat(p,".").concat(c)]||d[c]||m[c]||i;return t?r.createElement(k,o(o({ref:n},l),{},{components:t})):r.createElement(k,o({ref:n},l))}));function k(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=c;var u={};for(var p in n)hasOwnProperty.call(n,p)&&(u[p]=n[p]);u.originalType=e,u[d]="string"==typeof e?e:a,o[1]=u;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9848:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>u,toc:()=>s});var r=t(7462),a=(t(7294),t(3905));const i={title:"S\xe9mantique et op\xe9rateurs",tags:["C++"],sidebar_position:2},o=void 0,u={unversionedId:"Lessons/S2/Operators",id:"Lessons/S2/Operators",title:"S\xe9mantique et op\xe9rateurs",description:"Nous avons appris au semestre 1 \xe0 d\xe9finir des structures. Cela permet de regrouper des donn\xe9es qui ont un lien entre elles. Par exemple, on peut cr\xe9er une structure Point qui contient les coordonn\xe9es d'un point dans un plan.",source:"@site/content/Lessons/S2/Operators.md",sourceDirName:"Lessons/S2",slug:"/Lessons/S2/Operators",permalink:"/Learn--cpp_programming/Lessons/S2/Operators",draft:!1,tags:[{label:"C++",permalink:"/Learn--cpp_programming/tags/c"}],version:"current",sidebarPosition:2,frontMatter:{title:"S\xe9mantique et op\xe9rateurs",tags:["C++"],sidebar_position:2}},p={},s=[{value:"Op\xe9rateurs",id:"op\xe9rateurs",level:2},{value:"\xc9galit\xe9",id:"\xe9galit\xe9",level:2},{value:"Definition libre ou membre",id:"definition-libre-ou-membre",level:3},{value:"R\xe9utilisation des op\xe9rateurs",id:"r\xe9utilisation-des-op\xe9rateurs",level:2},{value:"Op\xe9rateurs d&#39;assignation compos\xe9s",id:"op\xe9rateurs-dassignation-compos\xe9s",level:2},{value:"Deux en un",id:"deux-en-un",level:3},{value:"Op\xe9rateurs de flux",id:"op\xe9rateurs-de-flux",level:2},{value:"Op\xe9rateurs d&#39;affection par copie",id:"op\xe9rateurs-daffection-par-copie",level:2},{value:"Quelques bonnes pratiques",id:"quelques-bonnes-pratiques",level:2},{value:"D&#39;autres op\xe9rateurs",id:"dautres-op\xe9rateurs",level:2},{value:"R\xe9sum\xe9",id:"r\xe9sum\xe9",level:2}],l={toc:s},d="wrapper";function m(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Nous avons appris au semestre 1 \xe0 d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"structures"),". Cela permet de regrouper des donn\xe9es qui ont un lien entre elles. Par exemple, on peut cr\xe9er une structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui contient les coordonn\xe9es d'un point dans un plan."),(0,a.kt)("p",null,"Nous avons aussi vu comment d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thodes")," pour l'utiliser la structure. Par exemple, on peut d\xe9finir une m\xe9thode ",(0,a.kt)("inlineCode",{parentName:"p"},"add")," qui permet d'ajouter deux points entre eux (en faisant la somme de leurs coordonn\xe9es respectives)."),(0,a.kt)("p",null,"On s\u2019aper\xe7oit avec cet exemple de structure ",(0,a.kt)("inlineCode",{parentName:"p"},"point")," que les structures permettent parfois de donner un sens \xe0 nos donn\xe9es. Ici cela fait sens de pouvoir ajouter deux points entre eux, mais cela n'aurait pas de sens d'ajouter deux ",(0,a.kt)("inlineCode",{parentName:"p"},"Personne")," entre elles. "),(0,a.kt)("p",null,"Nous allons d\xe9couvrir dans ce cours comment d\xe9finir des ",(0,a.kt)("strong",{parentName:"p"},"op\xe9rateurs")," pour manipuler nos structures comme si elles \xe9taient des types de base et ainsi leur donner du sens."),(0,a.kt)("h2",{id:"op\xe9rateurs"},"Op\xe9rateurs"),(0,a.kt)("p",null,"Les op\xe9rateurs sont des symboles qui permettent de manipuler des donn\xe9es. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," permet d'additionner deux nombres entre eux."),(0,a.kt)("p",null,"En C++, il est possible de d\xe9finir des op\xe9rateurs pour nos structures, c'est ce que l'on appelle la ",(0,a.kt)("strong",{parentName:"p"},"surcharge d'op\xe9rateurs"),". Cela permet ensuite d'utiliser l'op\xe9rateur sur nos structures sans devoir passer par une m\xe9thode."),(0,a.kt)("p",null,"Pour d\xe9finir un op\xe9rateur, on utilise le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"operator")," suivi du symbole de l'op\xe9rateur. Par exemple, pour d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),", on utilise ",(0,a.kt)("inlineCode",{parentName:"p"},"operator+"),"."),(0,a.kt)("p",null,"Par exemple, on peut d\xe9finir un op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet op\xe9rateur sur nos structures comme si elles \xe9taient des nombres."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nPoint operator+(Point a, Point b) {\n    return {a.x + b.x, a.y + b.y};\n}\n\nint main() {\n    Point a {1, 2};\n    Point b {3, 4};\n    Point c { a + b}; // c = {4, 6}\n}\n")),(0,a.kt)("h2",{id:"\xe9galit\xe9"},"\xc9galit\xe9"),(0,a.kt)("p",null,"Ce qui fait g\xe9n\xe9ralement sens pour une structure, c'est de pouvoir ",(0,a.kt)("strong",{parentName:"p"},"comparer")," deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont ",(0,a.kt)("strong",{parentName:"p"},"\xe9gaux")," ou non."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"D\xe8s que cela vous semble pertinent, c'est un ",(0,a.kt)("strong",{parentName:"p"},"indicateur"),' qui permet de savoir si ont doit se "limiter" \xe0 des m\xe9thodes ou si surcharger des op\xe9rateurs est pertinent.')),(0,a.kt)("p",null,"Pour \xeatre en mesure de d\xe9finir l\u2019\xe9galit\xe9, on doit respecter les conditions suivantes."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"a == a")," doit \xeatre vrai, c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"r\xe9flexivit\xe9"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"b")," de m\xeame type, si ",(0,a.kt)("inlineCode",{parentName:"li"},"a == b")," est ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", alors ",(0,a.kt)("inlineCode",{parentName:"li"},"b == a")," doit \xeatre ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"sym\xe9trie")," et la ",(0,a.kt)("strong",{parentName:"li"},"commutativit\xe9"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour n'importe quel ",(0,a.kt)("inlineCode",{parentName:"li"},"a"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"b")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"c")," de m\xeame type, si ",(0,a.kt)("inlineCode",{parentName:"li"},"a == b")," et ",(0,a.kt)("inlineCode",{parentName:"li"},"b == c")," sont ",(0,a.kt)("strong",{parentName:"li"},"vrais"),", alors ",(0,a.kt)("inlineCode",{parentName:"li"},"a == c")," doit \xeatre ",(0,a.kt)("strong",{parentName:"li"},"vrai"),", c'est ce qu'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"transitivit\xe9"),".")),(0,a.kt)("p",null,"Pour d\xe9finir l'op\xe9rateur d'\xe9galit\xe9, on utilise ",(0,a.kt)("inlineCode",{parentName:"p"},"operator=="),". On peut ensuite utiliser cet op\xe9rateur sur nos structures de la m\xeame fa\xe7on que pour les types de base."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nbool operator==(Point a, Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\nint main() {\n    Point a {1, 2};\n    Point b {1, 2};\n    bool c { a == b}; // c = true\n}\n")),(0,a.kt)("h3",{id:"definition-libre-ou-membre"},"Definition libre ou membre"),(0,a.kt)("p",null,"On peut d\xe9finir l'op\xe9rateur d'\xe9galit\xe9 comme une ",(0,a.kt)("strong",{parentName:"p"},"fonction libre")," (en dehors de la d\xe9finition de la structure) ou comme une ",(0,a.kt)("strong",{parentName:"p"},"m\xe9thode")," membre."),(0,a.kt)("p",null,"La diff\xe9rence est que dans le cas d'une m\xe9thode membre, le premier param\xe8tre est implicite et correspond \xe0 l'instance sur laquelle on appelle la m\xe9thode."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n    \n    bool operator==(Point b) {\n        return x == b.x && y == b.y;\n    }\n};\n")),(0,a.kt)("p",null,"Cela \xe0 donc une influence sur la fa\xe7on dont on utilise l'op\xe9rateur."),(0,a.kt)("p",null,"Par exemple si l'on souhaite multiplier un point par un nombre, on peut d\xe9finir l'op\xe9rateur comme une m\xe9thode membre."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n    \n    Point operator*(int a) {\n        return {x * a, y * a};\n    }\n};\n\nint main() {\n    Point a {1, 2};\n    Point b { a * 2}; // b = {2, 4}\n}\n")),(0,a.kt)("p",null,"Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas d\xe9finir l'op\xe9rateur comme une m\xe9thode membre car le premier param\xe8tre est implicite et correspond \xe0 l'instance sur laquelle on appelle la m\xe9thode."),(0,a.kt)("p",null,"Il faut donc d\xe9finir l'op\xe9rateur comme une fonction libre."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nPoint operator*(int a, Point b) {\n    return {a * b.x, a * b.y};\n}\n\nint main() {\n    Point a {1, 2};\n    Point b { 2 * a}; // b = {2, 4}\n}\n")),(0,a.kt)("p",null,"Les deux syntaxes sont donc valables, mais il faut garder en t\xeate que la syntaxe avec une m\xe9thode membre est plus limitante."),(0,a.kt)("h2",{id:"r\xe9utilisation-des-op\xe9rateurs"},"R\xe9utilisation des op\xe9rateurs"),(0,a.kt)("p",null,"Je vous ai d\xe9j\xe0 parl\xe9 de l\u2019int\xe9r\xeat de la ",(0,a.kt)("strong",{parentName:"p"},"r\xe9utilisation")," avec les fonctions. C'est aussi valable pour les op\xe9rateurs."),(0,a.kt)("p",null,"L\u2019habitude que beaucoup prennent est de d\xe9finir les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", puis de d\xe9finir les autres en fonction de ces deux-l\xe0."),(0,a.kt)("p",null,"On va donc d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," et l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},">")," en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nbool operator==(Point a, Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\nbool operator!=(Point a, Point b) {\n    return !(a == b);\n}\n\nbool operator<(Point a, Point b) {\n    return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nbool operator>(Point a, Point b) {\n    return b < a;\n}\n")),(0,a.kt)("h2",{id:"op\xe9rateurs-dassignation-compos\xe9s"},"Op\xe9rateurs d'assignation compos\xe9s"),(0,a.kt)("p",null,"Les op\xe9rateurs d'assignation compos\xe9s permettent de combiner une op\xe9ration et une assignation. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," permet d'additionner une valeur \xe0 une variable et de stocker le r\xe9sultat dans la variable."),(0,a.kt)("p",null,"Il est aussi possible de d\xe9finir des op\xe9rateurs d'assignation compos\xe9s pour nos structures. Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'additionner un point \xe0 un autre point et de stocker le r\xe9sultat dans le premier point."),(0,a.kt)("p",null,"Cela fait sens dans ce cas de les d\xe9finir comme des m\xe9thodes membres."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n\n    Point& operator+=(Point p) {\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n};\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"L'expression ",(0,a.kt)("inlineCode",{parentName:"p"},"*this")," peut sembler \xe9trange. ",(0,a.kt)("inlineCode",{parentName:"p"},"this")," est un pointeur sur l'instance courante. ",(0,a.kt)("inlineCode",{parentName:"p"},"*this")," est donc une r\xe9f\xe9rence sur l'instance courante.\nOn retourne une r\xe9f\xe9rence sur l'instance courante pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("p",{parentName:"admonition"},"Par exemple, on peut \xe9crire ",(0,a.kt)("inlineCode",{parentName:"p"},"a += b += c")," qui est \xe9quivalent \xe0 ",(0,a.kt)("inlineCode",{parentName:"p"},"a += (b += c)"),"."),(0,a.kt)("p",{parentName:"admonition"},"Cela nous permet d\u2019avoir le m\xeame comportement pour notre structure que s\u2019il s\u2019agissait d\u2019un type natif comme ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),".")),(0,a.kt)("h3",{id:"deux-en-un"},"Deux en un"),(0,a.kt)("p",null,"Pour chaque op\xe9rateur d'assignation compos\xe9, il existe un op\xe9rateur binaire (prenant deux param\xe8tres) correspondant. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," a pour op\xe9rateur binaire correspondant ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),"."),(0,a.kt)("p",null,"Dans un soucis de r\xe9utilisation, on peut d\xe9finir l'op\xe9rateur binaire en fonction de l'op\xe9rateur d'assignation compos\xe9."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n\n    Point& operator+=(Point b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n};\n\nPoint operator+(Point a, Point const& b) {\n    return a += b;\n}\n")),(0,a.kt)("p",null,"On ici le principe de copie de param\xe8tre par valeur. Puisque le premier param\xe8tre est copi\xe9, on peut le modifier avec l\u2019op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," sans risque modifier l'instance originale. On obtient donc l'op\xe9rateur binaire ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," en fonction de l'op\xe9rateur d'assignation compos\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"+="),"."),(0,a.kt)("p",null,"L'avantage est que si l'on doit modifier ou corriger le comportement le l'addition, on n'a pas besoin de modifier l'op\xe9rateur binaire ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," puisqu'il est d\xe9fini en fonction de l'op\xe9rateur d'assignation compos\xe9 ",(0,a.kt)("inlineCode",{parentName:"p"},"+="),"."),(0,a.kt)("h2",{id:"op\xe9rateurs-de-flux"},"Op\xe9rateurs de flux"),(0,a.kt)("p",null,"Les op\xe9rateurs de flux permettent de d\xe9finir comment afficher une structure ou la lire depuis un flux. Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," pour notre structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Point")," qui permet d'afficher un point dans un flux."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Point {\n    int x;\n    int y;\n};\n\nstd::ostream& operator<<(std::ostream& os, Point const& p) {\n    return os << '(' << p.x << \", \" << p.y << ')';\n}\n")),(0,a.kt)("p",null,"L'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," prend en premier param\xe8tre un flux de sortie (",(0,a.kt)("inlineCode",{parentName:"p"},"std::ostream&"),") et en deuxi\xe8me param\xe8tre un point (",(0,a.kt)("inlineCode",{parentName:"p"},"Point const&"),"). Il retourne le flux de sortie pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("detail",null,(0,a.kt)("summary",null,"op\xe9rateur `>>`"),(0,a.kt)("p",null,"Il existe aussi l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},">>")," qui permet de lire depuis un flux pour construire une structure."),(0,a.kt)("p",null,"Il se d\xe9fini ainsi:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::istream& operator>>(std::istream& is, Point& p) {\n    // gestion de la lecture\n\n    is >> p.x >> p.y;\n\n    if( /* Erreur, impossible de construire notre structure */ )\n    {\n        is.setstate(std::ios::failbit);\n    }\n    return is;\n\n}\n")),(0,a.kt)("p",null,"notez que dans ce cas il faut signaler si l\u2019entr\xe9e est invalide en mettant le flux dans un \xe9tat invalide avec ",(0,a.kt)("inlineCode",{parentName:"p"},"std::ios::failbit"),", ce qui permet \xe0 l\u2019utilisateur de faire ",(0,a.kt)("inlineCode",{parentName:"p"},"if (std::cin.fail())"),".")),(0,a.kt)("p",null,"Ces op\xe9rateurs s\u2019\xe9crivent toujours sous la forme libre car leur premier argument est toujours un flux. "),(0,a.kt)("h2",{id:"op\xe9rateurs-daffection-par-copie"},"Op\xe9rateurs d'affection par copie"),(0,a.kt)("p",null,"Parfois, on a besoin de copier une structure. Pas seulement \xe0 l'initialisation (dans ce cas l\xe0 on peut utiliser la syntaxe d'initialisation ",(0,a.kt)("inlineCode",{parentName:"p"},"{}"),"), mais on a besoin d'affecter une nouvelle valeur \xe0 une structure d\xe9j\xe0 existante."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Point const point { 3, 4 };\nPoint copie { 1, 1 };\n\n// ...\ncopie = point;\n")),(0,a.kt)("p",null,"Pour faire cela il faut d\xe9finir l'op\xe9rateur d'affection par copie ",(0,a.kt)("inlineCode",{parentName:"p"},"="),". Cet op\xe9rateur est appel\xe9 quand on affecte une valeur \xe0 une structure d\xe9j\xe0 existante."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\nstruct Point {\n    int x;\n    int y;\n\n    Point& operator=(Point const& b) {\n        x = b.x;\n        y = b.y;\n        return *this;\n    }\n};\n")),(0,a.kt)("h2",{id:"quelques-bonnes-pratiques"},"Quelques bonnes pratiques"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Il est important de garder en t\xeate que la surcharge d'op\xe9rateurs est une ",(0,a.kt)("strong",{parentName:"p"},"facilit\xe9")," et non une ",(0,a.kt)("strong",{parentName:"p"},"n\xe9cessit\xe9"),". Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"IL est aussi important de respecter la ",(0,a.kt)("strong",{parentName:"p"},"s\xe9mantique")," des op\xe9rateurs. Par exemple, l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," doit faire une addition et non une soustraction. Si un op\xe9rateur a une s\xe9mantique d\xe9j\xe0 d\xe9finie pour un ",(0,a.kt)("strong",{parentName:"p"},"domaine"),", tenez vous-y.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Si la signification de l'op\xe9rateur n'est pas \xe9vidente et indiscutable, il faut \xe9viter de le surcharger. Il est pr\xe9f\xe9rable de d\xe9finir une m\xe9thode explicite dans les cas o\xf9 la s\xe9mantique n'est pas \xe9vidente. Si pour une raison ou une autre, vous devez surcharger un op\xe9rateur qui n'a pas de s\xe9mantique \xe9vidente, il faut le commenter absolument.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Enfin, certains op\xe9rateurs sont li\xe9s entre eux. Par exemple, si vous surchargez l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"=="),", il est conseill\xe9 de surcharger l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," (en fonction de ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," si possible). De m\xeame, si vous surchargez l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", les utilisateurs de votre structure s'attendront \xe0 ce que les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},">"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<=")," et ",(0,a.kt)("inlineCode",{parentName:"p"},">=")," soient d\xe9finis \xe9galement."))),(0,a.kt)("h2",{id:"dautres-op\xe9rateurs"},"D'autres op\xe9rateurs"),(0,a.kt)("p",null,"On peut aussi surcharger les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"()")," pour d\xe9finir un acc\xe8s \xe0 un \xe9l\xe9ment de notre structure ou les op\xe9rateurs ",(0,a.kt)("inlineCode",{parentName:"p"},"--")," et ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," pour d\xe9finir un incr\xe9ment ou un d\xe9cr\xe9ment."),(0,a.kt)("p",null,"Il existe de nombreux op\xe9rateurs que l'on peut surcharger mais le principe reste le m\xeame."),(0,a.kt)("h2",{id:"r\xe9sum\xe9"},"R\xe9sum\xe9"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"On peut d\xe9finir des op\xe9rateurs pour nos structures, c'est ce que l'on appelle la ",(0,a.kt)("strong",{parentName:"li"},"surcharge d'op\xe9rateurs"),"."),(0,a.kt)("li",{parentName:"ul"},"Pour d\xe9finir un op\xe9rateur, on utilise le mot cl\xe9 ",(0,a.kt)("inlineCode",{parentName:"li"},"operator")," suivi du symbole de l'op\xe9rateur. Par exemple, pour d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+"),", on utilise ",(0,a.kt)("inlineCode",{parentName:"li"},"operator+"),"."),(0,a.kt)("li",{parentName:"ul"},"Les op\xe9rateurs permettent de donner du ",(0,a.kt)("strong",{parentName:"li"},"sens")," \xe0 nos structures et de les manipuler comme si elles \xe9taient des types de base. Cela donne de la ",(0,a.kt)("strong",{parentName:"li"},"s\xe9mantique")," \xe0 nos structures."),(0,a.kt)("li",{parentName:"ul"},"C'est int\xe9ressant de r\xe9utiliser les op\xe9rateurs entre eux. Par exemple, on peut d\xe9finir l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+")," en fonction de l'op\xe9rateur ",(0,a.kt)("inlineCode",{parentName:"li"},"+="),"."),(0,a.kt)("li",{parentName:"ul"},"L'expression ",(0,a.kt)("inlineCode",{parentName:"li"},"*this")," permet de retourner une r\xe9f\xe9rence sur l'instance courante pour pouvoir faire des op\xe9rations en cha\xeene."),(0,a.kt)("li",{parentName:"ul"},"Il est important de garder en t\xeate que la surcharge d'op\xe9rateurs est une ",(0,a.kt)("strong",{parentName:"li"},"facilit\xe9")," et non une ",(0,a.kt)("strong",{parentName:"li"},"n\xe9cessit\xe9"),". Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est pr\xe9f\xe9rable de d\xe9finir une ",(0,a.kt)("strong",{parentName:"li"},"m\xe9thode")," avec un nom explicite."),(0,a.kt)("li",{parentName:"ul"},"On peut surcharger les op\xe9rateurs de flux ",(0,a.kt)("inlineCode",{parentName:"li"},"<<")," et ",(0,a.kt)("inlineCode",{parentName:"li"},">>")," pour d\xe9finir comment afficher une structure ou la lire depuis un flux."),(0,a.kt)("li",{parentName:"ul"},"Vous trouverez la page de documentation sur la surcharge d'op\xe9rateurs ",(0,a.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/language/operators"},"ici"),".")))}m.isMDXComponent=!0}}]);
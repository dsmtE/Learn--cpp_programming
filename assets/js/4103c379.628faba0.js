"use strict";(self.webpackChunkprogramming_support_courses=self.webpackChunkprogramming_support_courses||[]).push([[8955],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var t=r(96540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},55018:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Annexes/this","title":"Comprendre le mot cl\xe9 this","description":"Revenons sur le mot cl\xe9 this en C++.","source":"@site/content/Annexes/this.md","sourceDirName":"Annexes","slug":"/Annexes/this","permalink":"/Learn--cpp_programming/Annexes/this","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"C++","permalink":"/Learn--cpp_programming/tags/c"},{"inline":true,"label":"Memory","permalink":"/Learn--cpp_programming/tags/memory"}],"version":"current","frontMatter":{"title":"Comprendre le mot cl\xe9 this","tags":["C++","Memory"]},"sidebar":"Annexes","previous":{"title":"Markdown","permalink":"/Learn--cpp_programming/Annexes/Markdown"}}');var s=r(74848),i=r(28453);const o={title:"Comprendre le mot cl\xe9 this",tags:["C++","Memory"]},c=void 0,l={},d=[{value:"Pourquoi <code>this</code> ?",id:"pourquoi-this-",level:2},{value:"Utilisation de <code>this</code> pour acc\xe9der aux membres de la structure \xe0 partir d&#39;une m\xe9thode",id:"utilisation-de-this-pour-acc\xe9der-aux-membres-de-la-structure-\xe0-partir-dune-m\xe9thode",level:2},{value:"Utilisation de <code>this</code> pour cha\xeener les appels de m\xe9thodes",id:"utilisation-de-this-pour-cha\xeener-les-appels-de-m\xe9thodes",level:2},{value:"Appeler une fonction par r\xe9f\xe9rence \xe0 partir d&#39;une m\xe9thode",id:"appeler-une-fonction-par-r\xe9f\xe9rence-\xe0-partir-dune-m\xe9thode",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Revenons sur le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"this"})," en ",(0,s.jsx)(n.strong,{children:"C++"}),"."]}),"\n",(0,s.jsxs)(n.h2,{id:"pourquoi-this-",children:["Pourquoi ",(0,s.jsx)(n.code,{children:"this"})," ?"]}),"\n",(0,s.jsxs)(n.p,{children:["Le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"this"})," est un ",(0,s.jsx)(n.strong,{children:"pointeur"})," qui pointe vers l'",(0,s.jsx)(n.strong,{children:"objet courant"}),". Il est utilis\xe9 principalement pour acc\xe9der aux membres de la structure/classe \xe0 partir d'une m\xe9thode (pour \xe9viter les ambigu\xeft\xe9s avec les param\xe8tres par ",(0,s.jsx)(n.a,{href:"/Lessons/S1/Struct/#conflit-de-noms",children:"exemple"}),")."]}),"\n",(0,s.jsxs)(n.h2,{id:"utilisation-de-this-pour-acc\xe9der-aux-membres-de-la-structure-\xe0-partir-dune-m\xe9thode",children:["Utilisation de ",(0,s.jsx)(n.code,{children:"this"})," pour acc\xe9der aux membres de la structure \xe0 partir d'une m\xe9thode"]}),"\n",(0,s.jsx)(n.p,{children:"Voici un exemple pour illustrer son utilisation :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Point\n{\n    int x {0};\n    int y {0};\n\n    void set_x(int const x)\n    {\n        this->x = x;\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Comme vous pouvez le voir, ",(0,s.jsx)(n.code,{children:"this"})," est utilis\xe9 pour acc\xe9der au ",(0,s.jsx)(n.strong,{children:"membre"})," ",(0,s.jsx)(n.code,{children:"x"})," de la structure ",(0,s.jsx)(n.code,{children:"Point"})," \xe0 partir de la ",(0,s.jsx)(n.strong,{children:"m\xe9thode"})," ",(0,s.jsx)(n.code,{children:"set_x"})," pour \xe9viter les ambigu\xeft\xe9s avec le ",(0,s.jsx)(n.strong,{children:"param\xe8tre"})," ",(0,s.jsx)(n.code,{children:"x"})," de la m\xe9thode."]}),"\n",(0,s.jsx)(n.p,{children:"J'en profite pour rappeler deux m\xe9canismes des pointeurs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"})," devant un pointeur permet de ",(0,s.jsx)(n.strong,{children:"d\xe9r\xe9f\xe9rencer"})," une pointeur et obtenir une sorte de r\xe9f\xe9rence vers l'objet point\xe9 par le pointeur."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"->"})," permet de d\xe9r\xe9f\xe9rencer un pointeur ",(0,s.jsx)(n.strong,{children:"et"})," d'acc\xe9der \xe0 un membre de l'objet point\xe9 par le pointeur. Donc ",(0,s.jsx)(n.code,{children:"this->x"})," est \xe9quivalent \xe0 ",(0,s.jsx)(n.code,{children:"(*this).x"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"On aurait donc pu \xe9crire \xe9galement :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void set_x(int const x)\n{\n    Point* myself_ptr {this};\n    // myself_ptr->x = x;\n    (*myself_ptr).x = x;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"ou bien encore:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void set_x(int const x)\n{\n    Point* myself_ptr {this};\n    Point& myself_ref {*myself_ptr};\n    myself_ref.x = x;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Dans l'id\xe9al pour ce cas de figure, il est pr\xe9f\xe9rable d'\xe9viter de nommer les param\xe8tres de m\xe9thodes avec le m\xeame nom que les membres de la structure pour \xe9viter les ambigu\xeft\xe9s. Dans ce cas ",(0,s.jsx)(n.code,{children:"this"})," n'est m\xeame pas n\xe9cessaire car il n'y a pas d'ambigu\xeft\xe9 et on peut simplement utiliser le nom du membre de la structure pour y acc\xe9der:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void set_x(int const new_x)\n{\n    x = new_x;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Je t'invite \xe0 relire cette section \xe9galement : ",(0,s.jsx)(n.a,{href:"/Lessons/S1/MemoryAllocation/#structure-et-this",children:"structure et this"}),"."]}),"\n",(0,s.jsxs)(n.h2,{id:"utilisation-de-this-pour-cha\xeener-les-appels-de-m\xe9thodes",children:["Utilisation de ",(0,s.jsx)(n.code,{children:"this"})," pour cha\xeener les appels de m\xe9thodes"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"This"})," permet \xe9galement de retourner une r\xe9f\xe9rence vers l'objet courant pour pouvoir cha\xeener les appels de m\xe9thodes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Point\n{\n    int x {0};\n    int y {0};\n\n    Point& set_x(int const new_x)\n    {\n        x = new_x;\n        return *this;\n    }\n\n    Point& set_y(int const new_y)\n    {\n        y = new_y;\n        return *this;\n    }\n};\n\nint main()\n{\n    Point p {};\n    p.set_x(3).set_y(4);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["C'est particuli\xe8rement utile pour les ",(0,s.jsx)(n.strong,{children:"op\xe9rateurs de flux"})," par exemple qui retournent une r\xe9f\xe9rence vers le flux pour pouvoir cha\xeener les appels de ",(0,s.jsx)(n.code,{children:"<<"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Un exemple d'op\xe9rateur de flux pour la structure ",(0,s.jsx)(n.code,{children:"Point"})," et son utilisation :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\nstd::ostream& operator<<(std::ostream& os, Point const& p)\n{\n    os << "Point(" << p.x << ", " << p.y << ")";\n    return os;\n}\n\nint main()\n{\n    Point p {1, 2};\n    std::cout << p << std::endl;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["C'est \xe9galement utilis\xe9 dans les ",(0,s.jsx)(n.strong,{children:"op\xe9rateurs d'affection"})," pour permettre d'\xe9crire ",(0,s.jsx)(n.code,{children:"a = b = c"})," par exemple."]}),"\n",(0,s.jsx)(n.p,{children:"En effet, l'op\xe9rateur d'affectation retourne une r\xe9f\xe9rence vers l'objet courant pour permettre de cha\xeener les appels de l'op\xe9rateur d'affectation."}),"\n",(0,s.jsxs)(n.p,{children:["Voil\xe0 un exemple d'op\xe9rateur d'affectation pour la structure ",(0,s.jsx)(n.code,{children:"Point"})," et son utilisation :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Point\n{\n    int x {0};\n    int y {0};\n\n    Point& operator=(Point const& other)\n    {\n        x = other.x;\n        y = other.y;\n        return *this;\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Lorsque l'on \xe9crit ",(0,s.jsx)(n.code,{children:"a = b = c"}),", l'op\xe9rateur d'affectation est appel\xe9 sur ",(0,s.jsx)(n.code,{children:"b"})," avec ",(0,s.jsx)(n.code,{children:"c"})," en param\xe8tre et retourne une r\xe9f\xe9rence vers ",(0,s.jsx)(n.code,{children:"b"})," qui est ensuite utilis\xe9e pour appeler l'op\xe9rateur d'affectation sur ",(0,s.jsx)(n.code,{children:"a"})," avec ",(0,s.jsx)(n.code,{children:"b"})," en param\xe8tre."]}),"\n",(0,s.jsxs)(n.p,{children:["ainsi ",(0,s.jsx)(n.code,{children:"a = b = c"})," est \xe9quivalent \xe0 ",(0,s.jsx)(n.code,{children:"a.operator=(b.operator=(c))"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Si l'op\xe9rateur d'affectation ne retournait pas une r\xe9f\xe9rence vers l'objet courant, on ne pourrait pas \xe9crire ",(0,s.jsx)(n.code,{children:"a = b = c"})," et on devrait \xe9crire ",(0,s.jsx)(n.code,{children:"a = c; b = c;"}),". C'est \xe0 mon sens tout \xe0 fait valable \xe9galement mais ce n'est pas la convention en C++ et cela pourrait \xeatre bloquant pour pouvoir utiliser des classes de la librairie standard qui utilisent cette convention."]}),"\n",(0,s.jsxs)(n.p,{children:["Il faut par contre \xe9viter de retourner une ",(0,s.jsx)(n.strong,{children:"copie"})," de l'objet plut\xf4t qu'une r\xe9f\xe9rence (",(0,s.jsx)(n.code,{children:"Point operator=(Point const& other)"}),"). Cela permettrait toujours de cha\xeener les appels de m\xe9thodes mais cela serait moins efficace car cela impliquerait de faire des copies et des destructions d'objets inutiles."]}),"\n",(0,s.jsx)(n.h2,{id:"appeler-une-fonction-par-r\xe9f\xe9rence-\xe0-partir-dune-m\xe9thode",children:"Appeler une fonction par r\xe9f\xe9rence \xe0 partir d'une m\xe9thode"}),"\n",(0,s.jsxs)(n.p,{children:["le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"this"})," permet \xe9galement de passer une r\xe9f\xe9rence vers l'objet courant \xe0 une fonction (depuis une m\xe9thode)."]}),"\n",(0,s.jsxs)(n.p,{children:["Prenons par exemple la structure ",(0,s.jsx)(n.code,{children:"Point"})," et une m\xe9thode ",(0,s.jsx)(n.code,{children:"turn_point"})," qui prend une r\xe9f\xe9rence vers un point en param\xe8tre :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Point\n{\n    int x {0};\n    int y {0};\n};\n\nvoid turn_point(Point& p)\n{\n    int temp {x};\n    x = p.y;\n    p.y = -temp;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Si l'on souhaite appeler la fonction ",(0,s.jsx)(n.code,{children:"turn_point"})," depuis une m\xe9thode de la structure ",(0,s.jsx)(n.code,{children:"Point"}),", on peut utiliser ",(0,s.jsx)(n.code,{children:"this"})," pour passer une r\xe9f\xe9rence vers l'objet courant \xe0 la fonction ",(0,s.jsx)(n.code,{children:"turn_point"})," :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Point\n{\n    // ...\n    void turn()\n    {\n        turn_point(*this);\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["J'esp\xe8re que cette section t'a permis de mieux comprendre le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"this"})," en ",(0,s.jsx)(n.strong,{children:"C++"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);
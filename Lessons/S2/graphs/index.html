<!doctype html>
<html lang="fr" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Lessons/S2/graphs" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">Graphes | Cours de programmation C++</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs"><meta data-rh="true" property="og:locale" content="fr"><meta data-rh="true" name="docusaurus_locale" content="fr"><meta data-rh="true" name="docsearch:language" content="fr"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Graphes | Cours de programmation C++"><meta data-rh="true" name="description" content="En informatique, il existe une grande famille de structures de données appelée graphes. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe."><meta data-rh="true" property="og:description" content="En informatique, il existe une grande famille de structures de données appelée graphes. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe."><link data-rh="true" rel="icon" href="/Learn--cpp_programming/imgs/favicon.ico"><link data-rh="true" rel="canonical" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs" hreflang="fr"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"><link rel="stylesheet" href="/Learn--cpp_programming/assets/css/styles.ae73d68e.css">
<script src="/Learn--cpp_programming/assets/js/runtime~main.a34f6936.js" defer="defer"></script>
<script src="/Learn--cpp_programming/assets/js/main.267c64c3.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"> <div role="region" aria-label="Aller au contenu principal"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Aller au contenu principal</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Ouvrir/fermer la barre de navigation" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Learn--cpp_programming/"><div class="navbar__logo"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Learn--cpp_programming/Lessons">Cours</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/TDs">TDs</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Annexes">Annexes</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Workshop">Workshop</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Annals">Annales</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Sources">Sources</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-label="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input id="search_input_react" type="search" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Retour au début de la page" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/Learn--cpp_programming/Lessons">Cours</a><button aria-label="Réduire la catégorie &#x27;Cours&#x27; de la barre latérale" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/Learn--cpp_programming/Lessons/S1/introduction">S1</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Operators">S2</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Operators">Sémantique et opérateurs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/dataStructures">Structures de données</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Sorting">Algorithmes de tri, complexité et recherche dichotomique</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm">Déduction de type et bibliothèque standard</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables">Hash et tableaux associatifs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/BinaryTree">Arbres binaires</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/graphs">Graphes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/EncodingAndCompression">Compression et encodage de données</a></li></ul></li></ul></li></ul></nav><button type="button" title="Réduire le menu latéral" aria-label="Réduire le menu latéral" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Fil d&#x27;Ariane"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Page d&#x27;accueil" class="breadcrumbs__link" href="/Learn--cpp_programming/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/Learn--cpp_programming/Lessons"><span itemprop="name">Cours</span></a><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">S2</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Graphes</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Sur cette page</button></div><div class="theme-doc-markdown markdown"><header><h1>Graphes</h1></header><p>En informatique, il existe une grande famille de structures de données appelée <strong>graphes</strong>. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="quelques-définitions">Quelques définitions<a class="hash-link" aria-label="Lien direct vers Quelques définitions" title="Lien direct vers Quelques définitions" href="/Learn--cpp_programming/Lessons/S2/graphs#quelques-définitions">​</a></h2>
<p>Un <strong>graphe</strong> est un ensemble de <strong>sommets</strong> reliés par des <strong>arêtes</strong>. On peut représenter un graphe par un ensemble de points reliés par des traits. Les points sont les sommets et les traits sont les arêtes.</p>
<!-- -->
<p>Un graphe est dit <strong>orienté</strong> si les arêtes ont un sens. Dans ce cas, on parle d&#x27;<strong>arc</strong>. Un graphe est dit <strong>non orienté</strong> si les arêtes n&#x27;ont pas de sens.</p>
<!-- -->
<p>Un graphe est dit <strong>pondéré</strong> si les arêtes ont un poids. Dans ce cas, on parle de <strong>poids</strong> d&#x27;une arête. Un graphe est dit <strong>non pondéré</strong> si les arêtes n&#x27;ont pas de poids.</p>
<!-- -->
<p>Un graphe est dit <strong>connexe</strong> si tous les sommets sont reliés entre eux par une arête ou une suite d&#x27;arêtes.</p>
<!-- -->
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>graphe orienté connexe</div><div class="admonitionContent_BuS1"><p>Pour un graphe orienté il y a plusieurs notions plus précises de connexité:</p><ul>
<li><strong>Connexité forte</strong>: un graphe orienté est dit fortement connexe si pour chaque paire de sommets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span> et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>, il existe un chemin de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span> à <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> et un chemin de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> à <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>.</li>
<li><strong>Connexité unilatérale</strong>: un graphe orienté est dit unilatéralement connexe si pour chaque paire de sommets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span> et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>, il existe un chemin de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span> à <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> ou un chemin de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> à <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>.</li>
<li><strong>Connexité faible</strong>: un graphe orienté est dit faiblement connexe si le graphe sous-jacent non orienté est connexe.</li>
</ul></div></div>
<p>Un graphe est dit <strong>cyclique</strong> si il contient au moins un cycle. Un cycle est une suite d&#x27;arêtes qui permet de revenir au point de départ.</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="les-arbres">Les arbres<a class="hash-link" aria-label="Lien direct vers Les arbres" title="Lien direct vers Les arbres" href="/Learn--cpp_programming/Lessons/S2/graphs#les-arbres">​</a></h3>
<p>On a précédemment vu les <strong>arbres binaires</strong>. Un arbre n&#x27;est rien d&#x27;autre qu&#x27;un graphe particulier. Un arbre est un graphe <strong>non orienté</strong>, <strong>non pondéré</strong>, <strong>connexe</strong> et <strong>acyclique</strong>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="représentation-dun-graphe">Représentation d&#x27;un graphe<a class="hash-link" aria-label="Lien direct vers Représentation d&#x27;un graphe" title="Lien direct vers Représentation d&#x27;un graphe" href="/Learn--cpp_programming/Lessons/S2/graphs#représentation-dun-graphe">​</a></h2>
<p>Il existe plusieurs manières de représenter un graphe en mémoire. Nous allons voir les deux plus courantes.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="matrice-dadjacence">Matrice d&#x27;adjacence<a class="hash-link" aria-label="Lien direct vers Matrice d&#x27;adjacence" title="Lien direct vers Matrice d&#x27;adjacence" href="/Learn--cpp_programming/Lessons/S2/graphs#matrice-dadjacence">​</a></h3>
<p>La première manière de représenter un graphe est d&#x27;utiliser une <strong>matrice d&#x27;adjacence</strong>. Une matrice d&#x27;adjacence est une matrice carrée dont les lignes et les colonnes représentent les sommets du graphe. Si le sommet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em"></span><span class="mord mathnormal">i</span></span></span></span> est relié au sommet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span></span></span></span>, alors la case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span><span class="mclose">)</span></span></span></span> de la matrice vaut 1. Sinon, elle vaut 0. Si le graphe est pondéré, la case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span><span class="mclose">)</span></span></span></span> de la matrice vaut le poids de l&#x27;arête.</p>
<p>Voici un exemple de matrice d&#x27;adjacence pour un graphe non orienté et non pondéré :</p>
<table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>B</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>E</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table>
<p>Et le graphe correspondant :</p>
<!-- -->
<p>Dans le cas d&#x27;un graphe orienté, la matrice n&#x27;est plus symétrique. Voici un exemple de matrice d&#x27;adjacence pour un graphe orienté et non pondéré :</p>
<table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>E</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>Et le graphe correspondant :</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="liste-dadjacence">Liste d&#x27;adjacence<a class="hash-link" aria-label="Lien direct vers Liste d&#x27;adjacence" title="Lien direct vers Liste d&#x27;adjacence" href="/Learn--cpp_programming/Lessons/S2/graphs#liste-dadjacence">​</a></h3>
<p>La deuxième manière de représenter un graphe est d&#x27;utiliser une <strong>liste d&#x27;adjacence</strong>. Une liste d&#x27;adjacence est une liste de listes. Pour chaque sommet, on a une liste des sommets adjacents. Si le graphe est pondéré, on a une liste des sommets adjacents avec leur poids (avec une paire par exemple).</p>
<p>Voici un exemple de liste d&#x27;adjacence pour un graphe non orienté et non pondéré :</p>
<table><thead><tr><th>Sommet</th><th>Adjacents</th></tr></thead><tbody><tr><td>A</td><td>B, C</td></tr><tr><td>B</td><td>A, C, D</td></tr><tr><td>C</td><td>A, B, E</td></tr><tr><td>D</td><td>B, E</td></tr><tr><td>E</td><td>C, D</td></tr></tbody></table>
<p>En pratique, on utilise plutôt la <strong>liste d&#x27;adjacence</strong> pour représenter un graphe car la <strong>matrice d&#x27;adjacence</strong> peut être très coûteuse en mémoire. En effet, une matrice d&#x27;adjacence est une matrice carrée. Donc, si on a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> sommets, on a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> cases. Même si le graphe possède peu d&#x27;arêtes, la matrice d&#x27;adjacence est quand même de taille <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>. Cela peut être légèrement optimisé dans le cas des graphes non orientés car la matrice est symétrique. On peut donc ne stocker que la moitié de la matrice. Mais cela reste quand même très coûteux en mémoire.</p>
<p>L&#x27;utilité de la <strong>matrice d&#x27;adjacence</strong> est qu&#x27;elle permet de savoir si deux sommets sont reliés en <strong>temps constant</strong>. Dans les cas où c&#x27;est acceptable de stocker une matrice d&#x27;adjacence, on peut donc utiliser cette propriété pour gagner du temps. Cela a aussi des applications en théorie des graphes pour analyser des graphes.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-dun-graphe">Parcours d&#x27;un graphe<a class="hash-link" aria-label="Lien direct vers Parcours d&#x27;un graphe" title="Lien direct vers Parcours d&#x27;un graphe" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-dun-graphe">​</a></h2>
<p>Maintenant que nous avons vu comment représenter un graphe en mémoire, nous allons voir comment parcourir un graphe. Il existe principalement deux manières de parcourir un graphe : en <strong>largeur</strong> et en <strong>profondeur</strong>.</p>
<p>Donnons-nous le graphe suivant :</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-en-largeur">Parcours en largeur<a class="hash-link" aria-label="Lien direct vers Parcours en largeur" title="Lien direct vers Parcours en largeur" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-largeur">​</a></h3>
<p>Le parcours en largeur consiste à parcourir le graphe en partant d&#x27;un sommet et en visitant tous les sommets adjacents avant de passer aux sommets adjacents de ces sommets adjacents. On visite donc les sommets par niveau.</p>
<p>Pour parcourir un graphe en largeur, on utilise une <strong>file</strong>. On commence par ajouter le sommet de départ dans la file. Tant que la file n&#x27;est pas vide, on retire le premier élément de la file et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file. On recommence jusqu&#x27;à ce que la file soit vide.</p>
<p>Voici le déroulement du parcours en largeur au départ du nœud A pour le graphe précédent :</p>
<ul>
<li>On commence par ajouter le sommet <strong>A</strong> dans la file.</li>
</ul>
<table><thead><tr><th>File</th><th>A</th></tr></thead></table>
<ul>
<li>Comme la file n&#x27;est pas vide, on retire le premier élément (<strong>A</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>B</strong> et <strong>C</strong> dans la file.</li>
</ul>
<table><thead><tr><th>File</th><th>C</th><th>B</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>B</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>D</strong> et <strong>E</strong> dans la file.</li>
</ul>
<table><thead><tr><th>File</th><th>E</th><th>D</th><th>C</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>C</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>F</strong> et <strong>G</strong> dans la file.</li>
</ul>
<table><thead><tr><th>File</th><th>G</th><th>F</th><th>E</th><th>D</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>D</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc rien dans la file.</li>
</ul>
<table><thead><tr><th>File</th><th>G</th><th>F</th><th>E</th></tr></thead></table>
<ul>
<li>On fait de même pour <strong>E</strong>, <strong>F</strong> et <strong>G</strong>. La file est maintenant vide. On a donc parcouru tous les sommets du graphe.</li>
</ul>
<p>Cela nous donne donc le parcours suivant : <strong>A, B, C, D, E, F, G</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-en-profondeur">Parcours en profondeur<a class="hash-link" aria-label="Lien direct vers Parcours en profondeur" title="Lien direct vers Parcours en profondeur" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-profondeur">​</a></h3>
<p>Le parcours en profondeur consiste à parcourir le graphe en partant d&#x27;un sommet et en visitant ses sommets adjacents puis les sommets adjacents de ces sommets adjacents, etc. On visite donc les sommets en profondeur. On peut voir le parcours en profondeur comme une descente dans le graphe.</p>
<p>Pour parcourir un graphe en profondeur, on utilise une <strong>pile</strong>. On commence par ajouter le sommet de départ dans la pile. Tant que la pile n&#x27;est pas vide, on retire le premier élément de la pile et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la pile. On recommence jusqu&#x27;à ce que la pile soit vide.</p>
<p>Voici le déroulement du parcours en profondeur au départ du nœud <strong>A</strong> pour le graphe précédent :</p>
<ul>
<li>On commence par ajouter le sommet <strong>A</strong> dans la pile.</li>
</ul>
<table><thead><tr><th>Pile</th><th>A</th></tr></thead></table>
<ul>
<li>Comme la pile n&#x27;est pas vide, on retire le premier élément (<strong>A</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile (<strong>B</strong> et <strong>C</strong>).</li>
</ul>
<table><thead><tr><th>Pile</th><th>B</th><th>C</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>C</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc <strong>F</strong> et <strong>G</strong> dans la pile.</li>
</ul>
<table><thead><tr><th>Pile</th><th>B</th><th>F</th><th>G</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>G</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile.</li>
</ul>
<table><thead><tr><th>Pile</th><th>B</th><th>F</th></tr></thead></table>
<ul>
<li>On retire le premier élément (<strong>F</strong>) de la pile, il n&#x27;a pas de sommets adjacents. On ajoute donc rien dans la pile.</li>
</ul>
<table><thead><tr><th>Pile</th><th>B</th></tr></thead></table>
<ul>
<li>On recommence avec <strong>B</strong>. On ajoute <strong>D</strong> et <strong>E</strong> dans la pile.</li>
</ul>
<table><thead><tr><th>Pile</th><th>D</th><th>E</th></tr></thead></table>
<ul>
<li>On fait de même pour <strong>E</strong> et <strong>D</strong>. La pile est maintenant vide. On a donc parcouru tous les sommets du graphe.</li>
</ul>
<p>Ce qui nous donne le parcours suivant : <strong>A, C, G, F, B, E, D</strong>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="en-pratique">En pratique<a class="hash-link" aria-label="Lien direct vers En pratique" title="Lien direct vers En pratique" href="/Learn--cpp_programming/Lessons/S2/graphs#en-pratique">​</a></h2>
<p>Maintenant que nous avons vu ce qu&#x27;est un graphe il est légitime de se demander à quoi cela peut bien servir. En effet, on peut se demander si on a déjà rencontré des graphes dans la vie de tous les jours. La réponse est oui. Les graphes sont utilisés dans de nombreux domaines. En voici quelques exemples :</p>
<ul>
<li>Les réseaux sociaux : les graphes sont utilisés pour modéliser les relations entre les utilisateurs.</li>
<li>Les jeux vidéos : les graphes sont utilisés pour modéliser les niveaux, les cartes ou encore pour de la recherche de chemin (intelligence artificielle des ennemis par exemple).</li>
<li>Les bases de données : les graphes sont utilisés pour modéliser les relations entre les données.</li>
<li>Les problèmes de transport : les graphes sont utilisés pour modéliser les réseaux de transport (routes, métro, etc.) et permettent de résoudre des problèmes d&#x27;optimisation (par exemple, trouver le plus court chemin entre deux villes).</li>
<li>Des algorithmes de programmation dynamique : les graphes sont beaucoup utilisés dans les algorithmes dis de programmation <strong>dynamique</strong> où le problème est si complexe qu&#x27;il est nécessaire de le décomposer en sous-problèmes, de faire des estimations et d&#x27;explorer les solutions possibles à travers un graphe de solutions.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dijkstra">Dijkstra<a class="hash-link" aria-label="Lien direct vers Dijkstra" title="Lien direct vers Dijkstra" href="/Learn--cpp_programming/Lessons/S2/graphs#dijkstra">​</a></h2>
<p>Je vous propose de voir un exemple d&#x27;algorithme de graphe : l&#x27;algorithme de <strong>Dijkstra</strong>. Cet algorithme permet de trouver le plus court chemin entre deux sommets d&#x27;un graphe <strong>pondéré</strong>. Il est très répandu et est utilisé dans de nombreux domaines.</p>
<p>L&#x27;algorithme de Dijkstra est simplement une application du parcours en largeur. On part d&#x27;un sommet de départ et on visite tous les sommets adjacents. On ajoute ensuite les sommets adjacents de ces sommets adjacents dans la file. On recommence jusqu&#x27;à ce qu&#x27;on ait trouvé le sommet d&#x27;arrivée. On peut alors remonter le chemin en partant du sommet d&#x27;arrivée et en remontant les sommets précédents jusqu&#x27;au sommet de départ.</p>
<p>Pour l&#x27;illustrer on peut prendre une liste de même taille que le nombre de sommets du graphe pour représenter les distances. On initialise toutes les distances à l&#x27;infini sauf la distance du sommet de départ qui est à 0. On utilise également une file pour stocker les sommets à visiter et une liste pour stocker les sommets déjà visités. On commence par ajouter le sommet de départ dans la file des sommets à visiter. Tant que la file n&#x27;est pas vide, on retire le premier élément de la file et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file s&#x27;ils n&#x27;ont pas déjà été visités. Pour chaque sommet adjacent, on met à jour sa distance si la distance actuelle est plus grande que la distance du sommet actuel plus le poids de l&#x27;arête entre le sommet actuel et le sommet adjacent. On recommence jusqu&#x27;à ce que la file soit vide.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>astuce</div><div class="admonitionContent_BuS1"><p>Dans la pratique:</p><ul>
<li>
<p>On utilise une <strong>file de priorité</strong> <code>std::priority_queue</code> pour stocker les sommets à visiter. Cela permet de retirer le sommet avec la plus petite distance facilement et de manière efficace.</p>
</li>
<li>
<p>On utilise un <strong>tableau associatif</strong> pour stocker les distances. Cela permet de ne pas avoir à créer une liste de taille fixe de tout les nœuds avec une distance infinie initialement. On peut simplement ajouter les distances au fur et à mesure que l&#x27;on parcourt le graphe et cela permet au passage de savoir quels nœuds ont déjà été visités sans avoir de liste de nœuds visités supplémentaire.
De plus, généralement, cet algorithme est utilisé pour trouver le plus court chemin entre deux sommets. On peut donc s&#x27;arrêter dès qu&#x27;on a trouvé le sommet d&#x27;arrivée.</p>
</li>
</ul></div></div>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>attention</div><div class="admonitionContent_BuS1"><p>L&#x27;algorithme de Dijkstra ne fonctionne que pour les graphes <strong>pondérés positivement</strong>. En effet, si le graphe contient des arêtes de poids négatif, l&#x27;algorithme peut boucler indéfiniment. Pour éviter ces problèmes,il est aussi possible d&#x27;utiliser une variante: l&#x27;algorithme de <strong>Bellman-Ford</strong> qui est plus lent mais qui fonctionne pour les graphes avec des cycles et des arêtes de poids négatif.</p></div></div>
<p>Pour illustrer l&#x27;algorithme de Dijkstra, donnons-nous le graphe suivant :</p>
<!-- -->
<p>L&#x27;idée de l&#x27;algorithme est de partir d&#x27;un sommet de départ que l&#x27;on ajoute à un ensemble de sommets à visiter (on va également noter la distance depuis le sommet de départ pour aller jusqu&#x27;à ce sommet (ce qui va permettre de prioriser les sommets à visiter)).</p>
<p>On va se servir d&#x27;un <strong>tableau associatif</strong> pour associer à chaque sommet visité la distance la plus courte connue pour aller du sommet de départ à ce sommet et d&#x27;où on vient pour atteindre cette distance (ce qui permet de reconstruire le chemin le plus court à la fin).
Cela permet au passage de marquer les sommets comme visités sans avoir de liste ou structure de données supplémentaire.</p>
<p>Ensuite on va <strong>itérer</strong> sur les sommets à visiter en choisissant à chaque fois le sommet le plus proche du sommet de départ. Pour cela, on va se servi d&#x27;une file de priorité <code>std::priority_queue</code> qui va nous permettre de choisir le sommet le plus proche à chaque itération.</p>
<p>Si le sommet choisi n&#x27;a pas encore été visité, on va le marquer comme visité (mettre à jour le tableau associatif) et on va ajouter à la liste des sommets à visiter tous les sommets voisins de ce sommet.</p>
<p>Si le sommet choisi a déjà été visité, on va regarder si la distance la plus courte connue pour aller à ce sommet (la valeur dans le <strong>tableau associatif</strong>) est plus grande en passant par le sommet choisi. Si c&#x27;est le cas, on va mettre à jour la distance la plus courte et le sommet d&#x27;où on vient pour atteindre cette distance et on va de nouveau ajouter le sommet à la liste des sommets à visiter car l&#x27;on a trouvé un chemin plus court pour y arriver, on dois propager cette information.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="illustration-de-lalgorithme-de-dijkstra">Illustration de l&#x27;algorithme de Dijkstra<a class="hash-link" aria-label="Lien direct vers Illustration de l&#x27;algorithme de Dijkstra" title="Lien direct vers Illustration de l&#x27;algorithme de Dijkstra" href="/Learn--cpp_programming/Lessons/S2/graphs#illustration-de-lalgorithme-de-dijkstra">​</a></h3>
<p>on considère que le sommet de départ est <strong>A</strong> et le sommet d&#x27;arrivée est <strong>E</strong>.</p>
<p>On ajoute le sommet <code>A</code> à la liste des sommets à visiter avec une distance de 0 (on est déjà sur le sommet de départ) et d&#x27;où on vient (on est déjà sur le sommet de départ).</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">A(0)</td></tr></tbody></table>
<p>Il reste des éléments dans la liste à visiter on récupère le sommet qui a la plus petite distance (<strong>A</strong>) et on le retire de la liste à visiter.
On parcours la liste des voisins de <strong>A</strong> (B et C), les deux ne sont pas déjà visités, on les ajoutes à la liste à visiter et au tableau associatif avec la distance en passant par <strong>A</strong> (0 + poids de l&#x27;arête) et d&#x27;où on vient (A).</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center"><strong>B(1, A), C(2, A)</strong></td><td style="text-align:center"><strong>B(1), C(2)</strong></td></tr></tbody></table>
<p>Je récupère maintenant <strong>B</strong> qui est le sommet prioritaire dans la liste à visiter (plus petites distance).</p>
<p>Je parcours la liste des voisins de <strong>B</strong> (C et D). <strong>C</strong> est déjà présent dans le tableau associatif ce qui indique qu&#x27;il a déjà été visité ou marqué à visiter. Ici le poids actuellement dans le tableau des distances est égale au poids en passant par B (1 + 1) donc on ne fait rien les deux chemins sont aussi cours l&#x27;un que l&#x27;autre.</p>
<p>pour <strong>D</strong> on ajoute comme précédemment ce qui donne:</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">B(1, A), C(2, A), <strong>D(6, B)</strong></td><td style="text-align:center">C(2), <strong>D(6)</strong></td></tr></tbody></table>
<p>Je recommence de nouveau avec <strong>C</strong> qui est le sommet prioritaire dans la liste à visiter (plus petites distance).
<strong>D</strong> a déjà été visité <strong>mais</strong> ici le coût en passant par <strong>C</strong> est plus faible (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>3</mn><mo>&lt;</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2 + 3 &lt; 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">6</span></span></span></span>), je mets donc à jour la distance et je rajoute de nouveau <strong>D</strong> dans la liste à visiter:</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">B(1, A), C(2, A),  <strong>D(5, C)</strong></td><td style="text-align:center">D(6), <strong>D(5)</strong></td></tr></tbody></table>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_BuS1"><p>Ici il y a deux fois <strong>D</strong> dans la liste, ce n&#x27;est pas grave car avec la priorité on va de toute façon choisir le plus petit. Puis au moment de traiter une deuxième fois <strong>D</strong> on va voir que la distance est plus grande et on ne va rien faire.</p></div></div>
<p>Enfin on ajoute aussi <strong>E</strong> l&#x27;autre sommet adjacent à <strong>C</strong>:</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">B(1, A), C(2, A), D(5, C), <strong>E(8, C)</strong></td><td style="text-align:center">D(6), D(5), <strong>E(8)</strong></td></tr></tbody></table>
<p>Je continue avec <strong>D</strong> :</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">B(1, A), C(2, A), D(5, C), <strong>E(7, D)</strong></td><td style="text-align:center">D(6), <strong>E(8)</strong>, <strong>E(7)</strong></td></tr></tbody></table>
<p>De nouveau avec D car il était en doublon dans la liste mais cela ne va avoir aucun effet car E est listé avec un poids donc plus faible.</p>
<table><thead><tr><th style="text-align:center">Distances</th><th style="text-align:center">A visiter</th></tr></thead><tbody><tr><td style="text-align:center">B(1, A), C(2, A), D(5, C), <strong>E(7, D)</strong></td><td style="text-align:center"><strong>E(8)</strong>, <strong>E(7)</strong></td></tr></tbody></table>
<p>Enfin on récupère <strong>E</strong>, il n&#x27;a pas d&#x27;arrêtes donc on ne fait rien, mais c&#x27;est le sommet de destination on a atteins notre destination, on peut s&#x27;arrêter et retourner le tableau associatif.</p>
<p>On peut s&#x27;amuser à retrouver la succession des arrêtes à parcours grâce au tableau associatif: <strong>A</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>C</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>D</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>E</strong>.</p>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_BuS1"><p>Vous pouvez trouver une autre façon de représenter l&#x27;algorithme avec une liste de distances pour tout les sommets (initialisée à l&#x27;infini) et une liste de sommets visités. Néanmoins, cette méthode est plus coûteuse en mémoire et moins proche de l&#x27;implémentation de l&#x27;algorithme de Dijkstra. C&#x27;est pour cela que j&#x27;ai choisi de vous présenter cette illustration (avec un tableau associatif (Distances) et une file de priorité (A visiter)).</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="pour-aller-plus-loin-a">Pour aller plus loin: A*<a class="hash-link" aria-label="Lien direct vers Pour aller plus loin: A*" title="Lien direct vers Pour aller plus loin: A*" href="/Learn--cpp_programming/Lessons/S2/graphs#pour-aller-plus-loin-a">​</a></h3>
<p>L&#x27;algorithme de Dijkstra peut être amélioré. En effet, il explore tous les sommets adjacents d&#x27;un sommet avant de passer au sommet suivant. Cela peut être très coûteux en temps si le graphe est très grand et / ou si le sommet de départ et le sommet d&#x27;arrivée sont très éloignés. L&#x27;algorithme de <strong>Dijkstra</strong> explore alors beaucoup de sommets inutilement.</p>
<p>L&#x27;algorithme A* est une amélioration de l&#x27;algorithme de <strong>Dijkstra</strong>. Il utilise une <strong>heuristique</strong> pour guider la recherche. L&#x27;<strong>heuristique</strong> est une fonction qui permet d&#x27;<strong>estimer</strong> la distance entre un sommet et le sommet d&#x27;arrivée. L&#x27;algorithme <strong>A</strong>* explore alors en priorité les sommets qui sont les plus proches(selon cette estimation) du sommet d&#x27;arrivée. Cela permet de réduire le nombre de sommets explorés et donc de gagner du temps.</p>
<p>Pour donner un exemple concret, on peut utiliser la <strong>distance euclidienne</strong> comme <strong>heuristique</strong>. La <strong>distance euclidienne</strong> est la distance à vol d&#x27;oiseau entre deux points. On peut l&#x27;utiliser pour guider la recherche dans un labyrinthe par exemple. On peut alors utiliser la <strong>distance euclidienne</strong> entre le sommet actuel et le sommet d&#x27;arrivée comme heuristique. Cela permet d&#x27;explorer en priorité les sommets qui sont les plus proches (à vol d&#x27;oiseau) du sommet d&#x27;arrivée.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="simplification-2d">Simplification 2D<a class="hash-link" aria-label="Lien direct vers Simplification 2D" title="Lien direct vers Simplification 2D" href="/Learn--cpp_programming/Lessons/S2/graphs#simplification-2d">​</a></h2>
<p>La représentation en liste d&#x27;adjacence est très pratique pour représenter un graphe arbitraire. Cependant, dans certains cas, on peut utiliser une représentation plus simple. C&#x27;est le cas par exemple quand on cherche le plus court chemin entre deux points dans une <strong>grille</strong>. Dans ce cas les sommets sont les centres des cases de la grille et les arêtes sont les côtés des cases de la grille. Il n&#x27;est alors pas nécessaire de stocker la représentation complète du graphe car celle-ci est connue à l&#x27;avance. On peut donc utiliser une représentation plus simple.</p>
<p>Dans le cas où le coup de déplacement d&#x27;une case à une autre est le même pour toutes les cases, appliquer <strong>Dijkstra</strong> sur une grille devient alors très simple. Il suffit de <strong>parcourir</strong> la grille <strong>en largeur</strong> en partant du point de départ et en s&#x27;arrêtant quand on a trouvé le point d&#x27;arrivée. On peut alors remonter le chemin en partant du point d&#x27;arrivée et en remontant les points précédents jusqu&#x27;au point de départ (parfois aussi nommé <strong>Breadth First Search</strong> ou <strong>BFS</strong>).</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="résumé">Résumé<a class="hash-link" aria-label="Lien direct vers Résumé" title="Lien direct vers Résumé" href="/Learn--cpp_programming/Lessons/S2/graphs#résumé">​</a></h2>
<ul>
<li>Un <strong>graphe</strong> est un <strong>ensemble</strong> de <strong>sommets</strong> reliés par des <strong>arêtes</strong>.</li>
<li>Un graphe est dit <strong>orienté</strong> si les <strong>arêtes ont un sens</strong>. Dans ce cas, on parle d&#x27;arc.</li>
<li>Un graphe est dit <strong>pondéré</strong> si les <strong>arêtes ont un poids</strong>.</li>
<li>Un graphe est dit <strong>connexe</strong> si <strong>tous les sommets sont reliés entre eux</strong> par une arête ou une suite d&#x27;arêtes.</li>
<li>Un arbre est un graphe(Un graphe <strong>non orienté</strong>, <strong>non pondéré</strong>, <strong>connexe</strong> et <strong>acyclique</strong>)</li>
<li>Il existe deux manières de représenter un graphe en mémoire : la <strong>matrice d&#x27;adjacence</strong> et la <strong>liste d&#x27;adjacence</strong>.</li>
<li>Il existe deux manières de parcourir un graphe : en <strong>largeur</strong> et en <strong>profondeur</strong>.</li>
<li>L&#x27;algorithme de <strong>Dijkstra</strong> permet de trouver les distances les plus courtes entre un sommet de départ et tous les autres sommets d&#x27;un graphe <strong>pondéré positivement</strong>.</li>
<li>L&#x27;algorithme A* est une amélioration de l&#x27;algorithme de <strong>Dijkstra</strong> qui utilise une <strong>heuristique</strong> pour guider la recherche.</li>
<li>Dans le cas d&#x27;un graphe non <strong>pondéré</strong>, <strong>Dijkstra</strong> n&#x27;est rien d&#x27;autre qu&#x27;un <strong>parcours en largeur</strong>.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sources">Sources<a class="hash-link" aria-label="Lien direct vers Sources" title="Lien direct vers Sources" href="/Learn--cpp_programming/Lessons/S2/graphs#sources">​</a></h2>
<p>Voilà quelques sources qui peuvent vous aider à approfondir le sujet et mieux comprendre les graphes et la recherche de chemin :</p>
<ul>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener noreferrer">https://www.redblobgames.com/pathfinding/a-star/introduction.html</a></li>
<li><a href="https://www.youtube.com/watch?v=GazC3A4OQTE" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=GazC3A4OQTE</a></li>
<li><a href="https://www.youtube.com/watch?v=i3_V90yUfcA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=i3_V90yUfcA</a></li>
<li><a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=-L-WgKMFuhE</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags :</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/Learn--cpp_programming/tags/c">C++</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Pages de documentation"><a class="pagination-nav__link pagination-nav__link--prev" href="/Learn--cpp_programming/Lessons/S2/BinaryTree"><div class="pagination-nav__sublabel">Précédent</div><div class="pagination-nav__label">Arbres binaires</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Learn--cpp_programming/Lessons/S2/EncodingAndCompression"><div class="pagination-nav__sublabel">Suivant</div><div class="pagination-nav__label">Compression et encodage de données</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#quelques-définitions">Quelques définitions</a><ul><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#les-arbres">Les arbres</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#représentation-dun-graphe">Représentation d&#39;un graphe</a><ul><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#matrice-dadjacence">Matrice d&#39;adjacence</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#liste-dadjacence">Liste d&#39;adjacence</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-dun-graphe">Parcours d&#39;un graphe</a><ul><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-largeur">Parcours en largeur</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#parcours-en-profondeur">Parcours en profondeur</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#en-pratique">En pratique</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#dijkstra">Dijkstra</a><ul><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#illustration-de-lalgorithme-de-dijkstra">Illustration de l&#39;algorithme de Dijkstra</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#pour-aller-plus-loin-a">Pour aller plus loin: A*</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#simplification-2d">Simplification 2D</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#résumé">Résumé</a></li><li><a class="table-of-contents__link toc-highlight" href="/Learn--cpp_programming/Lessons/S2/graphs#sources">Sources</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
              <a href="https://discord.com/users/264442459759706112" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/discord.svg"> Discord
              </a>
              </span><span class="footer__link-separator">·</span><a href="mailto:desmet.enguerrand@gmail.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">E-Mail</a><span class="footer__link-separator">·</span><span class="footer__link-item">
              <a href="https://github.com/dsmtE" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/github-dark.svg"> GitHub
              </a>
              </span></div></div><div class="footer__bottom text--center"><div class="footer__copyright">These lessons were written by <a href="https://github.com/dsmtE">DE SMET Enguerrand</a>.<br>Copyright © 2024. Built with <a href="https://docusaurus.io/">Docusaurus</a>.</div></div></div></footer> </div>
</body>
</html>
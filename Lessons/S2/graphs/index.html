<!doctype html>
<html lang="fr" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Lessons/S2/graphs" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">Graphes | Cours de programmation C++</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs"><meta data-rh="true" property="og:locale" content="fr"><meta data-rh="true" name="docusaurus_locale" content="fr"><meta data-rh="true" name="docsearch:language" content="fr"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Graphes | Cours de programmation C++"><meta data-rh="true" name="description" content="En informatique, il existe une grande famille de structures de données appelées graphes. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe."><meta data-rh="true" property="og:description" content="En informatique, il existe une grande famille de structures de données appelées graphes. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe."><link data-rh="true" rel="icon" href="/Learn--cpp_programming/imgs/favicon.ico"><link data-rh="true" rel="canonical" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs" hreflang="fr"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/graphs" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"><link rel="stylesheet" href="/Learn--cpp_programming/assets/css/styles.a80d302a.css">
<script src="/Learn--cpp_programming/assets/js/runtime~main.40819bfc.js" defer="defer"></script>
<script src="/Learn--cpp_programming/assets/js/main.e0cb680a.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"> <div role="region" aria-label="Aller au contenu principal"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Aller au contenu principal</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Ouvrir/fermer la barre de navigation" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Learn--cpp_programming/"><div class="navbar__logo"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Learn--cpp_programming/Lessons">Cours</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/TDs">TDs</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Annexes">Annexes</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Workshop">Workshop</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Sources">Sources</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-label="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input id="search_input_react" type="search" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Retour au début de la page" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/Learn--cpp_programming/Lessons">Cours</a><button aria-label="Réduire la catégorie &#x27;Cours&#x27; de la barre latérale" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Learn--cpp_programming/Lessons/S1/introduction">S1</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Operators">S2</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Operators">Sémantique et opérateurs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/Sorting">Algorithmes de tri, complexité et recherche dichotomique</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/dataStructures">Structures de données</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/AutoAndAlgorithm">Déduction de type et bibliothèque standard</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/HashAndAssociativeTables">Hash et tableaux associatifs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/BinaryTree">Arbres binaires</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/EncodingAndCompression">Compression et encodage de données</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Learn--cpp_programming/Lessons/S2/graphs">Graphes</a></li></ul></li></ul></li></ul></nav><button type="button" title="Réduire le menu latéral" aria-label="Réduire le menu latéral" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Fil d&#x27;Ariane"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Page d&#x27;accueil" class="breadcrumbs__link" href="/Learn--cpp_programming/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/Learn--cpp_programming/Lessons"><span itemprop="name">Cours</span></a><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">S2</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Graphes</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Sur cette page</button></div><div class="theme-doc-markdown markdown"><header><h1>Graphes</h1></header><p>En informatique, il existe une grande famille de structures de données appelées <strong>graphes</strong>. C&#x27;est un outil très puissant qui permet de modéliser des problèmes très variés. Dans cette leçon, nous allons voir comment représenter un graphe en mémoire et comment parcourir un graphe.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="quelques-définitions">Quelques définitions<a href="#quelques-définitions" class="hash-link" aria-label="Lien direct vers Quelques définitions" title="Lien direct vers Quelques définitions">​</a></h2>
<p>Un <strong>graphe</strong> est un ensemble de <strong>sommets</strong> reliés par des <strong>arêtes</strong>. On peut représenter un graphe par un ensemble de points reliés par des traits. Les points sont les sommets et les traits sont les arêtes.</p>
<!-- -->
<p>Un graphe est dit <strong>orienté</strong> si les arêtes ont un sens. Dans ce cas, on parle d&#x27;<strong>arc</strong>. Un graphe est dit <strong>non orienté</strong> si les arêtes n&#x27;ont pas de sens.</p>
<!-- -->
<p>Un graphe est dit <strong>pondéré</strong> si les arêtes ont un poids. Dans ce cas, on parle de <strong>poids</strong> d&#x27;une arête. Un graphe est dit <strong>non pondéré</strong> si les arêtes n&#x27;ont pas de poids.</p>
<!-- -->
<p>Un graphe est dit <strong>connexe</strong> si tous les sommets sont reliés entre eux par une arête ou une suite d&#x27;arêtes.</p>
<!-- -->
<p>Un graphe est dit <strong>cyclique</strong> si il contient au moins un cycle. Un cycle est une suite d&#x27;arêtes qui permet de revenir au point de départ.</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="les-arbres">Les arbres<a href="#les-arbres" class="hash-link" aria-label="Lien direct vers Les arbres" title="Lien direct vers Les arbres">​</a></h3>
<p>On à précédemment vu les <strong>arbres binaires</strong>. Un arbre n&#x27;est rien d&#x27;autre qu&#x27;un graphe particulier. Un arbre est un graphe <strong>non orienté</strong>, <strong>non pondéré</strong>, <strong>connexe</strong> et <strong>acyclique</strong>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="représentation-dun-graphe">Représentation d&#x27;un graphe<a href="#représentation-dun-graphe" class="hash-link" aria-label="Lien direct vers Représentation d&#x27;un graphe" title="Lien direct vers Représentation d&#x27;un graphe">​</a></h2>
<p>Il existe plusieurs manières de représenter un graphe en mémoire. Nous allons voir les deux plus courantes.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="matrice-dadjacence">Matrice d&#x27;adjacence<a href="#matrice-dadjacence" class="hash-link" aria-label="Lien direct vers Matrice d&#x27;adjacence" title="Lien direct vers Matrice d&#x27;adjacence">​</a></h3>
<p>La première manière de représenter un graphe est d&#x27;utiliser une <strong>matrice d&#x27;adjacence</strong>. Une matrice d&#x27;adjacence est une matrice carrée dont les lignes et les colonnes représentent les sommets du graphe. Si le sommet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em"></span><span class="mord mathnormal">i</span></span></span></span> est relié au sommet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span></span></span></span>, alors la case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span><span class="mclose">)</span></span></span></span> de la matrice vaut 1. Sinon, elle vaut 0. Si le graphe est pondéré, la case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05724em">j</span><span class="mclose">)</span></span></span></span> de la matrice vaut le poids de l&#x27;arête.</p>
<p>Voici un exemple de matrice d&#x27;adjacence pour un graphe non orienté et non pondéré :</p>
<table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>B</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>E</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table>
<p>Et le graphe correspondant :</p>
<!-- -->
<p>Dans le cas d&#x27;un graphe orienté, la matrice n&#x27;est plus symétrique. Voici un exemple de matrice d&#x27;adjacence pour un graphe orienté et non pondéré :</p>
<table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>E</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>Et le graphe correspondant :</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="liste-dadjacence">Liste d&#x27;adjacence<a href="#liste-dadjacence" class="hash-link" aria-label="Lien direct vers Liste d&#x27;adjacence" title="Lien direct vers Liste d&#x27;adjacence">​</a></h3>
<p>La deuxième manière de représenter un graphe est d&#x27;utiliser une <strong>liste d&#x27;adjacence</strong>. Une liste d&#x27;adjacence est une liste de listes. Pour chaque sommet, on a une liste des sommets adjacents. Si le graphe est pondéré, on a une liste des sommets adjacents avec leur poids (avec une paire par exemple).</p>
<p>Voici un exemple de liste d&#x27;adjacence pour un graphe non orienté et non pondéré :</p>
<table><thead><tr><th>Sommet</th><th>Adjacents</th></tr></thead><tbody><tr><td>A</td><td>B, C</td></tr><tr><td>B</td><td>A, C, D</td></tr><tr><td>C</td><td>A, B, E</td></tr><tr><td>D</td><td>B, E</td></tr><tr><td>E</td><td>C, D</td></tr></tbody></table>
<p>En pratique, on utilise plutôt la <strong>liste d&#x27;adjacence</strong> pour représenter un graphe car la <strong>matrice d&#x27;adjacence</strong> peut être très coûteuse en mémoire. En effet, une matrice d&#x27;adjacence est une matrice carrée. Donc, si on a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> sommets, on a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> cases. Même si le graphe possède peu d&#x27;arêtes, la matrice d&#x27;adjacence est quand même de taille <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>. Cela peut être légèrement optimisé dans le cas des graphe non orientés car la matrice est symétrique. On peut donc ne stocker que la moitié de la matrice. Mais cela reste quand même très coûteux en mémoire.</p>
<p>l’utilité de la <strong>matrice d&#x27;adjacence</strong> est qu&#x27;elle permet de savoir si deux sommets sont reliés en <strong>temps constant</strong>. Dans les cas où c&#x27;est acceptable de stocker une matrice d&#x27;adjacence, on peut donc utiliser cette propriété pour gagner du temps. Cela à aussi des applications en théorie des graphes pour analyser des graphes.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-dun-graphe">Parcours d&#x27;un graphe<a href="#parcours-dun-graphe" class="hash-link" aria-label="Lien direct vers Parcours d&#x27;un graphe" title="Lien direct vers Parcours d&#x27;un graphe">​</a></h2>
<p>Maintenant que nous avons vu comment représenter un graphe en mémoire, nous allons voir comment parcourir un graphe. Il existe principalement deux manières de parcourir un graphe : en <strong>largeur</strong> et en <strong>profondeur</strong>.</p>
<p>Donnons-nous le graphe suivant :</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-en-largeur">Parcours en largeur<a href="#parcours-en-largeur" class="hash-link" aria-label="Lien direct vers Parcours en largeur" title="Lien direct vers Parcours en largeur">​</a></h3>
<p>Le parcours en largeur consiste à parcourir le graphe en partant d&#x27;un sommet et en visitant tous les sommets adjacents avant de passer aux sommets adjacents de ces sommets adjacents. On visite donc les sommets par niveau.</p>
<p>Pour parcourir un graphe en largeur, on utilise une <strong>file</strong>. On commence par ajouter le sommet de départ dans la file. Tant que la file n&#x27;est pas vide, on retire le premier élément de la file et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file. On recommence jusqu&#x27;à ce que la file soit vide.</p>
<p>Voici le déroulement du parcours en largeur au départ du noeud A pour le graphe précédent :</p>
<ul>
<li>On commence par ajouter le sommet <strong>A</strong> dans la file.</li>
<li>Comme la file n&#x27;est pas vide, on retire le premier élément (<strong>A</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>B</strong> et <strong>C</strong> dans la file.</li>
<li>On retire le premier élément (<strong>B</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>D</strong> et <strong>E</strong> dans la file. La file contient maintenant <strong>C</strong>, <strong>D</strong> et <strong>E</strong>.</li>
<li>On retire le premier élément (<strong>C</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc <strong>F</strong> et <strong>G</strong> dans la file. La file contient maintenant <strong>D</strong>, <strong>E</strong>, <strong>F</strong> et <strong>G</strong>.</li>
<li>On retire le premier élément (<strong>D</strong>) de la file. On ajoute ensuite tous les sommets adjacents de ce sommet dans la file. On ajoute donc rien dans la file. La file contient maintenant <strong>E</strong>, <strong>F</strong> et <strong>G</strong>.</li>
<li>On fait de même pour <strong>E</strong>, <strong>F</strong> et <strong>G</strong>. La file est maintenant vide. On a donc parcouru tous les sommets du graphe.</li>
</ul>
<p>Cela nous donne donc le parcours suivant : <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>, <strong>E</strong>, <strong>F</strong>, <strong>G</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parcours-en-profondeur">Parcours en profondeur<a href="#parcours-en-profondeur" class="hash-link" aria-label="Lien direct vers Parcours en profondeur" title="Lien direct vers Parcours en profondeur">​</a></h3>
<p>Le parcours en profondeur consiste à parcourir le graphe en partant d&#x27;un sommet et en visitant ses sommets adjacents puis les sommets adjacents de ces sommets adjacents, etc. On visite donc les sommets en profondeur. On peut voir le parcours en profondeur comme une descente dans le graphe.</p>
<p>Pour parcourir un graphe en profondeur, on utilise une <strong>pile</strong>. On commence par ajouter le sommet de départ dans la pile. Tant que la pile n&#x27;est pas vide, on retire le premier élément de la pile et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la pile. On recommence jusqu&#x27;à ce que la pile soit vide.</p>
<p>Voici le déroulement du parcours en profondeur au départ du noeud <strong>A</strong> pour le graphe précédent :</p>
<ul>
<li>On commence par ajouter le sommet <strong>A</strong> dans la pile.</li>
<li>Comme la pile n&#x27;est pas vide, on retire le premier élément (<strong>A</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc <strong>B</strong> et <strong>C</strong> dans la pile.</li>
<li>On retire le premier élément (<strong>C</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc <strong>F</strong> et <strong>G</strong> dans la pile. La pile contient maintenant <strong>B</strong>, <strong>F</strong> et <strong>G</strong>.</li>
<li>On retire le premier élément (<strong>G</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile. La pile contient maintenant <strong>B</strong> et <strong>F</strong>.</li>
<li>On retire le premier élément (<strong>F</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc rien dans la pile. La pile contient maintenant <strong>B</strong>.</li>
<li>On retire le premier élément (<strong>B</strong>) de la pile. On ajoute ensuite tous les sommets adjacents de ce sommet dans la pile. On ajoute donc <strong>D</strong> et <strong>E</strong> dans la pile. La pile contient maintenant <strong>D</strong> et <strong>E</strong>.</li>
<li>On fait de même pour <strong>D</strong> et <strong>E</strong>. La pile est maintenant vide. On a donc parcouru tous les sommets du graphe.</li>
</ul>
<p>Ce qui nous donne le parcours suivant : <strong>A</strong>, <strong>C</strong>, <strong>G</strong>, <strong>F</strong>, <strong>B</strong>, <strong>D</strong>, <strong>E</strong>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="en-pratique">En pratique<a href="#en-pratique" class="hash-link" aria-label="Lien direct vers En pratique" title="Lien direct vers En pratique">​</a></h2>
<p>Maintenant que nous avons vu ce qu&#x27;est un graphe il est légitime de se demander à quoi cela peut bien servir. En effet, on peut se demander si on a déjà rencontré des graphes dans la vie de tous les jours. La réponse est oui. Les graphes sont utilisés dans de nombreux domaines. En voici quelques exemples :</p>
<ul>
<li>Les réseaux sociaux : les graphes sont utilisés pour modéliser les relations entre les utilisateurs.</li>
<li>Les jeux vidéos : les graphes sont utilisés pour modéliser les niveaux, les cartes ou encore pour de la recherche de chemin (intelligence artificielle des ennemis par exemple).</li>
<li>Les bases de données : les graphes sont utilisés pour modéliser les relations entre les données.</li>
<li>Les problèmes de transport : les graphes sont utilisés pour modéliser les réseaux de transport (routes, métro, etc.) et permettent de résoudre des problèmes d&#x27;optimisation (par exemple, trouver le plus court chemin entre deux villes).</li>
<li>Des algorithmes de programmation dynamique : les graphes sont beaucoup utilisés dans les algorithmes dit de programmation dynamique où le problème est si complexe qu&#x27;il est nécessaire de le décomposer en sous-problèmes, de faire des estimations et d&#x27;explorer les solutions possibles à travers un graphe de solutions.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dijkstra">Dijkstra<a href="#dijkstra" class="hash-link" aria-label="Lien direct vers Dijkstra" title="Lien direct vers Dijkstra">​</a></h3>
<p>Je vous propose de voir un exemple d&#x27;algorithme de graphe : l&#x27;algorithme de <strong>Dijkstra</strong>. Cet algorithme permet de trouver le plus court chemin entre deux sommets d&#x27;un graphe <strong>pondéré</strong>. Il est très répandu et est utilisé dans de nombreux domaines.</p>
<p>L&#x27;algorithme de Dijkstra est simplement une application du parcours en largeur. On part d&#x27;un sommet de départ et on visite tous les sommets adjacents. On ajoute ensuite les sommets adjacents de ces sommets adjacents dans la file. On recommence jusqu&#x27;à ce qu&#x27;on ait trouvé le sommet d&#x27;arrivée. On peut alors remonter le chemin en partant du sommet d&#x27;arrivée et en remontant les sommets précédents jusqu&#x27;au sommet de départ.</p>
<p>il faut une liste du même taille que le nombre de sommets du graphe pour stocker les distances. On initialise toutes les distances à l&#x27;infini sauf la distance du sommet de départ qui est à 0. On utilise également une file pour stocker les sommets à visiter et une liste pour stocker les sommets déjà visités. On commence par ajouter le sommet de départ dans la file des sommets à visiter. Tant que la file n&#x27;est pas vide, on retire le premier élément de la file et on l&#x27;ajoute à la liste des sommets visités. Ensuite, on ajoute tous les sommets adjacents de ce sommet dans la file s&#x27;il nos pas déjà été visités. Pour chaque sommet adjacent, on met à jour sa distance si la distance actuelle est plus grande que la distance du sommet actuel plus le poids de l&#x27;arête entre le sommet actuel et le sommet adjacent. On recommence jusqu&#x27;à ce que la file soit vide.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>astuce</div><div class="admonitionContent_BuS1"><p>Dans la pratique, on utilise une file de priorité pour stocker les sommets à visiter. Cela permet de toujours retirer le sommet avec la plus petite distance en premier. Cela permet d&#x27;optimiser l&#x27;algorithme.
De plus, généralement, cet algorithme est utilisé pour trouver le plus court chemin entre deux sommets. On peut donc s&#x27;arrêter dès qu&#x27;on a trouvé le sommet d&#x27;arrivée.</p></div></div>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>attention</div><div class="admonitionContent_BuS1"><p>L&#x27;algorithme de Dijkstra ne fonctionne que pour les graphes <strong>pondérés positivement</strong>. En effet, si le graphe contient des arêtes de poids négatif, l&#x27;algorithme peut boucler indéfiniment. Pour éviter ces problèmes,il est aussi possible d&#x27;utiliser une variante: l&#x27;algorithme de <strong>Bellman-Ford</strong> qui est plus lent mais qui fonctionne pour les graphes avec des cycles et des arêtes de poids négatif.</p></div></div>
<p>Pour illustrer l&#x27;algorithme de Dijkstra, donnons-nous le graphe suivant :</p>
<!-- -->
<p>on considère que le sommet de départ est <strong>A</strong> .</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>Sommets à visiter</th><th>Sommets visités</th></tr></thead><tbody><tr><td>0</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td>[A]</td><td>[-]</td></tr></tbody></table>
<p>On commence par ajouter le sommet de départ <strong>A</strong> dans la file de priorité des sommets à visiter. On initialise également la distance du sommet de départ à 0 et les autres distances à l&#x27;infini.</p>
<p><strong>B</strong> et <strong>C</strong> sont les sommets adjacents de <strong>A</strong>. On ajoute donc <strong>B</strong> et <strong>C</strong> dans la file de priorité des sommets à visiter. On met également à jour les distances de <strong>B</strong> et <strong>C</strong>. La distance de <strong>B</strong> est la distance de <strong>A</strong> plus le poids de l&#x27;arête entre <strong>A</strong> et <strong>B</strong>. La distance de <strong>C</strong> est la distance de <strong>A</strong> plus le poids de l&#x27;arête entre <strong>A</strong> et <strong>C</strong>.</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>Sommets à visiter</th><th>Sommets visités</th></tr></thead><tbody><tr><td>0</td><td>1(A)</td><td>3(A)</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td>[B, C]</td><td>[A]</td></tr></tbody></table>
<p>On continue en retirant le sommet <strong>B</strong>. Il a comme sommets adjacents <strong>C</strong> et <strong>D</strong>. <strong>C</strong> à déjà une distance de 3(venant de <strong>A</strong>) mais la distance depuis <strong>B</strong> est plus petite (1 venant de <strong>A</strong> plus 1 venant de <strong>B</strong>). On met donc à jour la distance de <strong>C</strong>. La distance de <strong>D</strong> est la distance de <strong>B</strong> plus le poids de l&#x27;arête entre <strong>B</strong> et <strong>D</strong>. On ajoute ensuite <strong>D</strong> dans la file de priorité des sommets à visiter (<strong>C</strong> est déjà dans la file).</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>Sommets à visiter</th><th>Sommets visités</th></tr></thead><tbody><tr><td>0</td><td>1(A)</td><td>2(B)</td><td>3(B)</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord">∞</span></span></span></span></td><td>[C, D]</td><td>[A, B]</td></tr></tbody></table>
<p>Voilà l&#x27;étape suivant en considérant <strong>C</strong>. <strong>C</strong> a comme sommets adjacents <strong>E</strong>. La distance de <strong>E</strong> est la distance de <strong>C</strong> plus le poids de l&#x27;arête entre <strong>C</strong> et <strong>E</strong>. On ajoute ensuite <strong>E</strong> dans la file de priorité des sommets à visiter.</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>Sommets à visiter</th><th>Sommets visités</th></tr></thead><tbody><tr><td>0</td><td>1(A)</td><td>2(B)</td><td>3(B)</td><td>3(C)</td><td>[D, E]</td><td>[A, B, C]</td></tr></tbody></table>
<p>On continue en retirant le sommet <strong>D</strong>. Il a comme sommets adjacents <strong>E</strong>. La distance de <strong>E</strong> est la distance de <strong>D</strong> plus le poids de l&#x27;arête entre <strong>D</strong> et <strong>E</strong>. Or la distance actuelle de <strong>E</strong> (venant de <strong>C</strong>) est plus petite. On ne met donc pas à jour la distance de <strong>E</strong>. <strong>E</strong> est déjà dans la file de priorité des sommets à visiter. On ne fait donc rien.</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>Sommets à visiter</th><th>Sommets visités</th></tr></thead><tbody><tr><td>0</td><td>1(A)</td><td>2(B)</td><td>3(B)</td><td>3(C)</td><td>[E]</td><td>[A, B, C, D]</td></tr></tbody></table>
<p>Enfin on retire le sommet <strong>E</strong>. Il n&#x27;a pas de sommets adjacents. On ne fait donc rien.</p>
<p>On a fini de parcourir le graphe. On a donc trouvé les distances de tous les sommets depuis le sommet de départ <strong>A</strong>. Si l&#x27;on souhaite trouver le plus court chemin entre <strong>A</strong> et <strong>E</strong>, il suffit de remonter le chemin en partant de E et en remontant les sommets précédents jusqu&#x27;à <strong>A</strong>. Le plus court chemin entre <strong>A</strong> et <strong>E</strong> est donc <strong>A</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>B</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>C</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> <strong>E</strong>.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>astuce</div><div class="admonitionContent_BuS1"><p>En pratique pour pouvoir remonter le chemin, il faut stocker donc stocker pour chaque sommet la distance la plus courte depuis le sommet de départ mais aussi le sommet précédent d&#x27;où l&#x27;on vient pour obtenir cette distance. On peut stocker cela dans une liste de paires (distance, sommet précédent).</p><p>On peut aussi stocker si un sommet a déjà été visité ou non dans une liste de booléens de la taille du nombre de sommets plutôt que dans une liste de sommets visités.</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="pour-aller-plus-loin-a">Pour aller plus loin: A*<a href="#pour-aller-plus-loin-a" class="hash-link" aria-label="Lien direct vers Pour aller plus loin: A*" title="Lien direct vers Pour aller plus loin: A*">​</a></h3>
<p>L&#x27;algorithme de Dijkstra peut être amélioré. En effet, il explore tous les sommets adjacents d&#x27;un sommet avant de passer au sommet suivant. Cela peut être très coûteux en temps si le graphe est très grand et ou si le sommet de départ et le sommet d&#x27;arrivée sont très éloignés. L&#x27;algorithme de <strong>Dijkstra</strong> explore alors beaucoup de sommets inutilement.</p>
<p>L&#x27;algorithme A* est une amélioration de l&#x27;algorithme de <strong>Dijkstra</strong>. Il utilise une <strong>heuristique</strong> pour guider la recherche. L&#x27;heuristique est une fonction qui permet d&#x27;estimer la distance entre un sommet et le sommet d&#x27;arrivée. L&#x27;algorithme <strong>A</strong>* explore alors en priorité les sommets qui sont les plus proches du sommet d&#x27;arrivée. Cela permet de réduire le nombre de sommets explorés et donc de gagner du temps.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="simplification-2d">Simplification 2D<a href="#simplification-2d" class="hash-link" aria-label="Lien direct vers Simplification 2D" title="Lien direct vers Simplification 2D">​</a></h2>
<p>La représentation en liste d&#x27;adjacence est très pratique pour représenter un graphe arbitraire. Cependant, dans certains cas, on peut utiliser une représentation plus simple. C&#x27;est le cas par exemple quand on cherche le plus court chemin entre deux points dans une <strong>grille</strong>. Dans ce cas les sommets sont les centres des cases de la grille et les arêtes sont les côtés des cases de la grille. Il n&#x27;est alors pas nécessaire de stocker la représentation complète du graphe car celle-ci est connue à l&#x27;avance. On peut donc utiliser une représentation plus simple.</p>
<p>Dans le cas où le coup de déplacement d&#x27;une case à une autre est le même pour toutes les cases, appliquer <strong>Dijkstra</strong> sur une grille devient alors très simple. Il suffit de <strong>parcourir</strong> la grille <strong>en largeur</strong> en partant du point de départ et en s&#x27;arrêtant quand on a trouvé le point d&#x27;arrivée. On peut alors remonter le chemin en partant du point d&#x27;arrivée et en remontant les points pr écédents jusqu&#x27;au point de départ (parfois aussi nommé <strong>Breadth First Search</strong> ou <strong>BFS</strong>).</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="résumé">Résumé<a href="#résumé" class="hash-link" aria-label="Lien direct vers Résumé" title="Lien direct vers Résumé">​</a></h2>
<ul>
<li>Un <strong>graphe</strong> est un <strong>ensemble</strong> de <strong>sommets</strong> reliés par des <strong>arêtes</strong>.</li>
<li>Un graphe est dit <strong>orienté</strong> si les <strong>arêtes ont un sens</strong>. Dans ce cas, on parle d&#x27;arc.</li>
<li>Un graphe est dit <strong>pondéré</strong> si les <strong>arêtes ont un poids</strong>.</li>
<li>Un graphe est dit <strong>connexe</strong> si <strong>tous les sommets sont reliés entre eux</strong> par une arête ou une suite d&#x27;arêtes.</li>
<li>Un arbre est un graphe(Un graphe <strong>non orienté</strong>, <strong>non pondéré</strong>, <strong>connexe</strong> et <strong>acyclique</strong>)</li>
<li>Il existe deux manières de représenter un graphe en mémoire : la <strong>matrice d&#x27;adjacence</strong> et la <strong>liste d&#x27;adjacence</strong>.</li>
<li>Il existe deux manières de parcourir un graphe : en <strong>largeur</strong> et en <strong>profondeur</strong>.</li>
<li>L&#x27;algorithme de <strong>Dijkstra</strong> permet de trouver les distances les plus courtes entre un sommet de départ et tous les autres sommets d&#x27;un graphe <strong>pondéré positivement</strong>.</li>
<li>L&#x27;algorithme A* est une amélioration de l&#x27;algorithme de <strong>Dijkstra</strong> qui utilise une <strong>heuristique</strong> pour guider la recherche.</li>
<li>Dans le cas d&#x27;un graphe non <strong>pondéré</strong>, <strong>Dijkstra</strong> n&#x27;est rien d&#x27;autre qu&#x27;un <strong>parcours en largeur</strong>.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sources">Sources<a href="#sources" class="hash-link" aria-label="Lien direct vers Sources" title="Lien direct vers Sources">​</a></h2>
<p>Voilà quelques sources qui peuvent vous aider à approfondir le sujet et mieux comprendre les graphes et la recherche de chemin :</p>
<ul>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener noreferrer">https://www.redblobgames.com/pathfinding/a-star/introduction.html</a></li>
<li><a href="https://www.youtube.com/watch?v=GazC3A4OQTE" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=GazC3A4OQTE</a></li>
<li><a href="https://www.youtube.com/watch?v=i3_V90yUfcA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=i3_V90yUfcA</a></li>
<li><a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=-L-WgKMFuhE</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags :</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/Learn--cpp_programming/tags/c">C++</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Pages de documentation"><a class="pagination-nav__link pagination-nav__link--prev" href="/Learn--cpp_programming/Lessons/S2/EncodingAndCompression"><div class="pagination-nav__sublabel">Précédent</div><div class="pagination-nav__label">Compression et encodage de données</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#quelques-définitions" class="table-of-contents__link toc-highlight">Quelques définitions</a><ul><li><a href="#les-arbres" class="table-of-contents__link toc-highlight">Les arbres</a></li></ul></li><li><a href="#représentation-dun-graphe" class="table-of-contents__link toc-highlight">Représentation d&#39;un graphe</a><ul><li><a href="#matrice-dadjacence" class="table-of-contents__link toc-highlight">Matrice d&#39;adjacence</a></li><li><a href="#liste-dadjacence" class="table-of-contents__link toc-highlight">Liste d&#39;adjacence</a></li></ul></li><li><a href="#parcours-dun-graphe" class="table-of-contents__link toc-highlight">Parcours d&#39;un graphe</a><ul><li><a href="#parcours-en-largeur" class="table-of-contents__link toc-highlight">Parcours en largeur</a></li><li><a href="#parcours-en-profondeur" class="table-of-contents__link toc-highlight">Parcours en profondeur</a></li></ul></li><li><a href="#en-pratique" class="table-of-contents__link toc-highlight">En pratique</a><ul><li><a href="#dijkstra" class="table-of-contents__link toc-highlight">Dijkstra</a></li><li><a href="#pour-aller-plus-loin-a" class="table-of-contents__link toc-highlight">Pour aller plus loin: A*</a></li></ul></li><li><a href="#simplification-2d" class="table-of-contents__link toc-highlight">Simplification 2D</a></li><li><a href="#résumé" class="table-of-contents__link toc-highlight">Résumé</a></li><li><a href="#sources" class="table-of-contents__link toc-highlight">Sources</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
              <a href="https://discord.com/users/264442459759706112" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/discord.svg"> Discord
              </a>
              </span><span class="footer__link-separator">·</span><a href="mailto:desmet.enguerrand@gmail.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">E-Mail</a><span class="footer__link-separator">·</span><span class="footer__link-item">
              <a href="https://github.com/dsmtE" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/github-dark.svg"> GitHub
              </a>
              </span></div></div><div class="footer__bottom text--center"><div class="footer__copyright">These lessons were written by <a href="https://github.com/dsmtE">DE SMET Enguerrand</a>.<br>Copyright © 2023. Built with <a href="https://docusaurus.io/">Docusaurus</a>.</div></div></div></footer> </div>
</body>
</html>